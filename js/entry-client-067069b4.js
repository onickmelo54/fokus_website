const Me = { context: void 0, registry: void 0 };
function Ks(n) {
  Me.context = n;
}
function PN() {
  return {
    ...Me.context,
    id: `${Me.context.id}${Me.context.count++}-`,
    count: 0,
  };
}
const NN = (n, e) => n === e,
  to = Symbol("solid-proxy"),
  rm = Symbol("solid-track"),
  sm = { equals: NN };
let Kf = null,
  p7 = _7;
const Es = 1,
  fg = 2,
  m7 = { owned: null, cleanups: null, context: null, owner: null },
  SI = {};
var bt = null;
let Pe = null,
  an = null,
  qi = null,
  Mi = null,
  xC = 0;
function wh(n, e) {
  const t = an,
    i = bt,
    r = n.length === 0,
    s = e === void 0 ? i : e,
    o = r
      ? m7
      : {
          owned: null,
          cleanups: null,
          context: s ? s.context : null,
          owner: s,
        },
    a = r ? n : () => n(() => zt(() => Rl(o)));
  ((bt = o), (an = null));
  try {
    return jr(a, !0);
  } finally {
    ((an = t), (bt = i));
  }
}
function Jt(n, e) {
  e = e ? Object.assign({}, sm, e) : sm;
  const t = {
      value: n,
      observers: null,
      observerSlots: null,
      comparator: e.equals || void 0,
    },
    i = (r) => (
      typeof r == "function" &&
        (Pe && Pe.running && Pe.sources.has(t)
          ? (r = r(t.tValue))
          : (r = r(t.value))),
      y7(t, r)
    );
  return [A7.bind(t), i];
}
function QA(n, e, t) {
  const i = $g(n, e, !0, Es);
  vd(i);
}
function vs(n, e, t) {
  const i = $g(n, e, !1, Es);
  vd(i);
}
function Ct(n, e, t) {
  p7 = WN;
  const i = $g(n, e, !1, Es),
    r = cu && ro(cu);
  (r && (i.suspense = r),
    (!t || !t.render) && (i.user = !0),
    Mi ? Mi.push(i) : vd(i));
}
function pe(n, e, t) {
  t = t ? Object.assign({}, sm, t) : sm;
  const i = $g(n, e, !0, 0);
  return (
    (i.observers = null),
    (i.observerSlots = null),
    (i.comparator = t.equals || void 0),
    vd(i),
    A7.bind(i)
  );
}
function DN(n) {
  return n && typeof n == "object" && "then" in n;
}
function gb(n, e, t) {
  let i, r, s;
  (arguments.length === 2 && typeof e == "object") || arguments.length === 1
    ? ((i = !0), (r = n), (s = e || {}))
    : ((i = n), (r = e), (s = t || {}));
  let o = null,
    a = SI,
    l = null,
    c = !1,
    u = !1,
    h = "initialValue" in s,
    d = typeof i == "function" && pe(i);
  const f = new Set(),
    [g, p] = (s.storage || Jt)(s.initialValue),
    [m, C] = Jt(void 0),
    [A, I] = Jt(void 0, { equals: !1 }),
    [y, x] = Jt(h ? "ready" : "unresolved");
  if (Me.context) {
    l = `${Me.context.id}${Me.context.count++}`;
    let b;
    s.ssrLoadFrom === "initial"
      ? (a = s.initialValue)
      : Me.load && (b = Me.load(l)) && (a = b);
  }
  function T(b, R, M, L) {
    return (
      o === b &&
        ((o = null),
        L !== void 0 && (h = !0),
        (b === a || R === a) &&
          s.onHydrated &&
          queueMicrotask(() => s.onHydrated(L, { value: R })),
        (a = SI),
        Pe && b && c
          ? (Pe.promises.delete(b),
            (c = !1),
            jr(() => {
              ((Pe.running = !0), S(R, M));
            }, !1))
          : S(R, M)),
      R
    );
  }
  function S(b, R) {
    jr(() => {
      (R === void 0 && p(() => b),
        x(R !== void 0 ? "errored" : h ? "ready" : "unresolved"),
        C(R));
      for (const M of f.keys()) M.decrement();
      f.clear();
    }, !1);
  }
  function E() {
    const b = cu && ro(cu),
      R = g(),
      M = m();
    if (M !== void 0 && !o) throw M;
    return (
      an &&
        !an.user &&
        b &&
        QA(() => {
          (A(),
            o &&
              (b.resolved && Pe && c
                ? Pe.promises.add(o)
                : f.has(b) || (b.increment(), f.add(b))));
        }),
      R
    );
  }
  function _(b = !0) {
    if (b !== !1 && u) return;
    u = !1;
    const R = d ? d() : i;
    if (((c = Pe && Pe.running), R == null || R === !1)) {
      T(o, zt(g));
      return;
    }
    Pe && o && Pe.promises.delete(o);
    const M = a !== SI ? a : zt(() => r(R, { value: g(), refetching: b }));
    return DN(M)
      ? ((o = M),
        "value" in M
          ? (M.status === "success"
              ? T(o, M.value, void 0, R)
              : T(o, void 0, void 0, R),
            M)
          : ((u = !0),
            queueMicrotask(() => (u = !1)),
            jr(() => {
              (x(h ? "refreshing" : "pending"), I());
            }, !1),
            M.then(
              (L) => T(M, L, void 0, R),
              (L) => T(M, void 0, x7(L), R),
            )))
      : (T(o, M, void 0, R), M);
  }
  return (
    Object.defineProperties(E, {
      state: { get: () => y() },
      error: { get: () => m() },
      loading: {
        get() {
          const b = y();
          return b === "pending" || b === "refreshing";
        },
      },
      latest: {
        get() {
          if (!h) return E();
          const b = m();
          if (b && !o) throw b;
          return g();
        },
      },
    }),
    d ? QA(() => _(!1)) : _(!1),
    [E, { refetch: _, mutate: p }]
  );
}
function qA(n) {
  return jr(n, !1);
}
function zt(n) {
  if (an === null) return n();
  const e = an;
  an = null;
  try {
    return n();
  } finally {
    an = e;
  }
}
function gr(n, e, t) {
  const i = Array.isArray(n);
  let r,
    s = t && t.defer;
  return (o) => {
    let a;
    if (i) {
      a = Array(n.length);
      for (let c = 0; c < n.length; c++) a[c] = n[c]();
    } else a = n();
    if (s) {
      s = !1;
      return;
    }
    const l = zt(() => e(a, r, o));
    return ((r = a), l);
  };
}
function rr(n) {
  Ct(() => zt(n));
}
function dn(n) {
  return (
    bt === null ||
      (bt.cleanups === null ? (bt.cleanups = [n]) : bt.cleanups.push(n)),
    n
  );
}
function GN(n, e) {
  (Kf || (Kf = Symbol("error")),
    (bt = $g(void 0, void 0, !0)),
    (bt.context = { ...bt.context, [Kf]: [e] }),
    Pe && Pe.running && Pe.sources.add(bt));
  try {
    return n();
  } catch (t) {
    Jg(t);
  } finally {
    bt = bt.owner;
  }
}
function ey() {
  return an;
}
function C7() {
  return bt;
}
function FN(n, e) {
  const t = bt,
    i = an;
  ((bt = n), (an = null));
  try {
    return jr(e, !0);
  } catch (r) {
    Jg(r);
  } finally {
    ((bt = t), (an = i));
  }
}
function pb(n) {
  if (Pe && Pe.running) return (n(), Pe.done);
  const e = an,
    t = bt;
  return Promise.resolve().then(() => {
    ((an = e), (bt = t));
    let i;
    return (
      cu &&
        ((i =
          Pe ||
          (Pe = {
            sources: new Set(),
            effects: [],
            promises: new Set(),
            disposed: new Set(),
            queue: new Set(),
            running: !0,
          })),
        i.done || (i.done = new Promise((r) => (i.resolve = r))),
        (i.running = !0)),
      jr(n, !1),
      (an = bt = null),
      i ? i.done : void 0
    );
  });
}
const [kN, G5] = Jt(!1);
function I7() {
  return [kN, pb];
}
function ON(n) {
  (Mi.push.apply(Mi, n), (n.length = 0));
}
function Fa(n, e) {
  const t = Symbol("context");
  return { id: t, Provider: VN(t), defaultValue: n };
}
function ro(n) {
  return bt && bt.context && bt.context[n.id] !== void 0
    ? bt.context[n.id]
    : n.defaultValue;
}
function wC(n) {
  const e = pe(n),
    t = pe(() => ty(e()));
  return (
    (t.toArray = () => {
      const i = t();
      return Array.isArray(i) ? i : i != null ? [i] : [];
    }),
    t
  );
}
let cu;
function UN() {
  return cu || (cu = Fa());
}
function A7() {
  const n = Pe && Pe.running;
  if (this.sources && (n ? this.tState : this.state))
    if ((n ? this.tState : this.state) === Es) vd(this);
    else {
      const e = qi;
      ((qi = null), jr(() => am(this), !1), (qi = e));
    }
  if (an) {
    const e = this.observers ? this.observers.length : 0;
    (an.sources
      ? (an.sources.push(this), an.sourceSlots.push(e))
      : ((an.sources = [this]), (an.sourceSlots = [e])),
      this.observers
        ? (this.observers.push(an),
          this.observerSlots.push(an.sources.length - 1))
        : ((this.observers = [an]),
          (this.observerSlots = [an.sources.length - 1])));
  }
  return n && Pe.sources.has(this) ? this.tValue : this.value;
}
function y7(n, e, t) {
  let i = Pe && Pe.running && Pe.sources.has(n) ? n.tValue : n.value;
  if (!n.comparator || !n.comparator(i, e)) {
    if (Pe) {
      const r = Pe.running;
      ((r || (!t && Pe.sources.has(n))) && (Pe.sources.add(n), (n.tValue = e)),
        r || (n.value = e));
    } else n.value = e;
    n.observers &&
      n.observers.length &&
      jr(() => {
        for (let r = 0; r < n.observers.length; r += 1) {
          const s = n.observers[r],
            o = Pe && Pe.running;
          (o && Pe.disposed.has(s)) ||
            ((o ? !s.tState : !s.state) &&
              (s.pure ? qi.push(s) : Mi.push(s), s.observers && b7(s)),
            o ? (s.tState = Es) : (s.state = Es));
        }
        if (qi.length > 1e6) throw ((qi = []), new Error());
      }, !1);
  }
  return e;
}
function vd(n) {
  if (!n.fn) return;
  Rl(n);
  const e = xC;
  (F5(n, Pe && Pe.running && Pe.sources.has(n) ? n.tValue : n.value, e),
    Pe &&
      !Pe.running &&
      Pe.sources.has(n) &&
      queueMicrotask(() => {
        jr(() => {
          (Pe && (Pe.running = !0),
            (an = bt = n),
            F5(n, n.tValue, e),
            (an = bt = null));
        }, !1);
      }));
}
function F5(n, e, t) {
  let i;
  const r = bt,
    s = an;
  an = bt = n;
  try {
    i = n.fn(e);
  } catch (o) {
    return (
      n.pure &&
        (Pe && Pe.running
          ? ((n.tState = Es),
            n.tOwned && n.tOwned.forEach(Rl),
            (n.tOwned = void 0))
          : ((n.state = Es), n.owned && n.owned.forEach(Rl), (n.owned = null))),
      (n.updatedAt = t + 1),
      Jg(o)
    );
  } finally {
    ((an = s), (bt = r));
  }
  (!n.updatedAt || n.updatedAt <= t) &&
    (n.updatedAt != null && "observers" in n
      ? y7(n, i, !0)
      : Pe && Pe.running && n.pure
        ? (Pe.sources.add(n), (n.tValue = i))
        : (n.value = i),
    (n.updatedAt = t));
}
function $g(n, e, t, i = Es, r) {
  const s = {
    fn: n,
    state: i,
    updatedAt: null,
    owned: null,
    sources: null,
    sourceSlots: null,
    cleanups: null,
    value: e,
    owner: bt,
    context: bt ? bt.context : null,
    pure: t,
  };
  return (
    Pe && Pe.running && ((s.state = 0), (s.tState = i)),
    bt === null ||
      (bt !== m7 &&
        (Pe && Pe.running && bt.pure
          ? bt.tOwned
            ? bt.tOwned.push(s)
            : (bt.tOwned = [s])
          : bt.owned
            ? bt.owned.push(s)
            : (bt.owned = [s]))),
    s
  );
}
function om(n) {
  const e = Pe && Pe.running;
  if ((e ? n.tState : n.state) === 0) return;
  if ((e ? n.tState : n.state) === fg) return am(n);
  if (n.suspense && zt(n.suspense.inFallback))
    return n.suspense.effects.push(n);
  const t = [n];
  for (; (n = n.owner) && (!n.updatedAt || n.updatedAt < xC); ) {
    if (e && Pe.disposed.has(n)) return;
    (e ? n.tState : n.state) && t.push(n);
  }
  for (let i = t.length - 1; i >= 0; i--) {
    if (((n = t[i]), e)) {
      let r = n,
        s = t[i + 1];
      for (; (r = r.owner) && r !== s; ) if (Pe.disposed.has(r)) return;
    }
    if ((e ? n.tState : n.state) === Es) vd(n);
    else if ((e ? n.tState : n.state) === fg) {
      const r = qi;
      ((qi = null), jr(() => am(n, t[0]), !1), (qi = r));
    }
  }
}
function jr(n, e) {
  if (qi) return n();
  let t = !1;
  (e || (qi = []), Mi ? (t = !0) : (Mi = []), xC++);
  try {
    const i = n();
    return (HN(t), i);
  } catch (i) {
    (t || (Mi = null), (qi = null), Jg(i));
  }
}
function HN(n) {
  if ((qi && (_7(qi), (qi = null)), n)) return;
  let e;
  if (Pe) {
    if (!Pe.promises.size && !Pe.queue.size) {
      const i = Pe.sources,
        r = Pe.disposed;
      (Mi.push.apply(Mi, Pe.effects), (e = Pe.resolve));
      for (const s of Mi)
        ("tState" in s && (s.state = s.tState), delete s.tState);
      ((Pe = null),
        jr(() => {
          for (const s of r) Rl(s);
          for (const s of i) {
            if (((s.value = s.tValue), s.owned))
              for (let o = 0, a = s.owned.length; o < a; o++) Rl(s.owned[o]);
            (s.tOwned && (s.owned = s.tOwned),
              delete s.tValue,
              delete s.tOwned,
              (s.tState = 0));
          }
          G5(!1);
        }, !1));
    } else if (Pe.running) {
      ((Pe.running = !1),
        Pe.effects.push.apply(Pe.effects, Mi),
        (Mi = null),
        G5(!0));
      return;
    }
  }
  const t = Mi;
  ((Mi = null), t.length && jr(() => p7(t), !1), e && e());
}
function _7(n) {
  for (let e = 0; e < n.length; e++) om(n[e]);
}
function WN(n) {
  let e,
    t = 0;
  for (e = 0; e < n.length; e++) {
    const i = n[e];
    i.user ? (n[t++] = i) : om(i);
  }
  if (Me.context) {
    if (Me.count) {
      (Me.effects || (Me.effects = []), Me.effects.push(...n.slice(0, t)));
      return;
    } else
      Me.effects &&
        ((n = [...Me.effects, ...n]),
        (t += Me.effects.length),
        delete Me.effects);
    Ks();
  }
  for (e = 0; e < t; e++) om(n[e]);
}
function am(n, e) {
  const t = Pe && Pe.running;
  t ? (n.tState = 0) : (n.state = 0);
  for (let i = 0; i < n.sources.length; i += 1) {
    const r = n.sources[i];
    if (r.sources) {
      const s = t ? r.tState : r.state;
      s === Es
        ? r !== e && (!r.updatedAt || r.updatedAt < xC) && om(r)
        : s === fg && am(r, e);
    }
  }
}
function b7(n) {
  const e = Pe && Pe.running;
  for (let t = 0; t < n.observers.length; t += 1) {
    const i = n.observers[t];
    (e ? !i.tState : !i.state) &&
      (e ? (i.tState = fg) : (i.state = fg),
      i.pure ? qi.push(i) : Mi.push(i),
      i.observers && b7(i));
  }
}
function Rl(n) {
  let e;
  if (n.sources)
    for (; n.sources.length; ) {
      const t = n.sources.pop(),
        i = n.sourceSlots.pop(),
        r = t.observers;
      if (r && r.length) {
        const s = r.pop(),
          o = t.observerSlots.pop();
        i < r.length &&
          ((s.sourceSlots[o] = i), (r[i] = s), (t.observerSlots[i] = o));
      }
    }
  if (Pe && Pe.running && n.pure) {
    if (n.tOwned) {
      for (e = n.tOwned.length - 1; e >= 0; e--) Rl(n.tOwned[e]);
      delete n.tOwned;
    }
    v7(n, !0);
  } else if (n.owned) {
    for (e = n.owned.length - 1; e >= 0; e--) Rl(n.owned[e]);
    n.owned = null;
  }
  if (n.cleanups) {
    for (e = n.cleanups.length - 1; e >= 0; e--) n.cleanups[e]();
    n.cleanups = null;
  }
  Pe && Pe.running ? (n.tState = 0) : (n.state = 0);
}
function v7(n, e) {
  if ((e || ((n.tState = 0), Pe.disposed.add(n)), n.owned))
    for (let t = 0; t < n.owned.length; t++) v7(n.owned[t]);
}
function x7(n) {
  return n instanceof Error
    ? n
    : new Error(typeof n == "string" ? n : "Unknown error", { cause: n });
}
function k5(n, e, t) {
  try {
    for (const i of e) i(n);
  } catch (i) {
    Jg(i, (t && t.owner) || null);
  }
}
function Jg(n, e = bt) {
  const t = Kf && e && e.context && e.context[Kf],
    i = x7(n);
  if (!t) throw i;
  Mi
    ? Mi.push({
        fn() {
          k5(i, t, e);
        },
        state: Es,
      })
    : k5(i, t, e);
}
function ty(n) {
  if (typeof n == "function" && !n.length) return ty(n());
  if (Array.isArray(n)) {
    const e = [];
    for (let t = 0; t < n.length; t++) {
      const i = ty(n[t]);
      Array.isArray(i) ? e.push.apply(e, i) : e.push(i);
    }
    return e;
  }
  return n;
}
function VN(n, e) {
  return function (i) {
    let r;
    return (
      vs(
        () =>
          (r = zt(
            () => (
              (bt.context = { ...bt.context, [n]: i.value }),
              wC(() => i.children)
            ),
          )),
        void 0,
      ),
      r
    );
  };
}
const ZN = Symbol("fallback");
function O5(n) {
  for (let e = 0; e < n.length; e++) n[e]();
}
function zN(n, e, t = {}) {
  let i = [],
    r = [],
    s = [],
    o = 0,
    a = e.length > 1 ? [] : null;
  return (
    dn(() => O5(s)),
    () => {
      let l = n() || [],
        c,
        u;
      return (
        l[rm],
        zt(() => {
          let d = l.length,
            f,
            g,
            p,
            m,
            C,
            A,
            I,
            y,
            x;
          if (d === 0)
            (o !== 0 &&
              (O5(s), (s = []), (i = []), (r = []), (o = 0), a && (a = [])),
              t.fallback &&
                ((i = [ZN]),
                (r[0] = wh((T) => ((s[0] = T), t.fallback()))),
                (o = 1)));
          else if (o === 0) {
            for (r = new Array(d), u = 0; u < d; u++)
              ((i[u] = l[u]), (r[u] = wh(h)));
            o = d;
          } else {
            for (
              p = new Array(d),
                m = new Array(d),
                a && (C = new Array(d)),
                A = 0,
                I = Math.min(o, d);
              A < I && i[A] === l[A];
              A++
            );
            for (
              I = o - 1, y = d - 1;
              I >= A && y >= A && i[I] === l[y];
              I--, y--
            )
              ((p[y] = r[I]), (m[y] = s[I]), a && (C[y] = a[I]));
            for (f = new Map(), g = new Array(y + 1), u = y; u >= A; u--)
              ((x = l[u]),
                (c = f.get(x)),
                (g[u] = c === void 0 ? -1 : c),
                f.set(x, u));
            for (c = A; c <= I; c++)
              ((x = i[c]),
                (u = f.get(x)),
                u !== void 0 && u !== -1
                  ? ((p[u] = r[c]),
                    (m[u] = s[c]),
                    a && (C[u] = a[c]),
                    (u = g[u]),
                    f.set(x, u))
                  : s[c]());
            for (u = A; u < d; u++)
              u in p
                ? ((r[u] = p[u]), (s[u] = m[u]), a && ((a[u] = C[u]), a[u](u)))
                : (r[u] = wh(h));
            ((r = r.slice(0, (o = d))), (i = l.slice(0)));
          }
          return r;
        })
      );
      function h(d) {
        if (((s[u] = d), a)) {
          const [f, g] = Jt(u);
          return ((a[u] = g), e(l[u], f));
        }
        return e(l[u]);
      }
    }
  );
}
let w7 = !1;
function YN() {
  w7 = !0;
}
function G(n, e) {
  if (w7 && Me.context) {
    const t = Me.context;
    Ks(PN());
    const i = zt(() => n(e || {}));
    return (Ks(t), i);
  }
  return zt(() => n(e || {}));
}
function Gp() {
  return !0;
}
const ny = {
  get(n, e, t) {
    return e === to ? t : n.get(e);
  },
  has(n, e) {
    return e === to ? !0 : n.has(e);
  },
  set: Gp,
  deleteProperty: Gp,
  getOwnPropertyDescriptor(n, e) {
    return {
      configurable: !0,
      enumerable: !0,
      get() {
        return n.get(e);
      },
      set: Gp,
      deleteProperty: Gp,
    };
  },
  ownKeys(n) {
    return n.keys();
  },
};
function TI(n) {
  return (n = typeof n == "function" ? n() : n) ? n : {};
}
function XN() {
  for (let n = 0, e = this.length; n < e; ++n) {
    const t = this[n]();
    if (t !== void 0) return t;
  }
}
function jn(...n) {
  let e = !1;
  for (let s = 0; s < n.length; s++) {
    const o = n[s];
    ((e = e || (!!o && to in o)),
      (n[s] = typeof o == "function" ? ((e = !0), pe(o)) : o));
  }
  if (e)
    return new Proxy(
      {
        get(s) {
          for (let o = n.length - 1; o >= 0; o--) {
            const a = TI(n[o])[s];
            if (a !== void 0) return a;
          }
        },
        has(s) {
          for (let o = n.length - 1; o >= 0; o--) if (s in TI(n[o])) return !0;
          return !1;
        },
        keys() {
          const s = [];
          for (let o = 0; o < n.length; o++) s.push(...Object.keys(TI(n[o])));
          return [...new Set(s)];
        },
      },
      ny,
    );
  const t = {},
    i = {},
    r = new Set();
  for (let s = n.length - 1; s >= 0; s--) {
    const o = n[s];
    if (!o) continue;
    const a = Object.getOwnPropertyNames(o);
    for (let l = 0, c = a.length; l < c; l++) {
      const u = a[l];
      if (u === "__proto__" || u === "constructor") continue;
      const h = Object.getOwnPropertyDescriptor(o, u);
      if (!r.has(u))
        h.get
          ? (r.add(u),
            Object.defineProperty(t, u, {
              enumerable: !0,
              configurable: !0,
              get: XN.bind((i[u] = [h.get.bind(o)])),
            }))
          : (h.value !== void 0 && r.add(u), (t[u] = h.value));
      else {
        const d = i[u];
        d
          ? h.get
            ? d.push(h.get.bind(o))
            : h.value !== void 0 && d.push(() => h.value)
          : t[u] === void 0 && (t[u] = h.value);
      }
    }
  }
  return t;
}
function Dr(n, ...e) {
  if (to in n) {
    const r = new Set(e.length > 1 ? e.flat() : e[0]),
      s = e.map(
        (o) =>
          new Proxy(
            {
              get(a) {
                return o.includes(a) ? n[a] : void 0;
              },
              has(a) {
                return o.includes(a) && a in n;
              },
              keys() {
                return o.filter((a) => a in n);
              },
            },
            ny,
          ),
      );
    return (
      s.push(
        new Proxy(
          {
            get(o) {
              return r.has(o) ? void 0 : n[o];
            },
            has(o) {
              return r.has(o) ? !1 : o in n;
            },
            keys() {
              return Object.keys(n).filter((o) => !r.has(o));
            },
          },
          ny,
        ),
      ),
      s
    );
  }
  const t = {},
    i = e.map(() => ({}));
  for (const r of Object.getOwnPropertyNames(n)) {
    const s = Object.getOwnPropertyDescriptor(n, r),
      o = !s.get && !s.set && s.enumerable && s.writable && s.configurable;
    let a = !1,
      l = 0;
    for (const c of e)
      (c.includes(r) &&
        ((a = !0), o ? (i[l][r] = s.value) : Object.defineProperty(i[l], r, s)),
        ++l);
    a || (o ? (t[r] = s.value) : Object.defineProperty(t, r, s));
  }
  return [...i, t];
}
function _r(n) {
  let e, t;
  const i = (r) => {
    const s = Me.context;
    if (s) {
      const [a, l] = Jt();
      (Me.count || (Me.count = 0),
        Me.count++,
        (t || (t = n())).then((c) => {
          (Ks(s), Me.count--, l(() => c.default), Ks());
        }),
        (e = a));
    } else if (!e) {
      const [a] = gb(() => (t || (t = n())).then((l) => l.default));
      e = a;
    }
    let o;
    return pe(
      () =>
        (o = e()) &&
        zt(() => {
          if (!s) return o(r);
          const a = Me.context;
          Ks(s);
          const l = o(r);
          return (Ks(a), l);
        }),
    );
  };
  return (
    (i.preload = () => t || ((t = n()).then((r) => (e = () => r.default)), t)),
    i
  );
}
let KN = 0;
function jN() {
  const n = Me.context;
  return n ? `${n.id}${n.count++}` : `cl-${KN++}`;
}
const S7 = (n) => `Stale read from <${n}>.`;
function Yn(n) {
  const e = "fallback" in n && { fallback: () => n.fallback };
  return pe(zN(() => n.each, n.children, e || void 0));
}
function Hl(n) {
  const e = n.keyed,
    t = pe(() => n.when, void 0, {
      equals: (i, r) => (e ? i === r : !i == !r),
    });
  return pe(
    () => {
      const i = t();
      if (i) {
        const r = n.children;
        return typeof r == "function" && r.length > 0
          ? zt(() =>
              r(
                e
                  ? i
                  : () => {
                      if (!zt(t)) throw S7("Show");
                      return n.when;
                    },
              ),
            )
          : r;
      }
      return n.fallback;
    },
    void 0,
    void 0,
  );
}
function R0e(n) {
  let e = !1;
  const t = (s, o) =>
      s[0] === o[0] && (e ? s[1] === o[1] : !s[1] == !o[1]) && s[2] === o[2],
    i = wC(() => n.children),
    r = pe(
      () => {
        let s = i();
        Array.isArray(s) || (s = [s]);
        for (let o = 0; o < s.length; o++) {
          const a = s[o].when;
          if (a) return ((e = !!s[o].keyed), [o, a, s[o]]);
        }
        return [-1];
      },
      void 0,
      { equals: t },
    );
  return pe(
    () => {
      const [s, o, a] = r();
      if (s < 0) return n.fallback;
      const l = a.children;
      return typeof l == "function" && l.length > 0
        ? zt(() =>
            l(
              e
                ? o
                : () => {
                    if (zt(r)[0] !== s) throw S7("Match");
                    return a.when;
                  },
            ),
          )
        : l;
    },
    void 0,
    void 0,
  );
}
function B0e(n) {
  return n;
}
let fh;
function T7() {
  fh && [...fh].forEach((n) => n());
}
function $N(n) {
  let e;
  Me.context && Me.load && (e = Me.load(Me.context.id + Me.context.count));
  const [t, i] = Jt(e, void 0);
  return (
    fh || (fh = new Set()),
    fh.add(i),
    dn(() => fh.delete(i)),
    pe(
      () => {
        let r;
        if ((r = t())) {
          const s = n.fallback;
          return typeof s == "function" && s.length
            ? zt(() => s(r, () => i()))
            : s;
        }
        return GN(() => n.children, i);
      },
      void 0,
      void 0,
    )
  );
}
const JN = Fa();
function QN(n) {
  let e = 0,
    t,
    i,
    r,
    s,
    o;
  const [a, l] = Jt(!1),
    c = UN(),
    u = {
      increment: () => {
        ++e === 1 && l(!0);
      },
      decrement: () => {
        --e === 0 && l(!1);
      },
      inFallback: a,
      effects: [],
      resolved: !1,
    },
    h = C7();
  if (Me.context && Me.load) {
    const g = Me.context.id + Me.context.count;
    let p = Me.load(g);
    if (
      (p && (typeof p != "object" || p.status !== "success") && (r = p),
      r && r !== "$$f")
    ) {
      const [m, C] = Jt(void 0, { equals: !1 });
      ((s = m),
        r
          .then(() => {
            (Me.gather(g), Ks(i), C(), Ks());
          })
          .catch((A) => {
            if (A || Me.done) return (A && (o = A), C());
          }));
    }
  }
  const d = ro(JN);
  d && (t = d.register(u.inFallback));
  let f;
  return (
    dn(() => f && f()),
    G(c.Provider, {
      value: u,
      get children() {
        return pe(() => {
          if (o) throw o;
          if (((i = Me.context), s)) return (s(), (s = void 0));
          i && r === "$$f" && Ks();
          const g = pe(() => n.children);
          return pe((p) => {
            const m = u.inFallback(),
              { showContent: C = !0, showFallback: A = !0 } = t ? t() : {};
            if ((!m || (r && r !== "$$f")) && C)
              return (
                (u.resolved = !0),
                f && f(),
                (f = i = r = void 0),
                ON(u.effects),
                g()
              );
            if (A)
              return f
                ? p
                : wh(
                    (I) => (
                      (f = I),
                      i && (Ks({ id: i.id + "f", count: 0 }), (i = void 0)),
                      n.fallback
                    ),
                    h,
                  );
          });
        });
      },
    })
  );
}
const qN = [
    "allowfullscreen",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "disabled",
    "formnovalidate",
    "hidden",
    "indeterminate",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "seamless",
    "selected",
  ],
  eD = new Set([
    "className",
    "value",
    "readOnly",
    "formNoValidate",
    "isMap",
    "noModule",
    "playsInline",
    ...qN,
  ]),
  tD = new Set(["innerHTML", "textContent", "innerText", "children"]),
  nD = Object.assign(Object.create(null), {
    className: "class",
    htmlFor: "for",
  }),
  iD = Object.assign(Object.create(null), {
    class: "className",
    formnovalidate: { $: "formNoValidate", BUTTON: 1, INPUT: 1 },
    ismap: { $: "isMap", IMG: 1 },
    nomodule: { $: "noModule", SCRIPT: 1 },
    playsinline: { $: "playsInline", VIDEO: 1 },
    readonly: { $: "readOnly", INPUT: 1, TEXTAREA: 1 },
  });
function rD(n, e) {
  const t = iD[n];
  return typeof t == "object" ? (t[e] ? t.$ : void 0) : t;
}
const sD = new Set([
    "beforeinput",
    "click",
    "dblclick",
    "contextmenu",
    "focusin",
    "focusout",
    "input",
    "keydown",
    "keyup",
    "mousedown",
    "mousemove",
    "mouseout",
    "mouseover",
    "mouseup",
    "pointerdown",
    "pointermove",
    "pointerout",
    "pointerover",
    "pointerup",
    "touchend",
    "touchmove",
    "touchstart",
  ]),
  oD = new Set([
    "altGlyph",
    "altGlyphDef",
    "altGlyphItem",
    "animate",
    "animateColor",
    "animateMotion",
    "animateTransform",
    "circle",
    "clipPath",
    "color-profile",
    "cursor",
    "defs",
    "desc",
    "ellipse",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "filter",
    "font",
    "font-face",
    "font-face-format",
    "font-face-name",
    "font-face-src",
    "font-face-uri",
    "foreignObject",
    "g",
    "glyph",
    "glyphRef",
    "hkern",
    "image",
    "line",
    "linearGradient",
    "marker",
    "mask",
    "metadata",
    "missing-glyph",
    "mpath",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "set",
    "stop",
    "svg",
    "switch",
    "symbol",
    "text",
    "textPath",
    "tref",
    "tspan",
    "use",
    "view",
    "vkern",
  ]),
  aD = {
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
  };
function lD(n, e, t) {
  let i = t.length,
    r = e.length,
    s = i,
    o = 0,
    a = 0,
    l = e[r - 1].nextSibling,
    c = null;
  for (; o < r || a < s; ) {
    if (e[o] === t[a]) {
      (o++, a++);
      continue;
    }
    for (; e[r - 1] === t[s - 1]; ) (r--, s--);
    if (r === o) {
      const u = s < i ? (a ? t[a - 1].nextSibling : t[s - a]) : l;
      for (; a < s; ) n.insertBefore(t[a++], u);
    } else if (s === a)
      for (; o < r; ) ((!c || !c.has(e[o])) && e[o].remove(), o++);
    else if (e[o] === t[s - 1] && t[a] === e[r - 1]) {
      const u = e[--r].nextSibling;
      (n.insertBefore(t[a++], e[o++].nextSibling),
        n.insertBefore(t[--s], u),
        (e[r] = t[s]));
    } else {
      if (!c) {
        c = new Map();
        let h = a;
        for (; h < s; ) c.set(t[h], h++);
      }
      const u = c.get(e[o]);
      if (u != null)
        if (a < u && u < s) {
          let h = o,
            d = 1,
            f;
          for (
            ;
            ++h < r && h < s && !((f = c.get(e[h])) == null || f !== u + d);
          )
            d++;
          if (d > u - a) {
            const g = e[o];
            for (; a < u; ) n.insertBefore(t[a++], g);
          } else n.replaceChild(t[a++], e[o++]);
        } else o++;
      else e[o++].remove();
    }
  }
}
const U5 = "_$DX_DELEGATE";
function cD(n, e, t, i = {}) {
  let r;
  return (
    wh((s) => {
      ((r = s),
        e === document ? n() : Mn(e, n(), e.firstChild ? null : void 0, t));
    }, i.owner),
    () => {
      (r(), (e.textContent = ""));
    }
  );
}
function xt(n, e, t) {
  let i;
  const r = () => {
      const o = document.createElement("template");
      return (
        (o.innerHTML = n),
        t ? o.content.firstChild.firstChild : o.content.firstChild
      );
    },
    s = e
      ? () => zt(() => document.importNode(i || (i = r()), !0))
      : () => (i || (i = r())).cloneNode(!0);
  return ((s.cloneNode = s), s);
}
function Qg(n, e = window.document) {
  const t = e[U5] || (e[U5] = new Set());
  for (let i = 0, r = n.length; i < r; i++) {
    const s = n[i];
    t.has(s) || (t.add(s), e.addEventListener(s, M7));
  }
}
function gg(n, e, t) {
  Me.context || (t == null ? n.removeAttribute(e) : n.setAttribute(e, t));
}
function uD(n, e, t, i) {
  Me.context ||
    (i == null ? n.removeAttributeNS(e, t) : n.setAttributeNS(e, t, i));
}
function iy(n, e) {
  Me.context || (e == null ? n.removeAttribute("class") : (n.className = e));
}
function E7(n, e, t, i) {
  if (i)
    Array.isArray(t)
      ? ((n[`$$${e}`] = t[0]), (n[`$$${e}Data`] = t[1]))
      : (n[`$$${e}`] = t);
  else if (Array.isArray(t)) {
    const r = t[0];
    n.addEventListener(e, (t[0] = (s) => r.call(n, t[1], s)));
  } else n.addEventListener(e, t);
}
function hD(n, e, t = {}) {
  const i = Object.keys(e || {}),
    r = Object.keys(t);
  let s, o;
  for (s = 0, o = r.length; s < o; s++) {
    const a = r[s];
    !a || a === "undefined" || e[a] || (H5(n, a, !1), delete t[a]);
  }
  for (s = 0, o = i.length; s < o; s++) {
    const a = i[s],
      l = !!e[a];
    !a || a === "undefined" || t[a] === l || !l || (H5(n, a, !0), (t[a] = l));
  }
  return t;
}
function dD(n, e, t) {
  if (!e) return t ? gg(n, "style") : e;
  const i = n.style;
  if (typeof e == "string") return (i.cssText = e);
  (typeof t == "string" && (i.cssText = t = void 0),
    t || (t = {}),
    e || (e = {}));
  let r, s;
  for (s in t) (e[s] == null && i.removeProperty(s), delete t[s]);
  for (s in e) ((r = e[s]), r !== t[s] && (i.setProperty(s, r), (t[s] = r)));
  return t;
}
function fn(n, e = {}, t, i) {
  const r = {};
  return (
    i || vs(() => (r.children = Yh(n, e.children, r.children))),
    vs(() => e.ref && e.ref(n)),
    vs(() => fD(n, e, t, !0, r, !0)),
    r
  );
}
function ry(n, e, t) {
  return zt(() => n(e, t));
}
function Mn(n, e, t, i) {
  if ((t !== void 0 && !i && (i = []), typeof e != "function"))
    return Yh(n, e, i, t);
  vs((r) => Yh(n, e(), r, t), i);
}
function fD(n, e, t, i, r = {}, s = !1) {
  e || (e = {});
  for (const o in r)
    if (!(o in e)) {
      if (o === "children") continue;
      r[o] = W5(n, o, null, r[o], t, s);
    }
  for (const o in e) {
    if (o === "children") {
      i || Yh(n, e.children);
      continue;
    }
    const a = e[o];
    r[o] = W5(n, o, a, r[o], t, s);
  }
}
function gD(n, e, t = {}) {
  ((Me.completed = globalThis._$HY.completed),
    (Me.events = globalThis._$HY.events),
    (Me.load = (r) => globalThis._$HY.r[r]),
    (Me.has = (r) => r in globalThis._$HY.r),
    (Me.gather = (r) => Z5(e, r)),
    (Me.registry = new Map()),
    (Me.context = { id: t.renderId || "", count: 0 }),
    Z5(e, t.renderId));
  const i = cD(n, e, [...e.childNodes], t);
  return ((Me.context = null), i);
}
function ft(n) {
  let e, t;
  const isHydrating = !!Me.context;
  const hasElement = isHydrating && (e = Me.registry.get((t = mD())));

  if (isHydrating && !hasElement) {
    console.error("Hydration Error: Missing element with ID:", t);
    if (typeof n !== "function") {
      console.error(
        "Fatal: No fallback function provided (n is undefined) for ID:",
        t,
      );
      // Fallback: create a dummy element to prevent crash
      const dummy = document.createElement("div");
      dummy.setAttribute("data-hydration-error", t);
      dummy.style.display = "none";
      return dummy;
    }
  }

  return !isHydrating || !hasElement
    ? n()
    : (Me.completed && Me.completed.add(e), Me.registry.delete(t), e);
}
function Xc(n) {
  let e = n,
    t = 0,
    i = [];
  if (Me.context)
    for (; e; ) {
      if (e.nodeType === 8) {
        const r = e.nodeValue;
        if (r === "$") t++;
        else if (r === "/") {
          if (t === 0) return [e, i];
          t--;
        }
      }
      (i.push(e), (e = e.nextSibling));
    }
  return [e, i];
}
function An() {
  Me.events &&
    !Me.events.queued &&
    (queueMicrotask(() => {
      const { completed: n, events: e } = Me;
      for (e.queued = !1; e.length; ) {
        const [t, i] = e[0];
        if (!n.has(t)) return;
        (M7(i), e.shift());
      }
    }),
    (Me.events.queued = !0));
}
function pD(n) {
  return n.toLowerCase().replace(/-([a-z])/g, (e, t) => t.toUpperCase());
}
function H5(n, e, t) {
  const i = e.trim().split(/\s+/);
  for (let r = 0, s = i.length; r < s; r++) n.classList.toggle(i[r], t);
}
function W5(n, e, t, i, r, s) {
  let o, a, l, c, u;
  if (e === "style") return dD(n, t, i);
  if (e === "classList") return hD(n, t, i);
  if (t === i) return i;
  if (e === "ref") s || t(n);
  else if (e.slice(0, 3) === "on:") {
    const h = e.slice(3);
    (i && n.removeEventListener(h, i), t && n.addEventListener(h, t));
  } else if (e.slice(0, 10) === "oncapture:") {
    const h = e.slice(10);
    (i && n.removeEventListener(h, i, !0), t && n.addEventListener(h, t, !0));
  } else if (e.slice(0, 2) === "on") {
    const h = e.slice(2).toLowerCase(),
      d = sD.has(h);
    if (!d && i) {
      const f = Array.isArray(i) ? i[0] : i;
      n.removeEventListener(h, f);
    }
    (d || t) && (E7(n, h, t, d), d && Qg([h]));
  } else if (e.slice(0, 5) === "attr:") gg(n, e.slice(5), t);
  else if (
    (u = e.slice(0, 5) === "prop:") ||
    (l = tD.has(e)) ||
    (!r && ((c = rD(e, n.tagName)) || (a = eD.has(e)))) ||
    (o = n.nodeName.includes("-"))
  ) {
    if (u) ((e = e.slice(5)), (a = !0));
    else if (Me.context) return t;
    e === "class" || e === "className"
      ? iy(n, t)
      : o && !a && !l
        ? (n[pD(e)] = t)
        : (n[c || e] = t);
  } else {
    const h = r && e.indexOf(":") > -1 && aD[e.split(":")[0]];
    h ? uD(n, h, e, t) : gg(n, nD[e] || e, t);
  }
  return t;
}
function M7(n) {
  const e = `$$${n.type}`;
  let t = (n.composedPath && n.composedPath()[0]) || n.target;
  for (
    n.target !== t &&
      Object.defineProperty(n, "target", { configurable: !0, value: t }),
      Object.defineProperty(n, "currentTarget", {
        configurable: !0,
        get() {
          return t || document;
        },
      }),
      Me.registry && !Me.done && (Me.done = _$HY.done = !0);
    t;
  ) {
    const i = t[e];
    if (i && !t.disabled) {
      const r = t[`${e}Data`];
      if ((r !== void 0 ? i.call(t, r, n) : i.call(t, n), n.cancelBubble))
        return;
    }
    t = t._$host || t.parentNode || t.host;
  }
}
function Yh(n, e, t, i, r) {
  if (Me.context) {
    !t && (t = [...n.childNodes]);
    let a = [];
    for (let l = 0; l < t.length; l++) {
      const c = t[l];
      c.nodeType === 8 && c.data.slice(0, 2) === "!$" ? c.remove() : a.push(c);
    }
    t = a;
  }
  for (; typeof t == "function"; ) t = t();
  if (e === t) return t;
  const s = typeof e,
    o = i !== void 0;
  if (
    ((n = (o && t[0] && t[0].parentNode) || n),
    s === "string" || s === "number")
  ) {
    if (Me.context) return t;
    if ((s === "number" && (e = e.toString()), o)) {
      let a = t[0];
      (a && a.nodeType === 3 ? (a.data = e) : (a = document.createTextNode(e)),
        (t = Bu(n, t, i, a)));
    } else
      t !== "" && typeof t == "string"
        ? (t = n.firstChild.data = e)
        : (t = n.textContent = e);
  } else if (e == null || s === "boolean") {
    if (Me.context) return t;
    t = Bu(n, t, i);
  } else {
    if (s === "function")
      return (
        vs(() => {
          let a = e();
          for (; typeof a == "function"; ) a = a();
          t = Yh(n, a, t, i);
        }),
        () => t
      );
    if (Array.isArray(e)) {
      const a = [],
        l = t && Array.isArray(t);
      if (sy(a, e, t, r)) return (vs(() => (t = Yh(n, a, t, i, !0))), () => t);
      if (Me.context) {
        if (!a.length) return t;
        if (i === void 0) return [...n.childNodes];
        let c = a[0],
          u = [c];
        for (; (c = c.nextSibling) !== i; ) u.push(c);
        return (t = u);
      }
      if (a.length === 0) {
        if (((t = Bu(n, t, i)), o)) return t;
      } else
        l
          ? t.length === 0
            ? V5(n, a, i)
            : lD(n, t, a)
          : (t && Bu(n), V5(n, a));
      t = a;
    } else if (e.nodeType) {
      if (Me.context && e.parentNode) return (t = o ? [e] : e);
      if (Array.isArray(t)) {
        if (o) return (t = Bu(n, t, i, e));
        Bu(n, t, null, e);
      } else
        t == null || t === "" || !n.firstChild
          ? n.appendChild(e)
          : n.replaceChild(e, n.firstChild);
      t = e;
    }
  }
  return t;
}
function sy(n, e, t, i) {
  let r = !1;
  for (let s = 0, o = e.length; s < o; s++) {
    let a = e[s],
      l = t && t[s],
      c;
    if (!(a == null || a === !0 || a === !1))
      if ((c = typeof a) == "object" && a.nodeType) n.push(a);
      else if (Array.isArray(a)) r = sy(n, a, l) || r;
      else if (c === "function")
        if (i) {
          for (; typeof a == "function"; ) a = a();
          r =
            sy(n, Array.isArray(a) ? a : [a], Array.isArray(l) ? l : [l]) || r;
        } else (n.push(a), (r = !0));
      else {
        const u = String(a);
        l && l.nodeType === 3 && l.data === u
          ? n.push(l)
          : n.push(document.createTextNode(u));
      }
  }
  return r;
}
function V5(n, e, t = null) {
  for (let i = 0, r = e.length; i < r; i++) n.insertBefore(e[i], t);
}
function Bu(n, e, t, i) {
  if (t === void 0) return (n.textContent = "");
  const r = i || document.createTextNode("");
  if (e.length) {
    let s = !1;
    for (let o = e.length - 1; o >= 0; o--) {
      const a = e[o];
      if (r !== a) {
        const l = a.parentNode === n;
        !s && !o
          ? l
            ? n.replaceChild(r, a)
            : n.insertBefore(r, t)
          : l && a.remove();
      } else s = !0;
    }
  } else n.insertBefore(r, t);
  return [r];
}
function Z5(n, e) {
  const t = n.querySelectorAll("*[data-hk]");
  for (let i = 0; i < t.length; i++) {
    const r = t[i],
      s = r.getAttribute("data-hk");
    (!e || s.startsWith(e)) && !Me.registry.has(s) && Me.registry.set(s, r);
  }
}
function mD() {
  const n = Me.context;
  return `${n.id}${n.count++}`;
}
function CD(n) {
  return Me.context ? void 0 : n.children;
}
function ID() {}
const pg = !1,
  AD = "http://www.w3.org/2000/svg";
function yD(n, e = !1) {
  return e ? document.createElementNS(AD, n) : document.createElement(n);
}
const _D = (...n) => (YN(), gD(...n));
function bD(n) {
  const [e, t] = Dr(n, ["component"]),
    i = pe(() => e.component);
  return pe(() => {
    const r = i();
    switch (typeof r) {
      case "function":
        return zt(() => r(t));
      case "string":
        const s = oD.has(r),
          o = Me.context ? ft() : yD(r, s);
        return (fn(o, t, s), o);
    }
  });
}
const tt = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__,
  sn = globalThis,
  Kc = "10.29.0";
function Au() {
  return (SC(sn), sn);
}
function SC(n) {
  const e = (n.__SENTRY__ = n.__SENTRY__ || {});
  return ((e.version = e.version || Kc), (e[Kc] = e[Kc] || {}));
}
function xd(n, e, t = sn) {
  const i = (t.__SENTRY__ = t.__SENTRY__ || {}),
    r = (i[Kc] = i[Kc] || {});
  return r[n] || (r[n] = e());
}
const vD = ["debug", "info", "warn", "error", "log", "assert", "trace"],
  xD = "Sentry Logger ",
  lm = {};
function wd(n) {
  if (!("console" in sn)) return n();
  const e = sn.console,
    t = {},
    i = Object.keys(lm);
  i.forEach((r) => {
    const s = lm[r];
    ((t[r] = e[r]), (e[r] = s));
  });
  try {
    return n();
  } finally {
    i.forEach((r) => {
      e[r] = t[r];
    });
  }
}
function wD() {
  Cb().enabled = !0;
}
function SD() {
  Cb().enabled = !1;
}
function L7() {
  return Cb().enabled;
}
function TD(...n) {
  mb("log", ...n);
}
function ED(...n) {
  mb("warn", ...n);
}
function MD(...n) {
  mb("error", ...n);
}
function mb(n, ...e) {
  tt &&
    L7() &&
    wd(() => {
      sn.console[n](`${xD}[${n}]:`, ...e);
    });
}
function Cb() {
  return tt ? xd("loggerSettings", () => ({ enabled: !1 })) : { enabled: !1 };
}
const Se = {
    enable: wD,
    disable: SD,
    isEnabled: L7,
    log: TD,
    warn: ED,
    error: MD,
  },
  R7 = 50,
  uu = "?",
  z5 = /\(error: (.*)\)/,
  Y5 = /captureMessage|captureException/;
function B7(...n) {
  const e = n.sort((t, i) => t[0] - i[0]).map((t) => t[1]);
  return (t, i = 0, r = 0) => {
    const s = [],
      o = t.split(`
`);
    for (let a = i; a < o.length; a++) {
      let l = o[a];
      l.length > 1024 && (l = l.slice(0, 1024));
      const c = z5.test(l) ? l.replace(z5, "$1") : l;
      if (!c.match(/\S*Error: /)) {
        for (const u of e) {
          const h = u(c);
          if (h) {
            s.push(h);
            break;
          }
        }
        if (s.length >= R7 + r) break;
      }
    }
    return RD(s.slice(r));
  };
}
function LD(n) {
  return Array.isArray(n) ? B7(...n) : n;
}
function RD(n) {
  if (!n.length) return [];
  const e = Array.from(n);
  return (
    /sentryWrapped/.test(Fp(e).function || "") && e.pop(),
    e.reverse(),
    Y5.test(Fp(e).function || "") &&
      (e.pop(), Y5.test(Fp(e).function || "") && e.pop()),
    e.slice(0, R7).map((t) => ({
      ...t,
      filename: t.filename || Fp(e).filename,
      function: t.function || uu,
    }))
  );
}
function Fp(n) {
  return n[n.length - 1] || {};
}
const EI = "<anonymous>";
function Ma(n) {
  try {
    return !n || typeof n != "function" ? EI : n.name || EI;
  } catch {
    return EI;
  }
}
function X5(n) {
  const e = n.exception;
  if (e) {
    const t = [];
    try {
      return (
        e.values.forEach((i) => {
          i.stacktrace.frames && t.push(...i.stacktrace.frames);
        }),
        t
      );
    } catch {
      return;
    }
  }
}
function P7(n) {
  return "__v_isVNode" in n && n.__v_isVNode ? "[VueVNode]" : "[VueViewModel]";
}
const s0 = {},
  K5 = {};
function Wl(n, e) {
  ((s0[n] = s0[n] || []), s0[n].push(e));
}
function Vl(n, e) {
  if (!K5[n]) {
    K5[n] = !0;
    try {
      e();
    } catch (t) {
      tt && Se.error(`Error while instrumenting ${n}`, t);
    }
  }
}
function xs(n, e) {
  const t = n && s0[n];
  if (t)
    for (const i of t)
      try {
        i(e);
      } catch (r) {
        tt &&
          Se.error(
            `Error while triggering instrumentation handler.
Type: ${n}
Name: ${Ma(i)}
Error:`,
            r,
          );
      }
}
let MI = null;
function N7(n) {
  const e = "error";
  (Wl(e, n), Vl(e, BD));
}
function BD() {
  ((MI = sn.onerror),
    (sn.onerror = function (n, e, t, i, r) {
      return (
        xs("error", { column: i, error: r, line: t, msg: n, url: e }),
        MI ? MI.apply(this, arguments) : !1
      );
    }),
    (sn.onerror.__SENTRY_INSTRUMENTED__ = !0));
}
let LI = null;
function D7(n) {
  const e = "unhandledrejection";
  (Wl(e, n), Vl(e, PD));
}
function PD() {
  ((LI = sn.onunhandledrejection),
    (sn.onunhandledrejection = function (n) {
      return (xs("unhandledrejection", n), LI ? LI.apply(this, arguments) : !0);
    }),
    (sn.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0));
}
const G7 = Object.prototype.toString;
function Ib(n) {
  switch (G7.call(n)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
    case "[object WebAssembly.Exception]":
      return !0;
    default:
      return La(n, Error);
  }
}
function Sd(n, e) {
  return G7.call(n) === `[object ${e}]`;
}
function F7(n) {
  return Sd(n, "ErrorEvent");
}
function j5(n) {
  return Sd(n, "DOMError");
}
function ND(n) {
  return Sd(n, "DOMException");
}
function _a(n) {
  return Sd(n, "String");
}
function Ab(n) {
  return (
    typeof n == "object" &&
    n !== null &&
    "__sentry_template_string__" in n &&
    "__sentry_template_values__" in n
  );
}
function Xh(n) {
  return (
    n === null || Ab(n) || (typeof n != "object" && typeof n != "function")
  );
}
function mg(n) {
  return Sd(n, "Object");
}
function TC(n) {
  return typeof Event < "u" && La(n, Event);
}
function DD(n) {
  return typeof Element < "u" && La(n, Element);
}
function GD(n) {
  return Sd(n, "RegExp");
}
function Td(n) {
  return !!(n?.then && typeof n.then == "function");
}
function FD(n) {
  return (
    mg(n) &&
    "nativeEvent" in n &&
    "preventDefault" in n &&
    "stopPropagation" in n
  );
}
function La(n, e) {
  try {
    return n instanceof e;
  } catch {
    return !1;
  }
}
function k7(n) {
  return !!(
    typeof n == "object" &&
    n !== null &&
    (n.__isVue || n._isVue || n.__v_isVNode)
  );
}
function O7(n) {
  return typeof Request < "u" && La(n, Request);
}
const yb = sn,
  kD = 80;
function Ms(n, e = {}) {
  if (!n) return "<unknown>";
  try {
    let t = n;
    const i = 5,
      r = [];
    let s = 0,
      o = 0;
    const a = " > ",
      l = a.length;
    let c;
    const u = Array.isArray(e) ? e : e.keyAttrs,
      h = (!Array.isArray(e) && e.maxStringLength) || kD;
    for (
      ;
      t &&
      s++ < i &&
      ((c = OD(t, u)),
      !(c === "html" || (s > 1 && o + r.length * l + c.length >= h)));
    )
      (r.push(c), (o += c.length), (t = t.parentNode));
    return r.reverse().join(a);
  } catch {
    return "<unknown>";
  }
}
function OD(n, e) {
  const t = n,
    i = [];
  if (!t?.tagName) return "";
  if (yb.HTMLElement && t instanceof HTMLElement && t.dataset) {
    if (t.dataset.sentryComponent) return t.dataset.sentryComponent;
    if (t.dataset.sentryElement) return t.dataset.sentryElement;
  }
  i.push(t.tagName.toLowerCase());
  const r = e?.length
    ? e.filter((o) => t.getAttribute(o)).map((o) => [o, t.getAttribute(o)])
    : null;
  if (r?.length)
    r.forEach((o) => {
      i.push(`[${o[0]}="${o[1]}"]`);
    });
  else {
    t.id && i.push(`#${t.id}`);
    const o = t.className;
    if (o && _a(o)) {
      const a = o.split(/\s+/);
      for (const l of a) i.push(`.${l}`);
    }
  }
  const s = ["aria-label", "type", "name", "title", "alt"];
  for (const o of s) {
    const a = t.getAttribute(o);
    a && i.push(`[${o}="${a}"]`);
  }
  return i.join("");
}
function qg() {
  try {
    return yb.document.location.href;
  } catch {
    return "";
  }
}
function U7(n) {
  if (!yb.HTMLElement) return null;
  let e = n;
  const t = 5;
  for (let i = 0; i < t; i++) {
    if (!e) return null;
    if (e instanceof HTMLElement) {
      if (e.dataset.sentryComponent) return e.dataset.sentryComponent;
      if (e.dataset.sentryElement) return e.dataset.sentryElement;
    }
    e = e.parentNode;
  }
  return null;
}
function Zr(n, e, t) {
  if (!(e in n)) return;
  const i = n[e];
  if (typeof i != "function") return;
  const r = t(i);
  typeof r == "function" && H7(r, i);
  try {
    n[e] = r;
  } catch {
    tt && Se.log(`Failed to replace method "${e}" in object`, n);
  }
}
function Qr(n, e, t) {
  try {
    Object.defineProperty(n, e, { value: t, writable: !0, configurable: !0 });
  } catch {
    tt && Se.log(`Failed to add non-enumerable property "${e}" to object`, n);
  }
}
function H7(n, e) {
  try {
    const t = e.prototype || {};
    ((n.prototype = e.prototype = t), Qr(n, "__sentry_original__", e));
  } catch {}
}
function _b(n) {
  return n.__sentry_original__;
}
function W7(n) {
  if (Ib(n))
    return { message: n.message, name: n.name, stack: n.stack, ...J5(n) };
  if (TC(n)) {
    const e = {
      type: n.type,
      target: $5(n.target),
      currentTarget: $5(n.currentTarget),
      ...J5(n),
    };
    return (
      typeof CustomEvent < "u" && La(n, CustomEvent) && (e.detail = n.detail),
      e
    );
  } else return n;
}
function $5(n) {
  try {
    return DD(n) ? Ms(n) : Object.prototype.toString.call(n);
  } catch {
    return "<unknown>";
  }
}
function J5(n) {
  if (typeof n == "object" && n !== null) {
    const e = {};
    for (const t in n)
      Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t]);
    return e;
  } else return {};
}
function UD(n) {
  const e = Object.keys(W7(n));
  return (e.sort(), e[0] ? e.join(", ") : "[object has no keys]");
}
function oy(n, e = 0) {
  return typeof n != "string" || e === 0 || n.length <= e
    ? n
    : `${n.slice(0, e)}...`;
}
function Q5(n, e) {
  if (!Array.isArray(n)) return "";
  const t = [];
  for (let i = 0; i < n.length; i++) {
    const r = n[i];
    try {
      k7(r) ? t.push(P7(r)) : t.push(String(r));
    } catch {
      t.push("[value cannot be serialized]");
    }
  }
  return t.join(e);
}
function o0(n, e, t = !1) {
  return _a(n)
    ? GD(e)
      ? e.test(n)
      : _a(e)
        ? t
          ? n === e
          : n.includes(e)
        : !1
    : !1;
}
function xl(n, e = [], t = !1) {
  return e.some((i) => o0(n, i, t));
}
function HD() {
  const n = sn;
  return n.crypto || n.msCrypto;
}
let RI;
function WD() {
  return Math.random() * 16;
}
function ws(n = HD()) {
  try {
    if (n?.randomUUID) return n.randomUUID().replace(/-/g, "");
  } catch {}
  return (
    RI || (RI = [1e7] + 1e3 + 4e3 + 8e3 + 1e11),
    RI.replace(/[018]/g, (e) => (e ^ ((WD() & 15) >> (e / 4))).toString(16))
  );
}
function V7(n) {
  return n.exception?.values?.[0];
}
function Dc(n) {
  const { message: e, event_id: t } = n;
  if (e) return e;
  const i = V7(n);
  return i
    ? i.type && i.value
      ? `${i.type}: ${i.value}`
      : i.type || i.value || t || "<unknown>"
    : t || "<unknown>";
}
function ay(n, e, t) {
  const i = (n.exception = n.exception || {}),
    r = (i.values = i.values || []),
    s = (r[0] = r[0] || {});
  (s.value || (s.value = e || ""), s.type || (s.type = t || "Error"));
}
function Kh(n, e) {
  const t = V7(n);
  if (!t) return;
  const i = { type: "generic", handled: !0 },
    r = t.mechanism;
  if (((t.mechanism = { ...i, ...r, ...e }), e && "data" in e)) {
    const s = { ...r?.data, ...e.data };
    t.mechanism.data = s;
  }
}
function q5(n) {
  if (VD(n)) return !0;
  try {
    Qr(n, "__sentry_captured__", !0);
  } catch {}
  return !1;
}
function VD(n) {
  try {
    return n.__sentry_captured__;
  } catch {}
}
const Z7 = 1e3;
function yu() {
  return Date.now() / Z7;
}
function ZD() {
  const { performance: n } = sn;
  if (!n?.now || !n.timeOrigin) return yu;
  const e = n.timeOrigin;
  return () => (e + n.now()) / Z7;
}
let e4;
function Bi() {
  return (e4 ?? (e4 = ZD()))();
}
let BI;
function zD() {
  const { performance: n } = sn;
  if (!n?.now) return [void 0, "none"];
  const e = 3600 * 1e3,
    t = n.now(),
    i = Date.now(),
    r = n.timeOrigin ? Math.abs(n.timeOrigin + t - i) : e,
    s = r < e,
    o = n.timing?.navigationStart,
    l = typeof o == "number" ? Math.abs(o + t - i) : e,
    c = l < e;
  return s || c
    ? r <= l
      ? [n.timeOrigin, "timeOrigin"]
      : [o, "navigationStart"]
    : [i, "dateNow"];
}
function ts() {
  return (BI || (BI = zD()), BI[0]);
}
function YD(n) {
  const e = Bi(),
    t = {
      sid: ws(),
      init: !0,
      timestamp: e,
      started: e,
      duration: 0,
      status: "ok",
      errors: 0,
      ignoreDuration: !1,
      toJSON: () => KD(t),
    };
  return (n && jh(t, n), t);
}
function jh(n, e = {}) {
  if (
    (e.user &&
      (!n.ipAddress && e.user.ip_address && (n.ipAddress = e.user.ip_address),
      !n.did &&
        !e.did &&
        (n.did = e.user.id || e.user.email || e.user.username)),
    (n.timestamp = e.timestamp || Bi()),
    e.abnormal_mechanism && (n.abnormal_mechanism = e.abnormal_mechanism),
    e.ignoreDuration && (n.ignoreDuration = e.ignoreDuration),
    e.sid && (n.sid = e.sid.length === 32 ? e.sid : ws()),
    e.init !== void 0 && (n.init = e.init),
    !n.did && e.did && (n.did = `${e.did}`),
    typeof e.started == "number" && (n.started = e.started),
    n.ignoreDuration)
  )
    n.duration = void 0;
  else if (typeof e.duration == "number") n.duration = e.duration;
  else {
    const t = n.timestamp - n.started;
    n.duration = t >= 0 ? t : 0;
  }
  (e.release && (n.release = e.release),
    e.environment && (n.environment = e.environment),
    !n.ipAddress && e.ipAddress && (n.ipAddress = e.ipAddress),
    !n.userAgent && e.userAgent && (n.userAgent = e.userAgent),
    typeof e.errors == "number" && (n.errors = e.errors),
    e.status && (n.status = e.status));
}
function XD(n, e) {
  let t = {};
  (e ? (t = { status: e }) : n.status === "ok" && (t = { status: "exited" }),
    jh(n, t));
}
function KD(n) {
  return {
    sid: `${n.sid}`,
    init: n.init,
    started: new Date(n.started * 1e3).toISOString(),
    timestamp: new Date(n.timestamp * 1e3).toISOString(),
    status: n.status,
    errors: n.errors,
    did:
      typeof n.did == "number" || typeof n.did == "string"
        ? `${n.did}`
        : void 0,
    duration: n.duration,
    abnormal_mechanism: n.abnormal_mechanism,
    attrs: {
      release: n.release,
      environment: n.environment,
      ip_address: n.ipAddress,
      user_agent: n.userAgent,
    },
  };
}
function ep(n, e, t = 2) {
  if (!e || typeof e != "object" || t <= 0) return e;
  if (n && Object.keys(e).length === 0) return n;
  const i = { ...n };
  for (const r in e)
    Object.prototype.hasOwnProperty.call(e, r) &&
      (i[r] = ep(i[r], e[r], t - 1));
  return i;
}
function Ra() {
  return ws();
}
function ba() {
  return ws().substring(16);
}
const ly = "_sentrySpan";
function $h(n, e) {
  e ? Qr(n, ly, e) : delete n[ly];
}
function cm(n) {
  return n[ly];
}
const jD = 100;
class Po {
  constructor() {
    ((this._notifyingListeners = !1),
      (this._scopeListeners = []),
      (this._eventProcessors = []),
      (this._breadcrumbs = []),
      (this._attachments = []),
      (this._user = {}),
      (this._tags = {}),
      (this._attributes = {}),
      (this._extra = {}),
      (this._contexts = {}),
      (this._sdkProcessingMetadata = {}),
      (this._propagationContext = {
        traceId: Ra(),
        sampleRand: Math.random(),
      }));
  }
  clone() {
    const e = new Po();
    return (
      (e._breadcrumbs = [...this._breadcrumbs]),
      (e._tags = { ...this._tags }),
      (e._attributes = { ...this._attributes }),
      (e._extra = { ...this._extra }),
      (e._contexts = { ...this._contexts }),
      this._contexts.flags &&
        (e._contexts.flags = { values: [...this._contexts.flags.values] }),
      (e._user = this._user),
      (e._level = this._level),
      (e._session = this._session),
      (e._transactionName = this._transactionName),
      (e._fingerprint = this._fingerprint),
      (e._eventProcessors = [...this._eventProcessors]),
      (e._attachments = [...this._attachments]),
      (e._sdkProcessingMetadata = { ...this._sdkProcessingMetadata }),
      (e._propagationContext = { ...this._propagationContext }),
      (e._client = this._client),
      (e._lastEventId = this._lastEventId),
      $h(e, cm(this)),
      e
    );
  }
  setClient(e) {
    this._client = e;
  }
  setLastEventId(e) {
    this._lastEventId = e;
  }
  getClient() {
    return this._client;
  }
  lastEventId() {
    return this._lastEventId;
  }
  addScopeListener(e) {
    this._scopeListeners.push(e);
  }
  addEventProcessor(e) {
    return (this._eventProcessors.push(e), this);
  }
  setUser(e) {
    return (
      (this._user = e || {
        email: void 0,
        id: void 0,
        ip_address: void 0,
        username: void 0,
      }),
      this._session && jh(this._session, { user: e }),
      this._notifyScopeListeners(),
      this
    );
  }
  getUser() {
    return this._user;
  }
  setTags(e) {
    return (
      (this._tags = { ...this._tags, ...e }),
      this._notifyScopeListeners(),
      this
    );
  }
  setTag(e, t) {
    return this.setTags({ [e]: t });
  }
  setAttributes(e) {
    return (
      (this._attributes = { ...this._attributes, ...e }),
      this._notifyScopeListeners(),
      this
    );
  }
  setAttribute(e, t) {
    return this.setAttributes({ [e]: t });
  }
  removeAttribute(e) {
    return (
      e in this._attributes &&
        (delete this._attributes[e], this._notifyScopeListeners()),
      this
    );
  }
  setExtras(e) {
    return (
      (this._extra = { ...this._extra, ...e }),
      this._notifyScopeListeners(),
      this
    );
  }
  setExtra(e, t) {
    return (
      (this._extra = { ...this._extra, [e]: t }),
      this._notifyScopeListeners(),
      this
    );
  }
  setFingerprint(e) {
    return ((this._fingerprint = e), this._notifyScopeListeners(), this);
  }
  setLevel(e) {
    return ((this._level = e), this._notifyScopeListeners(), this);
  }
  setTransactionName(e) {
    return ((this._transactionName = e), this._notifyScopeListeners(), this);
  }
  setContext(e, t) {
    return (
      t === null ? delete this._contexts[e] : (this._contexts[e] = t),
      this._notifyScopeListeners(),
      this
    );
  }
  setSession(e) {
    return (
      e ? (this._session = e) : delete this._session,
      this._notifyScopeListeners(),
      this
    );
  }
  getSession() {
    return this._session;
  }
  update(e) {
    if (!e) return this;
    const t = typeof e == "function" ? e(this) : e,
      i = t instanceof Po ? t.getScopeData() : mg(t) ? e : void 0,
      {
        tags: r,
        attributes: s,
        extra: o,
        user: a,
        contexts: l,
        level: c,
        fingerprint: u = [],
        propagationContext: h,
      } = i || {};
    return (
      (this._tags = { ...this._tags, ...r }),
      (this._attributes = { ...this._attributes, ...s }),
      (this._extra = { ...this._extra, ...o }),
      (this._contexts = { ...this._contexts, ...l }),
      a && Object.keys(a).length && (this._user = a),
      c && (this._level = c),
      u.length && (this._fingerprint = u),
      h && (this._propagationContext = h),
      this
    );
  }
  clear() {
    return (
      (this._breadcrumbs = []),
      (this._tags = {}),
      (this._attributes = {}),
      (this._extra = {}),
      (this._user = {}),
      (this._contexts = {}),
      (this._level = void 0),
      (this._transactionName = void 0),
      (this._fingerprint = void 0),
      (this._session = void 0),
      $h(this, void 0),
      (this._attachments = []),
      this.setPropagationContext({ traceId: Ra(), sampleRand: Math.random() }),
      this._notifyScopeListeners(),
      this
    );
  }
  addBreadcrumb(e, t) {
    const i = typeof t == "number" ? t : jD;
    if (i <= 0) return this;
    const r = {
      timestamp: yu(),
      ...e,
      message: e.message ? oy(e.message, 2048) : e.message,
    };
    return (
      this._breadcrumbs.push(r),
      this._breadcrumbs.length > i &&
        ((this._breadcrumbs = this._breadcrumbs.slice(-i)),
        this._client?.recordDroppedEvent("buffer_overflow", "log_item")),
      this._notifyScopeListeners(),
      this
    );
  }
  getLastBreadcrumb() {
    return this._breadcrumbs[this._breadcrumbs.length - 1];
  }
  clearBreadcrumbs() {
    return ((this._breadcrumbs = []), this._notifyScopeListeners(), this);
  }
  addAttachment(e) {
    return (this._attachments.push(e), this);
  }
  clearAttachments() {
    return ((this._attachments = []), this);
  }
  getScopeData() {
    return {
      breadcrumbs: this._breadcrumbs,
      attachments: this._attachments,
      contexts: this._contexts,
      tags: this._tags,
      attributes: this._attributes,
      extra: this._extra,
      user: this._user,
      level: this._level,
      fingerprint: this._fingerprint || [],
      eventProcessors: this._eventProcessors,
      propagationContext: this._propagationContext,
      sdkProcessingMetadata: this._sdkProcessingMetadata,
      transactionName: this._transactionName,
      span: cm(this),
    };
  }
  setSDKProcessingMetadata(e) {
    return (
      (this._sdkProcessingMetadata = ep(this._sdkProcessingMetadata, e, 2)),
      this
    );
  }
  setPropagationContext(e) {
    return ((this._propagationContext = e), this);
  }
  getPropagationContext() {
    return this._propagationContext;
  }
  captureException(e, t) {
    const i = t?.event_id || ws();
    if (!this._client)
      return (
        tt &&
          Se.warn(
            "No client configured on scope - will not capture exception!",
          ),
        i
      );
    const r = new Error("Sentry syntheticException");
    return (
      this._client.captureException(
        e,
        { originalException: e, syntheticException: r, ...t, event_id: i },
        this,
      ),
      i
    );
  }
  captureMessage(e, t, i) {
    const r = i?.event_id || ws();
    if (!this._client)
      return (
        tt &&
          Se.warn("No client configured on scope - will not capture message!"),
        r
      );
    const s = i?.syntheticException ?? new Error(e);
    return (
      this._client.captureMessage(
        e,
        t,
        { originalException: e, syntheticException: s, ...i, event_id: r },
        this,
      ),
      r
    );
  }
  captureEvent(e, t) {
    const i = t?.event_id || ws();
    return this._client
      ? (this._client.captureEvent(e, { ...t, event_id: i }, this), i)
      : (tt &&
          Se.warn("No client configured on scope - will not capture event!"),
        i);
  }
  _notifyScopeListeners() {
    this._notifyingListeners ||
      ((this._notifyingListeners = !0),
      this._scopeListeners.forEach((e) => {
        e(this);
      }),
      (this._notifyingListeners = !1));
  }
}
function $D() {
  return xd("defaultCurrentScope", () => new Po());
}
function JD() {
  return xd("defaultIsolationScope", () => new Po());
}
class QD {
  constructor(e, t) {
    let i;
    e ? (i = e) : (i = new Po());
    let r;
    (t ? (r = t) : (r = new Po()),
      (this._stack = [{ scope: i }]),
      (this._isolationScope = r));
  }
  withScope(e) {
    const t = this._pushScope();
    let i;
    try {
      i = e(t);
    } catch (r) {
      throw (this._popScope(), r);
    }
    return Td(i)
      ? i.then(
          (r) => (this._popScope(), r),
          (r) => {
            throw (this._popScope(), r);
          },
        )
      : (this._popScope(), i);
  }
  getClient() {
    return this.getStackTop().client;
  }
  getScope() {
    return this.getStackTop().scope;
  }
  getIsolationScope() {
    return this._isolationScope;
  }
  getStackTop() {
    return this._stack[this._stack.length - 1];
  }
  _pushScope() {
    const e = this.getScope().clone();
    return (this._stack.push({ client: this.getClient(), scope: e }), e);
  }
  _popScope() {
    return this._stack.length <= 1 ? !1 : !!this._stack.pop();
  }
}
function Jh() {
  const n = Au(),
    e = SC(n);
  return (e.stack = e.stack || new QD($D(), JD()));
}
function qD(n) {
  return Jh().withScope(n);
}
function eG(n, e) {
  const t = Jh();
  return t.withScope(() => ((t.getStackTop().scope = n), e(n)));
}
function t4(n) {
  return Jh().withScope(() => n(Jh().getIsolationScope()));
}
function tG() {
  return {
    withIsolationScope: t4,
    withScope: qD,
    withSetScope: eG,
    withSetIsolationScope: (n, e) => t4(e),
    getCurrentScope: () => Jh().getScope(),
    getIsolationScope: () => Jh().getIsolationScope(),
  };
}
function Ed(n) {
  const e = SC(n);
  return e.acs ? e.acs : tG();
}
function wn() {
  const n = Au();
  return Ed(n).getCurrentScope();
}
function _u() {
  const n = Au();
  return Ed(n).getIsolationScope();
}
function nG() {
  return xd("globalScope", () => new Po());
}
function EC(...n) {
  const e = Au(),
    t = Ed(e);
  if (n.length === 2) {
    const [i, r] = n;
    return i ? t.withSetScope(i, r) : t.withScope(r);
  }
  return t.withScope(n[0]);
}
function yn() {
  return wn().getClient();
}
function iG(n) {
  const e = n.getPropagationContext(),
    { traceId: t, parentSpanId: i, propagationSpanId: r } = e,
    s = { trace_id: t, span_id: r || ba() };
  return (i && (s.parent_span_id = i), s);
}
const _o = "sentry.source",
  bb = "sentry.sample_rate",
  z7 = "sentry.previous_trace_sample_rate",
  Ba = "sentry.op",
  pi = "sentry.origin",
  Cg = "sentry.idle_span_finish_reason",
  tp = "sentry.measurement_unit",
  np = "sentry.measurement_value",
  n4 = "sentry.custom_span_name",
  vb = "sentry.profile_id",
  Md = "sentry.exclusive_time",
  rG = "sentry.link.type",
  sG = 0,
  xb = 1,
  di = 2;
function oG(n) {
  if (n < 400 && n >= 100) return { code: xb };
  if (n >= 400 && n < 500)
    switch (n) {
      case 401:
        return { code: di, message: "unauthenticated" };
      case 403:
        return { code: di, message: "permission_denied" };
      case 404:
        return { code: di, message: "not_found" };
      case 409:
        return { code: di, message: "already_exists" };
      case 413:
        return { code: di, message: "failed_precondition" };
      case 429:
        return { code: di, message: "resource_exhausted" };
      case 499:
        return { code: di, message: "cancelled" };
      default:
        return { code: di, message: "invalid_argument" };
    }
  if (n >= 500 && n < 600)
    switch (n) {
      case 501:
        return { code: di, message: "unimplemented" };
      case 503:
        return { code: di, message: "unavailable" };
      case 504:
        return { code: di, message: "deadline_exceeded" };
      default:
        return { code: di, message: "internal_error" };
    }
  return { code: di, message: "internal_error" };
}
function Y7(n, e) {
  n.setAttribute("http.response.status_code", e);
  const t = oG(e);
  t.message !== "unknown_error" && n.setStatus(t);
}
const X7 = "_sentryScope",
  K7 = "_sentryIsolationScope";
function aG(n) {
  try {
    const e = sn.WeakRef;
    if (typeof e == "function") return new e(n);
  } catch {}
  return n;
}
function lG(n) {
  if (n) {
    if (typeof n == "object" && "deref" in n && typeof n.deref == "function")
      try {
        return n.deref();
      } catch {
        return;
      }
    return n;
  }
}
function cG(n, e, t) {
  n && (Qr(n, K7, aG(t)), Qr(n, X7, e));
}
function um(n) {
  const e = n;
  return { scope: e[X7], isolationScope: lG(e[K7]) };
}
const wb = "sentry-",
  uG = /^sentry-/,
  hG = 8192;
function j7(n) {
  const e = fG(n);
  if (!e) return;
  const t = Object.entries(e).reduce((i, [r, s]) => {
    if (r.match(uG)) {
      const o = r.slice(wb.length);
      i[o] = s;
    }
    return i;
  }, {});
  if (Object.keys(t).length > 0) return t;
}
function dG(n) {
  if (!n) return;
  const e = Object.entries(n).reduce(
    (t, [i, r]) => (r && (t[`${wb}${i}`] = r), t),
    {},
  );
  return gG(e);
}
function fG(n) {
  if (!(!n || (!_a(n) && !Array.isArray(n))))
    return Array.isArray(n)
      ? n.reduce((e, t) => {
          const i = i4(t);
          return (
            Object.entries(i).forEach(([r, s]) => {
              e[r] = s;
            }),
            e
          );
        }, {})
      : i4(n);
}
function i4(n) {
  return n
    .split(",")
    .map((e) => {
      const t = e.indexOf("=");
      if (t === -1) return [];
      const i = e.slice(0, t),
        r = e.slice(t + 1);
      return [i, r].map((s) => {
        try {
          return decodeURIComponent(s.trim());
        } catch {
          return;
        }
      });
    })
    .reduce((e, [t, i]) => (t && i && (e[t] = i), e), {});
}
function gG(n) {
  if (Object.keys(n).length !== 0)
    return Object.entries(n).reduce((e, [t, i], r) => {
      const s = `${encodeURIComponent(t)}=${encodeURIComponent(i)}`,
        o = r === 0 ? s : `${e},${s}`;
      return o.length > hG
        ? (tt &&
            Se.warn(
              `Not adding key: ${t} with val: ${i} to baggage header due to exceeding baggage size limits.`,
            ),
          e)
        : o;
    }, "");
}
const pG = /^o(\d+)\./,
  mG = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function CG(n) {
  return n === "http" || n === "https";
}
function Ld(n, e = !1) {
  const {
    host: t,
    path: i,
    pass: r,
    port: s,
    projectId: o,
    protocol: a,
    publicKey: l,
  } = n;
  return `${a}://${l}${e && r ? `:${r}` : ""}@${t}${s ? `:${s}` : ""}/${i && `${i}/`}${o}`;
}
function IG(n) {
  const e = mG.exec(n);
  if (!e) {
    wd(() => {
      console.error(`Invalid Sentry Dsn: ${n}`);
    });
    return;
  }
  const [t, i, r = "", s = "", o = "", a = ""] = e.slice(1);
  let l = "",
    c = a;
  const u = c.split("/");
  if ((u.length > 1 && ((l = u.slice(0, -1).join("/")), (c = u.pop())), c)) {
    const h = c.match(/^\d+/);
    h && (c = h[0]);
  }
  return $7({
    host: s,
    pass: r,
    path: l,
    projectId: c,
    port: o,
    protocol: t,
    publicKey: i,
  });
}
function $7(n) {
  return {
    protocol: n.protocol,
    publicKey: n.publicKey || "",
    pass: n.pass || "",
    host: n.host,
    port: n.port || "",
    path: n.path || "",
    projectId: n.projectId,
  };
}
function AG(n) {
  if (!tt) return !0;
  const { port: e, projectId: t, protocol: i } = n;
  return ["protocol", "publicKey", "host", "projectId"].find((o) =>
    n[o] ? !1 : (Se.error(`Invalid Sentry Dsn: ${o} missing`), !0),
  )
    ? !1
    : t.match(/^\d+$/)
      ? CG(i)
        ? e && isNaN(parseInt(e, 10))
          ? (Se.error(`Invalid Sentry Dsn: Invalid port ${e}`), !1)
          : !0
        : (Se.error(`Invalid Sentry Dsn: Invalid protocol ${i}`), !1)
      : (Se.error(`Invalid Sentry Dsn: Invalid projectId ${t}`), !1);
}
function yG(n) {
  return n.match(pG)?.[1];
}
function _G(n) {
  const e = n.getOptions(),
    { host: t } = n.getDsn() || {};
  let i;
  return (e.orgId ? (i = String(e.orgId)) : t && (i = yG(t)), i);
}
function bG(n) {
  const e = typeof n == "string" ? IG(n) : $7(n);
  if (!(!e || !AG(e))) return e;
}
function Ig(n) {
  if (typeof n == "boolean") return Number(n);
  const e = typeof n == "string" ? parseFloat(n) : n;
  if (!(typeof e != "number" || isNaN(e) || e < 0 || e > 1)) return e;
}
const J7 = new RegExp(
  "^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$",
);
function vG(n) {
  if (!n) return;
  const e = n.match(J7);
  if (!e) return;
  let t;
  return (
    e[3] === "1" ? (t = !0) : e[3] === "0" && (t = !1),
    { traceId: e[1], parentSampled: t, parentSpanId: e[2] }
  );
}
function xG(n, e) {
  const t = vG(n),
    i = j7(e);
  if (!t?.traceId) return { traceId: Ra(), sampleRand: Math.random() };
  const r = wG(t, i);
  i && (i.sample_rand = r.toString());
  const { traceId: s, parentSpanId: o, parentSampled: a } = t;
  return {
    traceId: s,
    parentSpanId: o,
    sampled: a,
    dsc: i || {},
    sampleRand: r,
  };
}
function Q7(n = Ra(), e = ba(), t) {
  let i = "";
  return (t !== void 0 && (i = t ? "-1" : "-0"), `${n}-${e}${i}`);
}
function q7(n = Ra(), e = ba(), t) {
  return `00-${n}-${e}-${t ? "01" : "00"}`;
}
function wG(n, e) {
  const t = Ig(e?.sample_rand);
  if (t !== void 0) return t;
  const i = Ig(e?.sample_rate);
  return i && n?.parentSampled !== void 0
    ? n.parentSampled
      ? Math.random() * i
      : i + Math.random() * (1 - i)
    : Math.random();
}
const e8 = 0,
  Sb = 1;
let r4 = !1;
function SG(n) {
  const { spanId: e, traceId: t } = n.spanContext(),
    {
      data: i,
      op: r,
      parent_span_id: s,
      status: o,
      origin: a,
      links: l,
    } = cn(n);
  return {
    parent_span_id: s,
    span_id: e,
    trace_id: t,
    data: i,
    op: r,
    status: o,
    origin: a,
    links: l,
  };
}
function TG(n) {
  const { spanId: e, traceId: t, isRemote: i } = n.spanContext(),
    r = i ? e : cn(n).parent_span_id,
    s = um(n).scope,
    o = i ? s?.getPropagationContext().propagationSpanId || ba() : e;
  return { parent_span_id: r, span_id: o, trace_id: t };
}
function EG(n) {
  const { traceId: e, spanId: t } = n.spanContext(),
    i = Zl(n);
  return Q7(e, t, i);
}
function MG(n) {
  const { traceId: e, spanId: t } = n.spanContext(),
    i = Zl(n);
  return q7(e, t, i);
}
function t8(n) {
  if (n && n.length > 0)
    return n.map(
      ({
        context: { spanId: e, traceId: t, traceFlags: i, ...r },
        attributes: s,
      }) => ({
        span_id: e,
        trace_id: t,
        sampled: i === Sb,
        attributes: s,
        ...r,
      }),
    );
}
function jc(n) {
  return typeof n == "number"
    ? s4(n)
    : Array.isArray(n)
      ? n[0] + n[1] / 1e9
      : n instanceof Date
        ? s4(n.getTime())
        : Bi();
}
function s4(n) {
  return n > 9999999999 ? n / 1e3 : n;
}
function cn(n) {
  if (RG(n)) return n.getSpanJSON();
  const { spanId: e, traceId: t } = n.spanContext();
  if (LG(n)) {
    const {
        attributes: i,
        startTime: r,
        name: s,
        endTime: o,
        status: a,
        links: l,
      } = n,
      c =
        "parentSpanId" in n
          ? n.parentSpanId
          : "parentSpanContext" in n
            ? n.parentSpanContext?.spanId
            : void 0;
    return {
      span_id: e,
      trace_id: t,
      data: i,
      description: s,
      parent_span_id: c,
      start_timestamp: jc(r),
      timestamp: jc(o) || void 0,
      status: n8(a),
      op: i[Ba],
      origin: i[pi],
      links: t8(l),
    };
  }
  return { span_id: e, trace_id: t, start_timestamp: 0, data: {} };
}
function LG(n) {
  const e = n;
  return (
    !!e.attributes && !!e.startTime && !!e.name && !!e.endTime && !!e.status
  );
}
function RG(n) {
  return typeof n.getSpanJSON == "function";
}
function Zl(n) {
  const { traceFlags: e } = n.spanContext();
  return e === Sb;
}
function n8(n) {
  if (!(!n || n.code === sG))
    return n.code === xb ? "ok" : n.message || "internal_error";
}
const $c = "_sentryChildSpans",
  cy = "_sentryRootSpan";
function i8(n, e) {
  const t = n[cy] || n;
  (Qr(e, cy, t), n[$c] ? n[$c].add(e) : Qr(n, $c, new Set([e])));
}
function BG(n, e) {
  n[$c] && n[$c].delete(e);
}
function a0(n) {
  const e = new Set();
  function t(i) {
    if (!e.has(i) && Zl(i)) {
      e.add(i);
      const r = i[$c] ? Array.from(i[$c]) : [];
      for (const s of r) t(s);
    }
  }
  return (t(n), Array.from(e));
}
function pr(n) {
  return n[cy] || n;
}
function ns() {
  const n = Au(),
    e = Ed(n);
  return e.getActiveSpan ? e.getActiveSpan() : cm(wn());
}
function uy() {
  r4 ||
    (wd(() => {
      console.warn(
        "[Sentry] Returning null from `beforeSendSpan` is disallowed. To drop certain spans, configure the respective integrations directly or use `ignoreSpans`.",
      );
    }),
    (r4 = !0));
}
let o4 = !1;
function PG() {
  if (o4) return;
  function n() {
    const e = ns(),
      t = e && pr(e);
    if (t) {
      const i = "internal_error";
      (tt && Se.log(`[Tracing] Root span: ${i} -> Global error occurred`),
        t.setStatus({ code: di, message: i }));
    }
  }
  ((n.tag = "sentry_tracingErrorCallback"), (o4 = !0), N7(n), D7(n));
}
function $s(n) {
  if (typeof __SENTRY_TRACING__ == "boolean" && !__SENTRY_TRACING__) return !1;
  const e = n || yn()?.getOptions();
  return !!e && (e.tracesSampleRate != null || !!e.tracesSampler);
}
function a4(n) {
  Se.log(
    `Ignoring span ${n.op} - ${n.description} because it matches \`ignoreSpans\`.`,
  );
}
function hm(n, e) {
  if (!e?.length || !n.description) return !1;
  for (const t of e) {
    if (DG(t)) {
      if (o0(n.description, t)) return (tt && a4(n), !0);
      continue;
    }
    if (!t.name && !t.op) continue;
    const i = t.name ? o0(n.description, t.name) : !0,
      r = t.op ? n.op && o0(n.op, t.op) : !0;
    if (i && r) return (tt && a4(n), !0);
  }
  return !1;
}
function NG(n, e) {
  const t = e.parent_span_id,
    i = e.span_id;
  if (t) for (const r of n) r.parent_span_id === i && (r.parent_span_id = t);
}
function DG(n) {
  return typeof n == "string" || n instanceof RegExp;
}
const Tb = "production",
  r8 = "_frozenDsc";
function l0(n, e) {
  Qr(n, r8, e);
}
function s8(n, e) {
  const t = e.getOptions(),
    { publicKey: i } = e.getDsn() || {},
    r = {
      environment: t.environment || Tb,
      release: t.release,
      public_key: i,
      trace_id: n,
      org_id: _G(e),
    };
  return (e.emit("createDsc", r), r);
}
function o8(n, e) {
  const t = e.getPropagationContext();
  return t.dsc || s8(t.traceId, n);
}
function Bl(n) {
  const e = yn();
  if (!e) return {};
  const t = pr(n),
    i = cn(t),
    r = i.data,
    s = t.spanContext().traceState,
    o = s?.get("sentry.sample_rate") ?? r[bb] ?? r[z7];
  function a(g) {
    return (
      (typeof o == "number" || typeof o == "string") &&
        (g.sample_rate = `${o}`),
      g
    );
  }
  const l = t[r8];
  if (l) return a(l);
  const c = s?.get("sentry.dsc"),
    u = c && j7(c);
  if (u) return a(u);
  const h = s8(n.spanContext().traceId, e),
    d = r[_o],
    f = i.description;
  return (
    d !== "url" && f && (h.transaction = f),
    $s() &&
      ((h.sampled = String(Zl(t))),
      (h.sample_rand =
        s?.get("sentry.sample_rand") ??
        um(t).scope?.getPropagationContext().sampleRand.toString())),
    a(h),
    e.emit("createDsc", h, t),
    h
  );
}
class Pl {
  constructor(e = {}) {
    ((this._traceId = e.traceId || Ra()), (this._spanId = e.spanId || ba()));
  }
  spanContext() {
    return { spanId: this._spanId, traceId: this._traceId, traceFlags: e8 };
  }
  end(e) {}
  setAttribute(e, t) {
    return this;
  }
  setAttributes(e) {
    return this;
  }
  setStatus(e) {
    return this;
  }
  updateName(e) {
    return this;
  }
  isRecording() {
    return !1;
  }
  addEvent(e, t, i) {
    return this;
  }
  addLink(e) {
    return this;
  }
  addLinks(e) {
    return this;
  }
  recordException(e, t) {}
}
function aa(n, e = 100, t = 1 / 0) {
  try {
    return hy("", n, e, t);
  } catch (i) {
    return { ERROR: `**non-serializable** (${i})` };
  }
}
function a8(n, e = 3, t = 100 * 1024) {
  const i = aa(n, e);
  return OG(i) > t ? a8(n, e - 1, t) : i;
}
function hy(n, e, t = 1 / 0, i = 1 / 0, r = UG()) {
  const [s, o] = r;
  if (
    e == null ||
    ["boolean", "string"].includes(typeof e) ||
    (typeof e == "number" && Number.isFinite(e))
  )
    return e;
  const a = GG(n, e);
  if (!a.startsWith("[object ")) return a;
  if (e.__sentry_skip_normalization__) return e;
  const l =
    typeof e.__sentry_override_normalization_depth__ == "number"
      ? e.__sentry_override_normalization_depth__
      : t;
  if (l === 0) return a.replace("object ", "");
  if (s(e)) return "[Circular ~]";
  const c = e;
  if (c && typeof c.toJSON == "function")
    try {
      const f = c.toJSON();
      return hy("", f, l - 1, i, r);
    } catch {}
  const u = Array.isArray(e) ? [] : {};
  let h = 0;
  const d = W7(e);
  for (const f in d) {
    if (!Object.prototype.hasOwnProperty.call(d, f)) continue;
    if (h >= i) {
      u[f] = "[MaxProperties ~]";
      break;
    }
    const g = d[f];
    ((u[f] = hy(f, g, l - 1, i, r)), h++);
  }
  return (o(e), u);
}
function GG(n, e) {
  try {
    if (n === "domain" && e && typeof e == "object" && e._events)
      return "[Domain]";
    if (n === "domainEmitter") return "[DomainEmitter]";
    if (typeof global < "u" && e === global) return "[Global]";
    if (typeof window < "u" && e === window) return "[Window]";
    if (typeof document < "u" && e === document) return "[Document]";
    if (k7(e)) return P7(e);
    if (FD(e)) return "[SyntheticEvent]";
    if (typeof e == "number" && !Number.isFinite(e)) return `[${e}]`;
    if (typeof e == "function") return `[Function: ${Ma(e)}]`;
    if (typeof e == "symbol") return `[${String(e)}]`;
    if (typeof e == "bigint") return `[BigInt: ${String(e)}]`;
    const t = FG(e);
    return /^HTML(\w*)Element$/.test(t)
      ? `[HTMLElement: ${t}]`
      : `[object ${t}]`;
  } catch (t) {
    return `**non-serializable** (${t})`;
  }
}
function FG(n) {
  const e = Object.getPrototypeOf(n);
  return e?.constructor ? e.constructor.name : "null prototype";
}
function kG(n) {
  return ~-encodeURI(n).split(/%..|./).length;
}
function OG(n) {
  return kG(JSON.stringify(n));
}
function UG() {
  const n = new WeakSet();
  function e(i) {
    return n.has(i) ? !0 : (n.add(i), !1);
  }
  function t(i) {
    n.delete(i);
  }
  return [e, t];
}
function bu(n, e = []) {
  return [n, e];
}
function HG(n, e) {
  const [t, i] = n;
  return [t, [...i, e]];
}
function l4(n, e) {
  const t = n[1];
  for (const i of t) {
    const r = i[0].type;
    if (e(i, r)) return !0;
  }
  return !1;
}
function dy(n) {
  const e = SC(sn);
  return e.encodePolyfill ? e.encodePolyfill(n) : new TextEncoder().encode(n);
}
function WG(n) {
  const [e, t] = n;
  let i = JSON.stringify(e);
  function r(s) {
    typeof i == "string"
      ? (i = typeof s == "string" ? i + s : [dy(i), s])
      : i.push(typeof s == "string" ? dy(s) : s);
  }
  for (const s of t) {
    const [o, a] = s;
    if (
      (r(`
${JSON.stringify(o)}
`),
      typeof a == "string" || a instanceof Uint8Array)
    )
      r(a);
    else {
      let l;
      try {
        l = JSON.stringify(a);
      } catch {
        l = JSON.stringify(aa(a));
      }
      r(l);
    }
  }
  return typeof i == "string" ? i : VG(i);
}
function VG(n) {
  const e = n.reduce((r, s) => r + s.length, 0),
    t = new Uint8Array(e);
  let i = 0;
  for (const r of n) (t.set(r, i), (i += r.length));
  return t;
}
function ZG(n) {
  return [{ type: "span" }, n];
}
function zG(n) {
  const e = typeof n.data == "string" ? dy(n.data) : n.data;
  return [
    {
      type: "attachment",
      length: e.length,
      filename: n.filename,
      content_type: n.contentType,
      attachment_type: n.attachmentType,
    },
    e,
  ];
}
const YG = {
  session: "session",
  sessions: "session",
  attachment: "attachment",
  transaction: "transaction",
  event: "error",
  client_report: "internal",
  user_report: "default",
  profile: "profile",
  profile_chunk: "profile",
  replay_event: "replay",
  replay_recording: "replay",
  check_in: "monitor",
  feedback: "feedback",
  span: "span",
  raw_security: "security",
  log: "log_item",
  metric: "metric",
  trace_metric: "metric",
};
function c4(n) {
  return YG[n];
}
function l8(n) {
  if (!n?.sdk) return;
  const { name: e, version: t } = n.sdk;
  return { name: e, version: t };
}
function XG(n, e, t, i) {
  const r = n.sdkProcessingMetadata?.dynamicSamplingContext;
  return {
    event_id: n.event_id,
    sent_at: new Date().toISOString(),
    ...(e && { sdk: e }),
    ...(!!t && i && { dsn: Ld(i) }),
    ...(r && { trace: r }),
  };
}
function KG(n, e) {
  if (!e) return n;
  const t = n.sdk || {};
  return (
    (n.sdk = {
      ...t,
      name: t.name || e.name,
      version: t.version || e.version,
      integrations: [...(n.sdk?.integrations || []), ...(e.integrations || [])],
      packages: [...(n.sdk?.packages || []), ...(e.packages || [])],
      settings:
        n.sdk?.settings || e.settings
          ? { ...n.sdk?.settings, ...e.settings }
          : void 0,
    }),
    n
  );
}
function jG(n, e, t, i) {
  const r = l8(t),
    s = {
      sent_at: new Date().toISOString(),
      ...(r && { sdk: r }),
      ...(!!i && e && { dsn: Ld(e) }),
    },
    o =
      "aggregates" in n
        ? [{ type: "sessions" }, n]
        : [{ type: "session" }, n.toJSON()];
  return bu(s, [o]);
}
function $G(n, e, t, i) {
  const r = l8(t),
    s = n.type && n.type !== "replay_event" ? n.type : "event";
  KG(n, t?.sdk);
  const o = XG(n, r, i, e);
  return (delete n.sdkProcessingMetadata, bu(o, [[{ type: s }, n]]));
}
function JG(n, e) {
  function t(f) {
    return !!f.trace_id && !!f.public_key;
  }
  const i = Bl(n[0]),
    r = e?.getDsn(),
    s = e?.getOptions().tunnel,
    o = {
      sent_at: new Date().toISOString(),
      ...(t(i) && { trace: i }),
      ...(!!s && r && { dsn: Ld(r) }),
    },
    { beforeSendSpan: a, ignoreSpans: l } = e?.getOptions() || {},
    c = l?.length ? n.filter((f) => !hm(cn(f), l)) : n,
    u = n.length - c.length;
  u && e?.recordDroppedEvent("before_send", "span", u);
  const h = a
      ? (f) => {
          const g = cn(f),
            p = a(g);
          return p || (uy(), g);
        }
      : cn,
    d = [];
  for (const f of c) {
    const g = h(f);
    g && d.push(ZG(g));
  }
  return bu(o, d);
}
function QG(n) {
  if (!tt) return;
  const {
      description: e = "< unknown name >",
      op: t = "< unknown op >",
      parent_span_id: i,
    } = cn(n),
    { spanId: r } = n.spanContext(),
    s = Zl(n),
    o = pr(n),
    a = o === n,
    l = `[Tracing] Starting ${s ? "sampled" : "unsampled"} ${a ? "root " : ""}span`,
    c = [`op: ${t}`, `name: ${e}`, `ID: ${r}`];
  if ((i && c.push(`parent ID: ${i}`), !a)) {
    const { op: u, description: h } = cn(o);
    (c.push(`root ID: ${o.spanContext().spanId}`),
      u && c.push(`root op: ${u}`),
      h && c.push(`root description: ${h}`));
  }
  Se.log(`${l}
  ${c.join(`
  `)}`);
}
function qG(n) {
  if (!tt) return;
  const { description: e = "< unknown name >", op: t = "< unknown op >" } =
      cn(n),
    { spanId: i } = n.spanContext(),
    s = pr(n) === n,
    o = `[Tracing] Finishing "${t}" ${s ? "root " : ""}span "${e}" with ID ${i}`;
  Se.log(o);
}
function eF(n, e, t, i = ns()) {
  const r = i && pr(i);
  r &&
    (tt &&
      Se.log(
        `[Measurement] Setting measurement on root span: ${n} = ${e} ${t}`,
      ),
    r.addEvent(n, { [np]: e, [tp]: t }));
}
function u4(n) {
  if (!n || n.length === 0) return;
  const e = {};
  return (
    n.forEach((t) => {
      const i = t.attributes || {},
        r = i[tp],
        s = i[np];
      typeof r == "string" &&
        typeof s == "number" &&
        (e[t.name] = { value: s, unit: r });
    }),
    e
  );
}
const h4 = 1e3;
class MC {
  constructor(e = {}) {
    ((this._traceId = e.traceId || Ra()),
      (this._spanId = e.spanId || ba()),
      (this._startTime = e.startTimestamp || Bi()),
      (this._links = e.links),
      (this._attributes = {}),
      this.setAttributes({ [pi]: "manual", [Ba]: e.op, ...e.attributes }),
      (this._name = e.name),
      e.parentSpanId && (this._parentSpanId = e.parentSpanId),
      "sampled" in e && (this._sampled = e.sampled),
      e.endTimestamp && (this._endTime = e.endTimestamp),
      (this._events = []),
      (this._isStandaloneSpan = e.isStandalone),
      this._endTime && this._onSpanEnded());
  }
  addLink(e) {
    return (this._links ? this._links.push(e) : (this._links = [e]), this);
  }
  addLinks(e) {
    return (this._links ? this._links.push(...e) : (this._links = e), this);
  }
  recordException(e, t) {}
  spanContext() {
    const { _spanId: e, _traceId: t, _sampled: i } = this;
    return { spanId: e, traceId: t, traceFlags: i ? Sb : e8 };
  }
  setAttribute(e, t) {
    return (
      t === void 0 ? delete this._attributes[e] : (this._attributes[e] = t),
      this
    );
  }
  setAttributes(e) {
    return (Object.keys(e).forEach((t) => this.setAttribute(t, e[t])), this);
  }
  updateStartTime(e) {
    this._startTime = jc(e);
  }
  setStatus(e) {
    return ((this._status = e), this);
  }
  updateName(e) {
    return ((this._name = e), this.setAttribute(_o, "custom"), this);
  }
  end(e) {
    this._endTime || ((this._endTime = jc(e)), qG(this), this._onSpanEnded());
  }
  getSpanJSON() {
    return {
      data: this._attributes,
      description: this._name,
      op: this._attributes[Ba],
      parent_span_id: this._parentSpanId,
      span_id: this._spanId,
      start_timestamp: this._startTime,
      status: n8(this._status),
      timestamp: this._endTime,
      trace_id: this._traceId,
      origin: this._attributes[pi],
      profile_id: this._attributes[vb],
      exclusive_time: this._attributes[Md],
      measurements: u4(this._events),
      is_segment: (this._isStandaloneSpan && pr(this) === this) || void 0,
      segment_id: this._isStandaloneSpan
        ? pr(this).spanContext().spanId
        : void 0,
      links: t8(this._links),
    };
  }
  isRecording() {
    return !this._endTime && !!this._sampled;
  }
  addEvent(e, t, i) {
    tt && Se.log("[Tracing] Adding an event to span:", e);
    const r = d4(t) ? t : i || Bi(),
      s = d4(t) ? {} : t || {},
      o = { name: e, time: jc(r), attributes: s };
    return (this._events.push(o), this);
  }
  isStandaloneSpan() {
    return !!this._isStandaloneSpan;
  }
  _onSpanEnded() {
    const e = yn();
    if (
      (e && e.emit("spanEnd", this),
      !(this._isStandaloneSpan || this === pr(this)))
    )
      return;
    if (this._isStandaloneSpan) {
      this._sampled
        ? nF(JG([this], e))
        : (tt &&
            Se.log(
              "[Tracing] Discarding standalone span because its trace was not chosen to be sampled.",
            ),
          e && e.recordDroppedEvent("sample_rate", "span"));
      return;
    }
    const i = this._convertSpanToTransaction();
    i && (um(this).scope || wn()).captureEvent(i);
  }
  _convertSpanToTransaction() {
    if (!f4(cn(this))) return;
    this._name ||
      (tt &&
        Se.warn(
          "Transaction has no name, falling back to `<unlabeled transaction>`.",
        ),
      (this._name = "<unlabeled transaction>"));
    const { scope: e, isolationScope: t } = um(this),
      i = e?.getScopeData().sdkProcessingMetadata?.normalizedRequest;
    if (this._sampled !== !0) return;
    const s = a0(this)
        .filter((u) => u !== this && !tF(u))
        .map((u) => cn(u))
        .filter(f4),
      o = this._attributes[_o];
    (delete this._attributes[n4],
      s.forEach((u) => {
        delete u.data[n4];
      }));
    const a = {
        contexts: { trace: SG(this) },
        spans:
          s.length > h4
            ? s
                .sort((u, h) => u.start_timestamp - h.start_timestamp)
                .slice(0, h4)
            : s,
        start_timestamp: this._startTime,
        timestamp: this._endTime,
        transaction: this._name,
        type: "transaction",
        sdkProcessingMetadata: {
          capturedSpanScope: e,
          capturedSpanIsolationScope: t,
          dynamicSamplingContext: Bl(this),
        },
        request: i,
        ...(o && { transaction_info: { source: o } }),
      },
      l = u4(this._events);
    return (
      l &&
        Object.keys(l).length &&
        (tt &&
          Se.log(
            "[Measurements] Adding measurements to transaction event",
            JSON.stringify(l, void 0, 2),
          ),
        (a.measurements = l)),
      a
    );
  }
}
function d4(n) {
  return (n && typeof n == "number") || n instanceof Date || Array.isArray(n);
}
function f4(n) {
  return !!n.start_timestamp && !!n.timestamp && !!n.span_id && !!n.trace_id;
}
function tF(n) {
  return n instanceof MC && n.isStandaloneSpan();
}
function nF(n) {
  const e = yn();
  if (!e) return;
  const t = n[1];
  if (!t || t.length === 0) {
    e.recordDroppedEvent("before_send", "span");
    return;
  }
  e.sendEnvelope(n);
}
function iF(n, e, t = () => {}, i = () => {}) {
  let r;
  try {
    r = n();
  } catch (s) {
    throw (e(s), t(), s);
  }
  return rF(r, e, t, i);
}
function rF(n, e, t, i) {
  return Td(n)
    ? n.then(
        (r) => (t(), i(r), r),
        (r) => {
          throw (e(r), t(), r);
        },
      )
    : (t(), i(n), n);
}
function sF(n, e, t) {
  if (!$s(n)) return [!1];
  let i, r;
  typeof n.tracesSampler == "function"
    ? ((r = n.tracesSampler({
        ...e,
        inheritOrSampleWith: (a) =>
          typeof e.parentSampleRate == "number"
            ? e.parentSampleRate
            : typeof e.parentSampled == "boolean"
              ? Number(e.parentSampled)
              : a,
      })),
      (i = !0))
    : e.parentSampled !== void 0
      ? (r = e.parentSampled)
      : typeof n.tracesSampleRate < "u" && ((r = n.tracesSampleRate), (i = !0));
  const s = Ig(r);
  if (s === void 0)
    return (
      tt &&
        Se.warn(
          `[Tracing] Discarding root span because of invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(r)} of type ${JSON.stringify(typeof r)}.`,
        ),
      [!1]
    );
  if (!s)
    return (
      tt &&
        Se.log(
          `[Tracing] Discarding transaction because ${typeof n.tracesSampler == "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"}`,
        ),
      [!1, s, i]
    );
  const o = t < s;
  return (
    o ||
      (tt &&
        Se.log(
          `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(r)})`,
        )),
    [o, s, i]
  );
}
const c8 = "__SENTRY_SUPPRESS_TRACING__";
function oF(n, e) {
  const t = Mb();
  if (t.startSpan) return t.startSpan(n, e);
  const i = h8(n),
    { forceTransaction: r, parentSpan: s, scope: o } = n,
    a = o?.clone();
  return EC(a, () =>
    lF(s)(() => {
      const c = wn(),
        u = d8(c, s),
        d =
          n.onlyIfParent && !u
            ? new Pl()
            : u8({
                parentSpan: u,
                spanArguments: i,
                forceTransaction: r,
                scope: c,
              });
      return (
        $h(c, d),
        iF(
          () => e(d),
          () => {
            const { status: f } = cn(d);
            d.isRecording() &&
              (!f || f === "ok") &&
              d.setStatus({ code: di, message: "internal_error" });
          },
          () => {
            d.end();
          },
        )
      );
    }),
  );
}
function Rd(n) {
  const e = Mb();
  if (e.startInactiveSpan) return e.startInactiveSpan(n);
  const t = h8(n),
    { forceTransaction: i, parentSpan: r } = n;
  return (
    n.scope
      ? (o) => EC(n.scope, o)
      : r !== void 0
        ? (o) => Eb(r, o)
        : (o) => o()
  )(() => {
    const o = wn(),
      a = d8(o, r);
    return n.onlyIfParent && !a
      ? new Pl()
      : u8({ parentSpan: a, spanArguments: t, forceTransaction: i, scope: o });
  });
}
function Eb(n, e) {
  const t = Mb();
  return t.withActiveSpan
    ? t.withActiveSpan(n, e)
    : EC((i) => ($h(i, n || void 0), e(i)));
}
function u8({
  parentSpan: n,
  spanArguments: e,
  forceTransaction: t,
  scope: i,
}) {
  if (!$s()) {
    const o = new Pl();
    if (t || !n) {
      const a = {
        sampled: "false",
        sample_rate: "0",
        transaction: e.name,
        ...Bl(o),
      };
      l0(o, a);
    }
    return o;
  }
  const r = _u();
  let s;
  if (n && !t) ((s = aF(n, i, e)), i8(n, s));
  else if (n) {
    const o = Bl(n),
      { traceId: a, spanId: l } = n.spanContext(),
      c = Zl(n);
    ((s = g4({ traceId: a, parentSpanId: l, ...e }, i, c)), l0(s, o));
  } else {
    const {
      traceId: o,
      dsc: a,
      parentSpanId: l,
      sampled: c,
    } = { ...r.getPropagationContext(), ...i.getPropagationContext() };
    ((s = g4({ traceId: o, parentSpanId: l, ...e }, i, c)), a && l0(s, a));
  }
  return (QG(s), cG(s, i, r), s);
}
function h8(n) {
  const t = { isStandalone: (n.experimental || {}).standalone, ...n };
  if (n.startTime) {
    const i = { ...t };
    return ((i.startTimestamp = jc(n.startTime)), delete i.startTime, i);
  }
  return t;
}
function Mb() {
  const n = Au();
  return Ed(n);
}
function g4(n, e, t) {
  const i = yn(),
    r = i?.getOptions() || {},
    { name: s = "" } = n,
    o = { spanAttributes: { ...n.attributes }, spanName: s, parentSampled: t };
  i?.emit("beforeSampling", o, { decision: !1 });
  const a = o.parentSampled ?? t,
    l = o.spanAttributes,
    c = e.getPropagationContext(),
    [u, h, d] = e.getScopeData().sdkProcessingMetadata[c8]
      ? [!1]
      : sF(
          r,
          {
            name: s,
            parentSampled: a,
            attributes: l,
            parentSampleRate: Ig(c.dsc?.sample_rate),
          },
          c.sampleRand,
        ),
    f = new MC({
      ...n,
      attributes: {
        [_o]: "custom",
        [bb]: h !== void 0 && d ? h : void 0,
        ...l,
      },
      sampled: u,
    });
  return (
    !u &&
      i &&
      (tt &&
        Se.log(
          "[Tracing] Discarding root span because its trace was not chosen to be sampled.",
        ),
      i.recordDroppedEvent("sample_rate", "transaction")),
    i && i.emit("spanStart", f),
    f
  );
}
function aF(n, e, t) {
  const { spanId: i, traceId: r } = n.spanContext(),
    s = e.getScopeData().sdkProcessingMetadata[c8] ? !1 : Zl(n),
    o = s
      ? new MC({ ...t, parentSpanId: i, traceId: r, sampled: s })
      : new Pl({ traceId: r });
  i8(n, o);
  const a = yn();
  return (
    a && (a.emit("spanStart", o), t.endTimestamp && a.emit("spanEnd", o)),
    o
  );
}
function d8(n, e) {
  if (e) return e;
  if (e === null) return;
  const t = cm(n);
  if (!t) return;
  const i = yn();
  return (i ? i.getOptions() : {}).parentSpanIsAlwaysRootSpan ? pr(t) : t;
}
function lF(n) {
  return n !== void 0 ? (e) => Eb(n, e) : (e) => e();
}
const c0 = { idleTimeout: 1e3, finalTimeout: 3e4, childSpanTimeout: 15e3 },
  cF = "heartbeatFailed",
  uF = "idleTimeout",
  hF = "finalTimeout",
  dF = "externalFinish";
function f8(n, e = {}) {
  const t = new Map();
  let i = !1,
    r,
    s = dF,
    o = !e.disableAutoFinish;
  const a = [],
    {
      idleTimeout: l = c0.idleTimeout,
      finalTimeout: c = c0.finalTimeout,
      childSpanTimeout: u = c0.childSpanTimeout,
      beforeSpanEnd: h,
      trimIdleSpanEndTimestamp: d = !0,
    } = e,
    f = yn();
  if (!f || !$s()) {
    const S = new Pl(),
      E = { sample_rate: "0", sampled: "false", ...Bl(S) };
    return (l0(S, E), S);
  }
  const g = wn(),
    p = ns(),
    m = fF(n);
  m.end = new Proxy(m.end, {
    apply(S, E, _) {
      if ((h && h(m), E instanceof Pl)) return;
      const [b, ...R] = _,
        M = b || Bi(),
        L = jc(M),
        P = a0(m).filter((Z) => Z !== m),
        U = cn(m);
      if (!P.length || !d) return (T(L), Reflect.apply(S, E, [L, ...R]));
      const O = f.getOptions().ignoreSpans,
        V = P?.reduce(
          (Z, te) => {
            const ge = cn(te);
            return !ge.timestamp || (O && hm(ge, O))
              ? Z
              : Z
                ? Math.max(Z, ge.timestamp)
                : ge.timestamp;
          },
          void 0,
        ),
        W = U.start_timestamp,
        re = Math.min(
          W ? W + c / 1e3 : 1 / 0,
          Math.max(W || -1 / 0, Math.min(L, V || 1 / 0)),
        );
      return (T(re), Reflect.apply(S, E, [re, ...R]));
    },
  });
  function C() {
    r && (clearTimeout(r), (r = void 0));
  }
  function A(S) {
    (C(),
      (r = setTimeout(() => {
        !i && t.size === 0 && o && ((s = uF), m.end(S));
      }, l)));
  }
  function I(S) {
    r = setTimeout(() => {
      !i && o && ((s = cF), m.end(S));
    }, u);
  }
  function y(S) {
    (C(), t.set(S, !0));
    const E = Bi();
    I(E + u / 1e3);
  }
  function x(S) {
    if ((t.has(S) && t.delete(S), t.size === 0)) {
      const E = Bi();
      A(E + l / 1e3);
    }
  }
  function T(S) {
    ((i = !0), t.clear(), a.forEach((P) => P()), $h(g, p));
    const E = cn(m),
      { start_timestamp: _ } = E;
    if (!_) return;
    E.data[Cg] || m.setAttribute(Cg, s);
    const R = E.status;
    ((!R || R === "unknown") && m.setStatus({ code: xb }),
      Se.log(`[Tracing] Idle span "${E.op}" finished`));
    const M = a0(m).filter((P) => P !== m);
    let L = 0;
    (M.forEach((P) => {
      P.isRecording() &&
        (P.setStatus({ code: di, message: "cancelled" }),
        P.end(S),
        tt &&
          Se.log(
            "[Tracing] Cancelling span since span ended early",
            JSON.stringify(P, void 0, 2),
          ));
      const U = cn(P),
        { timestamp: O = 0, start_timestamp: V = 0 } = U,
        W = V <= S,
        re = (c + l) / 1e3,
        Z = O - V <= re;
      if (tt) {
        const te = JSON.stringify(P, void 0, 2);
        W
          ? Z ||
            Se.log(
              "[Tracing] Discarding span since it finished after idle span final timeout",
              te,
            )
          : Se.log(
              "[Tracing] Discarding span since it happened after idle span was finished",
              te,
            );
      }
      (!Z || !W) && (BG(m, P), L++);
    }),
      L > 0 && m.setAttribute("sentry.idle_span_discarded_spans", L));
  }
  return (
    a.push(
      f.on("spanStart", (S) => {
        if (
          i ||
          S === m ||
          cn(S).timestamp ||
          (S instanceof MC && S.isStandaloneSpan())
        )
          return;
        a0(m).includes(S) && y(S.spanContext().spanId);
      }),
    ),
    a.push(
      f.on("spanEnd", (S) => {
        i || x(S.spanContext().spanId);
      }),
    ),
    a.push(
      f.on("idleSpanEnableAutoFinish", (S) => {
        S === m && ((o = !0), A(), t.size && I());
      }),
    ),
    e.disableAutoFinish || A(),
    setTimeout(() => {
      i ||
        (m.setStatus({ code: di, message: "deadline_exceeded" }),
        (s = hF),
        m.end());
    }, c),
    m
  );
}
function fF(n) {
  const e = Rd(n);
  return (
    $h(wn(), e),
    tt && Se.log("[Tracing] Started span is an idle span"),
    e
  );
}
const PI = 0,
  p4 = 1,
  m4 = 2;
function LC(n) {
  return new Ag((e) => {
    e(n);
  });
}
function Lb(n) {
  return new Ag((e, t) => {
    t(n);
  });
}
class Ag {
  constructor(e) {
    ((this._state = PI), (this._handlers = []), this._runExecutor(e));
  }
  then(e, t) {
    return new Ag((i, r) => {
      (this._handlers.push([
        !1,
        (s) => {
          if (!e) i(s);
          else
            try {
              i(e(s));
            } catch (o) {
              r(o);
            }
        },
        (s) => {
          if (!t) r(s);
          else
            try {
              i(t(s));
            } catch (o) {
              r(o);
            }
        },
      ]),
        this._executeHandlers());
    });
  }
  catch(e) {
    return this.then((t) => t, e);
  }
  finally(e) {
    return new Ag((t, i) => {
      let r, s;
      return this.then(
        (o) => {
          ((s = !1), (r = o), e && e());
        },
        (o) => {
          ((s = !0), (r = o), e && e());
        },
      ).then(() => {
        if (s) {
          i(r);
          return;
        }
        t(r);
      });
    });
  }
  _executeHandlers() {
    if (this._state === PI) return;
    const e = this._handlers.slice();
    ((this._handlers = []),
      e.forEach((t) => {
        t[0] ||
          (this._state === p4 && t[1](this._value),
          this._state === m4 && t[2](this._value),
          (t[0] = !0));
      }));
  }
  _runExecutor(e) {
    const t = (s, o) => {
        if (this._state === PI) {
          if (Td(o)) {
            o.then(i, r);
            return;
          }
          ((this._state = s), (this._value = o), this._executeHandlers());
        }
      },
      i = (s) => {
        t(p4, s);
      },
      r = (s) => {
        t(m4, s);
      };
    try {
      e(i, r);
    } catch (s) {
      r(s);
    }
  }
}
function gF(n, e, t, i = 0) {
  try {
    const r = fy(e, t, n, i);
    return Td(r) ? r : LC(r);
  } catch (r) {
    return Lb(r);
  }
}
function fy(n, e, t, i) {
  const r = t[i];
  if (!n || !r) return n;
  const s = r({ ...n }, e);
  return (
    tt &&
      s === null &&
      Se.log(`Event processor "${r.id || "?"}" dropped event`),
    Td(s) ? s.then((o) => fy(o, e, t, i + 1)) : fy(s, e, t, i + 1)
  );
}
function pF(n, e) {
  const {
    fingerprint: t,
    span: i,
    breadcrumbs: r,
    sdkProcessingMetadata: s,
  } = e;
  (mF(n, e), i && AF(n, i), yF(n, t), CF(n, r), IF(n, s));
}
function C4(n, e) {
  const {
    extra: t,
    tags: i,
    user: r,
    contexts: s,
    level: o,
    sdkProcessingMetadata: a,
    breadcrumbs: l,
    fingerprint: c,
    eventProcessors: u,
    attachments: h,
    propagationContext: d,
    transactionName: f,
    span: g,
  } = e;
  (kp(n, "extra", t),
    kp(n, "tags", i),
    kp(n, "user", r),
    kp(n, "contexts", s),
    (n.sdkProcessingMetadata = ep(n.sdkProcessingMetadata, a, 2)),
    o && (n.level = o),
    f && (n.transactionName = f),
    g && (n.span = g),
    l.length && (n.breadcrumbs = [...n.breadcrumbs, ...l]),
    c.length && (n.fingerprint = [...n.fingerprint, ...c]),
    u.length && (n.eventProcessors = [...n.eventProcessors, ...u]),
    h.length && (n.attachments = [...n.attachments, ...h]),
    (n.propagationContext = { ...n.propagationContext, ...d }));
}
function kp(n, e, t) {
  n[e] = ep(n[e], t, 1);
}
function mF(n, e) {
  const {
    extra: t,
    tags: i,
    user: r,
    contexts: s,
    level: o,
    transactionName: a,
  } = e;
  (Object.keys(t).length && (n.extra = { ...t, ...n.extra }),
    Object.keys(i).length && (n.tags = { ...i, ...n.tags }),
    Object.keys(r).length && (n.user = { ...r, ...n.user }),
    Object.keys(s).length && (n.contexts = { ...s, ...n.contexts }),
    o && (n.level = o),
    a && n.type !== "transaction" && (n.transaction = a));
}
function CF(n, e) {
  const t = [...(n.breadcrumbs || []), ...e];
  n.breadcrumbs = t.length ? t : void 0;
}
function IF(n, e) {
  n.sdkProcessingMetadata = { ...n.sdkProcessingMetadata, ...e };
}
function AF(n, e) {
  ((n.contexts = { trace: TG(e), ...n.contexts }),
    (n.sdkProcessingMetadata = {
      dynamicSamplingContext: Bl(e),
      ...n.sdkProcessingMetadata,
    }));
  const t = pr(e),
    i = cn(t).description;
  i && !n.transaction && n.type === "transaction" && (n.transaction = i);
}
function yF(n, e) {
  ((n.fingerprint = n.fingerprint
    ? Array.isArray(n.fingerprint)
      ? n.fingerprint
      : [n.fingerprint]
    : []),
    e && (n.fingerprint = n.fingerprint.concat(e)),
    n.fingerprint.length || delete n.fingerprint);
}
let Ql, I4, A4, Ha;
function _F(n) {
  const e = sn._sentryDebugIds,
    t = sn._debugIds;
  if (!e && !t) return {};
  const i = e ? Object.keys(e) : [],
    r = t ? Object.keys(t) : [];
  if (Ha && i.length === I4 && r.length === A4) return Ha;
  ((I4 = i.length), (A4 = r.length), (Ha = {}), Ql || (Ql = {}));
  const s = (o, a) => {
    for (const l of o) {
      const c = a[l],
        u = Ql?.[l];
      if (u && Ha && c) ((Ha[u[0]] = c), Ql && (Ql[l] = [u[0], c]));
      else if (c) {
        const h = n(l);
        for (let d = h.length - 1; d >= 0; d--) {
          const g = h[d]?.filename;
          if (g && Ha && Ql) {
            ((Ha[g] = c), (Ql[l] = [g, c]));
            break;
          }
        }
      }
    }
  };
  return (e && s(i, e), t && s(r, t), Ha);
}
function bF(n, e, t, i, r, s) {
  const { normalizeDepth: o = 3, normalizeMaxBreadth: a = 1e3 } = n,
    l = {
      ...e,
      event_id: e.event_id || t.event_id || ws(),
      timestamp: e.timestamp || yu(),
    },
    c = t.integrations || n.integrations.map((m) => m.name);
  (vF(l, n),
    SF(l, c),
    r && r.emit("applyFrameMetadata", e),
    e.type === void 0 && xF(l, n.stackParser));
  const u = EF(i, t.captureContext);
  t.mechanism && Kh(l, t.mechanism);
  const h = r ? r.getEventProcessors() : [],
    d = nG().getScopeData();
  if (s) {
    const m = s.getScopeData();
    C4(d, m);
  }
  if (u) {
    const m = u.getScopeData();
    C4(d, m);
  }
  const f = [...(t.attachments || []), ...d.attachments];
  (f.length && (t.attachments = f), pF(l, d));
  const g = [...h, ...d.eventProcessors];
  return gF(g, l, t).then(
    (m) => (m && wF(m), typeof o == "number" && o > 0 ? TF(m, o, a) : m),
  );
}
function vF(n, e) {
  const { environment: t, release: i, dist: r, maxValueLength: s } = e;
  ((n.environment = n.environment || t || Tb),
    !n.release && i && (n.release = i),
    !n.dist && r && (n.dist = r));
  const o = n.request;
  (o?.url && s && (o.url = oy(o.url, s)),
    s &&
      n.exception?.values?.forEach((a) => {
        a.value && (a.value = oy(a.value, s));
      }));
}
function xF(n, e) {
  const t = _F(e);
  n.exception?.values?.forEach((i) => {
    i.stacktrace?.frames?.forEach((r) => {
      r.filename && (r.debug_id = t[r.filename]);
    });
  });
}
function wF(n) {
  const e = {};
  if (
    (n.exception?.values?.forEach((i) => {
      i.stacktrace?.frames?.forEach((r) => {
        r.debug_id &&
          (r.abs_path
            ? (e[r.abs_path] = r.debug_id)
            : r.filename && (e[r.filename] = r.debug_id),
          delete r.debug_id);
      });
    }),
    Object.keys(e).length === 0)
  )
    return;
  ((n.debug_meta = n.debug_meta || {}),
    (n.debug_meta.images = n.debug_meta.images || []));
  const t = n.debug_meta.images;
  Object.entries(e).forEach(([i, r]) => {
    t.push({ type: "sourcemap", code_file: i, debug_id: r });
  });
}
function SF(n, e) {
  e.length > 0 &&
    ((n.sdk = n.sdk || {}),
    (n.sdk.integrations = [...(n.sdk.integrations || []), ...e]));
}
function TF(n, e, t) {
  if (!n) return null;
  const i = {
    ...n,
    ...(n.breadcrumbs && {
      breadcrumbs: n.breadcrumbs.map((r) => ({
        ...r,
        ...(r.data && { data: aa(r.data, e, t) }),
      })),
    }),
    ...(n.user && { user: aa(n.user, e, t) }),
    ...(n.contexts && { contexts: aa(n.contexts, e, t) }),
    ...(n.extra && { extra: aa(n.extra, e, t) }),
  };
  return (
    n.contexts?.trace &&
      i.contexts &&
      ((i.contexts.trace = n.contexts.trace),
      n.contexts.trace.data &&
        (i.contexts.trace.data = aa(n.contexts.trace.data, e, t))),
    n.spans &&
      (i.spans = n.spans.map((r) => ({
        ...r,
        ...(r.data && { data: aa(r.data, e, t) }),
      }))),
    n.contexts?.flags &&
      i.contexts &&
      (i.contexts.flags = aa(n.contexts.flags, 3, t)),
    i
  );
}
function EF(n, e) {
  if (!e) return n;
  const t = n ? n.clone() : new Po();
  return (t.update(e), t);
}
function MF(n) {
  if (n)
    return LF(n) ? { captureContext: n } : BF(n) ? { captureContext: n } : n;
}
function LF(n) {
  return n instanceof Po || typeof n == "function";
}
const RF = [
  "user",
  "level",
  "extra",
  "contexts",
  "tags",
  "fingerprint",
  "propagationContext",
];
function BF(n) {
  return Object.keys(n).some((e) => RF.includes(e));
}
function PF(n, e) {
  return wn().captureException(n, MF(e));
}
function g8(n, e) {
  return wn().captureEvent(n, e);
}
function NF() {
  const n = yn();
  return n?.getOptions().enabled !== !1 && !!n?.getTransport();
}
function y4(n) {
  const e = _u(),
    t = wn(),
    { userAgent: i } = sn.navigator || {},
    r = YD({
      user: t.getUser() || e.getUser(),
      ...(i && { userAgent: i }),
      ...n,
    }),
    s = e.getSession();
  return (
    s?.status === "ok" && jh(s, { status: "exited" }),
    p8(),
    e.setSession(r),
    r
  );
}
function p8() {
  const n = _u(),
    t = wn().getSession() || n.getSession();
  (t && XD(t), m8(), n.setSession());
}
function m8() {
  const n = _u(),
    e = yn(),
    t = n.getSession();
  t && e && e.captureSession(t);
}
function _4(n = !1) {
  if (n) {
    p8();
    return;
  }
  m8();
}
const DF = "7";
function GF(n) {
  const e = n.protocol ? `${n.protocol}:` : "",
    t = n.port ? `:${n.port}` : "";
  return `${e}//${n.host}${t}${n.path ? `/${n.path}` : ""}/api/`;
}
function FF(n) {
  return `${GF(n)}${n.projectId}/envelope/`;
}
function kF(n, e) {
  const t = { sentry_version: DF };
  return (
    n.publicKey && (t.sentry_key = n.publicKey),
    e && (t.sentry_client = `${e.name}/${e.version}`),
    new URLSearchParams(t).toString()
  );
}
function OF(n, e, t) {
  return e || `${FF(n)}?${kF(n, t)}`;
}
const b4 = [];
function UF(n) {
  const e = {};
  return (
    n.forEach((t) => {
      const { name: i } = t,
        r = e[i];
      (r && !r.isDefaultInstance && t.isDefaultInstance) || (e[i] = t);
    }),
    Object.values(e)
  );
}
function HF(n) {
  const e = n.defaultIntegrations || [],
    t = n.integrations;
  e.forEach((r) => {
    r.isDefaultInstance = !0;
  });
  let i;
  if (Array.isArray(t)) i = [...e, ...t];
  else if (typeof t == "function") {
    const r = t(e);
    i = Array.isArray(r) ? r : [r];
  } else i = e;
  return UF(i);
}
function WF(n, e) {
  const t = {};
  return (
    e.forEach((i) => {
      i && C8(n, i, t);
    }),
    t
  );
}
function v4(n, e) {
  for (const t of e) t?.afterAllSetup && t.afterAllSetup(n);
}
function C8(n, e, t) {
  if (t[e.name]) {
    tt &&
      Se.log(`Integration skipped because it was already installed: ${e.name}`);
    return;
  }
  if (
    ((t[e.name] = e),
    !b4.includes(e.name) &&
      typeof e.setupOnce == "function" &&
      (e.setupOnce(), b4.push(e.name)),
    e.setup && typeof e.setup == "function" && e.setup(n),
    typeof e.preprocessEvent == "function")
  ) {
    const i = e.preprocessEvent.bind(e);
    n.on("preprocessEvent", (r, s) => i(r, s, n));
  }
  if (typeof e.processEvent == "function") {
    const i = e.processEvent.bind(e),
      r = Object.assign((s, o) => i(s, o, n), { id: e.name });
    n.addEventProcessor(r);
  }
  tt && Se.log(`Integration installed: ${e.name}`);
}
function VF(n) {
  return [
    {
      type: "log",
      item_count: n.length,
      content_type: "application/vnd.sentry.items.log+json",
    },
    { items: n },
  ];
}
function ZF(n, e, t, i) {
  const r = {};
  return (
    e?.sdk && (r.sdk = { name: e.sdk.name, version: e.sdk.version }),
    t && i && (r.dsn = Ld(i)),
    bu(r, [VF(n)])
  );
}
function I8(n, e) {
  const t = e ?? zF(n) ?? [];
  if (t.length === 0) return;
  const i = n.getOptions(),
    r = ZF(t, i._metadata, i.tunnel, n.getDsn());
  (A8().set(n, []), n.emit("flushLogs"), n.sendEnvelope(r));
}
function zF(n) {
  return A8().get(n);
}
function A8() {
  return xd("clientToLogBufferMap", () => new WeakMap());
}
function YF(n) {
  return [
    {
      type: "trace_metric",
      item_count: n.length,
      content_type: "application/vnd.sentry.items.trace-metric+json",
    },
    { items: n },
  ];
}
function XF(n, e, t, i) {
  const r = {};
  return (
    e?.sdk && (r.sdk = { name: e.sdk.name, version: e.sdk.version }),
    t && i && (r.dsn = Ld(i)),
    bu(r, [YF(n)])
  );
}
function y8(n, e) {
  const t = e ?? KF(n) ?? [];
  if (t.length === 0) return;
  const i = n.getOptions(),
    r = XF(t, i._metadata, i.tunnel, n.getDsn());
  (_8().set(n, []), n.emit("flushMetrics"), n.sendEnvelope(r));
}
function KF(n) {
  return _8().get(n);
}
function _8() {
  return xd("clientToMetricBufferMap", () => new WeakMap());
}
const Rb = Symbol.for("SentryBufferFullError");
function Bb(n = 100) {
  const e = new Set();
  function t() {
    return e.size < n;
  }
  function i(o) {
    e.delete(o);
  }
  function r(o) {
    if (!t()) return Lb(Rb);
    const a = o();
    return (
      e.add(a),
      a.then(
        () => i(a),
        () => i(a),
      ),
      a
    );
  }
  function s(o) {
    if (!e.size) return LC(!0);
    const a = Promise.allSettled(Array.from(e)).then(() => !0);
    if (!o) return a;
    const l = [a, new Promise((c) => setTimeout(() => c(!1), o))];
    return Promise.race(l);
  }
  return {
    get $() {
      return Array.from(e);
    },
    add: r,
    drain: s,
  };
}
const jF = 60 * 1e3;
function $F(n, e = Date.now()) {
  const t = parseInt(`${n}`, 10);
  if (!isNaN(t)) return t * 1e3;
  const i = Date.parse(`${n}`);
  return isNaN(i) ? jF : i - e;
}
function JF(n, e) {
  return n[e] || n.all || 0;
}
function QF(n, e, t = Date.now()) {
  return JF(n, e) > t;
}
function qF(n, { statusCode: e, headers: t }, i = Date.now()) {
  const r = { ...n },
    s = t?.["x-sentry-rate-limits"],
    o = t?.["retry-after"];
  if (s)
    for (const a of s.trim().split(",")) {
      const [l, c, , , u] = a.split(":", 5),
        h = parseInt(l, 10),
        d = (isNaN(h) ? 60 : h) * 1e3;
      if (!c) r.all = i + d;
      else
        for (const f of c.split(";"))
          f === "metric_bucket"
            ? (!u || u.split(";").includes("custom")) && (r[f] = i + d)
            : (r[f] = i + d);
    }
  else o ? (r.all = i + $F(o, i)) : e === 429 && (r.all = i + 60 * 1e3);
  return r;
}
const b8 = 64;
function ek(n, e, t = Bb(n.bufferSize || b8)) {
  let i = {};
  const r = (o) => t.drain(o);
  function s(o) {
    const a = [];
    if (
      (l4(o, (h, d) => {
        const f = c4(d);
        QF(i, f) ? n.recordDroppedEvent("ratelimit_backoff", f) : a.push(h);
      }),
      a.length === 0)
    )
      return Promise.resolve({});
    const l = bu(o[0], a),
      c = (h) => {
        l4(l, (d, f) => {
          n.recordDroppedEvent(h, c4(f));
        });
      },
      u = () =>
        e({ body: WG(l) }).then(
          (h) => (
            h.statusCode !== void 0 &&
              (h.statusCode < 200 || h.statusCode >= 300) &&
              tt &&
              Se.warn(
                `Sentry responded with status code ${h.statusCode} to sent event.`,
              ),
            (i = qF(i, h)),
            h
          ),
          (h) => {
            throw (
              c("network_error"),
              tt && Se.error("Encountered error running transport request:", h),
              h
            );
          },
        );
    return t.add(u).then(
      (h) => h,
      (h) => {
        if (h === Rb)
          return (
            tt && Se.error("Skipped sending event because buffer is full."),
            c("queue_overflow"),
            Promise.resolve({})
          );
        throw h;
      },
    );
  }
  return { send: s, flush: r };
}
function tk(n, e, t) {
  const i = [
    { type: "client_report" },
    { timestamp: t || yu(), discarded_events: n },
  ];
  return bu(e ? { dsn: e } : {}, [i]);
}
function v8(n) {
  const e = [];
  n.message && e.push(n.message);
  try {
    const t = n.exception.values[n.exception.values.length - 1];
    t?.value && (e.push(t.value), t.type && e.push(`${t.type}: ${t.value}`));
  } catch {}
  return e;
}
function nk(n) {
  const {
    trace_id: e,
    parent_span_id: t,
    span_id: i,
    status: r,
    origin: s,
    data: o,
    op: a,
  } = n.contexts?.trace ?? {};
  return {
    data: o ?? {},
    description: n.transaction,
    op: a,
    parent_span_id: t,
    span_id: i ?? "",
    start_timestamp: n.start_timestamp ?? 0,
    status: r,
    timestamp: n.timestamp,
    trace_id: e ?? "",
    origin: s,
    profile_id: o?.[vb],
    exclusive_time: o?.[Md],
    measurements: n.measurements,
    is_segment: !0,
  };
}
function ik(n) {
  return {
    type: "transaction",
    timestamp: n.timestamp,
    start_timestamp: n.start_timestamp,
    transaction: n.description,
    contexts: {
      trace: {
        trace_id: n.trace_id,
        span_id: n.span_id,
        parent_span_id: n.parent_span_id,
        op: n.op,
        status: n.status,
        origin: n.origin,
        data: {
          ...n.data,
          ...(n.profile_id && { [vb]: n.profile_id }),
          ...(n.exclusive_time && { [Md]: n.exclusive_time }),
        },
      },
    },
    measurements: n.measurements,
  };
}
const x4 = "Not capturing exception because it's already been captured.",
  w4 = "Discarded session because of missing or non-string release",
  x8 = Symbol.for("SentryInternalError"),
  w8 = Symbol.for("SentryDoNotSendEventError"),
  rk = 5e3;
function u0(n) {
  return { message: n, [x8]: !0 };
}
function NI(n) {
  return { message: n, [w8]: !0 };
}
function S4(n) {
  return !!n && typeof n == "object" && x8 in n;
}
function T4(n) {
  return !!n && typeof n == "object" && w8 in n;
}
function E4(n, e, t, i, r) {
  let s = 0,
    o,
    a = !1;
  (n.on(t, () => {
    ((s = 0), clearTimeout(o), (a = !1));
  }),
    n.on(e, (l) => {
      ((s += i(l)),
        s >= 8e5
          ? r(n)
          : a ||
            ((a = !0),
            (o = setTimeout(() => {
              r(n);
            }, rk))));
    }),
    n.on("flush", () => {
      r(n);
    }));
}
let sk = class {
  constructor(e) {
    if (
      ((this._options = e),
      (this._integrations = {}),
      (this._numProcessing = 0),
      (this._outcomes = {}),
      (this._hooks = {}),
      (this._eventProcessors = []),
      (this._promiseBuffer = Bb(e.transportOptions?.bufferSize ?? b8)),
      e.dsn
        ? (this._dsn = bG(e.dsn))
        : tt && Se.warn("No DSN provided, client will not send events."),
      this._dsn)
    ) {
      const i = OF(this._dsn, e.tunnel, e._metadata ? e._metadata.sdk : void 0);
      this._transport = e.transport({
        tunnel: this._options.tunnel,
        recordDroppedEvent: this.recordDroppedEvent.bind(this),
        ...e.transportOptions,
        url: i,
      });
    }
    ((this._options.enableLogs =
      this._options.enableLogs ?? this._options._experiments?.enableLogs),
      this._options.enableLogs &&
        E4(this, "afterCaptureLog", "flushLogs", ck, I8),
      (this._options.enableMetrics ??
        this._options._experiments?.enableMetrics ??
        !0) &&
        E4(this, "afterCaptureMetric", "flushMetrics", lk, y8));
  }
  captureException(e, t, i) {
    const r = ws();
    if (q5(e)) return (tt && Se.log(x4), r);
    const s = { event_id: r, ...t };
    return (
      this._process(
        () =>
          this.eventFromException(e, s)
            .then((o) => this._captureEvent(o, s, i))
            .then((o) => o),
        "error",
      ),
      s.event_id
    );
  }
  captureMessage(e, t, i, r) {
    const s = { event_id: ws(), ...i },
      o = Ab(e) ? e : String(e),
      a = Xh(e),
      l = a ? this.eventFromMessage(o, t, s) : this.eventFromException(e, s);
    return (
      this._process(
        () => l.then((c) => this._captureEvent(c, s, r)),
        a ? "unknown" : "error",
      ),
      s.event_id
    );
  }
  captureEvent(e, t, i) {
    const r = ws();
    if (t?.originalException && q5(t.originalException))
      return (tt && Se.log(x4), r);
    const s = { event_id: r, ...t },
      o = e.sdkProcessingMetadata || {},
      a = o.capturedSpanScope,
      l = o.capturedSpanIsolationScope,
      c = M4(e.type);
    return (
      this._process(() => this._captureEvent(e, s, a || i, l), c),
      s.event_id
    );
  }
  captureSession(e) {
    (this.sendSession(e), jh(e, { init: !1 }));
  }
  getDsn() {
    return this._dsn;
  }
  getOptions() {
    return this._options;
  }
  getSdkMetadata() {
    return this._options._metadata;
  }
  getTransport() {
    return this._transport;
  }
  async flush(e) {
    const t = this._transport;
    if (!t) return !0;
    this.emit("flush");
    const i = await this._isClientDoneProcessing(e),
      r = await t.flush(e);
    return i && r;
  }
  async close(e) {
    const t = await this.flush(e);
    return ((this.getOptions().enabled = !1), this.emit("close"), t);
  }
  getEventProcessors() {
    return this._eventProcessors;
  }
  addEventProcessor(e) {
    this._eventProcessors.push(e);
  }
  init() {
    (this._isEnabled() ||
      this._options.integrations.some(({ name: e }) =>
        e.startsWith("Spotlight"),
      )) &&
      this._setupIntegrations();
  }
  getIntegrationByName(e) {
    return this._integrations[e];
  }
  addIntegration(e) {
    const t = this._integrations[e.name];
    (C8(this, e, this._integrations), t || v4(this, [e]));
  }
  sendEvent(e, t = {}) {
    this.emit("beforeSendEvent", e, t);
    let i = $G(e, this._dsn, this._options._metadata, this._options.tunnel);
    for (const r of t.attachments || []) i = HG(i, zG(r));
    this.sendEnvelope(i).then((r) => this.emit("afterSendEvent", e, r));
  }
  sendSession(e) {
    const { release: t, environment: i = Tb } = this._options;
    if ("aggregates" in e) {
      const s = e.attrs || {};
      if (!s.release && !t) {
        tt && Se.warn(w4);
        return;
      }
      ((s.release = s.release || t),
        (s.environment = s.environment || i),
        (e.attrs = s));
    } else {
      if (!e.release && !t) {
        tt && Se.warn(w4);
        return;
      }
      ((e.release = e.release || t), (e.environment = e.environment || i));
    }
    this.emit("beforeSendSession", e);
    const r = jG(e, this._dsn, this._options._metadata, this._options.tunnel);
    this.sendEnvelope(r);
  }
  recordDroppedEvent(e, t, i = 1) {
    if (this._options.sendClientReports) {
      const r = `${e}:${t}`;
      (tt && Se.log(`Recording outcome: "${r}"${i > 1 ? ` (${i} times)` : ""}`),
        (this._outcomes[r] = (this._outcomes[r] || 0) + i));
    }
  }
  on(e, t) {
    const i = (this._hooks[e] = this._hooks[e] || new Set()),
      r = (...s) => t(...s);
    return (
      i.add(r),
      () => {
        i.delete(r);
      }
    );
  }
  emit(e, ...t) {
    const i = this._hooks[e];
    i && i.forEach((r) => r(...t));
  }
  async sendEnvelope(e) {
    if ((this.emit("beforeEnvelope", e), this._isEnabled() && this._transport))
      try {
        return await this._transport.send(e);
      } catch (t) {
        return (tt && Se.error("Error while sending envelope:", t), {});
      }
    return (tt && Se.error("Transport disabled"), {});
  }
  _setupIntegrations() {
    const { integrations: e } = this._options;
    ((this._integrations = WF(this, e)), v4(this, e));
  }
  _updateSessionFromEvent(e, t) {
    let i = t.level === "fatal",
      r = !1;
    const s = t.exception?.values;
    if (s) {
      ((r = !0), (i = !1));
      for (const l of s)
        if (l.mechanism?.handled === !1) {
          i = !0;
          break;
        }
    }
    const o = e.status === "ok";
    ((o && e.errors === 0) || (o && i)) &&
      (jh(e, {
        ...(i && { status: "crashed" }),
        errors: e.errors || Number(r || i),
      }),
      this.captureSession(e));
  }
  async _isClientDoneProcessing(e) {
    let t = 0;
    for (; !e || t < e; ) {
      if ((await new Promise((i) => setTimeout(i, 1)), !this._numProcessing))
        return !0;
      t++;
    }
    return !1;
  }
  _isEnabled() {
    return this.getOptions().enabled !== !1 && this._transport !== void 0;
  }
  _prepareEvent(e, t, i, r) {
    const s = this.getOptions(),
      o = Object.keys(this._integrations);
    return (
      !t.integrations && o?.length && (t.integrations = o),
      this.emit("preprocessEvent", e, t),
      e.type || r.setLastEventId(e.event_id || t.event_id),
      bF(s, e, t, i, this, r).then((a) => {
        if (a === null) return a;
        (this.emit("postprocessEvent", a, t),
          (a.contexts = { trace: iG(i), ...a.contexts }));
        const l = o8(this, i);
        return (
          (a.sdkProcessingMetadata = {
            dynamicSamplingContext: l,
            ...a.sdkProcessingMetadata,
          }),
          a
        );
      })
    );
  }
  _captureEvent(e, t = {}, i = wn(), r = _u()) {
    return (
      tt &&
        gy(e) &&
        Se.log(`Captured error event \`${v8(e)[0] || "<unknown>"}\``),
      this._processEvent(e, t, i, r).then(
        (s) => s.event_id,
        (s) => {
          tt &&
            (T4(s)
              ? Se.log(s.message)
              : S4(s)
                ? Se.warn(s.message)
                : Se.warn(s));
        },
      )
    );
  }
  _processEvent(e, t, i, r) {
    const s = this.getOptions(),
      { sampleRate: o } = s,
      a = S8(e),
      l = gy(e),
      u = `before send for type \`${e.type || "error"}\``,
      h = typeof o > "u" ? void 0 : Ig(o);
    if (l && typeof h == "number" && Math.random() > h)
      return (
        this.recordDroppedEvent("sample_rate", "error"),
        Lb(
          NI(
            `Discarding event because it's not included in the random sample (sampling rate = ${o})`,
          ),
        )
      );
    const d = M4(e.type);
    return this._prepareEvent(e, t, i, r)
      .then((f) => {
        if (f === null)
          throw (
            this.recordDroppedEvent("event_processor", d),
            NI("An event processor returned `null`, will not send event.")
          );
        if (t.data && t.data.__sentry__ === !0) return f;
        const p = ak(this, s, f, t);
        return ok(p, u);
      })
      .then((f) => {
        if (f === null) {
          if ((this.recordDroppedEvent("before_send", d), a)) {
            const C = 1 + (e.spans || []).length;
            this.recordDroppedEvent("before_send", "span", C);
          }
          throw NI(`${u} returned \`null\`, will not send event.`);
        }
        const g = i.getSession() || r.getSession();
        if ((l && g && this._updateSessionFromEvent(g, f), a)) {
          const m = f.sdkProcessingMetadata?.spanCountBeforeProcessing || 0,
            C = f.spans ? f.spans.length : 0,
            A = m - C;
          A > 0 && this.recordDroppedEvent("before_send", "span", A);
        }
        const p = f.transaction_info;
        if (a && p && f.transaction !== e.transaction) {
          const m = "custom";
          f.transaction_info = { ...p, source: m };
        }
        return (this.sendEvent(f, t), f);
      })
      .then(null, (f) => {
        throw T4(f) || S4(f)
          ? f
          : (this.captureException(f, {
              mechanism: { handled: !1, type: "internal" },
              data: { __sentry__: !0 },
              originalException: f,
            }),
            u0(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${f}`));
      });
  }
  _process(e, t) {
    (this._numProcessing++,
      this._promiseBuffer.add(e).then(
        (i) => (this._numProcessing--, i),
        (i) => (
          this._numProcessing--,
          i === Rb && this.recordDroppedEvent("queue_overflow", t),
          i
        ),
      ));
  }
  _clearOutcomes() {
    const e = this._outcomes;
    return (
      (this._outcomes = {}),
      Object.entries(e).map(([t, i]) => {
        const [r, s] = t.split(":");
        return { reason: r, category: s, quantity: i };
      })
    );
  }
  _flushOutcomes() {
    tt && Se.log("Flushing outcomes...");
    const e = this._clearOutcomes();
    if (e.length === 0) {
      tt && Se.log("No outcomes to send");
      return;
    }
    if (!this._dsn) {
      tt && Se.log("No dsn provided, will not send outcomes");
      return;
    }
    tt && Se.log("Sending outcomes:", e);
    const t = tk(e, this._options.tunnel && Ld(this._dsn));
    this.sendEnvelope(t);
  }
};
function M4(n) {
  return n === "replay_event" ? "replay" : n || "error";
}
function ok(n, e) {
  const t = `${e} must return \`null\` or a valid event.`;
  if (Td(n))
    return n.then(
      (i) => {
        if (!mg(i) && i !== null) throw u0(t);
        return i;
      },
      (i) => {
        throw u0(`${e} rejected with ${i}`);
      },
    );
  if (!mg(n) && n !== null) throw u0(t);
  return n;
}
function ak(n, e, t, i) {
  const {
    beforeSend: r,
    beforeSendTransaction: s,
    beforeSendSpan: o,
    ignoreSpans: a,
  } = e;
  let l = t;
  if (gy(l) && r) return r(l, i);
  if (S8(l)) {
    if (o || a) {
      const c = nk(l);
      if (a?.length && hm(c, a)) return null;
      if (o) {
        const u = o(c);
        u ? (l = ep(t, ik(u))) : uy();
      }
      if (l.spans) {
        const u = [],
          h = l.spans;
        for (const f of h) {
          if (a?.length && hm(f, a)) {
            NG(h, f);
            continue;
          }
          if (o) {
            const g = o(f);
            g ? u.push(g) : (uy(), u.push(f));
          } else u.push(f);
        }
        const d = l.spans.length - u.length;
        (d && n.recordDroppedEvent("before_send", "span", d), (l.spans = u));
      }
    }
    if (s) {
      if (l.spans) {
        const c = l.spans.length;
        l.sdkProcessingMetadata = {
          ...t.sdkProcessingMetadata,
          spanCountBeforeProcessing: c,
        };
      }
      return s(l, i);
    }
  }
  return l;
}
function gy(n) {
  return n.type === void 0;
}
function S8(n) {
  return n.type === "transaction";
}
function lk(n) {
  let e = 0;
  return (n.name && (e += n.name.length * 2), (e += 8), e + T8(n.attributes));
}
function ck(n) {
  let e = 0;
  return (n.message && (e += n.message.length * 2), e + T8(n.attributes));
}
function T8(n) {
  if (!n) return 0;
  let e = 0;
  return (
    Object.values(n).forEach((t) => {
      Array.isArray(t)
        ? (e += t.length * L4(t[0]))
        : Xh(t)
          ? (e += L4(t))
          : (e += 100);
    }),
    e
  );
}
function L4(n) {
  return typeof n == "string"
    ? n.length * 2
    : typeof n == "number"
      ? 8
      : typeof n == "boolean"
        ? 4
        : 0;
}
function uk(n, e) {
  (e.debug === !0 &&
    (tt
      ? Se.enable()
      : wd(() => {
          console.warn(
            "[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.",
          );
        })),
    wn().update(e.initialScope));
  const i = new n(e);
  return (hk(i), i.init(), i);
}
function hk(n) {
  wn().setClient(n);
}
const dk = "thismessage:/";
function E8(n) {
  return "isRelative" in n;
}
function M8(n, e) {
  const t = n.indexOf("://") <= 0 && n.indexOf("//") !== 0,
    i = e ?? (t ? dk : void 0);
  try {
    if ("canParse" in URL && !URL.canParse(n, i)) return;
    const r = new URL(n, i);
    return t
      ? { isRelative: t, pathname: r.pathname, search: r.search, hash: r.hash }
      : r;
  } catch {}
}
function fk(n) {
  if (E8(n)) return n.pathname;
  const e = new URL(n);
  return (
    (e.search = ""),
    (e.hash = ""),
    ["80", "443"].includes(e.port) && (e.port = ""),
    e.password && (e.password = "%filtered%"),
    e.username && (e.username = "%filtered%"),
    e.toString()
  );
}
function Jc(n) {
  if (!n) return {};
  const e = n.match(
    /^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/,
  );
  if (!e) return {};
  const t = e[6] || "",
    i = e[8] || "";
  return {
    host: e[4],
    path: e[5],
    protocol: e[2],
    search: t,
    hash: i,
    relative: e[5] + t + i,
  };
}
function gk(n) {
  return n.split(/[?#]/, 1)[0];
}
function pk(n) {
  "aggregates" in n
    ? n.attrs?.ip_address === void 0 &&
      (n.attrs = { ...n.attrs, ip_address: "{{auto}}" })
    : n.ipAddress === void 0 && (n.ipAddress = "{{auto}}");
}
function Pb(n, e, t = [e], i = "npm") {
  const r = n._metadata || {};
  (r.sdk ||
    (r.sdk = {
      name: `sentry.javascript.${e}`,
      packages: t.map((s) => ({ name: `${i}:@sentry/${s}`, version: Kc })),
      version: Kc,
    }),
    (n._metadata = r));
}
function L8(n = {}) {
  const e = n.client || yn();
  if (!NF() || !e) return {};
  const t = Au(),
    i = Ed(t);
  if (i.getTraceData) return i.getTraceData(n);
  const r = n.scope || wn(),
    s = n.span || ns(),
    o = s ? EG(s) : mk(r),
    a = s ? Bl(s) : o8(e, r),
    l = dG(a);
  if (!J7.test(o))
    return (
      Se.warn("Invalid sentry-trace data. Cannot generate trace data"),
      {}
    );
  const u = { "sentry-trace": o, baggage: l };
  if (n.propagateTraceparent) {
    const h = s ? MG(s) : Ck(r);
    h && (u.traceparent = h);
  }
  return u;
}
function mk(n) {
  const {
    traceId: e,
    sampled: t,
    propagationSpanId: i,
  } = n.getPropagationContext();
  return Q7(e, i, t);
}
function Ck(n) {
  const {
    traceId: e,
    sampled: t,
    propagationSpanId: i,
  } = n.getPropagationContext();
  return q7(e, i, t);
}
const Ik = 100;
function hu(n, e) {
  const t = yn(),
    i = _u();
  if (!t) return;
  const { beforeBreadcrumb: r = null, maxBreadcrumbs: s = Ik } = t.getOptions();
  if (s <= 0) return;
  const a = { timestamp: yu(), ...n },
    l = r ? wd(() => r(a, e)) : a;
  l !== null &&
    (t.emit && t.emit("beforeAddBreadcrumb", l, e), i.addBreadcrumb(l, s));
}
let R4;
const Ak = "FunctionToString",
  B4 = new WeakMap(),
  yk = () => ({
    name: Ak,
    setupOnce() {
      R4 = Function.prototype.toString;
      try {
        Function.prototype.toString = function (...n) {
          const e = _b(this),
            t = B4.has(yn()) && e !== void 0 ? e : this;
          return R4.apply(t, n);
        };
      } catch {}
    },
    setup(n) {
      B4.set(n, !0);
    },
  }),
  _k = yk,
  bk = [
    /^Script error\.?$/,
    /^Javascript error: Script error\.? on line 0$/,
    /^ResizeObserver loop completed with undelivered notifications.$/,
    /^Cannot redefine property: googletag$/,
    /^Can't find variable: gmo$/,
    /^undefined is not an object \(evaluating 'a\.[A-Z]'\)$/,
    `can't redefine non-configurable property "solana"`,
    "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)",
    "Can't find variable: _AutofillCallbackHandler",
    /^Non-Error promise rejection captured with value: Object Not Found Matching Id:\d+, MethodName:simulateEvent, ParamCount:\d+$/,
    /^Java exception was raised during method invocation$/,
  ],
  vk = "EventFilters",
  xk = (n = {}) => {
    let e;
    return {
      name: vk,
      setup(t) {
        const i = t.getOptions();
        e = P4(n, i);
      },
      processEvent(t, i, r) {
        if (!e) {
          const s = r.getOptions();
          e = P4(n, s);
        }
        return Sk(t, e) ? null : t;
      },
    };
  },
  wk = (n = {}) => ({ ...xk(n), name: "InboundFilters" });
function P4(n = {}, e = {}) {
  return {
    allowUrls: [...(n.allowUrls || []), ...(e.allowUrls || [])],
    denyUrls: [...(n.denyUrls || []), ...(e.denyUrls || [])],
    ignoreErrors: [
      ...(n.ignoreErrors || []),
      ...(e.ignoreErrors || []),
      ...(n.disableErrorDefaults ? [] : bk),
    ],
    ignoreTransactions: [
      ...(n.ignoreTransactions || []),
      ...(e.ignoreTransactions || []),
    ],
  };
}
function Sk(n, e) {
  if (n.type) {
    if (n.type === "transaction" && Ek(n, e.ignoreTransactions))
      return (
        tt &&
          Se.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${Dc(n)}`),
        !0
      );
  } else {
    if (Tk(n, e.ignoreErrors))
      return (
        tt &&
          Se.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${Dc(n)}`),
        !0
      );
    if (Bk(n))
      return (
        tt &&
          Se.warn(`Event dropped due to not having an error message, error type or stacktrace.
Event: ${Dc(n)}`),
        !0
      );
    if (Mk(n, e.denyUrls))
      return (
        tt &&
          Se.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${Dc(n)}.
Url: ${dm(n)}`),
        !0
      );
    if (!Lk(n, e.allowUrls))
      return (
        tt &&
          Se.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${Dc(n)}.
Url: ${dm(n)}`),
        !0
      );
  }
  return !1;
}
function Tk(n, e) {
  return e?.length ? v8(n).some((t) => xl(t, e)) : !1;
}
function Ek(n, e) {
  if (!e?.length) return !1;
  const t = n.transaction;
  return t ? xl(t, e) : !1;
}
function Mk(n, e) {
  if (!e?.length) return !1;
  const t = dm(n);
  return t ? xl(t, e) : !1;
}
function Lk(n, e) {
  if (!e?.length) return !0;
  const t = dm(n);
  return t ? xl(t, e) : !0;
}
function Rk(n = []) {
  for (let e = n.length - 1; e >= 0; e--) {
    const t = n[e];
    if (t && t.filename !== "<anonymous>" && t.filename !== "[native code]")
      return t.filename || null;
  }
  return null;
}
function dm(n) {
  try {
    const t = [...(n.exception?.values ?? [])]
      .reverse()
      .find(
        (i) =>
          i.mechanism?.parent_id === void 0 && i.stacktrace?.frames?.length,
      )?.stacktrace?.frames;
    return t ? Rk(t) : null;
  } catch {
    return (tt && Se.error(`Cannot extract url for event ${Dc(n)}`), null);
  }
}
function Bk(n) {
  return n.exception?.values?.length
    ? !n.message &&
        !n.exception.values.some(
          (e) => e.stacktrace || (e.type && e.type !== "Error") || e.value,
        )
    : !1;
}
function Pk(n, e, t, i, r, s) {
  if (!r.exception?.values || !s || !La(s.originalException, Error)) return;
  const o =
    r.exception.values.length > 0
      ? r.exception.values[r.exception.values.length - 1]
      : void 0;
  o &&
    (r.exception.values = py(
      n,
      e,
      i,
      s.originalException,
      t,
      r.exception.values,
      o,
      0,
    ));
}
function py(n, e, t, i, r, s, o, a) {
  if (s.length >= t + 1) return s;
  let l = [...s];
  if (La(i[r], Error)) {
    N4(o, a);
    const c = n(e, i[r]),
      u = l.length;
    (D4(c, r, u, a), (l = py(n, e, t, i[r], r, [c, ...l], c, u)));
  }
  return (
    Array.isArray(i.errors) &&
      i.errors.forEach((c, u) => {
        if (La(c, Error)) {
          N4(o, a);
          const h = n(e, c),
            d = l.length;
          (D4(h, `errors[${u}]`, d, a),
            (l = py(n, e, t, c, r, [h, ...l], h, d)));
        }
      }),
    l
  );
}
function N4(n, e) {
  n.mechanism = {
    handled: !0,
    type: "auto.core.linked_errors",
    ...n.mechanism,
    ...(n.type === "AggregateError" && { is_exception_group: !0 }),
    exception_id: e,
  };
}
function D4(n, e, t, i) {
  n.mechanism = {
    handled: !0,
    ...n.mechanism,
    type: "chained",
    source: e,
    exception_id: t,
    parent_id: i,
  };
}
function Nk(n) {
  const e = "console";
  (Wl(e, n), Vl(e, Dk));
}
function Dk() {
  "console" in sn &&
    vD.forEach(function (n) {
      n in sn.console &&
        Zr(sn.console, n, function (e) {
          return (
            (lm[n] = e),
            function (...t) {
              (xs("console", { args: t, level: n }),
                lm[n]?.apply(sn.console, t));
            }
          );
        });
    });
}
function Gk(n) {
  return n === "warn"
    ? "warning"
    : ["fatal", "error", "warning", "log", "info", "debug"].includes(n)
      ? n
      : "log";
}
const Fk = "Dedupe",
  kk = () => {
    let n;
    return {
      name: Fk,
      processEvent(e) {
        if (e.type) return e;
        try {
          if (Uk(e, n))
            return (
              tt &&
                Se.warn(
                  "Event dropped due to being a duplicate of previously captured event.",
                ),
              null
            );
        } catch {}
        return (n = e);
      },
    };
  },
  Ok = kk;
function Uk(n, e) {
  return e ? !!(Hk(n, e) || Wk(n, e)) : !1;
}
function Hk(n, e) {
  const t = n.message,
    i = e.message;
  return !(
    (!t && !i) ||
    (t && !i) ||
    (!t && i) ||
    t !== i ||
    !B8(n, e) ||
    !R8(n, e)
  );
}
function Wk(n, e) {
  const t = G4(e),
    i = G4(n);
  return !(
    !t ||
    !i ||
    t.type !== i.type ||
    t.value !== i.value ||
    !B8(n, e) ||
    !R8(n, e)
  );
}
function R8(n, e) {
  let t = X5(n),
    i = X5(e);
  if (!t && !i) return !0;
  if ((t && !i) || (!t && i) || ((t = t), (i = i), i.length !== t.length))
    return !1;
  for (let r = 0; r < i.length; r++) {
    const s = i[r],
      o = t[r];
    if (
      s.filename !== o.filename ||
      s.lineno !== o.lineno ||
      s.colno !== o.colno ||
      s.function !== o.function
    )
      return !1;
  }
  return !0;
}
function B8(n, e) {
  let t = n.fingerprint,
    i = e.fingerprint;
  if (!t && !i) return !0;
  if ((t && !i) || (!t && i)) return !1;
  ((t = t), (i = i));
  try {
    return t.join("") === i.join("");
  } catch {
    return !1;
  }
}
function G4(n) {
  return n.exception?.values?.[0];
}
function Vk(n, e, t, i, r) {
  if (!n.fetchData) return;
  const { method: s, url: o } = n.fetchData,
    a = $s() && e(o);
  if (n.endTimestamp && a) {
    const f = n.fetchData.__span;
    if (!f) return;
    const g = i[f];
    g && (Yk(g, n), Zk(g, n, r), delete i[f]);
    return;
  }
  const { spanOrigin: l = "auto.http.browser", propagateTraceparent: c = !1 } =
      typeof r == "object" ? r : { spanOrigin: r },
    u = !!ns(),
    h = a && u ? Rd(Kk(o, s, l)) : new Pl();
  if (
    ((n.fetchData.__span = h.spanContext().spanId),
    (i[h.spanContext().spanId] = h),
    t(n.fetchData.url))
  ) {
    const f = n.args[0],
      g = n.args[1] || {},
      p = zk(f, g, $s() && u ? h : void 0, c);
    p && ((n.args[1] = g), (g.headers = p));
  }
  const d = yn();
  if (d) {
    const f = {
      input: n.args,
      response: n.response,
      startTimestamp: n.startTimestamp,
      endTimestamp: n.endTimestamp,
    };
    d.emit("beforeOutgoingRequestSpan", h, f);
  }
  return h;
}
function Zk(n, e, t) {
  (typeof t == "object" && t !== null ? t.onRequestSpanEnd : void 0)?.(n, {
    headers: e.response?.headers,
    error: e.error,
  });
}
function zk(n, e, t, i) {
  const r = L8({ span: t, propagateTraceparent: i }),
    s = r["sentry-trace"],
    o = r.baggage,
    a = r.traceparent;
  if (!s) return;
  const l = e.headers || (O7(n) ? n.headers : void 0);
  if (l)
    if (Xk(l)) {
      const c = new Headers(l);
      if (
        (c.get("sentry-trace") || c.set("sentry-trace", s),
        i && a && !c.get("traceparent") && c.set("traceparent", a),
        o)
      ) {
        const u = c.get("baggage");
        u ? Op(u) || c.set("baggage", `${u},${o}`) : c.set("baggage", o);
      }
      return c;
    } else if (Array.isArray(l)) {
      const c = [...l];
      (l.find((h) => h[0] === "sentry-trace") || c.push(["sentry-trace", s]),
        i &&
          a &&
          !l.find((h) => h[0] === "traceparent") &&
          c.push(["traceparent", a]));
      const u = l.find((h) => h[0] === "baggage" && Op(h[1]));
      return (o && !u && c.push(["baggage", o]), c);
    } else {
      const c = "sentry-trace" in l ? l["sentry-trace"] : void 0,
        u = "traceparent" in l ? l.traceparent : void 0,
        h = "baggage" in l ? l.baggage : void 0,
        d = h ? (Array.isArray(h) ? [...h] : [h]) : [],
        f = h && (Array.isArray(h) ? h.find((p) => Op(p)) : Op(h));
      o && !f && d.push(o);
      const g = {
        ...l,
        "sentry-trace": c ?? s,
        baggage: d.length > 0 ? d.join(",") : void 0,
      };
      return (i && a && !u && (g.traceparent = a), g);
    }
  else return { ...r };
}
function Yk(n, e) {
  if (e.response) {
    Y7(n, e.response.status);
    const t = e.response?.headers?.get("content-length");
    if (t) {
      const i = parseInt(t);
      i > 0 && n.setAttribute("http.response_content_length", i);
    }
  } else e.error && n.setStatus({ code: di, message: "internal_error" });
  n.end();
}
function Op(n) {
  return n.split(",").some((e) => e.trim().startsWith(wb));
}
function Xk(n) {
  return typeof Headers < "u" && La(n, Headers);
}
function Kk(n, e, t) {
  const i = M8(n);
  return { name: i ? `${e} ${fk(i)}` : e, attributes: jk(n, i, e, t) };
}
function jk(n, e, t, i) {
  const r = {
    url: n,
    type: "fetch",
    "http.method": t,
    [pi]: i,
    [Ba]: "http.client",
  };
  return (
    e &&
      (E8(e) || ((r["http.url"] = e.href), (r["server.address"] = e.host)),
      e.search && (r["http.query"] = e.search),
      e.hash && (r["http.fragment"] = e.hash)),
    r
  );
}
function P8(n) {
  if (n !== void 0)
    return n >= 400 && n < 500 ? "warning" : n >= 500 ? "error" : void 0;
}
const yg = sn;
function $k() {
  return "history" in yg && !!yg.history;
}
function Jk() {
  if (!("fetch" in yg)) return !1;
  try {
    return (new Headers(), new Request("data:,"), new Response(), !0);
  } catch {
    return !1;
  }
}
function my(n) {
  return (
    n && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(n.toString())
  );
}
function Qk() {
  if (typeof EdgeRuntime == "string") return !0;
  if (!Jk()) return !1;
  if (my(yg.fetch)) return !0;
  let n = !1;
  const e = yg.document;
  if (e && typeof e.createElement == "function")
    try {
      const t = e.createElement("iframe");
      ((t.hidden = !0),
        e.head.appendChild(t),
        t.contentWindow?.fetch && (n = my(t.contentWindow.fetch)),
        e.head.removeChild(t));
    } catch (t) {
      tt &&
        Se.warn(
          "Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ",
          t,
        );
    }
  return n;
}
function N8(n, e) {
  const t = "fetch";
  (Wl(t, n), Vl(t, () => D8(void 0, e)));
}
function qk(n) {
  const e = "fetch-body-resolved";
  (Wl(e, n), Vl(e, () => D8(tO)));
}
function D8(n, e = !1) {
  (e && !Qk()) ||
    Zr(sn, "fetch", function (t) {
      return function (...i) {
        const r = new Error(),
          { method: s, url: o } = nO(i),
          a = {
            args: i,
            fetchData: { method: s, url: o },
            startTimestamp: Bi() * 1e3,
            virtualError: r,
            headers: iO(i),
          };
        return (
          n || xs("fetch", { ...a }),
          t.apply(sn, i).then(
            async (l) => (
              n
                ? n(l)
                : xs("fetch", { ...a, endTimestamp: Bi() * 1e3, response: l }),
              l
            ),
            (l) => {
              if (
                (xs("fetch", { ...a, endTimestamp: Bi() * 1e3, error: l }),
                Ib(l) &&
                  l.stack === void 0 &&
                  ((l.stack = r.stack), Qr(l, "framesToPop", 1)),
                l instanceof TypeError &&
                  (l.message === "Failed to fetch" ||
                    l.message === "Load failed" ||
                    l.message ===
                      "NetworkError when attempting to fetch resource."))
              )
                try {
                  const c = new URL(a.fetchData.url);
                  l.message = `${l.message} (${c.host})`;
                } catch {}
              throw l;
            },
          )
        );
      };
    });
}
async function eO(n, e) {
  if (n?.body) {
    const t = n.body,
      i = t.getReader(),
      r = setTimeout(() => {
        t.cancel().then(null, () => {});
      }, 90 * 1e3);
    let s = !0;
    for (; s; ) {
      let o;
      try {
        o = setTimeout(() => {
          t.cancel().then(null, () => {});
        }, 5e3);
        const { done: a } = await i.read();
        (clearTimeout(o), a && (e(), (s = !1)));
      } catch {
        s = !1;
      } finally {
        clearTimeout(o);
      }
    }
    (clearTimeout(r), i.releaseLock(), t.cancel().then(null, () => {}));
  }
}
function tO(n) {
  let e;
  try {
    e = n.clone();
  } catch {
    return;
  }
  eO(e, () => {
    xs("fetch-body-resolved", { endTimestamp: Bi() * 1e3, response: n });
  });
}
function Cy(n, e) {
  return !!n && typeof n == "object" && !!n[e];
}
function F4(n) {
  return typeof n == "string"
    ? n
    : n
      ? Cy(n, "url")
        ? n.url
        : n.toString
          ? n.toString()
          : ""
      : "";
}
function nO(n) {
  if (n.length === 0) return { method: "GET", url: "" };
  if (n.length === 2) {
    const [t, i] = n;
    return {
      url: F4(t),
      method: Cy(i, "method") ? String(i.method).toUpperCase() : "GET",
    };
  }
  const e = n[0];
  return {
    url: F4(e),
    method: Cy(e, "method") ? String(e.method).toUpperCase() : "GET",
  };
}
function iO(n) {
  const [e, t] = n;
  try {
    if (typeof t == "object" && t !== null && "headers" in t && t.headers)
      return new Headers(t.headers);
    if (O7(e)) return new Headers(e.headers);
  } catch {}
}
function rO() {
  return typeof __SENTRY_BROWSER_BUNDLE__ < "u" && !!__SENTRY_BROWSER_BUNDLE__;
}
function sO() {
  return "npm";
}
function oO() {
  return (
    !rO() &&
    Object.prototype.toString.call(typeof process < "u" ? process : 0) ===
      "[object process]"
  );
}
function aO() {
  return typeof window < "u" && (!oO() || lO());
}
function lO() {
  return sn.process?.type === "renderer";
}
const en = sn;
let Iy = 0;
function G8() {
  return Iy > 0;
}
function cO() {
  (Iy++,
    setTimeout(() => {
      Iy--;
    }));
}
function Qh(n, e = {}) {
  function t(r) {
    return typeof r == "function";
  }
  if (!t(n)) return n;
  try {
    const r = n.__sentry_wrapped__;
    if (r) return typeof r == "function" ? r : n;
    if (_b(n)) return n;
  } catch {
    return n;
  }
  const i = function (...r) {
    try {
      const s = r.map((o) => Qh(o, e));
      return n.apply(this, s);
    } catch (s) {
      throw (
        cO(),
        EC((o) => {
          (o.addEventProcessor(
            (a) => (
              e.mechanism && (ay(a, void 0, void 0), Kh(a, e.mechanism)),
              (a.extra = { ...a.extra, arguments: r }),
              a
            ),
          ),
            PF(s));
        }),
        s
      );
    }
  };
  try {
    for (const r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (i[r] = n[r]);
  } catch {}
  (H7(i, n), Qr(n, "__sentry_wrapped__", i));
  try {
    Object.getOwnPropertyDescriptor(i, "name").configurable &&
      Object.defineProperty(i, "name", {
        get() {
          return n.name;
        },
      });
  } catch {}
  return i;
}
function Nb() {
  const n = qg(),
    { referrer: e } = en.document || {},
    { userAgent: t } = en.navigator || {},
    i = { ...(e && { Referer: e }), ...(t && { "User-Agent": t }) };
  return { url: n, headers: i };
}
function Db(n, e) {
  const t = Gb(n, e),
    i = { type: gO(e), value: pO(e) };
  return (
    t.length && (i.stacktrace = { frames: t }),
    i.type === void 0 &&
      i.value === "" &&
      (i.value = "Unrecoverable error caught"),
    i
  );
}
function uO(n, e, t, i) {
  const s = yn()?.getOptions().normalizeDepth,
    o = yO(e),
    a = { __serialized__: a8(e, s) };
  if (o) return { exception: { values: [Db(n, o)] }, extra: a };
  const l = {
    exception: {
      values: [
        {
          type: TC(e) ? e.constructor.name : i ? "UnhandledRejection" : "Error",
          value: IO(e, { isUnhandledRejection: i }),
        },
      ],
    },
    extra: a,
  };
  if (t) {
    const c = Gb(n, t);
    c.length && (l.exception.values[0].stacktrace = { frames: c });
  }
  return l;
}
function DI(n, e) {
  return { exception: { values: [Db(n, e)] } };
}
function Gb(n, e) {
  const t = e.stacktrace || e.stack || "",
    i = dO(e),
    r = fO(e);
  try {
    return n(t, i, r);
  } catch {}
  return [];
}
const hO = /Minified React error #\d+;/i;
function dO(n) {
  return n && hO.test(n.message) ? 1 : 0;
}
function fO(n) {
  return typeof n.framesToPop == "number" ? n.framesToPop : 0;
}
function F8(n) {
  return typeof WebAssembly < "u" && typeof WebAssembly.Exception < "u"
    ? n instanceof WebAssembly.Exception
    : !1;
}
function gO(n) {
  const e = n?.name;
  return !e && F8(n)
    ? n.message && Array.isArray(n.message) && n.message.length == 2
      ? n.message[0]
      : "WebAssembly.Exception"
    : e;
}
function pO(n) {
  const e = n?.message;
  return F8(n)
    ? Array.isArray(n.message) && n.message.length == 2
      ? n.message[1]
      : "wasm exception"
    : e
      ? e.error && typeof e.error.message == "string"
        ? e.error.message
        : e
      : "No error message";
}
function mO(n, e, t, i) {
  const r = t?.syntheticException || void 0,
    s = Fb(n, e, r, i);
  return (
    Kh(s),
    (s.level = "error"),
    t?.event_id && (s.event_id = t.event_id),
    LC(s)
  );
}
function CO(n, e, t = "info", i, r) {
  const s = i?.syntheticException || void 0,
    o = Ay(n, e, s, r);
  return ((o.level = t), i?.event_id && (o.event_id = i.event_id), LC(o));
}
function Fb(n, e, t, i, r) {
  let s;
  if (F7(e) && e.error) return DI(n, e.error);
  if (j5(e) || ND(e)) {
    const o = e;
    if ("stack" in e) s = DI(n, e);
    else {
      const a = o.name || (j5(o) ? "DOMError" : "DOMException"),
        l = o.message ? `${a}: ${o.message}` : a;
      ((s = Ay(n, l, t, i)), ay(s, l));
    }
    return (
      "code" in o && (s.tags = { ...s.tags, "DOMException.code": `${o.code}` }),
      s
    );
  }
  return Ib(e)
    ? DI(n, e)
    : mg(e) || TC(e)
      ? ((s = uO(n, e, t, r)), Kh(s, { synthetic: !0 }), s)
      : ((s = Ay(n, e, t, i)),
        ay(s, `${e}`, void 0),
        Kh(s, { synthetic: !0 }),
        s);
}
function Ay(n, e, t, i) {
  const r = {};
  if (i && t) {
    const s = Gb(n, t);
    (s.length &&
      (r.exception = { values: [{ value: e, stacktrace: { frames: s } }] }),
      Kh(r, { synthetic: !0 }));
  }
  if (Ab(e)) {
    const { __sentry_template_string__: s, __sentry_template_values__: o } = e;
    return ((r.logentry = { message: s, params: o }), r);
  }
  return ((r.message = e), r);
}
function IO(n, { isUnhandledRejection: e }) {
  const t = UD(n),
    i = e ? "promise rejection" : "exception";
  return F7(n)
    ? `Event \`ErrorEvent\` captured as ${i} with message \`${n.message}\``
    : TC(n)
      ? `Event \`${AO(n)}\` (type=${n.type}) captured as ${i}`
      : `Object captured as ${i} with keys: ${t}`;
}
function AO(n) {
  try {
    const e = Object.getPrototypeOf(n);
    return e ? e.constructor.name : void 0;
  } catch {}
}
function yO(n) {
  for (const e in n)
    if (Object.prototype.hasOwnProperty.call(n, e)) {
      const t = n[e];
      if (t instanceof Error) return t;
    }
}
class _O extends sk {
  constructor(e) {
    const t = bO(e),
      i = en.SENTRY_SDK_SOURCE || sO();
    (Pb(t, "browser", ["browser"], i),
      t._metadata?.sdk &&
        (t._metadata.sdk.settings = {
          infer_ip: t.sendDefaultPii ? "auto" : "never",
          ...t._metadata.sdk.settings,
        }),
      super(t));
    const {
        sendDefaultPii: r,
        sendClientReports: s,
        enableLogs: o,
        _experiments: a,
        enableMetrics: l,
      } = this._options,
      c = l ?? a?.enableMetrics ?? !0;
    (en.document &&
      (s || o || c) &&
      en.document.addEventListener("visibilitychange", () => {
        en.document.visibilityState === "hidden" &&
          (s && this._flushOutcomes(), o && I8(this), c && y8(this));
      }),
      r && this.on("beforeSendSession", pk));
  }
  eventFromException(e, t) {
    return mO(this._options.stackParser, e, t, this._options.attachStacktrace);
  }
  eventFromMessage(e, t = "info", i) {
    return CO(
      this._options.stackParser,
      e,
      t,
      i,
      this._options.attachStacktrace,
    );
  }
  _prepareEvent(e, t, i, r) {
    return (
      (e.platform = e.platform || "javascript"),
      super._prepareEvent(e, t, i, r)
    );
  }
}
function bO(n) {
  return {
    release:
      typeof __SENTRY_RELEASE__ == "string"
        ? __SENTRY_RELEASE__
        : en.SENTRY_RELEASE?.id,
    sendClientReports: !0,
    parentSpanIsAlwaysRootSpan: !0,
    ...n,
  };
}
const ip = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__,
  Tt = sn,
  vO = (n, e) => (n > e[1] ? "poor" : n > e[0] ? "needs-improvement" : "good"),
  rp = (n, e, t, i) => {
    let r, s;
    return (o) => {
      e.value >= 0 &&
        (o || i) &&
        ((s = e.value - (r ?? 0)),
        (s || r === void 0) &&
          ((r = e.value), (e.delta = s), (e.rating = vO(e.value, t)), n(e)));
    };
  },
  sp = (n = !0) => {
    const e = Tt.performance?.getEntriesByType?.("navigation")[0];
    if (!n || (e && e.responseStart > 0 && e.responseStart < performance.now()))
      return e;
  },
  Bd = () => sp()?.activationStart ?? 0;
function Qc(n, e, t) {
  Tt.document && Tt.addEventListener(n, e, t);
}
function kb(n, e, t) {
  Tt.document && Tt.removeEventListener(n, e, t);
}
let Sh = -1;
const k8 = new Set(),
  xO = () =>
    Tt.document?.visibilityState === "hidden" && !Tt.document?.prerendering
      ? 0
      : 1 / 0,
  h0 = (n) => {
    if (wO(n) && Sh > -1) {
      if (n.type === "visibilitychange" || n.type === "pagehide")
        for (const e of k8) e();
      isFinite(Sh) ||
        ((Sh = n.type === "visibilitychange" ? n.timeStamp : 0),
        kb("prerenderingchange", h0, !0));
    }
  },
  op = () => {
    if (Tt.document && Sh < 0) {
      const n = Bd();
      ((Sh =
        (Tt.document.prerendering
          ? void 0
          : globalThis.performance
              .getEntriesByType("visibility-state")
              .filter((t) => t.name === "hidden" && t.startTime > n)[0]
              ?.startTime) ?? xO()),
        Qc("visibilitychange", h0, !0),
        Qc("pagehide", h0, !0),
        Qc("prerenderingchange", h0, !0));
    }
    return {
      get firstHiddenTime() {
        return Sh;
      },
      onHidden(n) {
        k8.add(n);
      },
    };
  };
function wO(n) {
  return n.type === "pagehide" || Tt.document?.visibilityState === "hidden";
}
const SO = () =>
    `v5-${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`,
  ap = (n, e = -1) => {
    const t = sp();
    let i = "navigate";
    return (
      t &&
        (Tt.document?.prerendering || Bd() > 0
          ? (i = "prerender")
          : Tt.document?.wasDiscarded
            ? (i = "restore")
            : t.type && (i = t.type.replace(/_/g, "-"))),
      {
        name: n,
        value: e,
        rating: "good",
        delta: 0,
        entries: [],
        id: SO(),
        navigationType: i,
      }
    );
  },
  GI = new WeakMap();
function Ob(n, e) {
  return (GI.get(n) || GI.set(n, new e()), GI.get(n));
}
class fm {
  constructor() {
    (fm.prototype.__init.call(this), fm.prototype.__init2.call(this));
  }
  __init() {
    this._sessionValue = 0;
  }
  __init2() {
    this._sessionEntries = [];
  }
  _processEntry(e) {
    if (e.hadRecentInput) return;
    const t = this._sessionEntries[0],
      i = this._sessionEntries[this._sessionEntries.length - 1];
    (this._sessionValue &&
    t &&
    i &&
    e.startTime - i.startTime < 1e3 &&
    e.startTime - t.startTime < 5e3
      ? ((this._sessionValue += e.value), this._sessionEntries.push(e))
      : ((this._sessionValue = e.value), (this._sessionEntries = [e])),
      this._onAfterProcessingUnexpectedShift?.(e));
  }
}
const Pd = (n, e, t = {}) => {
    try {
      if (PerformanceObserver.supportedEntryTypes.includes(n)) {
        const i = new PerformanceObserver((r) => {
          Promise.resolve().then(() => {
            e(r.getEntries());
          });
        });
        return (i.observe({ type: n, buffered: !0, ...t }), i);
      }
    } catch {}
  },
  Ub = (n) => {
    let e = !1;
    return () => {
      e || (n(), (e = !0));
    };
  },
  RC = (n) => {
    Tt.document?.prerendering
      ? addEventListener("prerenderingchange", () => n(), !0)
      : n();
  },
  TO = [1800, 3e3],
  EO = (n, e = {}) => {
    RC(() => {
      const t = op(),
        i = ap("FCP");
      let r;
      const o = Pd("paint", (a) => {
        for (const l of a)
          l.name === "first-contentful-paint" &&
            (o.disconnect(),
            l.startTime < t.firstHiddenTime &&
              ((i.value = Math.max(l.startTime - Bd(), 0)),
              i.entries.push(l),
              r(!0)));
      });
      o && (r = rp(n, i, TO, e.reportAllChanges));
    });
  },
  MO = [0.1, 0.25],
  LO = (n, e = {}) => {
    EO(
      Ub(() => {
        const t = ap("CLS", 0);
        let i;
        const r = op(),
          s = Ob(e, fm),
          o = (l) => {
            for (const c of l) s._processEntry(c);
            s._sessionValue > t.value &&
              ((t.value = s._sessionValue),
              (t.entries = s._sessionEntries),
              i());
          },
          a = Pd("layout-shift", o);
        a &&
          ((i = rp(n, t, MO, e.reportAllChanges)),
          r.onHidden(() => {
            (o(a.takeRecords()), i(!0));
          }),
          Tt?.setTimeout?.(i));
      }),
    );
  };
let O8 = 0,
  FI = 1 / 0,
  Up = 0;
const RO = (n) => {
  n.forEach((e) => {
    e.interactionId &&
      ((FI = Math.min(FI, e.interactionId)),
      (Up = Math.max(Up, e.interactionId)),
      (O8 = Up ? (Up - FI) / 7 + 1 : 0));
  });
};
let yy;
const U8 = () => (yy ? O8 : performance.interactionCount || 0),
  BO = () => {
    "interactionCount" in performance ||
      yy ||
      (yy = Pd("event", RO, {
        type: "event",
        buffered: !0,
        durationThreshold: 0,
      }));
  },
  kI = 10;
let H8 = 0;
const PO = () => U8() - H8;
class gm {
  constructor() {
    (gm.prototype.__init.call(this), gm.prototype.__init2.call(this));
  }
  __init() {
    this._longestInteractionList = [];
  }
  __init2() {
    this._longestInteractionMap = new Map();
  }
  _resetInteractions() {
    ((H8 = U8()),
      (this._longestInteractionList.length = 0),
      this._longestInteractionMap.clear());
  }
  _estimateP98LongestInteraction() {
    const e = Math.min(
      this._longestInteractionList.length - 1,
      Math.floor(PO() / 50),
    );
    return this._longestInteractionList[e];
  }
  _processEntry(e) {
    if (
      (this._onBeforeProcessingEntry?.(e),
      !(e.interactionId || e.entryType === "first-input"))
    )
      return;
    const t = this._longestInteractionList.at(-1);
    let i = this._longestInteractionMap.get(e.interactionId);
    if (
      i ||
      this._longestInteractionList.length < kI ||
      e.duration > t._latency
    ) {
      if (
        (i
          ? e.duration > i._latency
            ? ((i.entries = [e]), (i._latency = e.duration))
            : e.duration === i._latency &&
              e.startTime === i.entries[0].startTime &&
              i.entries.push(e)
          : ((i = { id: e.interactionId, entries: [e], _latency: e.duration }),
            this._longestInteractionMap.set(i.id, i),
            this._longestInteractionList.push(i)),
        this._longestInteractionList.sort((r, s) => s._latency - r._latency),
        this._longestInteractionList.length > kI)
      ) {
        const r = this._longestInteractionList.splice(kI);
        for (const s of r) this._longestInteractionMap.delete(s.id);
      }
      this._onAfterProcessingINPCandidate?.(i);
    }
  }
}
const W8 = (n) => {
    const e = (t) => {
      (t.type === "pagehide" || Tt.document?.visibilityState === "hidden") &&
        n(t);
    };
    (Qc("visibilitychange", e, !0), Qc("pagehide", e, !0));
  },
  V8 = (n) => {
    const e = Tt.requestIdleCallback || Tt.setTimeout;
    Tt.document?.visibilityState === "hidden"
      ? n()
      : ((n = Ub(n)),
        Qc("visibilitychange", n, { once: !0, capture: !0 }),
        e(() => {
          (n(), kb("visibilitychange", n, { capture: !0 }));
        }),
        W8(n));
  },
  NO = [200, 500],
  DO = 40,
  GO = (n, e = {}) => {
    if (
      !(
        globalThis.PerformanceEventTiming &&
        "interactionId" in PerformanceEventTiming.prototype
      )
    )
      return;
    const t = op();
    RC(() => {
      BO();
      const i = ap("INP");
      let r;
      const s = Ob(e, gm),
        o = (l) => {
          V8(() => {
            for (const u of l) s._processEntry(u);
            const c = s._estimateP98LongestInteraction();
            c &&
              c._latency !== i.value &&
              ((i.value = c._latency), (i.entries = c.entries), r());
          });
        },
        a = Pd("event", o, { durationThreshold: e.durationThreshold ?? DO });
      ((r = rp(n, i, NO, e.reportAllChanges)),
        a &&
          (a.observe({ type: "first-input", buffered: !0 }),
          t.onHidden(() => {
            (o(a.takeRecords()), r(!0));
          })));
    });
  };
class FO {
  _processEntry(e) {
    this._onBeforeProcessingEntry?.(e);
  }
}
const kO = [2500, 4e3],
  OO = (n, e = {}) => {
    RC(() => {
      const t = op(),
        i = ap("LCP");
      let r;
      const s = Ob(e, FO),
        o = (l) => {
          e.reportAllChanges || (l = l.slice(-1));
          for (const c of l)
            (s._processEntry(c),
              c.startTime < t.firstHiddenTime &&
                ((i.value = Math.max(c.startTime - Bd(), 0)),
                (i.entries = [c]),
                r()));
        },
        a = Pd("largest-contentful-paint", o);
      if (a) {
        r = rp(n, i, kO, e.reportAllChanges);
        const l = Ub(() => {
            (o(a.takeRecords()), a.disconnect(), r(!0));
          }),
          c = (u) => {
            u.isTrusted && (V8(l), kb(u.type, c, { capture: !0 }));
          };
        for (const u of ["keydown", "click", "visibilitychange"])
          Qc(u, c, { capture: !0 });
      }
    });
  },
  UO = [800, 1800],
  _y = (n) => {
    Tt.document?.prerendering
      ? RC(() => _y(n))
      : Tt.document?.readyState !== "complete"
        ? addEventListener("load", () => _y(n), !0)
        : setTimeout(n);
  },
  HO = (n, e = {}) => {
    const t = ap("TTFB"),
      i = rp(n, t, UO, e.reportAllChanges);
    _y(() => {
      const r = sp();
      r &&
        ((t.value = Math.max(r.responseStart - Bd(), 0)),
        (t.entries = [r]),
        i(!0));
    });
  },
  jf = {},
  pm = {};
let Z8, z8, Y8, X8;
function K8(n, e = !1) {
  return BC("cls", n, ZO, Z8, e);
}
function j8(n, e = !1) {
  return BC("lcp", n, zO, z8, e);
}
function WO(n) {
  return BC("ttfb", n, YO, Y8);
}
function VO(n) {
  return BC("inp", n, XO, X8);
}
function qh(n, e) {
  return ($8(n, e), pm[n] || (KO(n), (pm[n] = !0)), J8(n, e));
}
function lp(n, e) {
  const t = jf[n];
  if (t?.length)
    for (const i of t)
      try {
        i(e);
      } catch (r) {
        ip &&
          Se.error(
            `Error while triggering instrumentation handler.
Type: ${n}
Name: ${Ma(i)}
Error:`,
            r,
          );
      }
}
function ZO() {
  return LO(
    (n) => {
      (lp("cls", { metric: n }), (Z8 = n));
    },
    { reportAllChanges: !0 },
  );
}
function zO() {
  return OO(
    (n) => {
      (lp("lcp", { metric: n }), (z8 = n));
    },
    { reportAllChanges: !0 },
  );
}
function YO() {
  return HO((n) => {
    (lp("ttfb", { metric: n }), (Y8 = n));
  });
}
function XO() {
  return GO((n) => {
    (lp("inp", { metric: n }), (X8 = n));
  });
}
function BC(n, e, t, i, r = !1) {
  $8(n, e);
  let s;
  return (
    pm[n] || ((s = t()), (pm[n] = !0)),
    i && e({ metric: i }),
    J8(n, e, r ? s : void 0)
  );
}
function KO(n) {
  const e = {};
  (n === "event" && (e.durationThreshold = 0),
    Pd(
      n,
      (t) => {
        lp(n, { entries: t });
      },
      e,
    ));
}
function $8(n, e) {
  ((jf[n] = jf[n] || []), jf[n].push(e));
}
function J8(n, e, t) {
  return () => {
    t && t();
    const i = jf[n];
    if (!i) return;
    const r = i.indexOf(e);
    r !== -1 && i.splice(r, 1);
  };
}
function jO(n) {
  return "duration" in n;
}
function OI(n) {
  return typeof n == "number" && isFinite(n);
}
function Nl(n, e, t, { ...i }) {
  const r = cn(n).start_timestamp;
  return (
    r &&
      r > e &&
      typeof n.updateStartTime == "function" &&
      n.updateStartTime(e),
    Eb(n, () => {
      const s = Rd({ startTime: e, ...i });
      return (s && s.end(t), s);
    })
  );
}
function Hb(n) {
  const e = yn();
  if (!e) return;
  const { name: t, transaction: i, attributes: r, startTime: s } = n,
    { release: o, environment: a, sendDefaultPii: l } = e.getOptions(),
    u = e.getIntegrationByName("Replay")?.getReplayId(),
    h = wn(),
    d = h.getUser(),
    f = d !== void 0 ? d.email || d.id || d.ip_address : void 0;
  let g;
  try {
    g = h.getScopeData().contexts.profile.profile_id;
  } catch {}
  const p = {
    release: o,
    environment: a,
    user: f || void 0,
    profile_id: g || void 0,
    replay_id: u || void 0,
    transaction: i,
    "user_agent.original": Tt.navigator?.userAgent,
    "client.address": l ? "{{auto}}" : void 0,
    ...r,
  };
  return Rd({
    name: t,
    attributes: p,
    startTime: s,
    experimental: { standalone: !0 },
  });
}
function cp() {
  return Tt.addEventListener && Tt.performance;
}
function Kn(n) {
  return n / 1e3;
}
function $O(n) {
  let e = "unknown",
    t = "unknown",
    i = "";
  for (const r of n) {
    if (r === "/") {
      [e, t] = n.split("/");
      break;
    }
    if (!isNaN(Number(r))) {
      ((e = i === "h" ? "http" : i), (t = n.split(i)[1]));
      break;
    }
    i += r;
  }
  return (i === n && (e = i), { name: e, version: t });
}
function Q8(n) {
  try {
    return PerformanceObserver.supportedEntryTypes.includes(n);
  } catch {
    return !1;
  }
}
function q8(n, e) {
  let t,
    i = !1;
  function r(a) {
    (!i && t && e(a, t), (i = !0));
  }
  W8(() => {
    r("pagehide");
  });
  const s = n.on("beforeStartNavigationSpan", (a, l) => {
      l?.isRedirect || (r("navigation"), s(), o());
    }),
    o = n.on("afterStartPageLoadSpan", (a) => {
      ((t = a.spanContext().spanId), o());
    });
}
function JO(n) {
  let e = 0,
    t;
  if (!Q8("layout-shift")) return;
  const i = K8(({ metric: r }) => {
    const s = r.entries[r.entries.length - 1];
    s && ((e = r.value), (t = s));
  }, !0);
  q8(n, (r, s) => {
    (QO(e, t, s, r), i());
  });
}
function QO(n, e, t, i) {
  ip && Se.log(`Sending CLS span (${n})`);
  const r = e ? Kn((ts() || 0) + e.startTime) : Bi(),
    s = wn().getScopeData().transactionName,
    o = e ? Ms(e.sources[0]?.node) : "Layout shift",
    a = {
      [pi]: "auto.http.browser.cls",
      [Ba]: "ui.webvital.cls",
      [Md]: 0,
      "sentry.pageload.span_id": t,
      "sentry.report_event": i,
    };
  e?.sources &&
    e.sources.forEach((c, u) => {
      a[`cls.source.${u + 1}`] = Ms(c.node);
    });
  const l = Hb({ name: o, transaction: s, attributes: a, startTime: r });
  l && (l.addEvent("cls", { [tp]: "", [np]: n }), l.end(r));
}
function qO(n) {
  let e = 0,
    t;
  if (!Q8("largest-contentful-paint")) return;
  const i = j8(({ metric: r }) => {
    const s = r.entries[r.entries.length - 1];
    s && ((e = r.value), (t = s));
  }, !0);
  q8(n, (r, s) => {
    (eU(e, t, s, r), i());
  });
}
function eU(n, e, t, i) {
  ip && Se.log(`Sending LCP span (${n})`);
  const r = Kn((ts() || 0) + (e?.startTime || 0)),
    s = wn().getScopeData().transactionName,
    o = e ? Ms(e.element) : "Largest contentful paint",
    a = {
      [pi]: "auto.http.browser.lcp",
      [Ba]: "ui.webvital.lcp",
      [Md]: 0,
      "sentry.pageload.span_id": t,
      "sentry.report_event": i,
    };
  e &&
    (e.element && (a["lcp.element"] = Ms(e.element)),
    e.id && (a["lcp.id"] = e.id),
    e.url && (a["lcp.url"] = e.url),
    e.loadTime != null && (a["lcp.loadTime"] = e.loadTime),
    e.renderTime != null && (a["lcp.renderTime"] = e.renderTime),
    e.size != null && (a["lcp.size"] = e.size));
  const l = Hb({ name: o, transaction: s, attributes: a, startTime: r });
  l && (l.addEvent("lcp", { [tp]: "millisecond", [np]: n }), l.end(r));
}
function os(n) {
  return n && ((ts() || performance.timeOrigin) + n) / 1e3;
}
function eT(n) {
  const e = {};
  if (n.nextHopProtocol != null) {
    const { name: t, version: i } = $O(n.nextHopProtocol);
    ((e["network.protocol.version"] = i), (e["network.protocol.name"] = t));
  }
  return ts() || cp()?.timeOrigin
    ? tU({
        ...e,
        "http.request.redirect_start": os(n.redirectStart),
        "http.request.redirect_end": os(n.redirectEnd),
        "http.request.worker_start": os(n.workerStart),
        "http.request.fetch_start": os(n.fetchStart),
        "http.request.domain_lookup_start": os(n.domainLookupStart),
        "http.request.domain_lookup_end": os(n.domainLookupEnd),
        "http.request.connect_start": os(n.connectStart),
        "http.request.secure_connection_start": os(n.secureConnectionStart),
        "http.request.connection_end": os(n.connectEnd),
        "http.request.request_start": os(n.requestStart),
        "http.request.response_start": os(n.responseStart),
        "http.request.response_end": os(n.responseEnd),
        "http.request.time_to_first_byte":
          n.responseStart != null ? n.responseStart / 1e3 : void 0,
      })
    : e;
}
function tU(n) {
  return Object.fromEntries(Object.entries(n).filter(([, e]) => e != null));
}
const nU = 2147483647;
let k4 = 0,
  Zs = {},
  xr,
  mm;
function iU({
  recordClsStandaloneSpans: n,
  recordLcpStandaloneSpans: e,
  client: t,
}) {
  const i = cp();
  if (i && ts()) {
    i.mark && Tt.performance.mark("sentry-tracing-init");
    const r = e ? qO(t) : lU(),
      s = cU(),
      o = n ? JO(t) : aU();
    return () => {
      (r?.(), s(), o?.());
    };
  }
  return () => {};
}
function rU() {
  qh("longtask", ({ entries: n }) => {
    const e = ns();
    if (!e) return;
    const { op: t, start_timestamp: i } = cn(e);
    for (const r of n) {
      const s = Kn(ts() + r.startTime),
        o = Kn(r.duration);
      (t === "navigation" && i && s < i) ||
        Nl(e, s, s + o, {
          name: "Main UI thread blocked",
          op: "ui.long-task",
          attributes: { [pi]: "auto.ui.browser.metrics" },
        });
    }
  });
}
function sU() {
  new PerformanceObserver((e) => {
    const t = ns();
    if (t)
      for (const i of e.getEntries()) {
        if (!i.scripts[0]) continue;
        const r = Kn(ts() + i.startTime),
          { start_timestamp: s, op: o } = cn(t);
        if (o === "navigation" && s && r < s) continue;
        const a = Kn(i.duration),
          l = { [pi]: "auto.ui.browser.metrics" },
          c = i.scripts[0],
          {
            invoker: u,
            invokerType: h,
            sourceURL: d,
            sourceFunctionName: f,
            sourceCharPosition: g,
          } = c;
        ((l["browser.script.invoker"] = u),
          (l["browser.script.invoker_type"] = h),
          d && (l["code.filepath"] = d),
          f && (l["code.function"] = f),
          g !== -1 && (l["browser.script.source_char_position"] = g),
          Nl(t, r, r + a, {
            name: "Main UI thread blocked",
            op: "ui.long-animation-frame",
            attributes: l,
          }));
      }
  }).observe({ type: "long-animation-frame", buffered: !0 });
}
function oU() {
  qh("event", ({ entries: n }) => {
    const e = ns();
    if (e) {
      for (const t of n)
        if (t.name === "click") {
          const i = Kn(ts() + t.startTime),
            r = Kn(t.duration),
            s = {
              name: Ms(t.target),
              op: `ui.interaction.${t.name}`,
              startTime: i,
              attributes: { [pi]: "auto.ui.browser.metrics" },
            },
            o = U7(t.target);
          (o && (s.attributes["ui.component_name"] = o), Nl(e, i, i + r, s));
        }
    }
  });
}
function aU() {
  return K8(({ metric: n }) => {
    const e = n.entries[n.entries.length - 1];
    e && ((Zs.cls = { value: n.value, unit: "" }), (mm = e));
  }, !0);
}
function lU() {
  return j8(({ metric: n }) => {
    const e = n.entries[n.entries.length - 1];
    e && ((Zs.lcp = { value: n.value, unit: "millisecond" }), (xr = e));
  }, !0);
}
function cU() {
  return WO(({ metric: n }) => {
    n.entries[n.entries.length - 1] &&
      (Zs.ttfb = { value: n.value, unit: "millisecond" });
  });
}
function uU(n, e) {
  const t = cp(),
    i = ts();
  if (!t?.getEntries || !i) return;
  const r = Kn(i),
    s = t.getEntries(),
    { op: o, start_timestamp: a } = cn(n);
  (s.slice(k4).forEach((l) => {
    const c = Kn(l.startTime),
      u = Kn(Math.max(0, l.duration));
    if (!(o === "navigation" && a && r + c < a))
      switch (l.entryType) {
        case "navigation": {
          gU(n, l, r);
          break;
        }
        case "mark":
        case "paint":
        case "measure": {
          dU(n, l, c, u, r, e.ignorePerformanceApiSpans);
          const h = op(),
            d = l.startTime < h.firstHiddenTime;
          (l.name === "first-paint" &&
            d &&
            (Zs.fp = { value: l.startTime, unit: "millisecond" }),
            l.name === "first-contentful-paint" &&
              d &&
              (Zs.fcp = { value: l.startTime, unit: "millisecond" }));
          break;
        }
        case "resource": {
          CU(n, l, l.name, c, u, r, e.ignoreResourceSpans);
          break;
        }
      }
  }),
    (k4 = Math.max(s.length - 1, 0)),
    IU(n),
    o === "pageload" &&
      (_U(Zs),
      e.recordClsOnPageloadSpan || delete Zs.cls,
      e.recordLcpOnPageloadSpan || delete Zs.lcp,
      Object.entries(Zs).forEach(([l, c]) => {
        eF(l, c.value, c.unit);
      }),
      n.setAttribute("performance.timeOrigin", r),
      n.setAttribute("performance.activationStart", Bd()),
      AU(n, e)),
    (xr = void 0),
    (mm = void 0),
    (Zs = {}));
}
function hU(n) {
  if (n?.entryType === "measure")
    try {
      return n.detail.devtools.track === "Components ";
    } catch {
      return;
    }
}
function dU(n, e, t, i, r, s) {
  if (hU(e) || (["mark", "measure"].includes(e.entryType) && xl(e.name, s)))
    return;
  const o = sp(!1),
    a = Kn(o ? o.requestStart : 0),
    l = r + Math.max(t, a),
    c = r + t,
    u = c + i,
    h = { [pi]: "auto.resource.browser.metrics" };
  (l !== c &&
    ((h["sentry.browser.measure_happened_before_request"] = !0),
    (h["sentry.browser.measure_start_time"] = l)),
    fU(h, e),
    l <= u && Nl(n, l, u, { name: e.name, op: e.entryType, attributes: h }));
}
function fU(n, e) {
  try {
    const t = e.detail;
    if (!t) return;
    if (typeof t == "object") {
      for (const [i, r] of Object.entries(t))
        if (r && Xh(r)) n[`sentry.browser.measure.detail.${i}`] = r;
        else if (r !== void 0)
          try {
            n[`sentry.browser.measure.detail.${i}`] = JSON.stringify(r);
          } catch {}
      return;
    }
    if (Xh(t)) {
      n["sentry.browser.measure.detail"] = t;
      return;
    }
    try {
      n["sentry.browser.measure.detail"] = JSON.stringify(t);
    } catch {}
  } catch {}
}
function gU(n, e, t) {
  ([
    "unloadEvent",
    "redirect",
    "domContentLoadedEvent",
    "loadEvent",
    "connect",
  ].forEach((i) => {
    Hp(n, e, i, t);
  }),
    Hp(n, e, "secureConnection", t, "TLS/SSL"),
    Hp(n, e, "fetch", t, "cache"),
    Hp(n, e, "domainLookup", t, "DNS"),
    mU(n, e, t));
}
function Hp(n, e, t, i, r = t) {
  const s = pU(t),
    o = e[s],
    a = e[`${t}Start`];
  !a ||
    !o ||
    Nl(n, i + Kn(a), i + Kn(o), {
      op: `browser.${r}`,
      name: e.name,
      attributes: {
        [pi]: "auto.ui.browser.metrics",
        ...(t === "redirect" && e.redirectCount != null
          ? { "http.redirect_count": e.redirectCount }
          : {}),
      },
    });
}
function pU(n) {
  return n === "secureConnection"
    ? "connectEnd"
    : n === "fetch"
      ? "domainLookupStart"
      : `${n}End`;
}
function mU(n, e, t) {
  const i = t + Kn(e.requestStart),
    r = t + Kn(e.responseEnd),
    s = t + Kn(e.responseStart);
  e.responseEnd &&
    (Nl(n, i, r, {
      op: "browser.request",
      name: e.name,
      attributes: { [pi]: "auto.ui.browser.metrics" },
    }),
    Nl(n, s, r, {
      op: "browser.response",
      name: e.name,
      attributes: { [pi]: "auto.ui.browser.metrics" },
    }));
}
function CU(n, e, t, i, r, s, o) {
  if (e.initiatorType === "xmlhttprequest" || e.initiatorType === "fetch")
    return;
  const a = e.initiatorType ? `resource.${e.initiatorType}` : "resource.other";
  if (o?.includes(a)) return;
  const l = { [pi]: "auto.resource.browser.metrics" },
    c = Jc(t);
  (c.protocol && (l["url.scheme"] = c.protocol.split(":").pop()),
    c.host && (l["server.address"] = c.host),
    (l["url.same_origin"] = t.includes(Tt.location.origin)),
    yU(e, l, [
      ["responseStatus", "http.response.status_code"],
      ["transferSize", "http.response_transfer_size"],
      ["encodedBodySize", "http.response_content_length"],
      ["decodedBodySize", "http.decoded_response_content_length"],
      ["renderBlockingStatus", "resource.render_blocking_status"],
      ["deliveryType", "http.response_delivery_type"],
    ]));
  const u = { ...l, ...eT(e) },
    h = s + i,
    d = h + r;
  Nl(n, h, d, {
    name: t.replace(Tt.location.origin, ""),
    op: a,
    attributes: u,
  });
}
function IU(n) {
  const e = Tt.navigator;
  if (!e) return;
  const t = e.connection;
  (t &&
    (t.effectiveType &&
      n.setAttribute("effectiveConnectionType", t.effectiveType),
    t.type && n.setAttribute("connectionType", t.type),
    OI(t.rtt) &&
      (Zs["connection.rtt"] = { value: t.rtt, unit: "millisecond" })),
    OI(e.deviceMemory) &&
      n.setAttribute("deviceMemory", `${e.deviceMemory} GB`),
    OI(e.hardwareConcurrency) &&
      n.setAttribute("hardwareConcurrency", String(e.hardwareConcurrency)));
}
function AU(n, e) {
  (xr &&
    e.recordLcpOnPageloadSpan &&
    (xr.element && n.setAttribute("lcp.element", Ms(xr.element)),
    xr.id && n.setAttribute("lcp.id", xr.id),
    xr.url && n.setAttribute("lcp.url", xr.url.trim().slice(0, 200)),
    xr.loadTime != null && n.setAttribute("lcp.loadTime", xr.loadTime),
    xr.renderTime != null && n.setAttribute("lcp.renderTime", xr.renderTime),
    n.setAttribute("lcp.size", xr.size)),
    mm?.sources &&
      e.recordClsOnPageloadSpan &&
      mm.sources.forEach((t, i) =>
        n.setAttribute(`cls.source.${i + 1}`, Ms(t.node)),
      ));
}
function yU(n, e, t) {
  t.forEach(([i, r]) => {
    const s = n[i];
    s != null &&
      ((typeof s == "number" && s < nU) || typeof s == "string") &&
      (e[r] = s);
  });
}
function _U(n) {
  const e = sp(!1);
  if (!e) return;
  const { responseStart: t, requestStart: i } = e;
  i <= t && (n["ttfb.requestTime"] = { value: t - i, unit: "millisecond" });
}
function bU() {
  return cp() && ts() ? qh("element", vU) : () => {};
}
const vU = ({ entries: n }) => {
    const e = ns(),
      t = e ? pr(e) : void 0,
      i = t ? cn(t).description : wn().getScopeData().transactionName;
    n.forEach((r) => {
      const s = r;
      if (!s.identifier) return;
      const o = s.name,
        a = s.renderTime,
        l = s.loadTime,
        [c, u] = l
          ? [Kn(l), "load-time"]
          : a
            ? [Kn(a), "render-time"]
            : [Bi(), "entry-emission"],
        h = o === "image-paint" ? Kn(Math.max(0, (a ?? 0) - (l ?? 0))) : 0,
        d = {
          [pi]: "auto.ui.browser.elementtiming",
          [Ba]: "ui.elementtiming",
          [_o]: "component",
          "sentry.span_start_time_source": u,
          "sentry.transaction_name": i,
          "element.id": s.id,
          "element.type": s.element?.tagName?.toLowerCase() || "unknown",
          "element.size":
            s.naturalWidth && s.naturalHeight
              ? `${s.naturalWidth}x${s.naturalHeight}`
              : void 0,
          "element.render_time": a,
          "element.load_time": l,
          "element.url": s.url || void 0,
          "element.identifier": s.identifier,
          "element.paint_type": o,
        };
      oF(
        {
          name: `element[${s.identifier}]`,
          attributes: d,
          startTime: c,
          onlyIfParent: !0,
        },
        (f) => {
          f.end(c + h);
        },
      );
    });
  },
  xU = 1e3;
let O4, by, vy;
function wU(n) {
  const e = "dom";
  (Wl(e, n), Vl(e, SU));
}
function SU() {
  if (!Tt.document) return;
  const n = xs.bind(null, "dom"),
    e = U4(n, !0);
  (Tt.document.addEventListener("click", e, !1),
    Tt.document.addEventListener("keypress", e, !1),
    ["EventTarget", "Node"].forEach((t) => {
      const r = Tt[t]?.prototype;
      r?.hasOwnProperty?.("addEventListener") &&
        (Zr(r, "addEventListener", function (s) {
          return function (o, a, l) {
            if (o === "click" || o == "keypress")
              try {
                const c = (this.__sentry_instrumentation_handlers__ =
                    this.__sentry_instrumentation_handlers__ || {}),
                  u = (c[o] = c[o] || { refCount: 0 });
                if (!u.handler) {
                  const h = U4(n);
                  ((u.handler = h), s.call(this, o, h, l));
                }
                u.refCount++;
              } catch {}
            return s.call(this, o, a, l);
          };
        }),
        Zr(r, "removeEventListener", function (s) {
          return function (o, a, l) {
            if (o === "click" || o == "keypress")
              try {
                const c = this.__sentry_instrumentation_handlers__ || {},
                  u = c[o];
                u &&
                  (u.refCount--,
                  u.refCount <= 0 &&
                    (s.call(this, o, u.handler, l),
                    (u.handler = void 0),
                    delete c[o]),
                  Object.keys(c).length === 0 &&
                    delete this.__sentry_instrumentation_handlers__);
              } catch {}
            return s.call(this, o, a, l);
          };
        }));
    }));
}
function TU(n) {
  if (n.type !== by) return !1;
  try {
    if (!n.target || n.target._sentryId !== vy) return !1;
  } catch {}
  return !0;
}
function EU(n, e) {
  return n !== "keypress"
    ? !1
    : e?.tagName
      ? !(
          e.tagName === "INPUT" ||
          e.tagName === "TEXTAREA" ||
          e.isContentEditable
        )
      : !0;
}
function U4(n, e = !1) {
  return (t) => {
    if (!t || t._sentryCaptured) return;
    const i = MU(t);
    if (EU(t.type, i)) return;
    (Qr(t, "_sentryCaptured", !0),
      i && !i._sentryId && Qr(i, "_sentryId", ws()));
    const r = t.type === "keypress" ? "input" : t.type;
    (TU(t) ||
      (n({ event: t, name: r, global: e }),
      (by = t.type),
      (vy = i ? i._sentryId : void 0)),
      clearTimeout(O4),
      (O4 = Tt.setTimeout(() => {
        ((vy = void 0), (by = void 0));
      }, xU)));
  };
}
function MU(n) {
  try {
    return n.target;
  } catch {
    return null;
  }
}
let Wp;
function Wb(n) {
  const e = "history";
  (Wl(e, n), Vl(e, LU));
}
function LU() {
  if (
    (Tt.addEventListener("popstate", () => {
      const e = Tt.location.href,
        t = Wp;
      if (((Wp = e), t === e)) return;
      xs("history", { from: t, to: e });
    }),
    !$k())
  )
    return;
  function n(e) {
    return function (...t) {
      const i = t.length > 2 ? t[2] : void 0;
      if (i) {
        const r = Wp,
          s = RU(String(i));
        if (((Wp = s), r === s)) return e.apply(this, t);
        xs("history", { from: r, to: s });
      }
      return e.apply(this, t);
    };
  }
  (Zr(Tt.history, "pushState", n), Zr(Tt.history, "replaceState", n));
}
function RU(n) {
  try {
    return new URL(n, Tt.location.origin).toString();
  } catch {
    return n;
  }
}
const d0 = {};
function BU(n) {
  const e = d0[n];
  if (e) return e;
  let t = Tt[n];
  if (my(t)) return (d0[n] = t.bind(Tt));
  const i = Tt.document;
  if (i && typeof i.createElement == "function")
    try {
      const r = i.createElement("iframe");
      ((r.hidden = !0), i.head.appendChild(r));
      const s = r.contentWindow;
      (s?.[n] && (t = s[n]), i.head.removeChild(r));
    } catch (r) {
      ip &&
        Se.warn(
          `Could not create sandbox iframe for ${n} check, bailing to window.${n}: `,
          r,
        );
    }
  return t && (d0[n] = t.bind(Tt));
}
function PU(n) {
  d0[n] = void 0;
}
const gh = "__sentry_xhr_v3__";
function tT(n) {
  const e = "xhr";
  (Wl(e, n), Vl(e, NU));
}
function NU() {
  if (!Tt.XMLHttpRequest) return;
  const n = XMLHttpRequest.prototype;
  ((n.open = new Proxy(n.open, {
    apply(e, t, i) {
      const r = new Error(),
        s = Bi() * 1e3,
        o = _a(i[0]) ? i[0].toUpperCase() : void 0,
        a = DU(i[1]);
      if (!o || !a) return e.apply(t, i);
      ((t[gh] = { method: o, url: a, request_headers: {} }),
        o === "POST" &&
          a.match(/sentry_key/) &&
          (t.__sentry_own_request__ = !0));
      const l = () => {
        const c = t[gh];
        if (c && t.readyState === 4) {
          try {
            c.status_code = t.status;
          } catch {}
          const u = {
            endTimestamp: Bi() * 1e3,
            startTimestamp: s,
            xhr: t,
            virtualError: r,
          };
          xs("xhr", u);
        }
      };
      return (
        "onreadystatechange" in t && typeof t.onreadystatechange == "function"
          ? (t.onreadystatechange = new Proxy(t.onreadystatechange, {
              apply(c, u, h) {
                return (l(), c.apply(u, h));
              },
            }))
          : t.addEventListener("readystatechange", l),
        (t.setRequestHeader = new Proxy(t.setRequestHeader, {
          apply(c, u, h) {
            const [d, f] = h,
              g = u[gh];
            return (
              g && _a(d) && _a(f) && (g.request_headers[d.toLowerCase()] = f),
              c.apply(u, h)
            );
          },
        })),
        e.apply(t, i)
      );
    },
  })),
    (n.send = new Proxy(n.send, {
      apply(e, t, i) {
        const r = t[gh];
        if (!r) return e.apply(t, i);
        i[0] !== void 0 && (r.body = i[0]);
        const s = { startTimestamp: Bi() * 1e3, xhr: t };
        return (xs("xhr", s), e.apply(t, i));
      },
    })));
}
function DU(n) {
  if (_a(n)) return n;
  try {
    return n.toString();
  } catch {}
}
function GU(n) {
  let e;
  try {
    e = n.getAllResponseHeaders();
  } catch (t) {
    return (ip && Se.error(t, "Failed to get xhr response headers", n), {});
  }
  return e
    ? e
        .split(
          `\r
`,
        )
        .reduce((t, i) => {
          const [r, s] = i.split(": ");
          return (s && (t[r.toLowerCase()] = s), t);
        }, {})
    : {};
}
const UI = [],
  f0 = new Map(),
  Pu = new Map(),
  FU = 60;
function kU() {
  if (cp() && ts()) {
    const e = OU();
    return () => {
      e();
    };
  }
  return () => {};
}
const xy = {
  click: "click",
  pointerdown: "click",
  pointerup: "click",
  mousedown: "click",
  mouseup: "click",
  touchstart: "click",
  touchend: "click",
  mouseover: "hover",
  mouseout: "hover",
  mouseenter: "hover",
  mouseleave: "hover",
  pointerover: "hover",
  pointerout: "hover",
  pointerenter: "hover",
  pointerleave: "hover",
  dragstart: "drag",
  dragend: "drag",
  drag: "drag",
  dragenter: "drag",
  dragleave: "drag",
  dragover: "drag",
  drop: "drag",
  keydown: "press",
  keyup: "press",
  keypress: "press",
  input: "press",
};
function OU() {
  return VO(UU);
}
const UU = ({ metric: n }) => {
  if (n.value == null) return;
  const e = Kn(n.value);
  if (e > FU) return;
  const t = n.entries.find((g) => g.duration === n.value && xy[g.name]);
  if (!t) return;
  const { interactionId: i } = t,
    r = xy[t.name],
    s = Kn(ts() + t.startTime),
    o = ns(),
    a = o ? pr(o) : void 0,
    l = i != null ? f0.get(i) : void 0,
    c = l?.span || a,
    u = c ? cn(c).description : wn().getScopeData().transactionName,
    h = l?.elementName || Ms(t.target),
    d = {
      [pi]: "auto.http.browser.inp",
      [Ba]: `ui.interaction.${r}`,
      [Md]: t.duration,
    },
    f = Hb({ name: h, transaction: u, attributes: d, startTime: s });
  f &&
    (f.addEvent("inp", { [tp]: "millisecond", [np]: n.value }), f.end(s + e));
};
function HU() {
  const n = Object.keys(xy);
  aO() &&
    n.forEach((r) => {
      Tt.addEventListener(r, e, { capture: !0, passive: !0 });
    });
  function e(r) {
    const s = r.target;
    if (!s) return;
    const o = Ms(s),
      a = Math.round(r.timeStamp);
    if ((Pu.set(a, o), Pu.size > 50)) {
      const l = Pu.keys().next().value;
      l !== void 0 && Pu.delete(l);
    }
  }
  function t(r) {
    const s = Math.round(r.startTime);
    let o = Pu.get(s);
    if (!o)
      for (let a = -5; a <= 5; a++) {
        const l = Pu.get(s + a);
        if (l) {
          o = l;
          break;
        }
      }
    return o || "<unknown>";
  }
  const i = ({ entries: r }) => {
    const s = ns(),
      o = s && pr(s);
    r.forEach((a) => {
      if (!jO(a)) return;
      const l = a.interactionId;
      if (l == null || f0.has(l)) return;
      const c = a.target ? Ms(a.target) : t(a);
      if (UI.length > 10) {
        const u = UI.shift();
        f0.delete(u);
      }
      (UI.push(l), f0.set(l, { span: o, elementName: c }));
    });
  };
  (qh("event", i), qh("first-input", i));
}
const WU = 40;
function VU(n, e = BU("fetch")) {
  let t = 0,
    i = 0;
  async function r(s) {
    const o = s.body.length;
    ((t += o), i++);
    const a = {
      body: s.body,
      method: "POST",
      referrerPolicy: "strict-origin",
      headers: n.headers,
      keepalive: t <= 6e4 && i < 15,
      ...n.fetchOptions,
    };
    try {
      const l = await e(n.url, a);
      return {
        statusCode: l.status,
        headers: {
          "x-sentry-rate-limits": l.headers.get("X-Sentry-Rate-Limits"),
          "retry-after": l.headers.get("Retry-After"),
        },
      };
    } catch (l) {
      throw (PU("fetch"), l);
    } finally {
      ((t -= o), i--);
    }
  }
  return ek(n, r, Bb(n.bufferSize || WU));
}
const Ls = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__,
  ZU = 30,
  zU = 50;
function wy(n, e, t, i) {
  const r = { filename: n, function: e === "<anonymous>" ? uu : e, in_app: !0 };
  return (t !== void 0 && (r.lineno = t), i !== void 0 && (r.colno = i), r);
}
const YU = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i,
  XU =
    /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
  KU = /\((\S*)(?::(\d+))(?::(\d+))\)/,
  jU = /at (.+?) ?\(data:(.+?),/,
  $U = (n) => {
    const e = n.match(jU);
    if (e) return { filename: `<data:${e[2]}>`, function: e[1] };
    const t = YU.exec(n);
    if (t) {
      const [, r, s, o] = t;
      return wy(r, uu, +s, +o);
    }
    const i = XU.exec(n);
    if (i) {
      if (i[2] && i[2].indexOf("eval") === 0) {
        const a = KU.exec(i[2]);
        a && ((i[2] = a[1]), (i[3] = a[2]), (i[4] = a[3]));
      }
      const [s, o] = nT(i[1] || uu, i[2]);
      return wy(o, s, i[3] ? +i[3] : void 0, i[4] ? +i[4] : void 0);
    }
  },
  JU = [ZU, $U],
  QU =
    /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i,
  qU = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i,
  eH = (n) => {
    const e = QU.exec(n);
    if (e) {
      if (e[3] && e[3].indexOf(" > eval") > -1) {
        const s = qU.exec(e[3]);
        s &&
          ((e[1] = e[1] || "eval"), (e[3] = s[1]), (e[4] = s[2]), (e[5] = ""));
      }
      let i = e[3],
        r = e[1] || uu;
      return (
        ([r, i] = nT(r, i)),
        wy(i, r, e[4] ? +e[4] : void 0, e[5] ? +e[5] : void 0)
      );
    }
  },
  tH = [zU, eH],
  nH = [JU, tH],
  iH = B7(...nH),
  nT = (n, e) => {
    const t = n.indexOf("safari-extension") !== -1,
      i = n.indexOf("safari-web-extension") !== -1;
    return t || i
      ? [
          n.indexOf("@") !== -1 ? n.split("@")[0] : uu,
          t ? `safari-extension:${e}` : `safari-web-extension:${e}`,
        ]
      : [n, e];
  },
  Vp = 1024,
  rH = "Breadcrumbs",
  sH = (n = {}) => {
    const e = {
      console: !0,
      dom: !0,
      fetch: !0,
      history: !0,
      sentry: !0,
      xhr: !0,
      ...n,
    };
    return {
      name: rH,
      setup(t) {
        (e.console && Nk(cH(t)),
          e.dom && wU(lH(t, e.dom)),
          e.xhr && tT(uH(t)),
          e.fetch && N8(hH(t)),
          e.history && Wb(dH(t)),
          e.sentry && t.on("beforeSendEvent", aH(t)));
      },
    };
  },
  oH = sH;
function aH(n) {
  return function (t) {
    yn() === n &&
      hu(
        {
          category: `sentry.${t.type === "transaction" ? "transaction" : "event"}`,
          event_id: t.event_id,
          level: t.level,
          message: Dc(t),
        },
        { event: t },
      );
  };
}
function lH(n, e) {
  return function (i) {
    if (yn() !== n) return;
    let r,
      s,
      o = typeof e == "object" ? e.serializeAttribute : void 0,
      a =
        typeof e == "object" && typeof e.maxStringLength == "number"
          ? e.maxStringLength
          : void 0;
    (a &&
      a > Vp &&
      (Ls &&
        Se.warn(
          `\`dom.maxStringLength\` cannot exceed ${Vp}, but a value of ${a} was configured. Sentry will use ${Vp} instead.`,
        ),
      (a = Vp)),
      typeof o == "string" && (o = [o]));
    try {
      const c = i.event,
        u = fH(c) ? c.target : c;
      ((r = Ms(u, { keyAttrs: o, maxStringLength: a })), (s = U7(u)));
    } catch {
      r = "<unknown>";
    }
    if (r.length === 0) return;
    const l = { category: `ui.${i.name}`, message: r };
    (s && (l.data = { "ui.component_name": s }),
      hu(l, { event: i.event, name: i.name, global: i.global }));
  };
}
function cH(n) {
  return function (t) {
    if (yn() !== n) return;
    const i = {
      category: "console",
      data: { arguments: t.args, logger: "console" },
      level: Gk(t.level),
      message: Q5(t.args, " "),
    };
    if (t.level === "assert")
      if (t.args[0] === !1)
        ((i.message = `Assertion failed: ${Q5(t.args.slice(1), " ") || "console.assert"}`),
          (i.data.arguments = t.args.slice(1)));
      else return;
    hu(i, { input: t.args, level: t.level });
  };
}
function uH(n) {
  return function (t) {
    if (yn() !== n) return;
    const { startTimestamp: i, endTimestamp: r } = t,
      s = t.xhr[gh];
    if (!i || !r || !s) return;
    const { method: o, url: a, status_code: l, body: c } = s,
      u = { method: o, url: a, status_code: l },
      h = { xhr: t.xhr, input: c, startTimestamp: i, endTimestamp: r },
      d = { category: "xhr", data: u, type: "http", level: P8(l) };
    (n.emit("beforeOutgoingRequestBreadcrumb", d, h), hu(d, h));
  };
}
function hH(n) {
  return function (t) {
    if (yn() !== n) return;
    const { startTimestamp: i, endTimestamp: r } = t;
    if (
      r &&
      !(t.fetchData.url.match(/sentry_key/) && t.fetchData.method === "POST")
    )
      if ((t.fetchData.method, t.fetchData.url, t.error)) {
        const s = t.fetchData,
          o = {
            data: t.error,
            input: t.args,
            startTimestamp: i,
            endTimestamp: r,
          },
          a = { category: "fetch", data: s, level: "error", type: "http" };
        (n.emit("beforeOutgoingRequestBreadcrumb", a, o), hu(a, o));
      } else {
        const s = t.response,
          o = { ...t.fetchData, status_code: s?.status };
        (t.fetchData.request_body_size,
          t.fetchData.response_body_size,
          s?.status);
        const a = {
            input: t.args,
            response: s,
            startTimestamp: i,
            endTimestamp: r,
          },
          l = {
            category: "fetch",
            data: o,
            type: "http",
            level: P8(o.status_code),
          };
        (n.emit("beforeOutgoingRequestBreadcrumb", l, a), hu(l, a));
      }
  };
}
function dH(n) {
  return function (t) {
    if (yn() !== n) return;
    let i = t.from,
      r = t.to;
    const s = Jc(en.location.href);
    let o = i ? Jc(i) : void 0;
    const a = Jc(r);
    (o?.path || (o = s),
      s.protocol === a.protocol && s.host === a.host && (r = a.relative),
      s.protocol === o.protocol && s.host === o.host && (i = o.relative),
      hu({ category: "navigation", data: { from: i, to: r } }));
  };
}
function fH(n) {
  return !!n && !!n.target;
}
const gH = [
    "EventTarget",
    "Window",
    "Node",
    "ApplicationCache",
    "AudioTrackList",
    "BroadcastChannel",
    "ChannelMergerNode",
    "CryptoOperation",
    "EventSource",
    "FileReader",
    "HTMLUnknownElement",
    "IDBDatabase",
    "IDBRequest",
    "IDBTransaction",
    "KeyOperation",
    "MediaController",
    "MessagePort",
    "ModalWindow",
    "Notification",
    "SVGElementInstance",
    "Screen",
    "SharedWorker",
    "TextTrack",
    "TextTrackCue",
    "TextTrackList",
    "WebSocket",
    "WebSocketWorker",
    "Worker",
    "XMLHttpRequest",
    "XMLHttpRequestEventTarget",
    "XMLHttpRequestUpload",
  ],
  pH = "BrowserApiErrors",
  mH = (n = {}) => {
    const e = {
      XMLHttpRequest: !0,
      eventTarget: !0,
      requestAnimationFrame: !0,
      setInterval: !0,
      setTimeout: !0,
      unregisterOriginalCallbacks: !1,
      ...n,
    };
    return {
      name: pH,
      setupOnce() {
        (e.setTimeout && Zr(en, "setTimeout", H4),
          e.setInterval && Zr(en, "setInterval", H4),
          e.requestAnimationFrame && Zr(en, "requestAnimationFrame", IH),
          e.XMLHttpRequest &&
            "XMLHttpRequest" in en &&
            Zr(XMLHttpRequest.prototype, "send", AH));
        const t = e.eventTarget;
        t && (Array.isArray(t) ? t : gH).forEach((r) => yH(r, e));
      },
    };
  },
  CH = mH;
function H4(n) {
  return function (...e) {
    const t = e[0];
    return (
      (e[0] = Qh(t, {
        mechanism: {
          handled: !1,
          type: `auto.browser.browserapierrors.${Ma(n)}`,
        },
      })),
      n.apply(this, e)
    );
  };
}
function IH(n) {
  return function (e) {
    return n.apply(this, [
      Qh(e, {
        mechanism: {
          data: { handler: Ma(n) },
          handled: !1,
          type: "auto.browser.browserapierrors.requestAnimationFrame",
        },
      }),
    ]);
  };
}
function AH(n) {
  return function (...e) {
    const t = this;
    return (
      ["onload", "onerror", "onprogress", "onreadystatechange"].forEach((r) => {
        r in t &&
          typeof t[r] == "function" &&
          Zr(t, r, function (s) {
            const o = {
                mechanism: {
                  data: { handler: Ma(s) },
                  handled: !1,
                  type: `auto.browser.browserapierrors.xhr.${r}`,
                },
              },
              a = _b(s);
            return (a && (o.mechanism.data.handler = Ma(a)), Qh(s, o));
          });
      }),
      n.apply(this, e)
    );
  };
}
function yH(n, e) {
  const i = en[n]?.prototype;
  i?.hasOwnProperty?.("addEventListener") &&
    (Zr(i, "addEventListener", function (r) {
      return function (s, o, a) {
        try {
          _H(o) &&
            (o.handleEvent = Qh(o.handleEvent, {
              mechanism: {
                data: { handler: Ma(o), target: n },
                handled: !1,
                type: "auto.browser.browserapierrors.handleEvent",
              },
            }));
        } catch {}
        return (
          e.unregisterOriginalCallbacks && bH(this, s, o),
          r.apply(this, [
            s,
            Qh(o, {
              mechanism: {
                data: { handler: Ma(o), target: n },
                handled: !1,
                type: "auto.browser.browserapierrors.addEventListener",
              },
            }),
            a,
          ])
        );
      };
    }),
    Zr(i, "removeEventListener", function (r) {
      return function (s, o, a) {
        try {
          const l = o.__sentry_wrapped__;
          l && r.call(this, s, l, a);
        } catch {}
        return r.call(this, s, o, a);
      };
    }));
}
function _H(n) {
  return typeof n.handleEvent == "function";
}
function bH(n, e, t) {
  n &&
    typeof n == "object" &&
    "removeEventListener" in n &&
    typeof n.removeEventListener == "function" &&
    n.removeEventListener(e, t);
}
const vH = () => ({
    name: "BrowserSession",
    setupOnce() {
      if (typeof en.document > "u") {
        Ls &&
          Se.warn(
            "Using the `browserSessionIntegration` in non-browser environments is not supported.",
          );
        return;
      }
      (y4({ ignoreDuration: !0 }),
        _4(),
        Wb(({ from: n, to: e }) => {
          n !== void 0 && n !== e && (y4({ ignoreDuration: !0 }), _4());
        }));
    },
  }),
  xH = "GlobalHandlers",
  wH = (n = {}) => {
    const e = { onerror: !0, onunhandledrejection: !0, ...n };
    return {
      name: xH,
      setupOnce() {
        Error.stackTraceLimit = 50;
      },
      setup(t) {
        (e.onerror && (TH(t), W4("onerror")),
          e.onunhandledrejection && (EH(t), W4("onunhandledrejection")));
      },
    };
  },
  SH = wH;
function TH(n) {
  N7((e) => {
    const { stackParser: t, attachStacktrace: i } = iT();
    if (yn() !== n || G8()) return;
    const { msg: r, url: s, line: o, column: a, error: l } = e,
      c = RH(Fb(t, l || r, void 0, i, !1), s, o, a);
    ((c.level = "error"),
      g8(c, {
        originalException: l,
        mechanism: {
          handled: !1,
          type: "auto.browser.global_handlers.onerror",
        },
      }));
  });
}
function EH(n) {
  D7((e) => {
    const { stackParser: t, attachStacktrace: i } = iT();
    if (yn() !== n || G8()) return;
    const r = MH(e),
      s = Xh(r) ? LH(r) : Fb(t, r, void 0, i, !0);
    ((s.level = "error"),
      g8(s, {
        originalException: r,
        mechanism: {
          handled: !1,
          type: "auto.browser.global_handlers.onunhandledrejection",
        },
      }));
  });
}
function MH(n) {
  if (Xh(n)) return n;
  try {
    if ("reason" in n) return n.reason;
    if ("detail" in n && "reason" in n.detail) return n.detail.reason;
  } catch {}
  return n;
}
function LH(n) {
  return {
    exception: {
      values: [
        {
          type: "UnhandledRejection",
          value: `Non-Error promise rejection captured with value: ${String(n)}`,
        },
      ],
    },
  };
}
function RH(n, e, t, i) {
  const r = (n.exception = n.exception || {}),
    s = (r.values = r.values || []),
    o = (s[0] = s[0] || {}),
    a = (o.stacktrace = o.stacktrace || {}),
    l = (a.frames = a.frames || []),
    c = i,
    u = t,
    h = BH(e) ?? qg();
  return (
    l.length === 0 &&
      l.push({ colno: c, filename: h, function: uu, in_app: !0, lineno: u }),
    n
  );
}
function W4(n) {
  Ls && Se.log(`Global Handler attached: ${n}`);
}
function iT() {
  return yn()?.getOptions() || { stackParser: () => [], attachStacktrace: !1 };
}
function BH(n) {
  if (!(!_a(n) || n.length === 0)) {
    if (n.startsWith("data:")) {
      const e = n.match(/^data:([^;]+)/),
        t = e ? e[1] : "text/javascript",
        i = n.includes("base64,");
      return `<data:${t}${i ? ",base64" : ""}>`;
    }
    return n;
  }
}
const PH = () => ({
    name: "HttpContext",
    preprocessEvent(n) {
      if (!en.navigator && !en.location && !en.document) return;
      const e = Nb(),
        t = { ...e.headers, ...n.request?.headers };
      n.request = { ...e, ...n.request, headers: t };
    },
  }),
  NH = "cause",
  DH = 5,
  GH = "LinkedErrors",
  FH = (n = {}) => {
    const e = n.limit || DH,
      t = n.key || NH;
    return {
      name: GH,
      preprocessEvent(i, r, s) {
        const o = s.getOptions();
        Pk(Db, o.stackParser, t, e, i, r);
      },
    };
  },
  kH = FH;
function OH() {
  return UH()
    ? (Ls &&
        wd(() => {
          console.error(
            "[Sentry] You cannot use Sentry.init() in a browser extension, see: https://docs.sentry.io/platforms/javascript/best-practices/browser-extensions/",
          );
        }),
      !0)
    : !1;
}
function UH() {
  if (typeof en.window > "u") return !1;
  const n = en;
  if (n.nw || !(n.chrome || n.browser)?.runtime?.id) return !1;
  const t = qg(),
    i = [
      "chrome-extension",
      "moz-extension",
      "ms-browser-extension",
      "safari-web-extension",
    ];
  return !(en === en.top && i.some((s) => t.startsWith(`${s}://`)));
}
function rT(n) {
  return [wk(), _k(), CH(), oH(), SH(), kH(), Ok(), PH(), vH()];
}
function HH(n = {}) {
  const e = !n.skipBrowserExtensionCheck && OH();
  let t = n.defaultIntegrations == null ? rT() : n.defaultIntegrations;
  const i = {
    ...n,
    enabled: e ? !1 : n.enabled,
    stackParser: LD(n.stackParser || iH),
    integrations: HF({ integrations: n.integrations, defaultIntegrations: t }),
    transport: n.transport || VU,
  };
  return uk(_O, i);
}
function WH(n) {
  return n.split(",").some((e) => e.trim().startsWith("sentry-"));
}
function sT(n) {
  try {
    return new URL(n, en.location.origin).href;
  } catch {
    return;
  }
}
function VH(n) {
  return (
    n.entryType === "resource" &&
    "initiatorType" in n &&
    typeof n.nextHopProtocol == "string" &&
    (n.initiatorType === "fetch" || n.initiatorType === "xmlhttprequest")
  );
}
function oT(n) {
  try {
    return new Headers(n);
  } catch {
    return;
  }
}
const V4 = new WeakMap(),
  HI = new Map(),
  aT = {
    traceFetch: !0,
    traceXHR: !0,
    enableHTTPTimings: !0,
    trackFetchStreamPerformance: !1,
  };
function ZH(n, e) {
  const {
      traceFetch: t,
      traceXHR: i,
      trackFetchStreamPerformance: r,
      shouldCreateSpanForRequest: s,
      enableHTTPTimings: o,
      tracePropagationTargets: a,
      onRequestSpanStart: l,
      onRequestSpanEnd: c,
    } = { ...aT, ...e },
    u = typeof s == "function" ? s : (g) => !0,
    h = (g) => zH(g, a),
    d = {},
    f = n.getOptions().propagateTraceparent;
  (t &&
    (n.addEventProcessor(
      (g) => (
        g.type === "transaction" &&
          g.spans &&
          g.spans.forEach((p) => {
            if (p.op === "http.client") {
              const m = HI.get(p.span_id);
              m && ((p.timestamp = m / 1e3), HI.delete(p.span_id));
            }
          }),
        g
      ),
    ),
    r &&
      qk((g) => {
        if (g.response) {
          const p = V4.get(g.response);
          p && g.endTimestamp && HI.set(p, g.endTimestamp);
        }
      }),
    N8((g) => {
      const p = Vk(g, u, h, d, {
        propagateTraceparent: f,
        onRequestSpanEnd: c,
      });
      if (
        (g.response &&
          g.fetchData.__span &&
          V4.set(g.response, g.fetchData.__span),
        p)
      ) {
        const m = sT(g.fetchData.url),
          C = m ? Jc(m).host : void 0;
        (p.setAttributes({ "http.url": m, "server.address": C }),
          o && Z4(p),
          l?.(p, { headers: g.headers }));
      }
    })),
    i &&
      tT((g) => {
        const p = YH(g, u, h, d, f, c);
        p &&
          (o && Z4(p),
          l?.(p, { headers: oT(g.xhr.__sentry_xhr_v3__?.request_headers) }));
      }));
}
function Z4(n) {
  const { url: e } = cn(n).data;
  if (!e || typeof e != "string") return;
  const t = qh("resource", ({ entries: i }) => {
    i.forEach((r) => {
      VH(r) && r.name.endsWith(e) && (n.setAttributes(eT(r)), setTimeout(t));
    });
  });
}
function zH(n, e) {
  const t = qg();
  if (t) {
    let i, r;
    try {
      ((i = new URL(n, t)), (r = new URL(t).origin));
    } catch {
      return !1;
    }
    const s = i.origin === r;
    return e ? xl(i.toString(), e) || (s && xl(i.pathname, e)) : s;
  } else {
    const i = !!n.match(/^\/(?!\/)/);
    return e ? xl(n, e) : i;
  }
}
function YH(n, e, t, i, r, s) {
  const o = n.xhr,
    a = o?.[gh];
  if (!o || o.__sentry_own_request__ || !a) return;
  const { url: l, method: c } = a,
    u = $s() && e(l);
  if (n.endTimestamp && u) {
    const C = o.__sentry_xhr_span_id__;
    if (!C) return;
    const A = i[C];
    A &&
      a.status_code !== void 0 &&
      (Y7(A, a.status_code),
      A.end(),
      s?.(A, { headers: oT(GU(o)), error: n.error }),
      delete i[C]);
    return;
  }
  const h = sT(l),
    d = Jc(h || l),
    f = gk(l),
    g = !!ns(),
    p =
      u && g
        ? Rd({
            name: `${c} ${f}`,
            attributes: {
              url: l,
              type: "xhr",
              "http.method": c,
              "http.url": h,
              "server.address": d?.host,
              [pi]: "auto.http.browser",
              [Ba]: "http.client",
              ...(d?.search && { "http.query": d?.search }),
              ...(d?.hash && { "http.fragment": d?.hash }),
            },
          })
        : new Pl();
  ((o.__sentry_xhr_span_id__ = p.spanContext().spanId),
    (i[o.__sentry_xhr_span_id__] = p),
    t(l) && XH(o, $s() && g ? p : void 0, r));
  const m = yn();
  return (m && m.emit("beforeOutgoingRequestSpan", p, n), p);
}
function XH(n, e, t) {
  const {
    "sentry-trace": i,
    baggage: r,
    traceparent: s,
  } = L8({ span: e, propagateTraceparent: t });
  i && KH(n, i, r, s);
}
function KH(n, e, t, i) {
  const r = n.__sentry_xhr_v3__?.request_headers;
  if (!(r?.["sentry-trace"] || !n.setRequestHeader))
    try {
      if (
        (n.setRequestHeader("sentry-trace", e),
        i && !r?.traceparent && n.setRequestHeader("traceparent", i),
        t)
      ) {
        const s = r?.baggage;
        (!s || !WH(s)) && n.setRequestHeader("baggage", t);
      }
    } catch {}
}
function jH() {
  en.document
    ? en.document.addEventListener("visibilitychange", () => {
        const n = ns();
        if (!n) return;
        const e = pr(n);
        if (en.document.hidden && e) {
          const t = "cancelled",
            { op: i, status: r } = cn(e);
          (Ls &&
            Se.log(
              `[Tracing] Transaction: ${t} -> since tab moved to the background, op: ${i}`,
            ),
            r || e.setStatus({ code: di, message: t }),
            e.setAttribute("sentry.cancellation_reason", "document.hidden"),
            e.end());
        }
      })
    : Ls &&
      Se.warn(
        "[Tracing] Could not set up background tab detection due to lack of global document",
      );
}
const $H = 3600,
  lT = "sentry_previous_trace",
  JH = "sentry.previous_trace";
function QH(n, { linkPreviousTrace: e, consistentTraceSampling: t }) {
  const i = e === "session-storage";
  let r = i ? tW() : void 0;
  n.on("spanStart", (o) => {
    if (pr(o) !== o) return;
    const a = wn().getPropagationContext();
    ((r = qH(r, o, a)), i && eW(r));
  });
  let s = !0;
  t &&
    n.on("beforeSampling", (o) => {
      if (!r) return;
      const a = wn(),
        l = a.getPropagationContext();
      if (s && l.parentSpanId) {
        s = !1;
        return;
      }
      (a.setPropagationContext({
        ...l,
        dsc: {
          ...l.dsc,
          sample_rate: String(r.sampleRate),
          sampled: String(Sy(r.spanContext)),
        },
        sampleRand: r.sampleRand,
      }),
        (o.parentSampled = Sy(r.spanContext)),
        (o.parentSampleRate = r.sampleRate),
        (o.spanAttributes = { ...o.spanAttributes, [z7]: r.sampleRate }));
    });
}
function qH(n, e, t) {
  const i = cn(e);
  function r() {
    try {
      return Number(t.dsc?.sample_rate) ?? Number(i.data?.[bb]);
    } catch {
      return 0;
    }
  }
  const s = {
    spanContext: e.spanContext(),
    startTimestamp: i.start_timestamp,
    sampleRate: r(),
    sampleRand: t.sampleRand,
  };
  if (!n) return s;
  const o = n.spanContext;
  return o.traceId === i.trace_id
    ? n
    : (Date.now() / 1e3 - n.startTimestamp <= $H &&
        (Ls &&
          Se.log(
            `Adding previous_trace ${o} link to span ${{ op: i.op, ...e.spanContext() }}`,
          ),
        e.addLink({ context: o, attributes: { [rG]: "previous_trace" } }),
        e.setAttribute(JH, `${o.traceId}-${o.spanId}-${Sy(o) ? 1 : 0}`)),
      s);
}
function eW(n) {
  try {
    en.sessionStorage.setItem(lT, JSON.stringify(n));
  } catch (e) {
    Ls && Se.warn("Could not store previous trace in sessionStorage", e);
  }
}
function tW() {
  try {
    const n = en.sessionStorage?.getItem(lT);
    return JSON.parse(n);
  } catch {
    return;
  }
}
function Sy(n) {
  return n.traceFlags === 1;
}
const nW = "BrowserTracing",
  iW = {
    ...c0,
    instrumentNavigation: !0,
    instrumentPageLoad: !0,
    markBackgroundSpan: !0,
    enableLongTask: !0,
    enableLongAnimationFrame: !0,
    enableInp: !0,
    enableElementTiming: !0,
    ignoreResourceSpans: [],
    ignorePerformanceApiSpans: [],
    detectRedirects: !0,
    linkPreviousTrace: "in-memory",
    consistentTraceSampling: !1,
    enableReportPageLoaded: !1,
    _experiments: {},
    ...aT,
  },
  rW = (n = {}) => {
    const e = { name: void 0, source: void 0 },
      t = en.document,
      {
        enableInp: i,
        enableElementTiming: r,
        enableLongTask: s,
        enableLongAnimationFrame: o,
        _experiments: {
          enableInteractions: a,
          enableStandaloneClsSpans: l,
          enableStandaloneLcpSpans: c,
        },
        beforeStartSpan: u,
        idleTimeout: h,
        finalTimeout: d,
        childSpanTimeout: f,
        markBackgroundSpan: g,
        traceFetch: p,
        traceXHR: m,
        trackFetchStreamPerformance: C,
        shouldCreateSpanForRequest: A,
        enableHTTPTimings: I,
        ignoreResourceSpans: y,
        ignorePerformanceApiSpans: x,
        instrumentPageLoad: T,
        instrumentNavigation: S,
        detectRedirects: E,
        linkPreviousTrace: _,
        consistentTraceSampling: b,
        enableReportPageLoaded: R,
        onRequestSpanStart: M,
        onRequestSpanEnd: L,
      } = { ...iW, ...n };
    let P, U, O;
    function V(W, re, Z = !0) {
      const te = re.op === "pageload",
        ge = re.name,
        be = u ? u(re) : re,
        J = be.attributes || {};
      if ((ge !== be.name && ((J[_o] = "custom"), (be.attributes = J)), !Z)) {
        const ae = yu();
        Rd({ ...be, startTime: ae }).end(ae);
        return;
      }
      ((e.name = be.name), (e.source = J[_o]));
      const se = f8(be, {
        idleTimeout: h,
        finalTimeout: d,
        childSpanTimeout: f,
        disableAutoFinish: te,
        beforeSpanEnd: (ae) => {
          (P?.(),
            uU(ae, {
              recordClsOnPageloadSpan: !l,
              recordLcpOnPageloadSpan: !c,
              ignoreResourceSpans: y,
              ignorePerformanceApiSpans: x,
            }),
            Y4(W, void 0));
          const Ce = wn(),
            $e = Ce.getPropagationContext();
          (Ce.setPropagationContext({
            ...$e,
            traceId: se.spanContext().traceId,
            sampled: Zl(se),
            dsc: Bl(ae),
          }),
            te && (O = void 0));
        },
        trimIdleSpanEndTimestamp: !R,
      });
      (te && R && (O = se), Y4(W, se));
      function ce() {
        t &&
          ["interactive", "complete"].includes(t.readyState) &&
          W.emit("idleSpanEnableAutoFinish", se);
      }
      te &&
        !R &&
        t &&
        (t.addEventListener("readystatechange", () => {
          ce();
        }),
        ce());
    }
    return {
      name: nW,
      setup(W) {
        if (
          (PG(),
          (P = iU({
            recordClsStandaloneSpans: l || !1,
            recordLcpStandaloneSpans: c || !1,
            client: W,
          })),
          i && kU(),
          r && bU(),
          o &&
          sn.PerformanceObserver &&
          PerformanceObserver.supportedEntryTypes &&
          PerformanceObserver.supportedEntryTypes.includes(
            "long-animation-frame",
          )
            ? sU()
            : s && rU(),
          a && oU(),
          E && t)
        ) {
          const Z = () => {
            U = Bi();
          };
          (addEventListener("click", Z, { capture: !0 }),
            addEventListener("keydown", Z, { capture: !0, passive: !0 }));
        }
        function re() {
          const Z = _g(W);
          Z &&
            !cn(Z).timestamp &&
            (Ls &&
              Se.log(
                `[Tracing] Finishing current active span with op: ${cn(Z).op}`,
              ),
            Z.setAttribute(Cg, "cancelled"),
            Z.end());
        }
        (W.on("startNavigationSpan", (Z, te) => {
          if (yn() !== W) return;
          if (te?.isRedirect) {
            (Ls &&
              Se.warn(
                "[Tracing] Detected redirect, navigation span will not be the root span, but a child span.",
              ),
              V(W, { op: "navigation.redirect", ...Z }, !1));
            return;
          }
          ((U = void 0),
            re(),
            _u().setPropagationContext({
              traceId: Ra(),
              sampleRand: Math.random(),
              propagationSpanId: $s() ? void 0 : ba(),
            }));
          const ge = wn();
          (ge.setPropagationContext({
            traceId: Ra(),
            sampleRand: Math.random(),
            propagationSpanId: $s() ? void 0 : ba(),
          }),
            ge.setSDKProcessingMetadata({ normalizedRequest: void 0 }),
            V(W, {
              op: "navigation",
              ...Z,
              parentSpan: null,
              forceTransaction: !0,
            }));
        }),
          W.on("startPageLoadSpan", (Z, te = {}) => {
            if (yn() !== W) return;
            re();
            const ge = te.sentryTrace || z4("sentry-trace"),
              be = te.baggage || z4("baggage"),
              J = xG(ge, be),
              se = wn();
            (se.setPropagationContext(J),
              $s() || (se.getPropagationContext().propagationSpanId = ba()),
              se.setSDKProcessingMetadata({ normalizedRequest: Nb() }),
              V(W, { op: "pageload", ...Z }));
          }),
          W.on("endPageloadSpan", () => {
            R && O && (O.setAttribute(Cg, "reportPageLoaded"), O.end());
          }));
      },
      afterAllSetup(W) {
        let re = qg();
        if (
          (_ !== "off" &&
            QH(W, { linkPreviousTrace: _, consistentTraceSampling: b }),
          en.location)
        ) {
          if (T) {
            const Z = ts();
            sW(W, {
              name: en.location.pathname,
              startTime: Z ? Z / 1e3 : void 0,
              attributes: { [_o]: "url", [pi]: "auto.pageload.browser" },
            });
          }
          S &&
            Wb(({ to: Z, from: te }) => {
              if (te === void 0 && re?.indexOf(Z) !== -1) {
                re = void 0;
                return;
              }
              re = void 0;
              const ge = M8(Z),
                be = _g(W),
                J = be && E && lW(be, U);
              oW(
                W,
                {
                  name: ge?.pathname || en.location.pathname,
                  attributes: { [_o]: "url", [pi]: "auto.navigation.browser" },
                },
                { url: Z, isRedirect: J },
              );
            });
        }
        (g && jH(),
          a && aW(W, h, d, f, e),
          i && HU(),
          ZH(W, {
            traceFetch: p,
            traceXHR: m,
            trackFetchStreamPerformance: C,
            tracePropagationTargets: W.getOptions().tracePropagationTargets,
            shouldCreateSpanForRequest: A,
            enableHTTPTimings: I,
            onRequestSpanStart: M,
            onRequestSpanEnd: L,
          }));
      },
    };
  };
function sW(n, e, t) {
  (n.emit("startPageLoadSpan", e, t), wn().setTransactionName(e.name));
  const i = _g(n);
  return (i && n.emit("afterStartPageLoadSpan", i), i);
}
function oW(n, e, t) {
  const { url: i, isRedirect: r } = t || {};
  (n.emit("beforeStartNavigationSpan", e, { isRedirect: r }),
    n.emit("startNavigationSpan", e, { isRedirect: r }));
  const s = wn();
  return (
    s.setTransactionName(e.name),
    i &&
      !r &&
      s.setSDKProcessingMetadata({ normalizedRequest: { ...Nb(), url: i } }),
    _g(n)
  );
}
function z4(n) {
  return (
    en.document?.querySelector(`meta[name=${n}]`)?.getAttribute("content") ||
    void 0
  );
}
function aW(n, e, t, i, r) {
  const s = en.document;
  let o;
  const a = () => {
    const l = "ui.action.click",
      c = _g(n);
    if (c) {
      const u = cn(c).op;
      if (["navigation", "pageload"].includes(u)) {
        Ls &&
          Se.warn(
            `[Tracing] Did not create ${l} span because a pageload or navigation span is in progress.`,
          );
        return;
      }
    }
    if (
      (o &&
        (o.setAttribute(Cg, "interactionInterrupted"), o.end(), (o = void 0)),
      !r.name)
    ) {
      Ls &&
        Se.warn(
          `[Tracing] Did not create ${l} transaction because _latestRouteName is missing.`,
        );
      return;
    }
    o = f8(
      { name: r.name, op: l, attributes: { [_o]: r.source || "url" } },
      { idleTimeout: e, finalTimeout: t, childSpanTimeout: i },
    );
  };
  s && addEventListener("click", a, { capture: !0 });
}
const cT = "_sentry_idleSpan";
function _g(n) {
  return n[cT];
}
function Y4(n, e) {
  Qr(n, cT, e);
}
const X4 = 1.5;
function lW(n, e) {
  const t = cn(n),
    i = yu(),
    r = t.start_timestamp;
  return !(i - r > X4 || (e && i - e <= X4));
}
function cW(n) {
  const e = { ...n };
  return (Pb(e, "solid"), HH(e));
}
function uW(n) {
  const e = { defaultIntegrations: hW(), ...n };
  return (Pb(e, "solidstart", ["solidstart", "solid"]), cW(e));
}
function hW(n) {
  const e = rT();
  return (
    (typeof __SENTRY_TRACING__ > "u" || __SENTRY_TRACING__) && e.push(rW()),
    e
  );
}
const dW = "modulepreload",
  fW = function (n) {
    return "/" + n;
  },
  K4 = {},
  lr = function (e, t, i) {
    if (!t || t.length === 0) return e();
    const r = document.getElementsByTagName("link");
    return Promise.all(
      t.map((s) => {
        if (((s = fW(s)), s in K4)) return;
        K4[s] = !0;
        const o = s.endsWith(".css"),
          a = o ? '[rel="stylesheet"]' : "";
        if (!!i)
          for (let u = r.length - 1; u >= 0; u--) {
            const h = r[u];
            if (h.href === s && (!o || h.rel === "stylesheet")) return;
          }
        else if (document.querySelector(`link[href="${s}"]${a}`)) return;
        const c = document.createElement("link");
        if (
          ((c.rel = o ? "stylesheet" : dW),
          o || ((c.as = "script"), (c.crossOrigin = "")),
          (c.href = s),
          document.head.appendChild(c),
          o)
        )
          return new Promise((u, h) => {
            (c.addEventListener("load", u),
              c.addEventListener("error", () =>
                h(new Error(`Unable to preload CSS for ${s}`)),
              ));
          });
      }),
    )
      .then(() => e())
      .catch((s) => {
        const o = new Event("vite:preloadError", { cancelable: !0 });
        if (((o.payload = s), window.dispatchEvent(o), !o.defaultPrevented))
          throw s;
      });
  },
  Ty = Symbol("store-raw"),
  Th = Symbol("store-node"),
  ha = Symbol("store-has"),
  uT = Symbol("store-self");
function hT(n) {
  let e = n[to];
  if (
    !e &&
    (Object.defineProperty(n, to, { value: (e = new Proxy(n, mW)) }),
    !Array.isArray(n))
  ) {
    const t = Object.keys(n),
      i = Object.getOwnPropertyDescriptors(n);
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r];
      i[o].get &&
        Object.defineProperty(n, o, {
          enumerable: i[o].enumerable,
          get: i[o].get.bind(e),
        });
    }
  }
  return e;
}
function Dl(n) {
  let e;
  return (
    n != null &&
    typeof n == "object" &&
    (n[to] ||
      !(e = Object.getPrototypeOf(n)) ||
      e === Object.prototype ||
      Array.isArray(n))
  );
}
function du(n, e = new Set()) {
  let t, i, r, s;
  if ((t = n != null && n[Ty])) return t;
  if (!Dl(n) || e.has(n)) return n;
  if (Array.isArray(n)) {
    Object.isFrozen(n) ? (n = n.slice(0)) : e.add(n);
    for (let o = 0, a = n.length; o < a; o++)
      ((r = n[o]), (i = du(r, e)) !== r && (n[o] = i));
  } else {
    Object.isFrozen(n) ? (n = Object.assign({}, n)) : e.add(n);
    const o = Object.keys(n),
      a = Object.getOwnPropertyDescriptors(n);
    for (let l = 0, c = o.length; l < c; l++)
      ((s = o[l]),
        !a[s].get && ((r = n[s]), (i = du(r, e)) !== r && (n[s] = i)));
  }
  return n;
}
function Cm(n, e) {
  let t = n[e];
  return (
    t || Object.defineProperty(n, e, { value: (t = Object.create(null)) }),
    t
  );
}
function bg(n, e, t) {
  if (n[e]) return n[e];
  const [i, r] = Jt(t, { equals: !1, internal: !0 });
  return ((i.$ = r), (n[e] = i));
}
function gW(n, e) {
  const t = Reflect.getOwnPropertyDescriptor(n, e);
  return (
    !t ||
      t.get ||
      !t.configurable ||
      e === to ||
      e === Th ||
      (delete t.value, delete t.writable, (t.get = () => n[to][e])),
    t
  );
}
function dT(n) {
  ey() && bg(Cm(n, Th), uT)();
}
function pW(n) {
  return (dT(n), Reflect.ownKeys(n));
}
const mW = {
  get(n, e, t) {
    if (e === Ty) return n;
    if (e === to) return t;
    if (e === rm) return (dT(n), t);
    const i = Cm(n, Th),
      r = i[e];
    let s = r ? r() : n[e];
    if (e === Th || e === ha || e === "__proto__") return s;
    if (!r) {
      const o = Object.getOwnPropertyDescriptor(n, e);
      ey() &&
        (typeof s != "function" || n.hasOwnProperty(e)) &&
        !(o && o.get) &&
        (s = bg(i, e, s)());
    }
    return Dl(s) ? hT(s) : s;
  },
  has(n, e) {
    return e === Ty ||
      e === to ||
      e === rm ||
      e === Th ||
      e === ha ||
      e === "__proto__"
      ? !0
      : (ey() && bg(Cm(n, ha), e)(), e in n);
  },
  set() {
    return !0;
  },
  deleteProperty() {
    return !0;
  },
  ownKeys: pW,
  getOwnPropertyDescriptor: gW,
};
function gs(n, e, t, i = !1) {
  if (!i && n[e] === t) return;
  const r = n[e],
    s = n.length;
  t === void 0
    ? (delete n[e], n[ha] && n[ha][e] && r !== void 0 && n[ha][e].$())
    : ((n[e] = t), n[ha] && n[ha][e] && r === void 0 && n[ha][e].$());
  let o = Cm(n, Th),
    a;
  if (((a = bg(o, e, r)) && a.$(() => t), Array.isArray(n) && n.length !== s)) {
    for (let l = n.length; l < s; l++) (a = o[l]) && a.$();
    (a = bg(o, "length", s)) && a.$(n.length);
  }
  (a = o[uT]) && a.$();
}
function fT(n, e) {
  const t = Object.keys(e);
  for (let i = 0; i < t.length; i += 1) {
    const r = t[i];
    gs(n, r, e[r]);
  }
}
function CW(n, e) {
  if ((typeof e == "function" && (e = e(n)), (e = du(e)), Array.isArray(e))) {
    if (n === e) return;
    let t = 0,
      i = e.length;
    for (; t < i; t++) {
      const r = e[t];
      n[t] !== r && gs(n, t, r);
    }
    gs(n, "length", i);
  } else fT(n, e);
}
function Tf(n, e, t = []) {
  let i,
    r = n;
  if (e.length > 1) {
    i = e.shift();
    const o = typeof i,
      a = Array.isArray(n);
    if (Array.isArray(i)) {
      for (let l = 0; l < i.length; l++) Tf(n, [i[l]].concat(e), t);
      return;
    } else if (a && o === "function") {
      for (let l = 0; l < n.length; l++) i(n[l], l) && Tf(n, [l].concat(e), t);
      return;
    } else if (a && o === "object") {
      const { from: l = 0, to: c = n.length - 1, by: u = 1 } = i;
      for (let h = l; h <= c; h += u) Tf(n, [h].concat(e), t);
      return;
    } else if (e.length > 1) {
      Tf(n[i], e, [i].concat(t));
      return;
    }
    ((r = n[i]), (t = [i].concat(t)));
  }
  let s = e[0];
  (typeof s == "function" && ((s = s(r, t)), s === r)) ||
    (i === void 0 && s == null) ||
    ((s = du(s)),
    i === void 0 || (Dl(r) && Dl(s) && !Array.isArray(s))
      ? fT(r, s)
      : gs(n, i, s));
}
function IW(...[n, e]) {
  const t = du(n || {}),
    i = Array.isArray(t),
    r = hT(t);
  function s(...o) {
    qA(() => {
      i && o.length === 1 ? CW(t, o[0]) : Tf(t, o);
    });
  }
  return [r, s];
}
const Ey = Symbol("store-root");
function th(n, e, t, i, r) {
  const s = e[t];
  if (n === s) return;
  if (t !== Ey && (!Dl(n) || !Dl(s) || (r && n[r] !== s[r]))) {
    gs(e, t, n);
    return;
  }
  if (Array.isArray(n)) {
    if (n.length && s.length && (!i || (r && n[0] && n[0][r] != null))) {
      let l, c, u, h, d, f, g, p;
      for (
        u = 0, h = Math.min(s.length, n.length);
        u < h && (s[u] === n[u] || (r && s[u] && n[u] && s[u][r] === n[u][r]));
        u++
      )
        th(n[u], s, u, i, r);
      const m = new Array(n.length),
        C = new Map();
      for (
        h = s.length - 1, d = n.length - 1;
        h >= u &&
        d >= u &&
        (s[h] === n[d] || (r && s[u] && n[u] && s[h][r] === n[d][r]));
        h--, d--
      )
        m[d] = s[h];
      if (u > d || u > h) {
        for (c = u; c <= d; c++) gs(s, c, n[c]);
        for (; c < n.length; c++) (gs(s, c, m[c]), th(n[c], s, c, i, r));
        s.length > n.length && gs(s, "length", n.length);
        return;
      }
      for (g = new Array(d + 1), c = d; c >= u; c--)
        ((f = n[c]),
          (p = r && f ? f[r] : f),
          (l = C.get(p)),
          (g[c] = l === void 0 ? -1 : l),
          C.set(p, c));
      for (l = u; l <= h; l++)
        ((f = s[l]),
          (p = r && f ? f[r] : f),
          (c = C.get(p)),
          c !== void 0 && c !== -1 && ((m[c] = s[l]), (c = g[c]), C.set(p, c)));
      for (c = u; c < n.length; c++)
        c in m ? (gs(s, c, m[c]), th(n[c], s, c, i, r)) : gs(s, c, n[c]);
    } else for (let l = 0, c = n.length; l < c; l++) th(n[l], s, l, i, r);
    s.length > n.length && gs(s, "length", n.length);
    return;
  }
  const o = Object.keys(n);
  for (let l = 0, c = o.length; l < c; l++) th(n[o[l]], s, o[l], i, r);
  const a = Object.keys(s);
  for (let l = 0, c = a.length; l < c; l++)
    n[a[l]] === void 0 && gs(s, a[l], void 0);
}
function AW(n, e = {}) {
  const { merge: t, key: i = "id" } = e,
    r = du(n);
  return (s) => {
    if (!Dl(s) || !Dl(r)) return r;
    const o = th(r, { [Ey]: s }, Ey, t, i);
    return o === void 0 ? s : o;
  };
}
function yW(n, e) {
  n && e && _D(n, e);
}
const gT = Fa(),
  _W = ["title", "meta"],
  j4 = [],
  $4 = ["name", "http-equiv", "content", "charset", "media"].concat([
    "property",
  ]),
  J4 = (n, e) => {
    const t = Object.fromEntries(
      Object.entries(n.props)
        .filter(([i]) => e.includes(i))
        .sort(),
    );
    return (
      (Object.hasOwn(t, "name") || Object.hasOwn(t, "property")) &&
        ((t.name = t.name || t.property), delete t.property),
      n.tag + JSON.stringify(t)
    );
  };
function bW() {
  if (!Me.context) {
    const t = document.head.querySelectorAll("[data-sm]");
    Array.prototype.forEach.call(t, (i) => i.parentNode.removeChild(i));
  }
  const n = new Map();
  function e(t) {
    if (t.ref) return t.ref;
    let i = document.querySelector(`[data-sm="${t.id}"]`);
    return (
      i
        ? (i.tagName.toLowerCase() !== t.tag &&
            (i.parentNode && i.parentNode.removeChild(i),
            (i = document.createElement(t.tag))),
          i.removeAttribute("data-sm"))
        : (i = document.createElement(t.tag)),
      i
    );
  }
  return {
    addTag(t) {
      if (_W.indexOf(t.tag) !== -1) {
        const s = t.tag === "title" ? j4 : $4,
          o = J4(t, s);
        n.has(o) || n.set(o, []);
        let a = n.get(o),
          l = a.length;
        ((a = [...a, t]), n.set(o, a));
        let c = e(t);
        ((t.ref = c), fn(c, t.props));
        let u = null;
        for (var i = l - 1; i >= 0; i--)
          if (a[i] != null) {
            u = a[i];
            break;
          }
        return (
          c.parentNode != document.head && document.head.appendChild(c),
          u && u.ref && document.head.removeChild(u.ref),
          l
        );
      }
      let r = e(t);
      return (
        (t.ref = r),
        fn(r, t.props),
        r.parentNode != document.head && document.head.appendChild(r),
        -1
      );
    },
    removeTag(t, i) {
      const r = t.tag === "title" ? j4 : $4,
        s = J4(t, r);
      if (t.ref) {
        const o = n.get(s);
        if (o) {
          if (t.ref.parentNode) {
            t.ref.parentNode.removeChild(t.ref);
            for (let a = i - 1; a >= 0; a--)
              o[a] != null && document.head.appendChild(o[a].ref);
          }
          ((o[i] = null), n.set(s, o));
        } else t.ref.parentNode && t.ref.parentNode.removeChild(t.ref);
      }
    },
  };
}
const vW = (n) => {
    const e = bW();
    return G(gT.Provider, {
      value: e,
      get children() {
        return n.children;
      },
    });
  },
  Vb = (n, e, t) => (
    xW({
      tag: n,
      props: e,
      setting: t,
      id: jN(),
      get name() {
        return e.name || e.property;
      },
    }),
    null
  );
function xW(n) {
  const e = ro(gT);
  if (!e) throw new Error("<MetaProvider /> should be in the tree");
  vs(() => {
    const t = e.addTag(n);
    dn(() => e.removeTag(n, t));
  });
}
const wW = (n) => Vb("title", n, { escape: !0, close: !0 }),
  bi = (n) => Vb("meta", n),
  Q4 = (n) => Vb("link", n);
function pT() {
  let n = new Set();
  function e(r) {
    return (n.add(r), () => n.delete(r));
  }
  let t = !1;
  function i(r, s) {
    if (t) return !(t = !1);
    const o = {
      to: r,
      options: s,
      defaultPrevented: !1,
      preventDefault: () => (o.defaultPrevented = !0),
    };
    for (const a of n)
      a.listener({
        ...o,
        from: a.location,
        retry: (l) => {
          (l && (t = !0), a.navigate(r, s));
        },
      });
    return !o.defaultPrevented;
  }
  return { subscribe: e, confirm: i };
}
function SW(n, e, t) {
  return (n.addEventListener(e, t), () => n.removeEventListener(e, t));
}
function TW([n, e], t, i) {
  return [t ? () => t(n()) : n, i ? (r) => e(i(r)) : e];
}
function EW(n) {
  try {
    return document.querySelector(n);
  } catch {
    return null;
  }
}
function MW(n, e) {
  const t = EW(`#${n}`);
  t ? t.scrollIntoView() : e && window.scrollTo(0, 0);
}
function LW(n, e, t, i) {
  let r = !1;
  const s = (a) => (typeof a == "string" ? { value: a } : a),
    o = TW(
      Jt(s(n()), { equals: (a, l) => a.value === l.value }),
      void 0,
      (a) => (!r && e(a), a),
    );
  return (
    t &&
      dn(
        t((a = n()) => {
          ((r = !0), o[1](s(a)), (r = !1));
        }),
      ),
    { signal: o, utils: i }
  );
}
function RW(n) {
  if (n) {
    if (Array.isArray(n)) return { signal: n };
  } else return { signal: Jt({ value: "" }) };
  return n;
}
let My;
function Zb() {
  ((!window.history.state || window.history.state._depth == null) &&
    window.history.replaceState(
      { ...window.history.state, _depth: window.history.length - 1 },
      "",
    ),
    (My = window.history.state._depth));
}
Zb();
function BW(n, e) {
  let t = !1;
  return () => {
    const i = My;
    Zb();
    const r = i == null ? null : My - i;
    if (t) {
      t = !1;
      return;
    }
    r && e(r) ? ((t = !0), window.history.go(-r)) : n();
  };
}
function PW() {
  const n = () => ({
      value:
        window.location.pathname +
        window.location.search +
        window.location.hash,
      state: window.history.state,
    }),
    e = pT();
  return LW(
    n,
    ({ value: t, replace: i, scroll: r, state: s }) => {
      (i
        ? window.history.replaceState(s, "", t)
        : window.history.pushState(s, "", t),
        MW(window.location.hash.slice(1), r),
        Zb());
    },
    (t) =>
      SW(
        window,
        "popstate",
        BW(t, (i) => {
          if (i && i < 0) return !e.confirm(i);
          {
            const r = n();
            return !e.confirm(r.value, { state: r.state });
          }
        }),
      ),
    { go: (t) => window.history.go(t), beforeLeave: e },
  );
}
const NW = /^(?:[a-z0-9]+:)?\/\//i,
  DW = /^\/+|(\/)\/+$/g;
function qc(n, e = !1) {
  const t = n.replace(DW, "$1");
  return t ? (e || /^[?#]/.test(t) ? t : "/" + t) : "";
}
function g0(n, e, t) {
  if (NW.test(e)) return;
  const i = qc(n),
    r = t && qc(t);
  let s = "";
  return (
    !r || e.startsWith("/")
      ? (s = i)
      : r.toLowerCase().indexOf(i.toLowerCase()) !== 0
        ? (s = i + r)
        : (s = r),
    (s || "/") + qc(e, !s)
  );
}
function GW(n, e) {
  if (n == null) throw new Error(e);
  return n;
}
function mT(n, e) {
  return qc(n).replace(/\/*(\*.*)?$/g, "") + qc(e);
}
function FW(n) {
  const e = {};
  return (
    n.searchParams.forEach((t, i) => {
      e[i] = t;
    }),
    e
  );
}
function kW(n, e, t) {
  const [i, r] = n.split("/*", 2),
    s = i.split("/").filter(Boolean),
    o = s.length;
  return (a) => {
    const l = a.split("/").filter(Boolean),
      c = l.length - o;
    if (c < 0 || (c > 0 && r === void 0 && !e)) return null;
    const u = { path: o ? "" : "/", params: {} },
      h = (d) => (t === void 0 ? void 0 : t[d]);
    for (let d = 0; d < o; d++) {
      const f = s[d],
        g = l[d],
        p = f[0] === ":",
        m = p ? f.slice(1) : f;
      if (p && WI(g, h(m))) u.params[m] = g;
      else if (p || !WI(g, f)) return null;
      u.path += `/${g}`;
    }
    if (r) {
      const d = c ? l.slice(-c).join("/") : "";
      if (WI(d, h(r))) u.params[r] = d;
      else return null;
    }
    return u;
  };
}
function WI(n, e) {
  const t = (i) => i.localeCompare(n, void 0, { sensitivity: "base" }) === 0;
  return e === void 0
    ? !0
    : typeof e == "string"
      ? t(e)
      : typeof e == "function"
        ? e(n)
        : Array.isArray(e)
          ? e.some(t)
          : e instanceof RegExp
            ? e.test(n)
            : !1;
}
function OW(n) {
  const [e, t] = n.pattern.split("/*", 2),
    i = e.split("/").filter(Boolean);
  return i.reduce(
    (r, s) => r + (s.startsWith(":") ? 2 : 3),
    i.length - (t === void 0 ? 0 : 1),
  );
}
function CT(n) {
  const e = new Map(),
    t = C7();
  return new Proxy(
    {},
    {
      get(i, r) {
        return (
          e.has(r) ||
            FN(t, () =>
              e.set(
                r,
                pe(() => n()[r]),
              ),
            ),
          e.get(r)()
        );
      },
      getOwnPropertyDescriptor() {
        return { enumerable: !0, configurable: !0 };
      },
      ownKeys() {
        return Reflect.ownKeys(n());
      },
    },
  );
}
function IT(n) {
  let e = /(\/?\:[^\/]+)\?/.exec(n);
  if (!e) return [n];
  let t = n.slice(0, e.index),
    i = n.slice(e.index + e[0].length);
  const r = [t, (t += e[1])];
  for (; (e = /^(\/\:[^\/]+)\?/.exec(i)); )
    (r.push((t += e[1])), (i = i.slice(e[0].length)));
  return IT(i).reduce((s, o) => [...s, ...r.map((a) => a + o)], []);
}
const UW = 100,
  AT = Fa(),
  PC = Fa(),
  vu = () => GW(ro(AT), "Make sure your app is wrapped in a <Router />");
let vg;
const NC = () => vg || ro(PC) || vu().base,
  HW = (n) => {
    const e = NC();
    return pe(() => e.resolvePath(n()));
  },
  WW = (n) => {
    const e = vu();
    return pe(() => {
      const t = n();
      return t !== void 0 ? e.renderPath(t) : t;
    });
  },
  zb = () => vu().navigatorFactory(),
  DC = () => vu().location,
  VW = () => vu().isRouting,
  ZW = () => NC().data,
  zW = (n) => {
    const e = vu().beforeLeave.subscribe({
      listener: n,
      location: DC(),
      navigate: zb(),
    });
    dn(e);
  };
function YW(n, e = "", t) {
  const { component: i, data: r, children: s } = n,
    o = !s || (Array.isArray(s) && !s.length),
    a = {
      key: n,
      element: i
        ? () => G(i, {})
        : () => {
            const { element: l } = n;
            return l === void 0 && t ? G(t, {}) : l;
          },
      preload: n.component ? i.preload : n.preload,
      data: r,
    };
  return yT(n.path).reduce((l, c) => {
    for (const u of IT(c)) {
      const h = mT(e, u),
        d = o ? h : h.split("/*", 1)[0];
      l.push({
        ...a,
        originalPath: u,
        pattern: d,
        matcher: kW(d, !o, n.matchFilters),
      });
    }
    return l;
  }, []);
}
function XW(n, e = 0) {
  return {
    routes: n,
    score: OW(n[n.length - 1]) * 1e4 - e,
    matcher(t) {
      const i = [];
      for (let r = n.length - 1; r >= 0; r--) {
        const s = n[r],
          o = s.matcher(t);
        if (!o) return null;
        i.unshift({ ...o, route: s });
      }
      return i;
    },
  };
}
function yT(n) {
  return Array.isArray(n) ? n : [n];
}
function _T(n, e = "", t, i = [], r = []) {
  const s = yT(n);
  for (let o = 0, a = s.length; o < a; o++) {
    const l = s[o];
    if (l && typeof l == "object" && l.hasOwnProperty("path")) {
      const c = YW(l, e, t);
      for (const u of c) {
        i.push(u);
        const h = Array.isArray(l.children) && l.children.length === 0;
        if (l.children && !h) _T(l.children, u.pattern, t, i, r);
        else {
          const d = XW([...i], r.length);
          r.push(d);
        }
        i.pop();
      }
    }
  }
  return i.length ? r : r.sort((o, a) => a.score - o.score);
}
function KW(n, e) {
  for (let t = 0, i = n.length; t < i; t++) {
    const r = n[t].matcher(e);
    if (r) return r;
  }
  return [];
}
function jW(n, e) {
  const t = new URL("http://sar"),
    i = pe(
      (l) => {
        const c = n();
        try {
          return new URL(c, t);
        } catch {
          return (console.error(`Invalid path ${c}`), l);
        }
      },
      t,
      { equals: (l, c) => l.href === c.href },
    ),
    r = pe(() => i().pathname),
    s = pe(() => i().search, !0),
    o = pe(() => i().hash),
    a = pe(() => "");
  return {
    get pathname() {
      return r();
    },
    get search() {
      return s();
    },
    get hash() {
      return o();
    },
    get state() {
      return e();
    },
    get key() {
      return a();
    },
    query: CT(gr(s, () => FW(i()))),
  };
}
function $W(n, e = "", t, i) {
  const {
      signal: [r, s],
      utils: o = {},
    } = RW(n),
    a = o.parsePath || ((_) => _),
    l = o.renderPath || ((_) => _),
    c = o.beforeLeave || pT(),
    u = g0("", e),
    h = void 0;
  if (u === void 0) throw new Error(`${u} is not a valid base path`);
  u && !r().value && s({ value: u, replace: !0, scroll: !1 });
  const [d, f] = Jt(!1),
    g = async (_) => {
      f(!0);
      try {
        await pb(_);
      } finally {
        f(!1);
      }
    },
    [p, m] = Jt(r().value),
    [C, A] = Jt(r().state),
    I = jW(p, C),
    y = [],
    x = {
      pattern: u,
      params: {},
      path: () => u,
      outlet: () => null,
      resolvePath(_) {
        return g0(u, _);
      },
    };
  if (t)
    try {
      ((vg = x),
        (x.data = t({
          data: void 0,
          params: {},
          location: I,
          navigate: S(x),
        })));
    } finally {
      vg = void 0;
    }
  function T(_, b, R) {
    zt(() => {
      if (typeof b == "number") {
        b &&
          (o.go
            ? o.go(b)
            : console.warn(
                "Router integration does not support relative routing",
              ));
        return;
      }
      const {
          replace: M,
          resolve: L,
          scroll: P,
          state: U,
        } = { replace: !1, resolve: !0, scroll: !0, ...R },
        O = L ? _.resolvePath(b) : g0("", b);
      if (O === void 0) throw new Error(`Path '${b}' is not a routable path`);
      if (y.length >= UW) throw new Error("Too many redirects");
      const V = p();
      if ((O !== V || U !== C()) && !pg) {
        if (c.confirm(O, R)) {
          const W = y.push({ value: V, replace: M, scroll: P, state: C() });
          g(() => {
            (m(O), A(U), T7());
          }).then(() => {
            y.length === W && E({ value: O, state: U });
          });
        }
      }
    });
  }
  function S(_) {
    return ((_ = _ || ro(PC) || x), (b, R) => T(_, b, R));
  }
  function E(_) {
    const b = y[0];
    b &&
      ((_.value !== b.value || _.state !== b.state) &&
        s({ ..._, replace: b.replace, scroll: b.scroll }),
      (y.length = 0));
  }
  vs(() => {
    const { value: _, state: b } = r();
    zt(() => {
      _ !== p() &&
        g(() => {
          (m(_), A(b));
        });
    });
  });
  {
    let _ = function (b) {
      if (
        b.defaultPrevented ||
        b.button !== 0 ||
        b.metaKey ||
        b.altKey ||
        b.ctrlKey ||
        b.shiftKey
      )
        return;
      const R = b
        .composedPath()
        .find((V) => V instanceof Node && V.nodeName.toUpperCase() === "A");
      if (!R || !R.hasAttribute("link")) return;
      const M = R.href;
      if (R.target || (!M && !R.hasAttribute("state"))) return;
      const L = (R.getAttribute("rel") || "").split(/\s+/);
      if (R.hasAttribute("download") || (L && L.includes("external"))) return;
      const P = new URL(M);
      if (
        P.origin !== window.location.origin ||
        (u &&
          P.pathname &&
          !P.pathname.toLowerCase().startsWith(u.toLowerCase()))
      )
        return;
      const U = a(P.pathname + P.search + P.hash),
        O = R.getAttribute("state");
      (b.preventDefault(),
        T(x, U, {
          resolve: !1,
          replace: R.hasAttribute("replace"),
          scroll: !R.hasAttribute("noscroll"),
          state: O && JSON.parse(O),
        }));
    };
    (Qg(["click"]),
      document.addEventListener("click", _),
      dn(() => document.removeEventListener("click", _)));
  }
  return {
    base: x,
    out: h,
    location: I,
    isRouting: d,
    renderPath: l,
    parsePath: a,
    navigatorFactory: S,
    beforeLeave: c,
  };
}
function JW(n, e, t, i, r) {
  const { base: s, location: o, navigatorFactory: a } = n,
    { pattern: l, element: c, preload: u, data: h } = i().route,
    d = pe(() => i().path);
  u && u();
  const f = {
    parent: e,
    pattern: l,
    get child() {
      return t();
    },
    path: d,
    params: r,
    data: e.data,
    outlet: c,
    resolvePath(g) {
      return g0(s.path(), g, d());
    },
  };
  if (h)
    try {
      ((vg = f),
        (f.data = h({ data: e.data, params: r, location: o, navigate: a(f) })));
    } finally {
      vg = void 0;
    }
  return f;
}
const QW = xt("<a link>"),
  qW = (n) => {
    const { source: e, url: t, base: i, data: r, out: s } = n,
      o = e || PW(),
      a = $W(o, i, r);
    return G(AT.Provider, {
      value: a,
      get children() {
        return n.children;
      },
    });
  },
  eV = (n) => {
    const e = vu(),
      t = NC(),
      i = wC(() => n.children),
      r = pe(() => _T(i(), mT(t.pattern, n.base || ""), tV)),
      s = pe(() => KW(r(), e.location.pathname)),
      o = CT(() => {
        const u = s(),
          h = {};
        for (let d = 0; d < u.length; d++) Object.assign(h, u[d].params);
        return h;
      });
    e.out &&
      e.out.matches.push(
        s().map(({ route: u, path: h, params: d }) => ({
          originalPath: u.originalPath,
          pattern: u.pattern,
          path: h,
          params: d,
        })),
      );
    const a = [];
    let l;
    const c = pe(
      gr(s, (u, h, d) => {
        let f = h && u.length === h.length;
        const g = [];
        for (let p = 0, m = u.length; p < m; p++) {
          const C = h && h[p],
            A = u[p];
          d && C && A.route.key === C.route.key
            ? (g[p] = d[p])
            : ((f = !1),
              a[p] && a[p](),
              wh((I) => {
                ((a[p] = I),
                  (g[p] = JW(
                    e,
                    g[p - 1] || t,
                    () => c()[p + 1],
                    () => s()[p],
                    o,
                  )));
              }));
        }
        return (
          a.splice(u.length).forEach((p) => p()),
          d && f ? d : ((l = g[0]), g)
        );
      }),
    );
    return G(Hl, {
      get when() {
        return c() && l;
      },
      keyed: !0,
      children: (u) =>
        G(PC.Provider, {
          value: u,
          get children() {
            return u.outlet();
          },
        }),
    });
  },
  tV = () => {
    const n = NC();
    return G(Hl, {
      get when() {
        return n.child;
      },
      keyed: !0,
      children: (e) =>
        G(PC.Provider, {
          value: e,
          get children() {
            return e.outlet();
          },
        }),
    });
  };
function zr(n) {
  n = jn({ inactiveClass: "inactive", activeClass: "active" }, n);
  const [, e] = Dr(n, [
      "href",
      "state",
      "class",
      "activeClass",
      "inactiveClass",
      "end",
    ]),
    t = HW(() => n.href),
    i = WW(t),
    r = DC(),
    s = pe(() => {
      const o = t();
      if (o === void 0) return !1;
      const a = qc(o.split(/[?#]/, 1)[0]).toLowerCase(),
        l = qc(r.pathname).toLowerCase();
      return n.end ? a === l : l.startsWith(a);
    });
  return (() => {
    const o = ft(QW);
    return (
      fn(
        o,
        jn(e, {
          get href() {
            return i() || n.href;
          },
          get state() {
            return JSON.stringify(n.state);
          },
          get classList() {
            return {
              ...(n.class && { [n.class]: !0 }),
              [n.inactiveClass]: !s(),
              [n.activeClass]: s(),
              ...e.classList,
            };
          },
          get "aria-current"() {
            return s() ? "page" : void 0;
          },
        }),
        !1,
        !1,
      ),
      An(),
      o
    );
  })();
}
function nV(n) {
  const e = zb(),
    t = DC(),
    { href: i, state: r } = n,
    s = typeof i == "function" ? i({ navigate: e, location: t }) : i;
  return (e(s, { replace: !0, state: r }), null);
}
let iV = { data: "" },
  rV = (n) =>
    typeof window == "object"
      ? (
          (n ? n.querySelector("#_goober") : window._goober) ||
          Object.assign(
            (n || document.head).appendChild(document.createElement("style")),
            { innerHTML: " ", id: "_goober" },
          )
        ).firstChild
      : n || iV,
  sV = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g,
  oV = /\/\*[^]*?\*\/|  +/g,
  q4 = /\n+/g,
  ol = (n, e) => {
    let t = "",
      i = "",
      r = "";
    if (Array.isArray(n)) return n.reduce((s, o) => s + ol(o, e), "");
    for (let s in n) {
      let o = n[s];
      s[0] == "@"
        ? s[1] == "i"
          ? (t = s + " " + o + ";")
          : (i +=
              s[1] == "f"
                ? ol(o, s)
                : s + "{" + ol(o, s[1] == "k" ? "" : e) + "}")
        : typeof o == "object"
          ? (i += ol(
              o,
              e
                ? e.replace(/([^,])+/g, (a) =>
                    s.replace(/(^:.*)|([^,])+/g, (l) =>
                      /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l,
                    ),
                  )
                : s,
            ))
          : o != null &&
            ((s = /^--/.test(s) ? s : s.replace(/[A-Z]/g, "-$&").toLowerCase()),
            (r += ol.p ? ol.p(s, o) : s + ":" + o + ";"));
    }
    return t + (e && r ? e + "{" + r + "}" : r) + i;
  },
  jo = {},
  Ly = (n) => {
    if (Array.isArray(n)) return n.reduce((e, t) => e + Ly(t), "");
    if (typeof n == "object") {
      let e = "";
      for (let t in n) e += t + Ly(n[t]);
      return e;
    }
    return n;
  },
  aV = (n, e, t, i, r) => {
    let s = Ly(n),
      o =
        jo[s] ||
        (jo[s] = ((l) => {
          let c = 0,
            u = 11;
          for (; c < l.length; ) u = (101 * u + l.charCodeAt(c++)) >>> 0;
          return "go" + u;
        })(s));
    if (!jo[o]) {
      let l =
        s !== n
          ? n
          : ((c) => {
              let u,
                h,
                d = [{}];
              for (; (u = sV.exec(c.replace(oV, ""))); )
                u[4]
                  ? d.shift()
                  : u[3]
                    ? ((h = u[3].replace(q4, " ").trim()),
                      d.unshift((d[0][h] = d[0][h] || {})))
                    : (d[0][u[1]] = u[2].replace(q4, " ").trim());
              return d[0];
            })(n);
      jo[o] = ol(r ? { ["@keyframes " + o]: l } : l, t ? "" : "." + o);
    }
    let a = t && jo.g && typeof window < "u" ? jo.g : null;
    return (
      t && (jo.g = jo[o]),
      ((l, c, u, h) => {
        h
          ? (c.data = c.data.replace(h, l))
          : c.data.indexOf(l) === -1 && (c.data = u ? l + c.data : c.data + l);
      })(jo[o], e, i, a),
      o
    );
  },
  lV = (n, e, t) =>
    n.reduce((i, r, s) => {
      let o = e[s];
      if (o && o.call) {
        let a = o(t),
          l = (a && a.props && a.props.className) || (/^go/.test(a) && a);
        o = l
          ? "." + l
          : a && typeof a == "object"
            ? a.props
              ? ""
              : ol(a, "")
            : a === !1
              ? ""
              : a;
      }
      return i + r + (o ?? "");
    }, "");
function Yb(n) {
  let e = this || {},
    t = n.call ? n(e.p) : n;
  return aV(
    t.raw ? lV(t, [].slice.call(arguments, 1), e.p) : t,
    rV(e.target),
    e.g,
    e.o,
    e.k,
  );
}
Yb.bind({ g: 1 });
Yb.bind({ k: 1 });
function Di(n, e = Object.is) {
  let [t, i] = Jt(n, { equals: e });
  return (...r) => (r.length === 1 && i(() => r[0]), t());
}
function e9(n, e = !1) {
  return Yb.apply({ g: e ? 1 : null }, [n]);
}
function cV() {
  const n = document.querySelector(`*[data-hk^="${Me.context?.id}"]`);
  return n == null ? null : n.getAttribute("class");
}
function uV(n) {
  return (e) => {
    const t = jn({ css: {} }, e),
      i = n === "Global";
    let r;
    ((r = cV()), r == null && !i && (r = e9(t.css, i)));
    let s = t.css;
    const o = Di(r);
    return (
      Ct(() => {
        s !== t.css && ((s = t.css), o(e9(t.css, i)));
      }),
      t.debug &&
        Ct(() => {
          console.debug(t.css);
        }),
      i
        ? document.createElement("div")
        : G(
            bD,
            jn(
              {
                get component() {
                  return t.as ?? n;
                },
                get class() {
                  return [...new Set([t.class, o()].filter(Boolean))].join(" ");
                },
              },
              () => Dr(t, ["css", "as", "class", "debug"])[1],
            ),
          )
    );
  };
}
const $ = new Proxy(uV, {
    get: (n, e) =>
      typeof e == "string" ? (e === "Generic" ? n() : n(e)) : n(e.description),
  }),
  N0e = {
    borderBottomWidth: "1px",
    "--tw-border-opacity": "0.1",
    borderColor: "rgb(255 255 255 / var(--tw-border-opacity))",
  },
  nt = {
    breit: {
      h0: {
        fontFamily: "Sohne Breit, sans-serif",
        fontSize: "248rem",
        lineHeight: "1",
      },
      h1: {
        fontFamily: "Sohne Breit, sans-serif",
        fontSize: "192rem",
        lineHeight: "0.9",
      },
      h2: {
        fontFamily: "Sohne Breit, sans-serif",
        fontSize: "124rem",
        lineHeight: "1",
      },
      h3: {
        fontFamily: "Sohne Breit, sans-serif",
        fontSize: "104rem",
        lineHeight: "1.25",
        letterSpacing: "-0.03em",
      },
      h35: {
        fontFamily: "Sohne Breit, sans-serif",
        fontSize: "71.2rem",
        lineHeight: "1.15",
        letterSpacing: "-0.03em",
      },
      h4: {
        fontFamily: "Sohne Breit, sans-serif",
        fontSize: "64rem",
        lineHeight: "1",
      },
      h5: {
        fontFamily: "Sohne Breit, sans-serif",
        fontSize: "40rem",
        lineHeight: "1.2",
      },
      h55: {
        fontFamily: "Sohne Breit, sans-serif",
        fontSize: "28rem",
        lineHeight: "1.2",
      },
      h6: {
        fontFamily: "Sohne Breit, sans-serif",
        fontSize: "24rem",
        lineHeight: "1.4",
      },
      h7: {
        fontFamily: "Sohne Breit, sans-serif",
        fontSize: "16rem",
        lineHeight: "1",
      },
      h8: {
        fontFamily: "Sohne Breit, sans-serif",
        fontSize: "14rem",
        lineHeight: "1.2",
      },
    },
    sohne: {
      h1: {
        fontFamily: "Sohne, sans-serif",
        fontSize: "104rem",
        lineHeight: "1.25",
        letterSpacing: "-0.03em",
      },
      h15: {
        fontFamily: "Sohne, sans-serif",
        fontSize: "72rem",
        lineHeight: "1",
        letterSpacing: "-0.03em",
      },
      h2: {
        fontFamily: "Sohne, sans-serif",
        fontSize: "64rem",
        lineHeight: "1",
        letterSpacing: "-0.03em",
      },
      h3: {
        fontFamily: "Sohne, sans-serif",
        fontSize: "40rem",
        lineHeight: "1.2",
        letterSpacing: "-0.03em",
      },
      h4: {
        fontFamily: "Sohne, sans-serif",
        fontSize: "32rem",
        lineHeight: "1.25",
        letterSpacing: "-0.03em",
      },
      body1: {
        fontFamily: "Sohne, sans-serif",
        fontSize: "24rem",
        lineHeight: "1.4",
        letterSpacing: "-0.02em",
      },
      body2: {
        fontFamily: "Sohne, sans-serif",
        fontSize: "21rem",
        lineHeight: "32rem",
        letterSpacing: "-0.02em",
      },
      body3: {
        fontFamily: "Sohne, sans-serif",
        fontSize: "16rem",
        lineHeight: "24rem",
        letterSpacing: "-0.02em",
      },
      body4: {
        fontFamily: "Sohne, sans-serif",
        fontSize: "16rem",
        fontWeight: "300",
        lineHeight: "24rem",
        letterSpacing: "-0.02em",
      },
      body5: {
        fontFamily: "Sohne, sans-serif",
        fontSize: "14rem",
        lineHeight: "24rem",
        letterSpacing: "-0.02em",
      },
      body6: {
        fontFamily: "Sohne, sans-serif",
        fontSize: "12rem",
        lineHeight: "16rem",
        letterSpacing: "-0.02em",
      },
    },
    m: {
      breit: {
        h0: {
          "@media (max-width: 767px)": {
            fontFamily: "Sohne Breit, sans-serif",
            fontSize: "72rem",
            lineHeight: "1",
          },
        },
        h05: {
          "@media (max-width: 767px)": {
            fontFamily: "Sohne Breit, sans-serif",
            fontSize: "62rem",
            lineHeight: "1",
          },
        },
        h1: {
          "@media (max-width: 767px)": {
            fontFamily: "Sohne Breit, sans-serif",
            fontSize: "48rem",
            lineHeight: "1",
          },
        },
        h2: {
          "@media (max-width: 767px)": {
            fontFamily: "Sohne Breit, sans-serif",
            fontSize: "40rem",
            lineHeight: "1",
          },
        },
        h3: {
          "@media (max-width: 767px)": {
            fontFamily: "Sohne Breit, sans-serif",
            fontSize: "32rem",
            lineHeight: "1",
          },
        },
        h4: {
          "@media (max-width: 767px)": {
            fontFamily: "Sohne Breit, sans-serif",
            fontSize: "24rem",
            lineHeight: "1.4",
          },
        },
        h5: {
          "@media (max-width: 767px)": {
            fontFamily: "Sohne Breit, sans-serif",
            fontSize: "14rem",
            lineHeight: "1.2",
          },
        },
      },
      sohne: {
        h1: {
          "@media (max-width: 767px)": {
            fontFamily: "Sohne, sans-serif",
            fontSize: "40rem",
            lineHeight: "1.2",
            letterSpacing: "-0.03em",
          },
        },
        h2: {
          "@media (max-width: 767px)": {
            fontFamily: "Sohne, sans-serif",
            fontSize: "32rem",
            lineHeight: "1.2",
            letterSpacing: "-0.03em",
          },
        },
        body1: {
          "@media (max-width: 767px)": {
            fontFamily: "Sohne, sans-serif",
            fontSize: "24rem",
            lineHeight: "1.333",
            letterSpacing: "-0.04em",
          },
        },
        body2: {
          "@media (max-width: 767px)": {
            fontFamily: "Sohne, sans-serif",
            fontSize: "16rem",
            lineHeight: "1.5",
            letterSpacing: "-0.03em",
          },
        },
        body3: {
          "@media (max-width: 767px)": {
            fontFamily: "Sohne, sans-serif",
            fontSize: "14rem",
            lineHeight: "1.42857143",
            letterSpacing: "-0.03em",
          },
        },
        body4: {
          "@media (max-width: 767px)": {
            fontFamily: "Sohne, sans-serif",
            fontSize: "12rem",
            fontWeight: "300",
            lineHeight: "1.25",
            letterSpacing: "-0.03em",
          },
        },
      },
    },
  },
  D0e = {
    marginTop: "-96rem",
    "@media (max-width: 767px)": { marginTop: "-72rem" },
  },
  G0e = {
    paddingTop: "96rem",
    "@media (max-width: 767px)": { paddingTop: "72rem" },
  },
  va = {
    width: "100%",
    paddingLeft: "64rem",
    paddingRight: "64rem",
    "@media (max-width: 767px)": {
      paddingLeft: "24rem",
      paddingRight: "24rem",
    },
  },
  Im = {
    display: "grid",
    gridTemplateColumns: "repeat(12, minmax(0, 1fr))",
    columnGap: "32rem",
  },
  bT = {
    userSelect: "none",
    borderRadius: "9999px",
    borderWidth: "1px",
    "--tw-border-opacity": "0.3",
    borderColor: "rgb(255 255 255 / var(--tw-border-opacity))",
    paddingLeft: "16rem",
    paddingRight: "16rem",
    paddingTop: "4rem",
    paddingBottom: "4rem",
    ...nt.sohne.body3,
  },
  F0e = {
    marginTop: "-32rem",
    marginBottom: "-32rem",
    p: { marginTop: "32rem", marginBottom: "32rem" },
    a: {
      "--tw-text-opacity": "1",
      color: "rgb(255 255 255 / var(--tw-text-opacity))",
      textDecorationLine: "underline",
      transitionProperty:
        "color, background-color, border-color, text-decoration-color, fill, stroke",
      transitionTimingFunction: "cubic-bezier(0.4, 0, 0.2, 1)",
      transitionDuration: "500ms",
      "&:hover": { "--tw-text-opacity": "0.5" },
    },
    ol: { listStylePosition: "inside", listStyleType: "decimal" },
    "ol li": {
      marginTop: "32rem",
      marginBottom: "32rem",
      paddingLeft: "1em",
      textIndent: "-0.98em",
    },
  },
  hV = xt(
    '<svg width="110" height="149" viewBox="0 0 110 149" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M42.7831 52.0711H42.2062L41.9174 52.5704L36.295 62.2914L1.36604 42.1191L25.0302 1.14062H109V52.0711H42.7831Z" stroke-width="2"></path><path d="M61.1132 104.982H60.5359L60.2473 105.481L36.2944 146.96L1.36596 126.788L37.2377 64.6562H109V104.982H61.1132Z" stroke-width="2">',
  ),
  dV = (n = {}) =>
    (() => {
      const e = ft(hV);
      return (fn(e, n, !0, !0), An(), e);
    })(),
  fV = xt(
    '<svg width="124" height="18" viewBox="0 0 124 18" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M20.4688 15.0161V2.99609H31.4504V4.40125H22.0434V8.26919H30.4979V9.67434H22.0434V15.0139H20.4688V15.0161Z"></path><path d="M45.9146 9.00738C45.9146 12.6072 42.952 15.2008 38.9339 15.2008C34.9158 15.2008 31.9531 12.605 31.9531 9.00738C31.9531 5.40975 34.9158 2.81396 38.9339 2.81396C42.952 2.81396 45.9146 5.40975 45.9146 9.00738ZM33.5771 9.00738C33.5771 11.837 35.7867 13.7613 38.9339 13.7613C42.081 13.7613 44.2735 11.837 44.2735 9.00738C44.2735 6.17776 42.081 4.25345 38.9339 4.25345C35.7867 4.25345 33.5771 6.17776 33.5771 9.00738Z"></path><path d="M49.1908 15.0161H47.584V2.99609H55.101C57.6132 2.99609 59.353 4.18458 59.353 6.47788C59.353 8.40219 58.0808 9.59068 56.1394 9.89316L59.604 15.0161H57.7633L54.3824 9.97683H49.1929V15.0161H49.1908ZM55.0174 8.58883C56.725 8.58883 57.7805 7.83584 57.7805 6.48003C57.7805 5.12421 56.725 4.38838 55.0174 4.38838H49.1908V8.59098H55.0174V8.58883Z"></path><path d="M67.7562 15.0161L62.5497 4.45274V15.0161H60.9922V2.99609H63.4871L68.4427 13.1068L73.4155 2.99609H75.8418V15.0161H74.2843V4.45274L69.0949 15.0161H67.7562Z"></path><path d="M85.0641 2.99609L91.3755 15.0161H89.6678L87.9259 11.6845H80.4431L78.6862 15.0161H76.9785L83.3071 2.99609H85.0641ZM81.1811 10.2772H87.19L84.1931 4.56858L81.179 10.2772H81.1811Z"></path><path d="M96.7654 4.40369V15.0164H95.1586V4.40369H89.4844V2.99854H102.442V4.40369H96.7676H96.7654Z"></path><path d="M102.473 8.50293H110.206V9.72574H102.473V8.50293Z"></path><path d="M111.111 11.5519L112.551 10.9319C113.053 12.6395 115.063 13.828 117.489 13.828C119.916 13.828 121.758 12.957 121.758 11.4682C121.758 9.97939 120.016 9.44307 118.008 9.44307H115.582V8.08725H117.976C119.952 8.08725 121.291 7.51875 121.291 6.26162C121.291 5.00449 119.785 4.18499 117.59 4.18499C115.196 4.18499 113.488 5.25548 113.003 6.83012L111.581 6.34528C112.132 4.36948 114.31 2.81201 117.624 2.81201C120.939 2.81201 122.932 4.16783 122.932 6.14363C122.932 7.48228 122.011 8.38759 120.604 8.70509C122.245 9.02259 123.382 9.91074 123.382 11.5669C123.382 13.592 121.072 15.1988 117.506 15.1988C114.293 15.1988 111.748 13.7422 111.111 11.5497V11.5519Z"></path><path d="M12.3718 0.666504H2.75025L0 5.42902L4.12322 7.81028L4.81186 6.61965H12.3718V0.666504Z"></path><path d="M12.3718 7.81055H4.12322L0 14.9522L4.12322 17.3334L6.87347 12.5709H12.3718V7.81055Z">',
  ),
  vT = (n = {}) =>
    (() => {
      const e = ft(fV);
      return (fn(e, n, !0, !0), An(), e);
    })(),
  In = Di(
    typeof window > "u"
      ? { width: 0, height: 0 }
      : { width: window.innerWidth, height: window.innerHeight },
  ),
  gV = Di(typeof window > "u" ? 0 : document.body.offsetWidth),
  Eh = Di(-1),
  pV = Di(null),
  Qn = Di(0),
  ph = Di(0),
  Si = { XL: 1279, LG: 1023, MD: 767, SM: 639 },
  No = Di(!1),
  mV = In,
  xT = pe(() => {
    const { width: n } = mV();
    let e = Si.XL;
    for (const t of Object.values(Si)) n <= t && (e = t);
    return e;
  }),
  xg = Di(0),
  Xb = !0;
var $f = Object.freeze({
    Linear: Object.freeze({
      None: function (n) {
        return n;
      },
      In: function (n) {
        return this.None(n);
      },
      Out: function (n) {
        return this.None(n);
      },
      InOut: function (n) {
        return this.None(n);
      },
    }),
    Quadratic: Object.freeze({
      In: function (n) {
        return n * n;
      },
      Out: function (n) {
        return n * (2 - n);
      },
      InOut: function (n) {
        return (n *= 2) < 1 ? 0.5 * n * n : -0.5 * (--n * (n - 2) - 1);
      },
    }),
    Cubic: Object.freeze({
      In: function (n) {
        return n * n * n;
      },
      Out: function (n) {
        return --n * n * n + 1;
      },
      InOut: function (n) {
        return (n *= 2) < 1 ? 0.5 * n * n * n : 0.5 * ((n -= 2) * n * n + 2);
      },
    }),
    Quartic: Object.freeze({
      In: function (n) {
        return n * n * n * n;
      },
      Out: function (n) {
        return 1 - --n * n * n * n;
      },
      InOut: function (n) {
        return (n *= 2) < 1
          ? 0.5 * n * n * n * n
          : -0.5 * ((n -= 2) * n * n * n - 2);
      },
    }),
    Quintic: Object.freeze({
      In: function (n) {
        return n * n * n * n * n;
      },
      Out: function (n) {
        return --n * n * n * n * n + 1;
      },
      InOut: function (n) {
        return (n *= 2) < 1
          ? 0.5 * n * n * n * n * n
          : 0.5 * ((n -= 2) * n * n * n * n + 2);
      },
    }),
    Sinusoidal: Object.freeze({
      In: function (n) {
        return 1 - Math.sin(((1 - n) * Math.PI) / 2);
      },
      Out: function (n) {
        return Math.sin((n * Math.PI) / 2);
      },
      InOut: function (n) {
        return 0.5 * (1 - Math.sin(Math.PI * (0.5 - n)));
      },
    }),
    Exponential: Object.freeze({
      In: function (n) {
        return n === 0 ? 0 : Math.pow(1024, n - 1);
      },
      Out: function (n) {
        return n === 1 ? 1 : 1 - Math.pow(2, -10 * n);
      },
      InOut: function (n) {
        return n === 0
          ? 0
          : n === 1
            ? 1
            : (n *= 2) < 1
              ? 0.5 * Math.pow(1024, n - 1)
              : 0.5 * (-Math.pow(2, -10 * (n - 1)) + 2);
      },
    }),
    Circular: Object.freeze({
      In: function (n) {
        return 1 - Math.sqrt(1 - n * n);
      },
      Out: function (n) {
        return Math.sqrt(1 - --n * n);
      },
      InOut: function (n) {
        return (n *= 2) < 1
          ? -0.5 * (Math.sqrt(1 - n * n) - 1)
          : 0.5 * (Math.sqrt(1 - (n -= 2) * n) + 1);
      },
    }),
    Elastic: Object.freeze({
      In: function (n) {
        return n === 0
          ? 0
          : n === 1
            ? 1
            : -Math.pow(2, 10 * (n - 1)) * Math.sin((n - 1.1) * 5 * Math.PI);
      },
      Out: function (n) {
        return n === 0
          ? 0
          : n === 1
            ? 1
            : Math.pow(2, -10 * n) * Math.sin((n - 0.1) * 5 * Math.PI) + 1;
      },
      InOut: function (n) {
        return n === 0
          ? 0
          : n === 1
            ? 1
            : ((n *= 2),
              n < 1
                ? -0.5 *
                  Math.pow(2, 10 * (n - 1)) *
                  Math.sin((n - 1.1) * 5 * Math.PI)
                : 0.5 *
                    Math.pow(2, -10 * (n - 1)) *
                    Math.sin((n - 1.1) * 5 * Math.PI) +
                  1);
      },
    }),
    Back: Object.freeze({
      In: function (n) {
        var e = 1.70158;
        return n === 1 ? 1 : n * n * ((e + 1) * n - e);
      },
      Out: function (n) {
        var e = 1.70158;
        return n === 0 ? 0 : --n * n * ((e + 1) * n + e) + 1;
      },
      InOut: function (n) {
        var e = 2.5949095;
        return (n *= 2) < 1
          ? 0.5 * (n * n * ((e + 1) * n - e))
          : 0.5 * ((n -= 2) * n * ((e + 1) * n + e) + 2);
      },
    }),
    Bounce: Object.freeze({
      In: function (n) {
        return 1 - $f.Bounce.Out(1 - n);
      },
      Out: function (n) {
        return n < 1 / 2.75
          ? 7.5625 * n * n
          : n < 2 / 2.75
            ? 7.5625 * (n -= 1.5 / 2.75) * n + 0.75
            : n < 2.5 / 2.75
              ? 7.5625 * (n -= 2.25 / 2.75) * n + 0.9375
              : 7.5625 * (n -= 2.625 / 2.75) * n + 0.984375;
      },
      InOut: function (n) {
        return n < 0.5
          ? $f.Bounce.In(n * 2) * 0.5
          : $f.Bounce.Out(n * 2 - 1) * 0.5 + 0.5;
      },
    }),
    generatePow: function (n) {
      return (
        n === void 0 && (n = 4),
        (n = n < Number.EPSILON ? Number.EPSILON : n),
        (n = n > 1e4 ? 1e4 : n),
        {
          In: function (e) {
            return Math.pow(e, n);
          },
          Out: function (e) {
            return 1 - Math.pow(1 - e, n);
          },
          InOut: function (e) {
            return e < 0.5
              ? Math.pow(e * 2, n) / 2
              : (1 - Math.pow(2 - e * 2, n)) / 2 + 0.5;
          },
        }
      );
    },
  }),
  Ef = function () {
    return performance.now();
  },
  CV = (function () {
    function n() {
      ((this._tweens = {}), (this._tweensAddedDuringUpdate = {}));
    }
    return (
      (n.prototype.getAll = function () {
        var e = this;
        return Object.keys(this._tweens).map(function (t) {
          return e._tweens[t];
        });
      }),
      (n.prototype.removeAll = function () {
        this._tweens = {};
      }),
      (n.prototype.add = function (e) {
        ((this._tweens[e.getId()] = e),
          (this._tweensAddedDuringUpdate[e.getId()] = e));
      }),
      (n.prototype.remove = function (e) {
        (delete this._tweens[e.getId()],
          delete this._tweensAddedDuringUpdate[e.getId()]);
      }),
      (n.prototype.update = function (e, t) {
        (e === void 0 && (e = Ef()), t === void 0 && (t = !1));
        var i = Object.keys(this._tweens);
        if (i.length === 0) return !1;
        for (; i.length > 0; ) {
          this._tweensAddedDuringUpdate = {};
          for (var r = 0; r < i.length; r++) {
            var s = this._tweens[i[r]],
              o = !t;
            s && s.update(e, o) === !1 && !t && delete this._tweens[i[r]];
          }
          i = Object.keys(this._tweensAddedDuringUpdate);
        }
        return !0;
      }),
      n
    );
  })(),
  mh = {
    Linear: function (n, e) {
      var t = n.length - 1,
        i = t * e,
        r = Math.floor(i),
        s = mh.Utils.Linear;
      return e < 0
        ? s(n[0], n[1], i)
        : e > 1
          ? s(n[t], n[t - 1], t - i)
          : s(n[r], n[r + 1 > t ? t : r + 1], i - r);
    },
    Bezier: function (n, e) {
      for (
        var t = 0,
          i = n.length - 1,
          r = Math.pow,
          s = mh.Utils.Bernstein,
          o = 0;
        o <= i;
        o++
      )
        t += r(1 - e, i - o) * r(e, o) * n[o] * s(i, o);
      return t;
    },
    CatmullRom: function (n, e) {
      var t = n.length - 1,
        i = t * e,
        r = Math.floor(i),
        s = mh.Utils.CatmullRom;
      return n[0] === n[t]
        ? (e < 0 && (r = Math.floor((i = t * (1 + e)))),
          s(n[(r - 1 + t) % t], n[r], n[(r + 1) % t], n[(r + 2) % t], i - r))
        : e < 0
          ? n[0] - (s(n[0], n[0], n[1], n[1], -i) - n[0])
          : e > 1
            ? n[t] - (s(n[t], n[t], n[t - 1], n[t - 1], i - t) - n[t])
            : s(
                n[r ? r - 1 : 0],
                n[r],
                n[t < r + 1 ? t : r + 1],
                n[t < r + 2 ? t : r + 2],
                i - r,
              );
    },
    Utils: {
      Linear: function (n, e, t) {
        return (e - n) * t + n;
      },
      Bernstein: function (n, e) {
        var t = mh.Utils.Factorial;
        return t(n) / t(e) / t(n - e);
      },
      Factorial: (function () {
        var n = [1];
        return function (e) {
          var t = 1;
          if (n[e]) return n[e];
          for (var i = e; i > 1; i--) t *= i;
          return ((n[e] = t), t);
        };
      })(),
      CatmullRom: function (n, e, t, i, r) {
        var s = (t - n) * 0.5,
          o = (i - e) * 0.5,
          a = r * r,
          l = r * a;
        return (
          (2 * e - 2 * t + s + o) * l +
          (-3 * e + 3 * t - 2 * s - o) * a +
          s * r +
          e
        );
      },
    },
  },
  IV = (function () {
    function n() {}
    return (
      (n.nextId = function () {
        return n._nextId++;
      }),
      (n._nextId = 0),
      n
    );
  })(),
  Ry = new CV(),
  AV = (function () {
    function n(e, t) {
      (t === void 0 && (t = Ry),
        (this._object = e),
        (this._group = t),
        (this._isPaused = !1),
        (this._pauseStart = 0),
        (this._valuesStart = {}),
        (this._valuesEnd = {}),
        (this._valuesStartRepeat = {}),
        (this._duration = 1e3),
        (this._isDynamic = !1),
        (this._initialRepeat = 0),
        (this._repeat = 0),
        (this._yoyo = !1),
        (this._isPlaying = !1),
        (this._reversed = !1),
        (this._delayTime = 0),
        (this._startTime = 0),
        (this._easingFunction = $f.Linear.None),
        (this._interpolationFunction = mh.Linear),
        (this._chainedTweens = []),
        (this._onStartCallbackFired = !1),
        (this._onEveryStartCallbackFired = !1),
        (this._id = IV.nextId()),
        (this._isChainStopped = !1),
        (this._propertiesAreSetUp = !1),
        (this._goToEnd = !1));
    }
    return (
      (n.prototype.getId = function () {
        return this._id;
      }),
      (n.prototype.isPlaying = function () {
        return this._isPlaying;
      }),
      (n.prototype.isPaused = function () {
        return this._isPaused;
      }),
      (n.prototype.to = function (e, t) {
        if ((t === void 0 && (t = 1e3), this._isPlaying))
          throw new Error(
            "Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.",
          );
        return (
          (this._valuesEnd = e),
          (this._propertiesAreSetUp = !1),
          (this._duration = t),
          this
        );
      }),
      (n.prototype.duration = function (e) {
        return (e === void 0 && (e = 1e3), (this._duration = e), this);
      }),
      (n.prototype.dynamic = function (e) {
        return (e === void 0 && (e = !1), (this._isDynamic = e), this);
      }),
      (n.prototype.start = function (e, t) {
        if (
          (e === void 0 && (e = Ef()),
          t === void 0 && (t = !1),
          this._isPlaying)
        )
          return this;
        if (
          (this._group && this._group.add(this),
          (this._repeat = this._initialRepeat),
          this._reversed)
        ) {
          this._reversed = !1;
          for (var i in this._valuesStartRepeat)
            (this._swapEndStartRepeatValues(i),
              (this._valuesStart[i] = this._valuesStartRepeat[i]));
        }
        if (
          ((this._isPlaying = !0),
          (this._isPaused = !1),
          (this._onStartCallbackFired = !1),
          (this._onEveryStartCallbackFired = !1),
          (this._isChainStopped = !1),
          (this._startTime = e),
          (this._startTime += this._delayTime),
          !this._propertiesAreSetUp || t)
        ) {
          if (((this._propertiesAreSetUp = !0), !this._isDynamic)) {
            var r = {};
            for (var s in this._valuesEnd) r[s] = this._valuesEnd[s];
            this._valuesEnd = r;
          }
          this._setupProperties(
            this._object,
            this._valuesStart,
            this._valuesEnd,
            this._valuesStartRepeat,
            t,
          );
        }
        return this;
      }),
      (n.prototype.startFromCurrentValues = function (e) {
        return this.start(e, !0);
      }),
      (n.prototype._setupProperties = function (e, t, i, r, s) {
        for (var o in i) {
          var a = e[o],
            l = Array.isArray(a),
            c = l ? "array" : typeof a,
            u = !l && Array.isArray(i[o]);
          if (!(c === "undefined" || c === "function")) {
            if (u) {
              var h = i[o];
              if (h.length === 0) continue;
              for (var d = [a], f = 0, g = h.length; f < g; f += 1) {
                var p = this._handleRelativeValue(a, h[f]);
                if (isNaN(p)) {
                  ((u = !1),
                    console.warn(
                      "Found invalid interpolation list. Skipping.",
                    ));
                  break;
                }
                d.push(p);
              }
              u && (i[o] = d);
            }
            if ((c === "object" || l) && a && !u) {
              t[o] = l ? [] : {};
              var m = a;
              for (var C in m) t[o][C] = m[C];
              r[o] = l ? [] : {};
              var h = i[o];
              if (!this._isDynamic) {
                var A = {};
                for (var C in h) A[C] = h[C];
                i[o] = h = A;
              }
              this._setupProperties(m, t[o], h, r[o], s);
            } else
              ((typeof t[o] > "u" || s) && (t[o] = a),
                l || (t[o] *= 1),
                u ? (r[o] = i[o].slice().reverse()) : (r[o] = t[o] || 0));
          }
        }
      }),
      (n.prototype.stop = function () {
        return (
          this._isChainStopped ||
            ((this._isChainStopped = !0), this.stopChainedTweens()),
          this._isPlaying
            ? (this._group && this._group.remove(this),
              (this._isPlaying = !1),
              (this._isPaused = !1),
              this._onStopCallback && this._onStopCallback(this._object),
              this)
            : this
        );
      }),
      (n.prototype.end = function () {
        return ((this._goToEnd = !0), this.update(1 / 0), this);
      }),
      (n.prototype.pause = function (e) {
        return (
          e === void 0 && (e = Ef()),
          this._isPaused || !this._isPlaying
            ? this
            : ((this._isPaused = !0),
              (this._pauseStart = e),
              this._group && this._group.remove(this),
              this)
        );
      }),
      (n.prototype.resume = function (e) {
        return (
          e === void 0 && (e = Ef()),
          !this._isPaused || !this._isPlaying
            ? this
            : ((this._isPaused = !1),
              (this._startTime += e - this._pauseStart),
              (this._pauseStart = 0),
              this._group && this._group.add(this),
              this)
        );
      }),
      (n.prototype.stopChainedTweens = function () {
        for (var e = 0, t = this._chainedTweens.length; e < t; e++)
          this._chainedTweens[e].stop();
        return this;
      }),
      (n.prototype.group = function (e) {
        return (e === void 0 && (e = Ry), (this._group = e), this);
      }),
      (n.prototype.delay = function (e) {
        return (e === void 0 && (e = 0), (this._delayTime = e), this);
      }),
      (n.prototype.repeat = function (e) {
        return (
          e === void 0 && (e = 0),
          (this._initialRepeat = e),
          (this._repeat = e),
          this
        );
      }),
      (n.prototype.repeatDelay = function (e) {
        return ((this._repeatDelayTime = e), this);
      }),
      (n.prototype.yoyo = function (e) {
        return (e === void 0 && (e = !1), (this._yoyo = e), this);
      }),
      (n.prototype.easing = function (e) {
        return (
          e === void 0 && (e = $f.Linear.None),
          (this._easingFunction = e),
          this
        );
      }),
      (n.prototype.interpolation = function (e) {
        return (
          e === void 0 && (e = mh.Linear),
          (this._interpolationFunction = e),
          this
        );
      }),
      (n.prototype.chain = function () {
        for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
        return ((this._chainedTweens = e), this);
      }),
      (n.prototype.onStart = function (e) {
        return ((this._onStartCallback = e), this);
      }),
      (n.prototype.onEveryStart = function (e) {
        return ((this._onEveryStartCallback = e), this);
      }),
      (n.prototype.onUpdate = function (e) {
        return ((this._onUpdateCallback = e), this);
      }),
      (n.prototype.onRepeat = function (e) {
        return ((this._onRepeatCallback = e), this);
      }),
      (n.prototype.onComplete = function (e) {
        return ((this._onCompleteCallback = e), this);
      }),
      (n.prototype.onStop = function (e) {
        return ((this._onStopCallback = e), this);
      }),
      (n.prototype.update = function (e, t) {
        if (
          (e === void 0 && (e = Ef()), t === void 0 && (t = !0), this._isPaused)
        )
          return !0;
        var i,
          r,
          s = this._startTime + this._duration;
        if (!this._goToEnd && !this._isPlaying) {
          if (e > s) return !1;
          t && this.start(e, !0);
        }
        if (((this._goToEnd = !1), e < this._startTime)) return !0;
        (this._onStartCallbackFired === !1 &&
          (this._onStartCallback && this._onStartCallback(this._object),
          (this._onStartCallbackFired = !0)),
          this._onEveryStartCallbackFired === !1 &&
            (this._onEveryStartCallback &&
              this._onEveryStartCallback(this._object),
            (this._onEveryStartCallbackFired = !0)),
          (r = (e - this._startTime) / this._duration),
          (r = this._duration === 0 || r > 1 ? 1 : r));
        var o = this._easingFunction(r);
        if (
          (this._updateProperties(
            this._object,
            this._valuesStart,
            this._valuesEnd,
            o,
          ),
          this._onUpdateCallback && this._onUpdateCallback(this._object, r),
          r === 1)
        )
          if (this._repeat > 0) {
            isFinite(this._repeat) && this._repeat--;
            for (i in this._valuesStartRepeat)
              (!this._yoyo &&
                typeof this._valuesEnd[i] == "string" &&
                (this._valuesStartRepeat[i] =
                  this._valuesStartRepeat[i] + parseFloat(this._valuesEnd[i])),
                this._yoyo && this._swapEndStartRepeatValues(i),
                (this._valuesStart[i] = this._valuesStartRepeat[i]));
            return (
              this._yoyo && (this._reversed = !this._reversed),
              this._repeatDelayTime !== void 0
                ? (this._startTime = e + this._repeatDelayTime)
                : (this._startTime = e + this._delayTime),
              this._onRepeatCallback && this._onRepeatCallback(this._object),
              (this._onEveryStartCallbackFired = !1),
              !0
            );
          } else {
            this._onCompleteCallback && this._onCompleteCallback(this._object);
            for (var a = 0, l = this._chainedTweens.length; a < l; a++)
              this._chainedTweens[a].start(
                this._startTime + this._duration,
                !1,
              );
            return ((this._isPlaying = !1), !1);
          }
        return !0;
      }),
      (n.prototype._updateProperties = function (e, t, i, r) {
        for (var s in i)
          if (t[s] !== void 0) {
            var o = t[s] || 0,
              a = i[s],
              l = Array.isArray(e[s]),
              c = Array.isArray(a),
              u = !l && c;
            u
              ? (e[s] = this._interpolationFunction(a, r))
              : typeof a == "object" && a
                ? this._updateProperties(e[s], o, a, r)
                : ((a = this._handleRelativeValue(o, a)),
                  typeof a == "number" && (e[s] = o + (a - o) * r));
          }
      }),
      (n.prototype._handleRelativeValue = function (e, t) {
        return typeof t != "string"
          ? t
          : t.charAt(0) === "+" || t.charAt(0) === "-"
            ? e + parseFloat(t)
            : parseFloat(t);
      }),
      (n.prototype._swapEndStartRepeatValues = function (e) {
        var t = this._valuesStartRepeat[e],
          i = this._valuesEnd[e];
        (typeof i == "string"
          ? (this._valuesStartRepeat[e] =
              this._valuesStartRepeat[e] + parseFloat(i))
          : (this._valuesStartRepeat[e] = this._valuesEnd[e]),
          (this._valuesEnd[e] = t));
      }),
      n
    );
  })(),
  Do = Ry;
Do.getAll.bind(Do);
Do.removeAll.bind(Do);
Do.add.bind(Do);
Do.remove.bind(Do);
Do.update.bind(Do);
class xu extends Error {}
class yV extends xu {
  constructor(e) {
    super(`Invalid DateTime: ${e.toMessage()}`);
  }
}
class _V extends xu {
  constructor(e) {
    super(`Invalid Interval: ${e.toMessage()}`);
  }
}
class bV extends xu {
  constructor(e) {
    super(`Invalid Duration: ${e.toMessage()}`);
  }
}
class Ch extends xu {}
class wT extends xu {
  constructor(e) {
    super(`Invalid unit ${e}`);
  }
}
class wr extends xu {}
class Wa extends xu {
  constructor() {
    super("Zone is an abstract class");
  }
}
const Ne = "numeric",
  no = "short",
  $r = "long",
  Am = { year: Ne, month: Ne, day: Ne },
  ST = { year: Ne, month: no, day: Ne },
  vV = { year: Ne, month: no, day: Ne, weekday: no },
  TT = { year: Ne, month: $r, day: Ne },
  ET = { year: Ne, month: $r, day: Ne, weekday: $r },
  MT = { hour: Ne, minute: Ne },
  LT = { hour: Ne, minute: Ne, second: Ne },
  RT = { hour: Ne, minute: Ne, second: Ne, timeZoneName: no },
  BT = { hour: Ne, minute: Ne, second: Ne, timeZoneName: $r },
  PT = { hour: Ne, minute: Ne, hourCycle: "h23" },
  NT = { hour: Ne, minute: Ne, second: Ne, hourCycle: "h23" },
  DT = { hour: Ne, minute: Ne, second: Ne, hourCycle: "h23", timeZoneName: no },
  GT = { hour: Ne, minute: Ne, second: Ne, hourCycle: "h23", timeZoneName: $r },
  FT = { year: Ne, month: Ne, day: Ne, hour: Ne, minute: Ne },
  kT = { year: Ne, month: Ne, day: Ne, hour: Ne, minute: Ne, second: Ne },
  OT = { year: Ne, month: no, day: Ne, hour: Ne, minute: Ne },
  UT = { year: Ne, month: no, day: Ne, hour: Ne, minute: Ne, second: Ne },
  xV = { year: Ne, month: no, day: Ne, weekday: no, hour: Ne, minute: Ne },
  HT = { year: Ne, month: $r, day: Ne, hour: Ne, minute: Ne, timeZoneName: no },
  WT = {
    year: Ne,
    month: $r,
    day: Ne,
    hour: Ne,
    minute: Ne,
    second: Ne,
    timeZoneName: no,
  },
  VT = {
    year: Ne,
    month: $r,
    day: Ne,
    weekday: $r,
    hour: Ne,
    minute: Ne,
    timeZoneName: $r,
  },
  ZT = {
    year: Ne,
    month: $r,
    day: Ne,
    weekday: $r,
    hour: Ne,
    minute: Ne,
    second: Ne,
    timeZoneName: $r,
  };
class up {
  get type() {
    throw new Wa();
  }
  get name() {
    throw new Wa();
  }
  get ianaName() {
    return this.name;
  }
  get isUniversal() {
    throw new Wa();
  }
  offsetName(e, t) {
    throw new Wa();
  }
  formatOffset(e, t) {
    throw new Wa();
  }
  offset(e) {
    throw new Wa();
  }
  equals(e) {
    throw new Wa();
  }
  get isValid() {
    throw new Wa();
  }
}
let VI = null;
class GC extends up {
  static get instance() {
    return (VI === null && (VI = new GC()), VI);
  }
  get type() {
    return "system";
  }
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  get isUniversal() {
    return !1;
  }
  offsetName(e, { format: t, locale: i }) {
    return qT(e, t, i);
  }
  formatOffset(e, t) {
    return Jf(this.offset(e), t);
  }
  offset(e) {
    return -new Date(e).getTimezoneOffset();
  }
  equals(e) {
    return e.type === "system";
  }
  get isValid() {
    return !0;
  }
}
let p0 = {};
function wV(n) {
  return (
    p0[n] ||
      (p0[n] = new Intl.DateTimeFormat("en-US", {
        hour12: !1,
        timeZone: n,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        era: "short",
      })),
    p0[n]
  );
}
const SV = { year: 0, month: 1, day: 2, era: 3, hour: 4, minute: 5, second: 6 };
function TV(n, e) {
  const t = n.format(e).replace(/\u200E/g, ""),
    i = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(t),
    [, r, s, o, a, l, c, u] = i;
  return [o, r, s, a, l, c, u];
}
function EV(n, e) {
  const t = n.formatToParts(e),
    i = [];
  for (let r = 0; r < t.length; r++) {
    const { type: s, value: o } = t[r],
      a = SV[s];
    s === "era" ? (i[a] = o) : _t(a) || (i[a] = parseInt(o, 10));
  }
  return i;
}
let Zp = {};
class Pa extends up {
  static create(e) {
    return (Zp[e] || (Zp[e] = new Pa(e)), Zp[e]);
  }
  static resetCache() {
    ((Zp = {}), (p0 = {}));
  }
  static isValidSpecifier(e) {
    return this.isValidZone(e);
  }
  static isValidZone(e) {
    if (!e) return !1;
    try {
      return (new Intl.DateTimeFormat("en-US", { timeZone: e }).format(), !0);
    } catch {
      return !1;
    }
  }
  constructor(e) {
    (super(), (this.zoneName = e), (this.valid = Pa.isValidZone(e)));
  }
  get type() {
    return "iana";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return !1;
  }
  offsetName(e, { format: t, locale: i }) {
    return qT(e, t, i, this.name);
  }
  formatOffset(e, t) {
    return Jf(this.offset(e), t);
  }
  offset(e) {
    const t = new Date(e);
    if (isNaN(t)) return NaN;
    const i = wV(this.name);
    let [r, s, o, a, l, c, u] = i.formatToParts ? EV(i, t) : TV(i, t);
    a === "BC" && (r = -Math.abs(r) + 1);
    const d = kC({
      year: r,
      month: s,
      day: o,
      hour: l === 24 ? 0 : l,
      minute: c,
      second: u,
      millisecond: 0,
    });
    let f = +t;
    const g = f % 1e3;
    return ((f -= g >= 0 ? g : 1e3 + g), (d - f) / (60 * 1e3));
  }
  equals(e) {
    return e.type === "iana" && e.name === this.name;
  }
  get isValid() {
    return this.valid;
  }
}
let t9 = {};
function MV(n, e = {}) {
  const t = JSON.stringify([n, e]);
  let i = t9[t];
  return (i || ((i = new Intl.ListFormat(n, e)), (t9[t] = i)), i);
}
let By = {};
function Py(n, e = {}) {
  const t = JSON.stringify([n, e]);
  let i = By[t];
  return (i || ((i = new Intl.DateTimeFormat(n, e)), (By[t] = i)), i);
}
let Ny = {};
function LV(n, e = {}) {
  const t = JSON.stringify([n, e]);
  let i = Ny[t];
  return (i || ((i = new Intl.NumberFormat(n, e)), (Ny[t] = i)), i);
}
let Dy = {};
function RV(n, e = {}) {
  const { base: t, ...i } = e,
    r = JSON.stringify([n, i]);
  let s = Dy[r];
  return (s || ((s = new Intl.RelativeTimeFormat(n, e)), (Dy[r] = s)), s);
}
let Mf = null;
function BV() {
  return Mf || ((Mf = new Intl.DateTimeFormat().resolvedOptions().locale), Mf);
}
let n9 = {};
function PV(n) {
  let e = n9[n];
  if (!e) {
    const t = new Intl.Locale(n);
    ((e = "getWeekInfo" in t ? t.getWeekInfo() : t.weekInfo), (n9[n] = e));
  }
  return e;
}
function NV(n) {
  const e = n.indexOf("-x-");
  e !== -1 && (n = n.substring(0, e));
  const t = n.indexOf("-u-");
  if (t === -1) return [n];
  {
    let i, r;
    try {
      ((i = Py(n).resolvedOptions()), (r = n));
    } catch {
      const l = n.substring(0, t);
      ((i = Py(l).resolvedOptions()), (r = l));
    }
    const { numberingSystem: s, calendar: o } = i;
    return [r, s, o];
  }
}
function DV(n, e, t) {
  return (
    (t || e) &&
      (n.includes("-u-") || (n += "-u"),
      t && (n += `-ca-${t}`),
      e && (n += `-nu-${e}`)),
    n
  );
}
function GV(n) {
  const e = [];
  for (let t = 1; t <= 12; t++) {
    const i = Rt.utc(2009, t, 1);
    e.push(n(i));
  }
  return e;
}
function FV(n) {
  const e = [];
  for (let t = 1; t <= 7; t++) {
    const i = Rt.utc(2016, 11, 13 + t);
    e.push(n(i));
  }
  return e;
}
function zp(n, e, t, i) {
  const r = n.listingMode();
  return r === "error" ? null : r === "en" ? t(e) : i(e);
}
function kV(n) {
  return n.numberingSystem && n.numberingSystem !== "latn"
    ? !1
    : n.numberingSystem === "latn" ||
        !n.locale ||
        n.locale.startsWith("en") ||
        new Intl.DateTimeFormat(n.intl).resolvedOptions().numberingSystem ===
          "latn";
}
class OV {
  constructor(e, t, i) {
    ((this.padTo = i.padTo || 0), (this.floor = i.floor || !1));
    const { padTo: r, floor: s, ...o } = i;
    if (!t || Object.keys(o).length > 0) {
      const a = { useGrouping: !1, ...i };
      (i.padTo > 0 && (a.minimumIntegerDigits = i.padTo),
        (this.inf = LV(e, a)));
    }
  }
  format(e) {
    if (this.inf) {
      const t = this.floor ? Math.floor(e) : e;
      return this.inf.format(t);
    } else {
      const t = this.floor ? Math.floor(e) : Jb(e, 3);
      return ti(t, this.padTo);
    }
  }
}
class UV {
  constructor(e, t, i) {
    ((this.opts = i), (this.originalZone = void 0));
    let r;
    if (this.opts.timeZone) this.dt = e;
    else if (e.zone.type === "fixed") {
      const o = -1 * (e.offset / 60),
        a = o >= 0 ? `Etc/GMT+${o}` : `Etc/GMT${o}`;
      e.offset !== 0 && Pa.create(a).valid
        ? ((r = a), (this.dt = e))
        : ((r = "UTC"),
          (this.dt =
            e.offset === 0 ? e : e.setZone("UTC").plus({ minutes: e.offset })),
          (this.originalZone = e.zone));
    } else
      e.zone.type === "system"
        ? (this.dt = e)
        : e.zone.type === "iana"
          ? ((this.dt = e), (r = e.zone.name))
          : ((r = "UTC"),
            (this.dt = e.setZone("UTC").plus({ minutes: e.offset })),
            (this.originalZone = e.zone));
    const s = { ...this.opts };
    ((s.timeZone = s.timeZone || r), (this.dtf = Py(t, s)));
  }
  format() {
    return this.originalZone
      ? this.formatToParts()
          .map(({ value: e }) => e)
          .join("")
      : this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const e = this.dtf.formatToParts(this.dt.toJSDate());
    return this.originalZone
      ? e.map((t) => {
          if (t.type === "timeZoneName") {
            const i = this.originalZone.offsetName(this.dt.ts, {
              locale: this.dt.locale,
              format: this.opts.timeZoneName,
            });
            return { ...t, value: i };
          } else return t;
        })
      : e;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}
class HV {
  constructor(e, t, i) {
    ((this.opts = { style: "long", ...i }),
      !t && JT() && (this.rtf = RV(e, i)));
  }
  format(e, t) {
    return this.rtf
      ? this.rtf.format(e, t)
      : aZ(t, e, this.opts.numeric, this.opts.style !== "long");
  }
  formatToParts(e, t) {
    return this.rtf ? this.rtf.formatToParts(e, t) : [];
  }
}
const WV = { firstDay: 1, minimalDays: 4, weekend: [6, 7] };
class Cn {
  static fromOpts(e) {
    return Cn.create(
      e.locale,
      e.numberingSystem,
      e.outputCalendar,
      e.weekSettings,
      e.defaultToEN,
    );
  }
  static create(e, t, i, r, s = !1) {
    const o = e || $n.defaultLocale,
      a = o || (s ? "en-US" : BV()),
      l = t || $n.defaultNumberingSystem,
      c = i || $n.defaultOutputCalendar,
      u = Gy(r) || $n.defaultWeekSettings;
    return new Cn(a, l, c, u, o);
  }
  static resetCache() {
    ((Mf = null), (By = {}), (Ny = {}), (Dy = {}));
  }
  static fromObject({
    locale: e,
    numberingSystem: t,
    outputCalendar: i,
    weekSettings: r,
  } = {}) {
    return Cn.create(e, t, i, r);
  }
  constructor(e, t, i, r, s) {
    const [o, a, l] = NV(e);
    ((this.locale = o),
      (this.numberingSystem = t || a || null),
      (this.outputCalendar = i || l || null),
      (this.weekSettings = r),
      (this.intl = DV(this.locale, this.numberingSystem, this.outputCalendar)),
      (this.weekdaysCache = { format: {}, standalone: {} }),
      (this.monthsCache = { format: {}, standalone: {} }),
      (this.meridiemCache = null),
      (this.eraCache = {}),
      (this.specifiedLocale = s),
      (this.fastNumbersCached = null));
  }
  get fastNumbers() {
    return (
      this.fastNumbersCached == null && (this.fastNumbersCached = kV(this)),
      this.fastNumbersCached
    );
  }
  listingMode() {
    const e = this.isEnglish(),
      t =
        (this.numberingSystem === null || this.numberingSystem === "latn") &&
        (this.outputCalendar === null || this.outputCalendar === "gregory");
    return e && t ? "en" : "intl";
  }
  clone(e) {
    return !e || Object.getOwnPropertyNames(e).length === 0
      ? this
      : Cn.create(
          e.locale || this.specifiedLocale,
          e.numberingSystem || this.numberingSystem,
          e.outputCalendar || this.outputCalendar,
          Gy(e.weekSettings) || this.weekSettings,
          e.defaultToEN || !1,
        );
  }
  redefaultToEN(e = {}) {
    return this.clone({ ...e, defaultToEN: !0 });
  }
  redefaultToSystem(e = {}) {
    return this.clone({ ...e, defaultToEN: !1 });
  }
  months(e, t = !1) {
    return zp(this, e, nE, () => {
      const i = t ? { month: e, day: "numeric" } : { month: e },
        r = t ? "format" : "standalone";
      return (
        this.monthsCache[r][e] ||
          (this.monthsCache[r][e] = GV((s) => this.extract(s, i, "month"))),
        this.monthsCache[r][e]
      );
    });
  }
  weekdays(e, t = !1) {
    return zp(this, e, sE, () => {
      const i = t
          ? { weekday: e, year: "numeric", month: "long", day: "numeric" }
          : { weekday: e },
        r = t ? "format" : "standalone";
      return (
        this.weekdaysCache[r][e] ||
          (this.weekdaysCache[r][e] = FV((s) => this.extract(s, i, "weekday"))),
        this.weekdaysCache[r][e]
      );
    });
  }
  meridiems() {
    return zp(
      this,
      void 0,
      () => oE,
      () => {
        if (!this.meridiemCache) {
          const e = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [
            Rt.utc(2016, 11, 13, 9),
            Rt.utc(2016, 11, 13, 19),
          ].map((t) => this.extract(t, e, "dayperiod"));
        }
        return this.meridiemCache;
      },
    );
  }
  eras(e) {
    return zp(this, e, aE, () => {
      const t = { era: e };
      return (
        this.eraCache[e] ||
          (this.eraCache[e] = [Rt.utc(-40, 1, 1), Rt.utc(2017, 1, 1)].map((i) =>
            this.extract(i, t, "era"),
          )),
        this.eraCache[e]
      );
    });
  }
  extract(e, t, i) {
    const r = this.dtFormatter(e, t),
      s = r.formatToParts(),
      o = s.find((a) => a.type.toLowerCase() === i);
    return o ? o.value : null;
  }
  numberFormatter(e = {}) {
    return new OV(this.intl, e.forceSimple || this.fastNumbers, e);
  }
  dtFormatter(e, t = {}) {
    return new UV(e, this.intl, t);
  }
  relFormatter(e = {}) {
    return new HV(this.intl, this.isEnglish(), e);
  }
  listFormatter(e = {}) {
    return MV(this.intl, e);
  }
  isEnglish() {
    return (
      this.locale === "en" ||
      this.locale.toLowerCase() === "en-us" ||
      new Intl.DateTimeFormat(this.intl)
        .resolvedOptions()
        .locale.startsWith("en-us")
    );
  }
  getWeekSettings() {
    return this.weekSettings ? this.weekSettings : QT() ? PV(this.locale) : WV;
  }
  getStartOfWeek() {
    return this.getWeekSettings().firstDay;
  }
  getMinDaysInFirstWeek() {
    return this.getWeekSettings().minimalDays;
  }
  getWeekendDays() {
    return this.getWeekSettings().weekend;
  }
  equals(e) {
    return (
      this.locale === e.locale &&
      this.numberingSystem === e.numberingSystem &&
      this.outputCalendar === e.outputCalendar
    );
  }
}
let ZI = null;
class dr extends up {
  static get utcInstance() {
    return (ZI === null && (ZI = new dr(0)), ZI);
  }
  static instance(e) {
    return e === 0 ? dr.utcInstance : new dr(e);
  }
  static parseSpecifier(e) {
    if (e) {
      const t = e.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (t) return new dr(OC(t[1], t[2]));
    }
    return null;
  }
  constructor(e) {
    (super(), (this.fixed = e));
  }
  get type() {
    return "fixed";
  }
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${Jf(this.fixed, "narrow")}`;
  }
  get ianaName() {
    return this.fixed === 0 ? "Etc/UTC" : `Etc/GMT${Jf(-this.fixed, "narrow")}`;
  }
  offsetName() {
    return this.name;
  }
  formatOffset(e, t) {
    return Jf(this.fixed, t);
  }
  get isUniversal() {
    return !0;
  }
  offset() {
    return this.fixed;
  }
  equals(e) {
    return e.type === "fixed" && e.fixed === this.fixed;
  }
  get isValid() {
    return !0;
  }
}
class VV extends up {
  constructor(e) {
    (super(), (this.zoneName = e));
  }
  get type() {
    return "invalid";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return !1;
  }
  offsetName() {
    return null;
  }
  formatOffset() {
    return "";
  }
  offset() {
    return NaN;
  }
  equals() {
    return !1;
  }
  get isValid() {
    return !1;
  }
}
function hl(n, e) {
  if (_t(n) || n === null) return e;
  if (n instanceof up) return n;
  if (YV(n)) {
    const t = n.toLowerCase();
    return t === "default"
      ? e
      : t === "local" || t === "system"
        ? GC.instance
        : t === "utc" || t === "gmt"
          ? dr.utcInstance
          : dr.parseSpecifier(t) || Pa.create(n);
  } else
    return eu(n)
      ? dr.instance(n)
      : typeof n == "object" && "offset" in n && typeof n.offset == "function"
        ? n
        : new VV(n);
}
let i9 = () => Date.now(),
  r9 = "system",
  s9 = null,
  o9 = null,
  a9 = null,
  l9 = 60,
  c9,
  u9 = null;
class $n {
  static get now() {
    return i9;
  }
  static set now(e) {
    i9 = e;
  }
  static set defaultZone(e) {
    r9 = e;
  }
  static get defaultZone() {
    return hl(r9, GC.instance);
  }
  static get defaultLocale() {
    return s9;
  }
  static set defaultLocale(e) {
    s9 = e;
  }
  static get defaultNumberingSystem() {
    return o9;
  }
  static set defaultNumberingSystem(e) {
    o9 = e;
  }
  static get defaultOutputCalendar() {
    return a9;
  }
  static set defaultOutputCalendar(e) {
    a9 = e;
  }
  static get defaultWeekSettings() {
    return u9;
  }
  static set defaultWeekSettings(e) {
    u9 = Gy(e);
  }
  static get twoDigitCutoffYear() {
    return l9;
  }
  static set twoDigitCutoffYear(e) {
    l9 = e % 100;
  }
  static get throwOnInvalid() {
    return c9;
  }
  static set throwOnInvalid(e) {
    c9 = e;
  }
  static resetCaches() {
    (Cn.resetCache(), Pa.resetCache());
  }
}
class js {
  constructor(e, t) {
    ((this.reason = e), (this.explanation = t));
  }
  toMessage() {
    return this.explanation
      ? `${this.reason}: ${this.explanation}`
      : this.reason;
  }
}
const zT = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],
  YT = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function ms(n, e) {
  return new js(
    "unit out of range",
    `you specified ${e} (of type ${typeof e}) as a ${n}, which is invalid`,
  );
}
function Kb(n, e, t) {
  const i = new Date(Date.UTC(n, e - 1, t));
  n < 100 && n >= 0 && i.setUTCFullYear(i.getUTCFullYear() - 1900);
  const r = i.getUTCDay();
  return r === 0 ? 7 : r;
}
function XT(n, e, t) {
  return t + (hp(n) ? YT : zT)[e - 1];
}
function KT(n, e) {
  const t = hp(n) ? YT : zT,
    i = t.findIndex((s) => s < e),
    r = e - t[i];
  return { month: i + 1, day: r };
}
function jb(n, e) {
  return ((n - e + 7) % 7) + 1;
}
function ym(n, e = 4, t = 1) {
  const { year: i, month: r, day: s } = n,
    o = XT(i, r, s),
    a = jb(Kb(i, r, s), t);
  let l = Math.floor((o - a + 14 - e) / 7),
    c;
  return (
    l < 1
      ? ((c = i - 1), (l = wg(c, e, t)))
      : l > wg(i, e, t)
        ? ((c = i + 1), (l = 1))
        : (c = i),
    { weekYear: c, weekNumber: l, weekday: a, ...UC(n) }
  );
}
function h9(n, e = 4, t = 1) {
  const { weekYear: i, weekNumber: r, weekday: s } = n,
    o = jb(Kb(i, 1, e), t),
    a = Mh(i);
  let l = r * 7 + s - o - 7 + e,
    c;
  l < 1
    ? ((c = i - 1), (l += Mh(c)))
    : l > a
      ? ((c = i + 1), (l -= Mh(i)))
      : (c = i);
  const { month: u, day: h } = KT(c, l);
  return { year: c, month: u, day: h, ...UC(n) };
}
function zI(n) {
  const { year: e, month: t, day: i } = n,
    r = XT(e, t, i);
  return { year: e, ordinal: r, ...UC(n) };
}
function d9(n) {
  const { year: e, ordinal: t } = n,
    { month: i, day: r } = KT(e, t);
  return { year: e, month: i, day: r, ...UC(n) };
}
function f9(n, e) {
  if (!_t(n.localWeekday) || !_t(n.localWeekNumber) || !_t(n.localWeekYear)) {
    if (!_t(n.weekday) || !_t(n.weekNumber) || !_t(n.weekYear))
      throw new Ch(
        "Cannot mix locale-based week fields with ISO-based week fields",
      );
    return (
      _t(n.localWeekday) || (n.weekday = n.localWeekday),
      _t(n.localWeekNumber) || (n.weekNumber = n.localWeekNumber),
      _t(n.localWeekYear) || (n.weekYear = n.localWeekYear),
      delete n.localWeekday,
      delete n.localWeekNumber,
      delete n.localWeekYear,
      {
        minDaysInFirstWeek: e.getMinDaysInFirstWeek(),
        startOfWeek: e.getStartOfWeek(),
      }
    );
  } else return { minDaysInFirstWeek: 4, startOfWeek: 1 };
}
function ZV(n, e = 4, t = 1) {
  const i = FC(n.weekYear),
    r = Cs(n.weekNumber, 1, wg(n.weekYear, e, t)),
    s = Cs(n.weekday, 1, 7);
  return i
    ? r
      ? s
        ? !1
        : ms("weekday", n.weekday)
      : ms("week", n.weekNumber)
    : ms("weekYear", n.weekYear);
}
function zV(n) {
  const e = FC(n.year),
    t = Cs(n.ordinal, 1, Mh(n.year));
  return e ? (t ? !1 : ms("ordinal", n.ordinal)) : ms("year", n.year);
}
function jT(n) {
  const e = FC(n.year),
    t = Cs(n.month, 1, 12),
    i = Cs(n.day, 1, _m(n.year, n.month));
  return e
    ? t
      ? i
        ? !1
        : ms("day", n.day)
      : ms("month", n.month)
    : ms("year", n.year);
}
function $T(n) {
  const { hour: e, minute: t, second: i, millisecond: r } = n,
    s = Cs(e, 0, 23) || (e === 24 && t === 0 && i === 0 && r === 0),
    o = Cs(t, 0, 59),
    a = Cs(i, 0, 59),
    l = Cs(r, 0, 999);
  return s
    ? o
      ? a
        ? l
          ? !1
          : ms("millisecond", r)
        : ms("second", i)
      : ms("minute", t)
    : ms("hour", e);
}
function _t(n) {
  return typeof n > "u";
}
function eu(n) {
  return typeof n == "number";
}
function FC(n) {
  return typeof n == "number" && n % 1 === 0;
}
function YV(n) {
  return typeof n == "string";
}
function XV(n) {
  return Object.prototype.toString.call(n) === "[object Date]";
}
function JT() {
  try {
    return typeof Intl < "u" && !!Intl.RelativeTimeFormat;
  } catch {
    return !1;
  }
}
function QT() {
  try {
    return (
      typeof Intl < "u" &&
      !!Intl.Locale &&
      ("weekInfo" in Intl.Locale.prototype ||
        "getWeekInfo" in Intl.Locale.prototype)
    );
  } catch {
    return !1;
  }
}
function KV(n) {
  return Array.isArray(n) ? n : [n];
}
function g9(n, e, t) {
  if (n.length !== 0)
    return n.reduce((i, r) => {
      const s = [e(r), r];
      return i && t(i[0], s[0]) === i[0] ? i : s;
    }, null)[1];
}
function jV(n, e) {
  return e.reduce((t, i) => ((t[i] = n[i]), t), {});
}
function ed(n, e) {
  return Object.prototype.hasOwnProperty.call(n, e);
}
function Gy(n) {
  if (n == null) return null;
  if (typeof n != "object") throw new wr("Week settings must be an object");
  if (
    !Cs(n.firstDay, 1, 7) ||
    !Cs(n.minimalDays, 1, 7) ||
    !Array.isArray(n.weekend) ||
    n.weekend.some((e) => !Cs(e, 1, 7))
  )
    throw new wr("Invalid week settings");
  return {
    firstDay: n.firstDay,
    minimalDays: n.minimalDays,
    weekend: Array.from(n.weekend),
  };
}
function Cs(n, e, t) {
  return FC(n) && n >= e && n <= t;
}
function $V(n, e) {
  return n - e * Math.floor(n / e);
}
function ti(n, e = 2) {
  const t = n < 0;
  let i;
  return (
    t
      ? (i = "-" + ("" + -n).padStart(e, "0"))
      : (i = ("" + n).padStart(e, "0")),
    i
  );
}
function al(n) {
  if (!(_t(n) || n === null || n === "")) return parseInt(n, 10);
}
function ql(n) {
  if (!(_t(n) || n === null || n === "")) return parseFloat(n);
}
function $b(n) {
  if (!(_t(n) || n === null || n === "")) {
    const e = parseFloat("0." + n) * 1e3;
    return Math.floor(e);
  }
}
function Jb(n, e, t = !1) {
  const i = 10 ** e;
  return (t ? Math.trunc : Math.round)(n * i) / i;
}
function hp(n) {
  return n % 4 === 0 && (n % 100 !== 0 || n % 400 === 0);
}
function Mh(n) {
  return hp(n) ? 366 : 365;
}
function _m(n, e) {
  const t = $V(e - 1, 12) + 1,
    i = n + (e - t) / 12;
  return t === 2
    ? hp(i)
      ? 29
      : 28
    : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][t - 1];
}
function kC(n) {
  let e = Date.UTC(
    n.year,
    n.month - 1,
    n.day,
    n.hour,
    n.minute,
    n.second,
    n.millisecond,
  );
  return (
    n.year < 100 &&
      n.year >= 0 &&
      ((e = new Date(e)), e.setUTCFullYear(n.year, n.month - 1, n.day)),
    +e
  );
}
function p9(n, e, t) {
  return -jb(Kb(n, 1, e), t) + e - 1;
}
function wg(n, e = 4, t = 1) {
  const i = p9(n, e, t),
    r = p9(n + 1, e, t);
  return (Mh(n) - i + r) / 7;
}
function Fy(n) {
  return n > 99 ? n : n > $n.twoDigitCutoffYear ? 1900 + n : 2e3 + n;
}
function qT(n, e, t, i = null) {
  const r = new Date(n),
    s = {
      hourCycle: "h23",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
    };
  i && (s.timeZone = i);
  const o = { timeZoneName: e, ...s },
    a = new Intl.DateTimeFormat(t, o)
      .formatToParts(r)
      .find((l) => l.type.toLowerCase() === "timezonename");
  return a ? a.value : null;
}
function OC(n, e) {
  let t = parseInt(n, 10);
  Number.isNaN(t) && (t = 0);
  const i = parseInt(e, 10) || 0,
    r = t < 0 || Object.is(t, -0) ? -i : i;
  return t * 60 + r;
}
function eE(n) {
  const e = Number(n);
  if (typeof n == "boolean" || n === "" || Number.isNaN(e))
    throw new wr(`Invalid unit value ${n}`);
  return e;
}
function bm(n, e) {
  const t = {};
  for (const i in n)
    if (ed(n, i)) {
      const r = n[i];
      if (r == null) continue;
      t[e(i)] = eE(r);
    }
  return t;
}
function Jf(n, e) {
  const t = Math.trunc(Math.abs(n / 60)),
    i = Math.trunc(Math.abs(n % 60)),
    r = n >= 0 ? "+" : "-";
  switch (e) {
    case "short":
      return `${r}${ti(t, 2)}:${ti(i, 2)}`;
    case "narrow":
      return `${r}${t}${i > 0 ? `:${i}` : ""}`;
    case "techie":
      return `${r}${ti(t, 2)}${ti(i, 2)}`;
    default:
      throw new RangeError(
        `Value format ${e} is out of range for property format`,
      );
  }
}
function UC(n) {
  return jV(n, ["hour", "minute", "second", "millisecond"]);
}
const JV = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December",
  ],
  tE = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec",
  ],
  QV = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function nE(n) {
  switch (n) {
    case "narrow":
      return [...QV];
    case "short":
      return [...tE];
    case "long":
      return [...JV];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return [
        "01",
        "02",
        "03",
        "04",
        "05",
        "06",
        "07",
        "08",
        "09",
        "10",
        "11",
        "12",
      ];
    default:
      return null;
  }
}
const iE = [
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
    "Sunday",
  ],
  rE = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
  qV = ["M", "T", "W", "T", "F", "S", "S"];
function sE(n) {
  switch (n) {
    case "narrow":
      return [...qV];
    case "short":
      return [...rE];
    case "long":
      return [...iE];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const oE = ["AM", "PM"],
  eZ = ["Before Christ", "Anno Domini"],
  tZ = ["BC", "AD"],
  nZ = ["B", "A"];
function aE(n) {
  switch (n) {
    case "narrow":
      return [...nZ];
    case "short":
      return [...tZ];
    case "long":
      return [...eZ];
    default:
      return null;
  }
}
function iZ(n) {
  return oE[n.hour < 12 ? 0 : 1];
}
function rZ(n, e) {
  return sE(e)[n.weekday - 1];
}
function sZ(n, e) {
  return nE(e)[n.month - 1];
}
function oZ(n, e) {
  return aE(e)[n.year < 0 ? 0 : 1];
}
function aZ(n, e, t = "always", i = !1) {
  const r = {
      years: ["year", "yr."],
      quarters: ["quarter", "qtr."],
      months: ["month", "mo."],
      weeks: ["week", "wk."],
      days: ["day", "day", "days"],
      hours: ["hour", "hr."],
      minutes: ["minute", "min."],
      seconds: ["second", "sec."],
    },
    s = ["hours", "minutes", "seconds"].indexOf(n) === -1;
  if (t === "auto" && s) {
    const h = n === "days";
    switch (e) {
      case 1:
        return h ? "tomorrow" : `next ${r[n][0]}`;
      case -1:
        return h ? "yesterday" : `last ${r[n][0]}`;
      case 0:
        return h ? "today" : `this ${r[n][0]}`;
    }
  }
  const o = Object.is(e, -0) || e < 0,
    a = Math.abs(e),
    l = a === 1,
    c = r[n],
    u = i ? (l ? c[1] : c[2] || c[1]) : l ? r[n][0] : n;
  return o ? `${a} ${u} ago` : `in ${a} ${u}`;
}
function m9(n, e) {
  let t = "";
  for (const i of n) i.literal ? (t += i.val) : (t += e(i.val));
  return t;
}
const lZ = {
  D: Am,
  DD: ST,
  DDD: TT,
  DDDD: ET,
  t: MT,
  tt: LT,
  ttt: RT,
  tttt: BT,
  T: PT,
  TT: NT,
  TTT: DT,
  TTTT: GT,
  f: FT,
  ff: OT,
  fff: HT,
  ffff: VT,
  F: kT,
  FF: UT,
  FFF: WT,
  FFFF: ZT,
};
class Xi {
  static create(e, t = {}) {
    return new Xi(e, t);
  }
  static parseFormat(e) {
    let t = null,
      i = "",
      r = !1;
    const s = [];
    for (let o = 0; o < e.length; o++) {
      const a = e.charAt(o);
      a === "'"
        ? (i.length > 0 && s.push({ literal: r || /^\s+$/.test(i), val: i }),
          (t = null),
          (i = ""),
          (r = !r))
        : r || a === t
          ? (i += a)
          : (i.length > 0 && s.push({ literal: /^\s+$/.test(i), val: i }),
            (i = a),
            (t = a));
    }
    return (
      i.length > 0 && s.push({ literal: r || /^\s+$/.test(i), val: i }),
      s
    );
  }
  static macroTokenToFormatOpts(e) {
    return lZ[e];
  }
  constructor(e, t) {
    ((this.opts = t), (this.loc = e), (this.systemLoc = null));
  }
  formatWithSystemDefault(e, t) {
    return (
      this.systemLoc === null &&
        (this.systemLoc = this.loc.redefaultToSystem()),
      this.systemLoc.dtFormatter(e, { ...this.opts, ...t }).format()
    );
  }
  dtFormatter(e, t = {}) {
    return this.loc.dtFormatter(e, { ...this.opts, ...t });
  }
  formatDateTime(e, t) {
    return this.dtFormatter(e, t).format();
  }
  formatDateTimeParts(e, t) {
    return this.dtFormatter(e, t).formatToParts();
  }
  formatInterval(e, t) {
    return this.dtFormatter(e.start, t).dtf.formatRange(
      e.start.toJSDate(),
      e.end.toJSDate(),
    );
  }
  resolvedOptions(e, t) {
    return this.dtFormatter(e, t).resolvedOptions();
  }
  num(e, t = 0) {
    if (this.opts.forceSimple) return ti(e, t);
    const i = { ...this.opts };
    return (t > 0 && (i.padTo = t), this.loc.numberFormatter(i).format(e));
  }
  formatDateTimeFromString(e, t) {
    const i = this.loc.listingMode() === "en",
      r = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory",
      s = (f, g) => this.loc.extract(e, f, g),
      o = (f) =>
        e.isOffsetFixed && e.offset === 0 && f.allowZ
          ? "Z"
          : e.isValid
            ? e.zone.formatOffset(e.ts, f.format)
            : "",
      a = () =>
        i ? iZ(e) : s({ hour: "numeric", hourCycle: "h12" }, "dayperiod"),
      l = (f, g) =>
        i
          ? sZ(e, f)
          : s(g ? { month: f } : { month: f, day: "numeric" }, "month"),
      c = (f, g) =>
        i
          ? rZ(e, f)
          : s(
              g
                ? { weekday: f }
                : { weekday: f, month: "long", day: "numeric" },
              "weekday",
            ),
      u = (f) => {
        const g = Xi.macroTokenToFormatOpts(f);
        return g ? this.formatWithSystemDefault(e, g) : f;
      },
      h = (f) => (i ? oZ(e, f) : s({ era: f }, "era")),
      d = (f) => {
        switch (f) {
          case "S":
            return this.num(e.millisecond);
          case "u":
          case "SSS":
            return this.num(e.millisecond, 3);
          case "s":
            return this.num(e.second);
          case "ss":
            return this.num(e.second, 2);
          case "uu":
            return this.num(Math.floor(e.millisecond / 10), 2);
          case "uuu":
            return this.num(Math.floor(e.millisecond / 100));
          case "m":
            return this.num(e.minute);
          case "mm":
            return this.num(e.minute, 2);
          case "h":
            return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12);
          case "hh":
            return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12, 2);
          case "H":
            return this.num(e.hour);
          case "HH":
            return this.num(e.hour, 2);
          case "Z":
            return o({ format: "narrow", allowZ: this.opts.allowZ });
          case "ZZ":
            return o({ format: "short", allowZ: this.opts.allowZ });
          case "ZZZ":
            return o({ format: "techie", allowZ: this.opts.allowZ });
          case "ZZZZ":
            return e.zone.offsetName(e.ts, {
              format: "short",
              locale: this.loc.locale,
            });
          case "ZZZZZ":
            return e.zone.offsetName(e.ts, {
              format: "long",
              locale: this.loc.locale,
            });
          case "z":
            return e.zoneName;
          case "a":
            return a();
          case "d":
            return r ? s({ day: "numeric" }, "day") : this.num(e.day);
          case "dd":
            return r ? s({ day: "2-digit" }, "day") : this.num(e.day, 2);
          case "c":
            return this.num(e.weekday);
          case "ccc":
            return c("short", !0);
          case "cccc":
            return c("long", !0);
          case "ccccc":
            return c("narrow", !0);
          case "E":
            return this.num(e.weekday);
          case "EEE":
            return c("short", !1);
          case "EEEE":
            return c("long", !1);
          case "EEEEE":
            return c("narrow", !1);
          case "L":
            return r
              ? s({ month: "numeric", day: "numeric" }, "month")
              : this.num(e.month);
          case "LL":
            return r
              ? s({ month: "2-digit", day: "numeric" }, "month")
              : this.num(e.month, 2);
          case "LLL":
            return l("short", !0);
          case "LLLL":
            return l("long", !0);
          case "LLLLL":
            return l("narrow", !0);
          case "M":
            return r ? s({ month: "numeric" }, "month") : this.num(e.month);
          case "MM":
            return r ? s({ month: "2-digit" }, "month") : this.num(e.month, 2);
          case "MMM":
            return l("short", !1);
          case "MMMM":
            return l("long", !1);
          case "MMMMM":
            return l("narrow", !1);
          case "y":
            return r ? s({ year: "numeric" }, "year") : this.num(e.year);
          case "yy":
            return r
              ? s({ year: "2-digit" }, "year")
              : this.num(e.year.toString().slice(-2), 2);
          case "yyyy":
            return r ? s({ year: "numeric" }, "year") : this.num(e.year, 4);
          case "yyyyyy":
            return r ? s({ year: "numeric" }, "year") : this.num(e.year, 6);
          case "G":
            return h("short");
          case "GG":
            return h("long");
          case "GGGGG":
            return h("narrow");
          case "kk":
            return this.num(e.weekYear.toString().slice(-2), 2);
          case "kkkk":
            return this.num(e.weekYear, 4);
          case "W":
            return this.num(e.weekNumber);
          case "WW":
            return this.num(e.weekNumber, 2);
          case "n":
            return this.num(e.localWeekNumber);
          case "nn":
            return this.num(e.localWeekNumber, 2);
          case "ii":
            return this.num(e.localWeekYear.toString().slice(-2), 2);
          case "iiii":
            return this.num(e.localWeekYear, 4);
          case "o":
            return this.num(e.ordinal);
          case "ooo":
            return this.num(e.ordinal, 3);
          case "q":
            return this.num(e.quarter);
          case "qq":
            return this.num(e.quarter, 2);
          case "X":
            return this.num(Math.floor(e.ts / 1e3));
          case "x":
            return this.num(e.ts);
          default:
            return u(f);
        }
      };
    return m9(Xi.parseFormat(t), d);
  }
  formatDurationFromString(e, t) {
    const i = (l) => {
        switch (l[0]) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
            return "hour";
          case "d":
            return "day";
          case "w":
            return "week";
          case "M":
            return "month";
          case "y":
            return "year";
          default:
            return null;
        }
      },
      r = (l) => (c) => {
        const u = i(c);
        return u ? this.num(l.get(u), c.length) : c;
      },
      s = Xi.parseFormat(t),
      o = s.reduce((l, { literal: c, val: u }) => (c ? l : l.concat(u)), []),
      a = e.shiftTo(...o.map(i).filter((l) => l));
    return m9(s, r(a));
  }
}
const lE =
  /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function Nd(...n) {
  const e = n.reduce((t, i) => t + i.source, "");
  return RegExp(`^${e}$`);
}
function Dd(...n) {
  return (e) =>
    n
      .reduce(
        ([t, i, r], s) => {
          const [o, a, l] = s(e, r);
          return [{ ...t, ...o }, a || i, l];
        },
        [{}, null, 1],
      )
      .slice(0, 2);
}
function Gd(n, ...e) {
  if (n == null) return [null, null];
  for (const [t, i] of e) {
    const r = t.exec(n);
    if (r) return i(r);
  }
  return [null, null];
}
function cE(...n) {
  return (e, t) => {
    const i = {};
    let r;
    for (r = 0; r < n.length; r++) i[n[r]] = al(e[t + r]);
    return [i, null, t + r];
  };
}
const uE = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/,
  cZ = `(?:${uE.source}?(?:\\[(${lE.source})\\])?)?`,
  Qb = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/,
  hE = RegExp(`${Qb.source}${cZ}`),
  qb = RegExp(`(?:T${hE.source})?`),
  uZ = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/,
  hZ = /(\d{4})-?W(\d\d)(?:-?(\d))?/,
  dZ = /(\d{4})-?(\d{3})/,
  fZ = cE("weekYear", "weekNumber", "weekDay"),
  gZ = cE("year", "ordinal"),
  pZ = /(\d{4})-(\d\d)-(\d\d)/,
  dE = RegExp(`${Qb.source} ?(?:${uE.source}|(${lE.source}))?`),
  mZ = RegExp(`(?: ${dE.source})?`);
function Lh(n, e, t) {
  const i = n[e];
  return _t(i) ? t : al(i);
}
function CZ(n, e) {
  return [
    { year: Lh(n, e), month: Lh(n, e + 1, 1), day: Lh(n, e + 2, 1) },
    null,
    e + 3,
  ];
}
function Fd(n, e) {
  return [
    {
      hours: Lh(n, e, 0),
      minutes: Lh(n, e + 1, 0),
      seconds: Lh(n, e + 2, 0),
      milliseconds: $b(n[e + 3]),
    },
    null,
    e + 4,
  ];
}
function dp(n, e) {
  const t = !n[e] && !n[e + 1],
    i = OC(n[e + 1], n[e + 2]),
    r = t ? null : dr.instance(i);
  return [{}, r, e + 3];
}
function fp(n, e) {
  const t = n[e] ? Pa.create(n[e]) : null;
  return [{}, t, e + 1];
}
const IZ = RegExp(`^T?${Qb.source}$`),
  AZ =
    /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function yZ(n) {
  const [e, t, i, r, s, o, a, l, c] = n,
    u = e[0] === "-",
    h = l && l[0] === "-",
    d = (f, g = !1) => (f !== void 0 && (g || (f && u)) ? -f : f);
  return [
    {
      years: d(ql(t)),
      months: d(ql(i)),
      weeks: d(ql(r)),
      days: d(ql(s)),
      hours: d(ql(o)),
      minutes: d(ql(a)),
      seconds: d(ql(l), l === "-0"),
      milliseconds: d($b(c), h),
    },
  ];
}
const _Z = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60,
};
function ev(n, e, t, i, r, s, o) {
  const a = {
    year: e.length === 2 ? Fy(al(e)) : al(e),
    month: tE.indexOf(t) + 1,
    day: al(i),
    hour: al(r),
    minute: al(s),
  };
  return (
    o && (a.second = al(o)),
    n && (a.weekday = n.length > 3 ? iE.indexOf(n) + 1 : rE.indexOf(n) + 1),
    a
  );
}
const bZ =
  /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function vZ(n) {
  const [, e, t, i, r, s, o, a, l, c, u, h] = n,
    d = ev(e, r, i, t, s, o, a);
  let f;
  return (l ? (f = _Z[l]) : c ? (f = 0) : (f = OC(u, h)), [d, new dr(f)]);
}
function xZ(n) {
  return n
    .replace(/\([^()]*\)|[\n\t]/g, " ")
    .replace(/(\s\s+)/g, " ")
    .trim();
}
const wZ =
    /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/,
  SZ =
    /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/,
  TZ =
    /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function C9(n) {
  const [, e, t, i, r, s, o, a] = n;
  return [ev(e, r, i, t, s, o, a), dr.utcInstance];
}
function EZ(n) {
  const [, e, t, i, r, s, o, a] = n;
  return [ev(e, a, t, i, r, s, o), dr.utcInstance];
}
const MZ = Nd(uZ, qb),
  LZ = Nd(hZ, qb),
  RZ = Nd(dZ, qb),
  BZ = Nd(hE),
  fE = Dd(CZ, Fd, dp, fp),
  PZ = Dd(fZ, Fd, dp, fp),
  NZ = Dd(gZ, Fd, dp, fp),
  DZ = Dd(Fd, dp, fp);
function GZ(n) {
  return Gd(n, [MZ, fE], [LZ, PZ], [RZ, NZ], [BZ, DZ]);
}
function FZ(n) {
  return Gd(xZ(n), [bZ, vZ]);
}
function kZ(n) {
  return Gd(n, [wZ, C9], [SZ, C9], [TZ, EZ]);
}
function OZ(n) {
  return Gd(n, [AZ, yZ]);
}
const UZ = Dd(Fd);
function HZ(n) {
  return Gd(n, [IZ, UZ]);
}
const WZ = Nd(pZ, mZ),
  VZ = Nd(dE),
  ZZ = Dd(Fd, dp, fp);
function zZ(n) {
  return Gd(n, [WZ, fE], [VZ, ZZ]);
}
const I9 = "Invalid Duration",
  gE = {
    weeks: {
      days: 7,
      hours: 7 * 24,
      minutes: 7 * 24 * 60,
      seconds: 7 * 24 * 60 * 60,
      milliseconds: 7 * 24 * 60 * 60 * 1e3,
    },
    days: {
      hours: 24,
      minutes: 24 * 60,
      seconds: 24 * 60 * 60,
      milliseconds: 24 * 60 * 60 * 1e3,
    },
    hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
    minutes: { seconds: 60, milliseconds: 60 * 1e3 },
    seconds: { milliseconds: 1e3 },
  },
  YZ = {
    years: {
      quarters: 4,
      months: 12,
      weeks: 52,
      days: 365,
      hours: 365 * 24,
      minutes: 365 * 24 * 60,
      seconds: 365 * 24 * 60 * 60,
      milliseconds: 365 * 24 * 60 * 60 * 1e3,
    },
    quarters: {
      months: 3,
      weeks: 13,
      days: 91,
      hours: 91 * 24,
      minutes: 91 * 24 * 60,
      seconds: 91 * 24 * 60 * 60,
      milliseconds: 91 * 24 * 60 * 60 * 1e3,
    },
    months: {
      weeks: 4,
      days: 30,
      hours: 30 * 24,
      minutes: 30 * 24 * 60,
      seconds: 30 * 24 * 60 * 60,
      milliseconds: 30 * 24 * 60 * 60 * 1e3,
    },
    ...gE,
  },
  as = 146097 / 400,
  Nu = 146097 / 4800,
  XZ = {
    years: {
      quarters: 4,
      months: 12,
      weeks: as / 7,
      days: as,
      hours: as * 24,
      minutes: as * 24 * 60,
      seconds: as * 24 * 60 * 60,
      milliseconds: as * 24 * 60 * 60 * 1e3,
    },
    quarters: {
      months: 3,
      weeks: as / 28,
      days: as / 4,
      hours: (as * 24) / 4,
      minutes: (as * 24 * 60) / 4,
      seconds: (as * 24 * 60 * 60) / 4,
      milliseconds: (as * 24 * 60 * 60 * 1e3) / 4,
    },
    months: {
      weeks: Nu / 7,
      days: Nu,
      hours: Nu * 24,
      minutes: Nu * 24 * 60,
      seconds: Nu * 24 * 60 * 60,
      milliseconds: Nu * 24 * 60 * 60 * 1e3,
    },
    ...gE,
  },
  Hc = [
    "years",
    "quarters",
    "months",
    "weeks",
    "days",
    "hours",
    "minutes",
    "seconds",
    "milliseconds",
  ],
  KZ = Hc.slice(0).reverse();
function Va(n, e, t = !1) {
  const i = {
    values: t ? e.values : { ...n.values, ...(e.values || {}) },
    loc: n.loc.clone(e.loc),
    conversionAccuracy: e.conversionAccuracy || n.conversionAccuracy,
    matrix: e.matrix || n.matrix,
  };
  return new qt(i);
}
function pE(n, e) {
  let t = e.milliseconds ?? 0;
  for (const i of KZ.slice(1)) e[i] && (t += e[i] * n[i].milliseconds);
  return t;
}
function A9(n, e) {
  const t = pE(n, e) < 0 ? -1 : 1;
  (Hc.reduceRight((i, r) => {
    if (_t(e[r])) return i;
    if (i) {
      const s = e[i] * t,
        o = n[r][i],
        a = Math.floor(s / o);
      ((e[r] += a * t), (e[i] -= a * o * t));
    }
    return r;
  }, null),
    Hc.reduce((i, r) => {
      if (_t(e[r])) return i;
      if (i) {
        const s = e[i] % 1;
        ((e[i] -= s), (e[r] += s * n[i][r]));
      }
      return r;
    }, null));
}
function jZ(n) {
  const e = {};
  for (const [t, i] of Object.entries(n)) i !== 0 && (e[t] = i);
  return e;
}
class qt {
  constructor(e) {
    const t = e.conversionAccuracy === "longterm" || !1;
    let i = t ? XZ : YZ;
    (e.matrix && (i = e.matrix),
      (this.values = e.values),
      (this.loc = e.loc || Cn.create()),
      (this.conversionAccuracy = t ? "longterm" : "casual"),
      (this.invalid = e.invalid || null),
      (this.matrix = i),
      (this.isLuxonDuration = !0));
  }
  static fromMillis(e, t) {
    return qt.fromObject({ milliseconds: e }, t);
  }
  static fromObject(e, t = {}) {
    if (e == null || typeof e != "object")
      throw new wr(
        `Duration.fromObject: argument expected to be an object, got ${e === null ? "null" : typeof e}`,
      );
    return new qt({
      values: bm(e, qt.normalizeUnit),
      loc: Cn.fromObject(t),
      conversionAccuracy: t.conversionAccuracy,
      matrix: t.matrix,
    });
  }
  static fromDurationLike(e) {
    if (eu(e)) return qt.fromMillis(e);
    if (qt.isDuration(e)) return e;
    if (typeof e == "object") return qt.fromObject(e);
    throw new wr(`Unknown duration argument ${e} of type ${typeof e}`);
  }
  static fromISO(e, t) {
    const [i] = OZ(e);
    return i
      ? qt.fromObject(i, t)
      : qt.invalid(
          "unparsable",
          `the input "${e}" can't be parsed as ISO 8601`,
        );
  }
  static fromISOTime(e, t) {
    const [i] = HZ(e);
    return i
      ? qt.fromObject(i, t)
      : qt.invalid(
          "unparsable",
          `the input "${e}" can't be parsed as ISO 8601`,
        );
  }
  static invalid(e, t = null) {
    if (!e) throw new wr("need to specify a reason the Duration is invalid");
    const i = e instanceof js ? e : new js(e, t);
    if ($n.throwOnInvalid) throw new bV(i);
    return new qt({ invalid: i });
  }
  static normalizeUnit(e) {
    const t = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds",
    }[e && e.toLowerCase()];
    if (!t) throw new wT(e);
    return t;
  }
  static isDuration(e) {
    return (e && e.isLuxonDuration) || !1;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  toFormat(e, t = {}) {
    const i = { ...t, floor: t.round !== !1 && t.floor !== !1 };
    return this.isValid
      ? Xi.create(this.loc, i).formatDurationFromString(this, e)
      : I9;
  }
  toHuman(e = {}) {
    if (!this.isValid) return I9;
    const t = Hc.map((i) => {
      const r = this.values[i];
      return _t(r)
        ? null
        : this.loc
            .numberFormatter({
              style: "unit",
              unitDisplay: "long",
              ...e,
              unit: i.slice(0, -1),
            })
            .format(r);
    }).filter((i) => i);
    return this.loc
      .listFormatter({
        type: "conjunction",
        style: e.listStyle || "narrow",
        ...e,
      })
      .format(t);
  }
  toObject() {
    return this.isValid ? { ...this.values } : {};
  }
  toISO() {
    if (!this.isValid) return null;
    let e = "P";
    return (
      this.years !== 0 && (e += this.years + "Y"),
      (this.months !== 0 || this.quarters !== 0) &&
        (e += this.months + this.quarters * 3 + "M"),
      this.weeks !== 0 && (e += this.weeks + "W"),
      this.days !== 0 && (e += this.days + "D"),
      (this.hours !== 0 ||
        this.minutes !== 0 ||
        this.seconds !== 0 ||
        this.milliseconds !== 0) &&
        (e += "T"),
      this.hours !== 0 && (e += this.hours + "H"),
      this.minutes !== 0 && (e += this.minutes + "M"),
      (this.seconds !== 0 || this.milliseconds !== 0) &&
        (e += Jb(this.seconds + this.milliseconds / 1e3, 3) + "S"),
      e === "P" && (e += "T0S"),
      e
    );
  }
  toISOTime(e = {}) {
    if (!this.isValid) return null;
    const t = this.toMillis();
    return t < 0 || t >= 864e5
      ? null
      : ((e = {
          suppressMilliseconds: !1,
          suppressSeconds: !1,
          includePrefix: !1,
          format: "extended",
          ...e,
          includeOffset: !1,
        }),
        Rt.fromMillis(t, { zone: "UTC" }).toISOTime(e));
  }
  toJSON() {
    return this.toISO();
  }
  toString() {
    return this.toISO();
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid
      ? `Duration { values: ${JSON.stringify(this.values)} }`
      : `Duration { Invalid, reason: ${this.invalidReason} }`;
  }
  toMillis() {
    return this.isValid ? pE(this.matrix, this.values) : NaN;
  }
  valueOf() {
    return this.toMillis();
  }
  plus(e) {
    if (!this.isValid) return this;
    const t = qt.fromDurationLike(e),
      i = {};
    for (const r of Hc)
      (ed(t.values, r) || ed(this.values, r)) &&
        (i[r] = t.get(r) + this.get(r));
    return Va(this, { values: i }, !0);
  }
  minus(e) {
    if (!this.isValid) return this;
    const t = qt.fromDurationLike(e);
    return this.plus(t.negate());
  }
  mapUnits(e) {
    if (!this.isValid) return this;
    const t = {};
    for (const i of Object.keys(this.values)) t[i] = eE(e(this.values[i], i));
    return Va(this, { values: t }, !0);
  }
  get(e) {
    return this[qt.normalizeUnit(e)];
  }
  set(e) {
    if (!this.isValid) return this;
    const t = { ...this.values, ...bm(e, qt.normalizeUnit) };
    return Va(this, { values: t });
  }
  reconfigure({
    locale: e,
    numberingSystem: t,
    conversionAccuracy: i,
    matrix: r,
  } = {}) {
    const o = {
      loc: this.loc.clone({ locale: e, numberingSystem: t }),
      matrix: r,
      conversionAccuracy: i,
    };
    return Va(this, o);
  }
  as(e) {
    return this.isValid ? this.shiftTo(e).get(e) : NaN;
  }
  normalize() {
    if (!this.isValid) return this;
    const e = this.toObject();
    return (A9(this.matrix, e), Va(this, { values: e }, !0));
  }
  rescale() {
    if (!this.isValid) return this;
    const e = jZ(this.normalize().shiftToAll().toObject());
    return Va(this, { values: e }, !0);
  }
  shiftTo(...e) {
    if (!this.isValid) return this;
    if (e.length === 0) return this;
    e = e.map((o) => qt.normalizeUnit(o));
    const t = {},
      i = {},
      r = this.toObject();
    let s;
    for (const o of Hc)
      if (e.indexOf(o) >= 0) {
        s = o;
        let a = 0;
        for (const c in i) ((a += this.matrix[c][o] * i[c]), (i[c] = 0));
        eu(r[o]) && (a += r[o]);
        const l = Math.trunc(a);
        ((t[o] = l), (i[o] = (a * 1e3 - l * 1e3) / 1e3));
      } else eu(r[o]) && (i[o] = r[o]);
    for (const o in i)
      i[o] !== 0 && (t[s] += o === s ? i[o] : i[o] / this.matrix[s][o]);
    return (A9(this.matrix, t), Va(this, { values: t }, !0));
  }
  shiftToAll() {
    return this.isValid
      ? this.shiftTo(
          "years",
          "months",
          "weeks",
          "days",
          "hours",
          "minutes",
          "seconds",
          "milliseconds",
        )
      : this;
  }
  negate() {
    if (!this.isValid) return this;
    const e = {};
    for (const t of Object.keys(this.values))
      e[t] = this.values[t] === 0 ? 0 : -this.values[t];
    return Va(this, { values: e }, !0);
  }
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  equals(e) {
    if (!this.isValid || !e.isValid || !this.loc.equals(e.loc)) return !1;
    function t(i, r) {
      return i === void 0 || i === 0 ? r === void 0 || r === 0 : i === r;
    }
    for (const i of Hc) if (!t(this.values[i], e.values[i])) return !1;
    return !0;
  }
}
const Du = "Invalid Interval";
function $Z(n, e) {
  return !n || !n.isValid
    ? zn.invalid("missing or invalid start")
    : !e || !e.isValid
      ? zn.invalid("missing or invalid end")
      : e < n
        ? zn.invalid(
            "end before start",
            `The end of an interval must be after its start, but you had start=${n.toISO()} and end=${e.toISO()}`,
          )
        : null;
}
class zn {
  constructor(e) {
    ((this.s = e.start),
      (this.e = e.end),
      (this.invalid = e.invalid || null),
      (this.isLuxonInterval = !0));
  }
  static invalid(e, t = null) {
    if (!e) throw new wr("need to specify a reason the Interval is invalid");
    const i = e instanceof js ? e : new js(e, t);
    if ($n.throwOnInvalid) throw new _V(i);
    return new zn({ invalid: i });
  }
  static fromDateTimes(e, t) {
    const i = sf(e),
      r = sf(t),
      s = $Z(i, r);
    return s ?? new zn({ start: i, end: r });
  }
  static after(e, t) {
    const i = qt.fromDurationLike(t),
      r = sf(e);
    return zn.fromDateTimes(r, r.plus(i));
  }
  static before(e, t) {
    const i = qt.fromDurationLike(t),
      r = sf(e);
    return zn.fromDateTimes(r.minus(i), r);
  }
  static fromISO(e, t) {
    const [i, r] = (e || "").split("/", 2);
    if (i && r) {
      let s, o;
      try {
        ((s = Rt.fromISO(i, t)), (o = s.isValid));
      } catch {
        o = !1;
      }
      let a, l;
      try {
        ((a = Rt.fromISO(r, t)), (l = a.isValid));
      } catch {
        l = !1;
      }
      if (o && l) return zn.fromDateTimes(s, a);
      if (o) {
        const c = qt.fromISO(r, t);
        if (c.isValid) return zn.after(s, c);
      } else if (l) {
        const c = qt.fromISO(i, t);
        if (c.isValid) return zn.before(a, c);
      }
    }
    return zn.invalid(
      "unparsable",
      `the input "${e}" can't be parsed as ISO 8601`,
    );
  }
  static isInterval(e) {
    return (e && e.isLuxonInterval) || !1;
  }
  get start() {
    return this.isValid ? this.s : null;
  }
  get end() {
    return this.isValid ? this.e : null;
  }
  get isValid() {
    return this.invalidReason === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  length(e = "milliseconds") {
    return this.isValid ? this.toDuration(e).get(e) : NaN;
  }
  count(e = "milliseconds", t) {
    if (!this.isValid) return NaN;
    const i = this.start.startOf(e, t);
    let r;
    return (
      t?.useLocaleWeeks
        ? (r = this.end.reconfigure({ locale: i.locale }))
        : (r = this.end),
      (r = r.startOf(e, t)),
      Math.floor(r.diff(i, e).get(e)) + (r.valueOf() !== this.end.valueOf())
    );
  }
  hasSame(e) {
    return this.isValid
      ? this.isEmpty() || this.e.minus(1).hasSame(this.s, e)
      : !1;
  }
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  isAfter(e) {
    return this.isValid ? this.s > e : !1;
  }
  isBefore(e) {
    return this.isValid ? this.e <= e : !1;
  }
  contains(e) {
    return this.isValid ? this.s <= e && this.e > e : !1;
  }
  set({ start: e, end: t } = {}) {
    return this.isValid ? zn.fromDateTimes(e || this.s, t || this.e) : this;
  }
  splitAt(...e) {
    if (!this.isValid) return [];
    const t = e
        .map(sf)
        .filter((o) => this.contains(o))
        .sort((o, a) => o.toMillis() - a.toMillis()),
      i = [];
    let { s: r } = this,
      s = 0;
    for (; r < this.e; ) {
      const o = t[s] || this.e,
        a = +o > +this.e ? this.e : o;
      (i.push(zn.fromDateTimes(r, a)), (r = a), (s += 1));
    }
    return i;
  }
  splitBy(e) {
    const t = qt.fromDurationLike(e);
    if (!this.isValid || !t.isValid || t.as("milliseconds") === 0) return [];
    let { s: i } = this,
      r = 1,
      s;
    const o = [];
    for (; i < this.e; ) {
      const a = this.start.plus(t.mapUnits((l) => l * r));
      ((s = +a > +this.e ? this.e : a),
        o.push(zn.fromDateTimes(i, s)),
        (i = s),
        (r += 1));
    }
    return o;
  }
  divideEqually(e) {
    return this.isValid ? this.splitBy(this.length() / e).slice(0, e) : [];
  }
  overlaps(e) {
    return this.e > e.s && this.s < e.e;
  }
  abutsStart(e) {
    return this.isValid ? +this.e == +e.s : !1;
  }
  abutsEnd(e) {
    return this.isValid ? +e.e == +this.s : !1;
  }
  engulfs(e) {
    return this.isValid ? this.s <= e.s && this.e >= e.e : !1;
  }
  equals(e) {
    return !this.isValid || !e.isValid
      ? !1
      : this.s.equals(e.s) && this.e.equals(e.e);
  }
  intersection(e) {
    if (!this.isValid) return this;
    const t = this.s > e.s ? this.s : e.s,
      i = this.e < e.e ? this.e : e.e;
    return t >= i ? null : zn.fromDateTimes(t, i);
  }
  union(e) {
    if (!this.isValid) return this;
    const t = this.s < e.s ? this.s : e.s,
      i = this.e > e.e ? this.e : e.e;
    return zn.fromDateTimes(t, i);
  }
  static merge(e) {
    const [t, i] = e
      .sort((r, s) => r.s - s.s)
      .reduce(
        ([r, s], o) =>
          s
            ? s.overlaps(o) || s.abutsStart(o)
              ? [r, s.union(o)]
              : [r.concat([s]), o]
            : [r, o],
        [[], null],
      );
    return (i && t.push(i), t);
  }
  static xor(e) {
    let t = null,
      i = 0;
    const r = [],
      s = e.map((l) => [
        { time: l.s, type: "s" },
        { time: l.e, type: "e" },
      ]),
      o = Array.prototype.concat(...s),
      a = o.sort((l, c) => l.time - c.time);
    for (const l of a)
      ((i += l.type === "s" ? 1 : -1),
        i === 1
          ? (t = l.time)
          : (t && +t != +l.time && r.push(zn.fromDateTimes(t, l.time)),
            (t = null)));
    return zn.merge(r);
  }
  difference(...e) {
    return zn
      .xor([this].concat(e))
      .map((t) => this.intersection(t))
      .filter((t) => t && !t.isEmpty());
  }
  toString() {
    return this.isValid ? `[${this.s.toISO()}  ${this.e.toISO()})` : Du;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid
      ? `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`
      : `Interval { Invalid, reason: ${this.invalidReason} }`;
  }
  toLocaleString(e = Am, t = {}) {
    return this.isValid
      ? Xi.create(this.s.loc.clone(t), e).formatInterval(this)
      : Du;
  }
  toISO(e) {
    return this.isValid ? `${this.s.toISO(e)}/${this.e.toISO(e)}` : Du;
  }
  toISODate() {
    return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : Du;
  }
  toISOTime(e) {
    return this.isValid ? `${this.s.toISOTime(e)}/${this.e.toISOTime(e)}` : Du;
  }
  toFormat(e, { separator: t = "  " } = {}) {
    return this.isValid ? `${this.s.toFormat(e)}${t}${this.e.toFormat(e)}` : Du;
  }
  toDuration(e, t) {
    return this.isValid
      ? this.e.diff(this.s, e, t)
      : qt.invalid(this.invalidReason);
  }
  mapEndpoints(e) {
    return zn.fromDateTimes(e(this.s), e(this.e));
  }
}
class Yp {
  static hasDST(e = $n.defaultZone) {
    const t = Rt.now().setZone(e).set({ month: 12 });
    return !e.isUniversal && t.offset !== t.set({ month: 6 }).offset;
  }
  static isValidIANAZone(e) {
    return Pa.isValidZone(e);
  }
  static normalizeZone(e) {
    return hl(e, $n.defaultZone);
  }
  static getStartOfWeek({ locale: e = null, locObj: t = null } = {}) {
    return (t || Cn.create(e)).getStartOfWeek();
  }
  static getMinimumDaysInFirstWeek({
    locale: e = null,
    locObj: t = null,
  } = {}) {
    return (t || Cn.create(e)).getMinDaysInFirstWeek();
  }
  static getWeekendWeekdays({ locale: e = null, locObj: t = null } = {}) {
    return (t || Cn.create(e)).getWeekendDays().slice();
  }
  static months(
    e = "long",
    {
      locale: t = null,
      numberingSystem: i = null,
      locObj: r = null,
      outputCalendar: s = "gregory",
    } = {},
  ) {
    return (r || Cn.create(t, i, s)).months(e);
  }
  static monthsFormat(
    e = "long",
    {
      locale: t = null,
      numberingSystem: i = null,
      locObj: r = null,
      outputCalendar: s = "gregory",
    } = {},
  ) {
    return (r || Cn.create(t, i, s)).months(e, !0);
  }
  static weekdays(
    e = "long",
    { locale: t = null, numberingSystem: i = null, locObj: r = null } = {},
  ) {
    return (r || Cn.create(t, i, null)).weekdays(e);
  }
  static weekdaysFormat(
    e = "long",
    { locale: t = null, numberingSystem: i = null, locObj: r = null } = {},
  ) {
    return (r || Cn.create(t, i, null)).weekdays(e, !0);
  }
  static meridiems({ locale: e = null } = {}) {
    return Cn.create(e).meridiems();
  }
  static eras(e = "short", { locale: t = null } = {}) {
    return Cn.create(t, null, "gregory").eras(e);
  }
  static features() {
    return { relative: JT(), localeWeek: QT() };
  }
}
function y9(n, e) {
  const t = (r) => r.toUTC(0, { keepLocalTime: !0 }).startOf("day").valueOf(),
    i = t(e) - t(n);
  return Math.floor(qt.fromMillis(i).as("days"));
}
function JZ(n, e, t) {
  const i = [
      ["years", (l, c) => c.year - l.year],
      ["quarters", (l, c) => c.quarter - l.quarter + (c.year - l.year) * 4],
      ["months", (l, c) => c.month - l.month + (c.year - l.year) * 12],
      [
        "weeks",
        (l, c) => {
          const u = y9(l, c);
          return (u - (u % 7)) / 7;
        },
      ],
      ["days", y9],
    ],
    r = {},
    s = n;
  let o, a;
  for (const [l, c] of i)
    t.indexOf(l) >= 0 &&
      ((o = l),
      (r[l] = c(n, e)),
      (a = s.plus(r)),
      a > e
        ? (r[l]--, (n = s.plus(r)), n > e && ((a = n), r[l]--, (n = s.plus(r))))
        : (n = a));
  return [n, r, a, o];
}
function QZ(n, e, t, i) {
  let [r, s, o, a] = JZ(n, e, t);
  const l = e - r,
    c = t.filter(
      (h) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(h) >= 0,
    );
  c.length === 0 &&
    (o < e && (o = r.plus({ [a]: 1 })),
    o !== r && (s[a] = (s[a] || 0) + l / (o - r)));
  const u = qt.fromObject(s, i);
  return c.length > 0
    ? qt
        .fromMillis(l, i)
        .shiftTo(...c)
        .plus(u)
    : u;
}
const tv = {
    arab: "[-]",
    arabext: "[-]",
    bali: "[-]",
    beng: "[-]",
    deva: "[-]",
    fullwide: "[-]",
    gujr: "[-]",
    hanidec: "[|||||||||]",
    khmr: "[-]",
    knda: "[-]",
    laoo: "[-]",
    limb: "[-]",
    mlym: "[-]",
    mong: "[-]",
    mymr: "[-]",
    orya: "[-]",
    tamldec: "[-]",
    telu: "[-]",
    thai: "[-]",
    tibt: "[-]",
    latn: "\\d",
  },
  _9 = {
    arab: [1632, 1641],
    arabext: [1776, 1785],
    bali: [6992, 7001],
    beng: [2534, 2543],
    deva: [2406, 2415],
    fullwide: [65296, 65303],
    gujr: [2790, 2799],
    khmr: [6112, 6121],
    knda: [3302, 3311],
    laoo: [3792, 3801],
    limb: [6470, 6479],
    mlym: [3430, 3439],
    mong: [6160, 6169],
    mymr: [4160, 4169],
    orya: [2918, 2927],
    tamldec: [3046, 3055],
    telu: [3174, 3183],
    thai: [3664, 3673],
    tibt: [3872, 3881],
  },
  qZ = tv.hanidec.replace(/[\[|\]]/g, "").split("");
function ez(n) {
  let e = parseInt(n, 10);
  if (isNaN(e)) {
    e = "";
    for (let t = 0; t < n.length; t++) {
      const i = n.charCodeAt(t);
      if (n[t].search(tv.hanidec) !== -1) e += qZ.indexOf(n[t]);
      else
        for (const r in _9) {
          const [s, o] = _9[r];
          i >= s && i <= o && (e += i - s);
        }
    }
    return parseInt(e, 10);
  } else return e;
}
function Ps({ numberingSystem: n }, e = "") {
  return new RegExp(`${tv[n || "latn"]}${e}`);
}
const tz = "missing Intl.DateTimeFormat.formatToParts support";
function on(n, e = (t) => t) {
  return { regex: n, deser: ([t]) => e(ez(t)) };
}
const nz = String.fromCharCode(160),
  mE = `[ ${nz}]`,
  CE = new RegExp(mE, "g");
function iz(n) {
  return n.replace(/\./g, "\\.?").replace(CE, mE);
}
function b9(n) {
  return n.replace(/\./g, "").replace(CE, " ").toLowerCase();
}
function Ns(n, e) {
  return n === null
    ? null
    : {
        regex: RegExp(n.map(iz).join("|")),
        deser: ([t]) => n.findIndex((i) => b9(t) === b9(i)) + e,
      };
}
function v9(n, e) {
  return { regex: n, deser: ([, t, i]) => OC(t, i), groups: e };
}
function Xp(n) {
  return { regex: n, deser: ([e]) => e };
}
function rz(n) {
  return n.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function sz(n, e) {
  const t = Ps(e),
    i = Ps(e, "{2}"),
    r = Ps(e, "{3}"),
    s = Ps(e, "{4}"),
    o = Ps(e, "{6}"),
    a = Ps(e, "{1,2}"),
    l = Ps(e, "{1,3}"),
    c = Ps(e, "{1,6}"),
    u = Ps(e, "{1,9}"),
    h = Ps(e, "{2,4}"),
    d = Ps(e, "{4,6}"),
    f = (m) => ({ regex: RegExp(rz(m.val)), deser: ([C]) => C, literal: !0 }),
    p = ((m) => {
      if (n.literal) return f(m);
      switch (m.val) {
        case "G":
          return Ns(e.eras("short"), 0);
        case "GG":
          return Ns(e.eras("long"), 0);
        case "y":
          return on(c);
        case "yy":
          return on(h, Fy);
        case "yyyy":
          return on(s);
        case "yyyyy":
          return on(d);
        case "yyyyyy":
          return on(o);
        case "M":
          return on(a);
        case "MM":
          return on(i);
        case "MMM":
          return Ns(e.months("short", !0), 1);
        case "MMMM":
          return Ns(e.months("long", !0), 1);
        case "L":
          return on(a);
        case "LL":
          return on(i);
        case "LLL":
          return Ns(e.months("short", !1), 1);
        case "LLLL":
          return Ns(e.months("long", !1), 1);
        case "d":
          return on(a);
        case "dd":
          return on(i);
        case "o":
          return on(l);
        case "ooo":
          return on(r);
        case "HH":
          return on(i);
        case "H":
          return on(a);
        case "hh":
          return on(i);
        case "h":
          return on(a);
        case "mm":
          return on(i);
        case "m":
          return on(a);
        case "q":
          return on(a);
        case "qq":
          return on(i);
        case "s":
          return on(a);
        case "ss":
          return on(i);
        case "S":
          return on(l);
        case "SSS":
          return on(r);
        case "u":
          return Xp(u);
        case "uu":
          return Xp(a);
        case "uuu":
          return on(t);
        case "a":
          return Ns(e.meridiems(), 0);
        case "kkkk":
          return on(s);
        case "kk":
          return on(h, Fy);
        case "W":
          return on(a);
        case "WW":
          return on(i);
        case "E":
        case "c":
          return on(t);
        case "EEE":
          return Ns(e.weekdays("short", !1), 1);
        case "EEEE":
          return Ns(e.weekdays("long", !1), 1);
        case "ccc":
          return Ns(e.weekdays("short", !0), 1);
        case "cccc":
          return Ns(e.weekdays("long", !0), 1);
        case "Z":
        case "ZZ":
          return v9(new RegExp(`([+-]${a.source})(?::(${i.source}))?`), 2);
        case "ZZZ":
          return v9(new RegExp(`([+-]${a.source})(${i.source})?`), 2);
        case "z":
          return Xp(/[a-z_+-/]{1,256}?/i);
        case " ":
          return Xp(/[^\S\n\r]/);
        default:
          return f(m);
      }
    })(n) || { invalidReason: tz };
  return ((p.token = n), p);
}
const oz = {
  year: { "2-digit": "yy", numeric: "yyyyy" },
  month: { numeric: "M", "2-digit": "MM", short: "MMM", long: "MMMM" },
  day: { numeric: "d", "2-digit": "dd" },
  weekday: { short: "EEE", long: "EEEE" },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: { numeric: "h", "2-digit": "hh" },
  hour24: { numeric: "H", "2-digit": "HH" },
  minute: { numeric: "m", "2-digit": "mm" },
  second: { numeric: "s", "2-digit": "ss" },
  timeZoneName: { long: "ZZZZZ", short: "ZZZ" },
};
function az(n, e, t) {
  const { type: i, value: r } = n;
  if (i === "literal") {
    const l = /^\s+$/.test(r);
    return { literal: !l, val: l ? " " : r };
  }
  const s = e[i];
  let o = i;
  i === "hour" &&
    (e.hour12 != null
      ? (o = e.hour12 ? "hour12" : "hour24")
      : e.hourCycle != null
        ? e.hourCycle === "h11" || e.hourCycle === "h12"
          ? (o = "hour12")
          : (o = "hour24")
        : (o = t.hour12 ? "hour12" : "hour24"));
  let a = oz[o];
  if ((typeof a == "object" && (a = a[s]), a)) return { literal: !1, val: a };
}
function lz(n) {
  return [
    `^${n.map((t) => t.regex).reduce((t, i) => `${t}(${i.source})`, "")}$`,
    n,
  ];
}
function cz(n, e, t) {
  const i = n.match(e);
  if (i) {
    const r = {};
    let s = 1;
    for (const o in t)
      if (ed(t, o)) {
        const a = t[o],
          l = a.groups ? a.groups + 1 : 1;
        (!a.literal &&
          a.token &&
          (r[a.token.val[0]] = a.deser(i.slice(s, s + l))),
          (s += l));
      }
    return [i, r];
  } else return [i, {}];
}
function uz(n) {
  const e = (s) => {
    switch (s) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let t = null,
    i;
  return (
    _t(n.z) || (t = Pa.create(n.z)),
    _t(n.Z) || (t || (t = new dr(n.Z)), (i = n.Z)),
    _t(n.q) || (n.M = (n.q - 1) * 3 + 1),
    _t(n.h) ||
      (n.h < 12 && n.a === 1
        ? (n.h += 12)
        : n.h === 12 && n.a === 0 && (n.h = 0)),
    n.G === 0 && n.y && (n.y = -n.y),
    _t(n.u) || (n.S = $b(n.u)),
    [
      Object.keys(n).reduce((s, o) => {
        const a = e(o);
        return (a && (s[a] = n[o]), s);
      }, {}),
      t,
      i,
    ]
  );
}
let YI = null;
function hz() {
  return (YI || (YI = Rt.fromMillis(1555555555555)), YI);
}
function dz(n, e) {
  if (n.literal) return n;
  const t = Xi.macroTokenToFormatOpts(n.val),
    i = yE(t, e);
  return i == null || i.includes(void 0) ? n : i;
}
function IE(n, e) {
  return Array.prototype.concat(...n.map((t) => dz(t, e)));
}
function AE(n, e, t) {
  const i = IE(Xi.parseFormat(t), n),
    r = i.map((o) => sz(o, n)),
    s = r.find((o) => o.invalidReason);
  if (s) return { input: e, tokens: i, invalidReason: s.invalidReason };
  {
    const [o, a] = lz(r),
      l = RegExp(o, "i"),
      [c, u] = cz(e, l, a),
      [h, d, f] = u ? uz(u) : [null, null, void 0];
    if (ed(u, "a") && ed(u, "H"))
      throw new Ch("Can't include meridiem when specifying 24-hour format");
    return {
      input: e,
      tokens: i,
      regex: l,
      rawMatches: c,
      matches: u,
      result: h,
      zone: d,
      specificOffset: f,
    };
  }
}
function fz(n, e, t) {
  const {
    result: i,
    zone: r,
    specificOffset: s,
    invalidReason: o,
  } = AE(n, e, t);
  return [i, r, s, o];
}
function yE(n, e) {
  if (!n) return null;
  const i = Xi.create(e, n).dtFormatter(hz()),
    r = i.formatToParts(),
    s = i.resolvedOptions();
  return r.map((o) => az(o, n, s));
}
const XI = "Invalid DateTime",
  x9 = 864e13;
function Kp(n) {
  return new js("unsupported zone", `the zone "${n.name}" is not supported`);
}
function KI(n) {
  return (n.weekData === null && (n.weekData = ym(n.c)), n.weekData);
}
function jI(n) {
  return (
    n.localWeekData === null &&
      (n.localWeekData = ym(
        n.c,
        n.loc.getMinDaysInFirstWeek(),
        n.loc.getStartOfWeek(),
      )),
    n.localWeekData
  );
}
function ec(n, e) {
  const t = {
    ts: n.ts,
    zone: n.zone,
    c: n.c,
    o: n.o,
    loc: n.loc,
    invalid: n.invalid,
  };
  return new Rt({ ...t, ...e, old: t });
}
function _E(n, e, t) {
  let i = n - e * 60 * 1e3;
  const r = t.offset(i);
  if (e === r) return [i, e];
  i -= (r - e) * 60 * 1e3;
  const s = t.offset(i);
  return r === s ? [i, r] : [n - Math.min(r, s) * 60 * 1e3, Math.max(r, s)];
}
function jp(n, e) {
  n += e * 60 * 1e3;
  const t = new Date(n);
  return {
    year: t.getUTCFullYear(),
    month: t.getUTCMonth() + 1,
    day: t.getUTCDate(),
    hour: t.getUTCHours(),
    minute: t.getUTCMinutes(),
    second: t.getUTCSeconds(),
    millisecond: t.getUTCMilliseconds(),
  };
}
function m0(n, e, t) {
  return _E(kC(n), e, t);
}
function w9(n, e) {
  const t = n.o,
    i = n.c.year + Math.trunc(e.years),
    r = n.c.month + Math.trunc(e.months) + Math.trunc(e.quarters) * 3,
    s = {
      ...n.c,
      year: i,
      month: r,
      day:
        Math.min(n.c.day, _m(i, r)) +
        Math.trunc(e.days) +
        Math.trunc(e.weeks) * 7,
    },
    o = qt
      .fromObject({
        years: e.years - Math.trunc(e.years),
        quarters: e.quarters - Math.trunc(e.quarters),
        months: e.months - Math.trunc(e.months),
        weeks: e.weeks - Math.trunc(e.weeks),
        days: e.days - Math.trunc(e.days),
        hours: e.hours,
        minutes: e.minutes,
        seconds: e.seconds,
        milliseconds: e.milliseconds,
      })
      .as("milliseconds"),
    a = kC(s);
  let [l, c] = _E(a, t, n.zone);
  return (o !== 0 && ((l += o), (c = n.zone.offset(l))), { ts: l, o: c });
}
function rf(n, e, t, i, r, s) {
  const { setZone: o, zone: a } = t;
  if ((n && Object.keys(n).length !== 0) || e) {
    const l = e || a,
      c = Rt.fromObject(n, { ...t, zone: l, specificOffset: s });
    return o ? c : c.setZone(a);
  } else
    return Rt.invalid(
      new js("unparsable", `the input "${r}" can't be parsed as ${i}`),
    );
}
function $p(n, e, t = !0) {
  return n.isValid
    ? Xi.create(Cn.create("en-US"), {
        allowZ: t,
        forceSimple: !0,
      }).formatDateTimeFromString(n, e)
    : null;
}
function $I(n, e) {
  const t = n.c.year > 9999 || n.c.year < 0;
  let i = "";
  return (
    t && n.c.year >= 0 && (i += "+"),
    (i += ti(n.c.year, t ? 6 : 4)),
    e
      ? ((i += "-"), (i += ti(n.c.month)), (i += "-"), (i += ti(n.c.day)))
      : ((i += ti(n.c.month)), (i += ti(n.c.day))),
    i
  );
}
function S9(n, e, t, i, r, s) {
  let o = ti(n.c.hour);
  return (
    e
      ? ((o += ":"),
        (o += ti(n.c.minute)),
        (n.c.millisecond !== 0 || n.c.second !== 0 || !t) && (o += ":"))
      : (o += ti(n.c.minute)),
    (n.c.millisecond !== 0 || n.c.second !== 0 || !t) &&
      ((o += ti(n.c.second)),
      (n.c.millisecond !== 0 || !i) &&
        ((o += "."), (o += ti(n.c.millisecond, 3)))),
    r &&
      (n.isOffsetFixed && n.offset === 0 && !s
        ? (o += "Z")
        : n.o < 0
          ? ((o += "-"),
            (o += ti(Math.trunc(-n.o / 60))),
            (o += ":"),
            (o += ti(Math.trunc(-n.o % 60))))
          : ((o += "+"),
            (o += ti(Math.trunc(n.o / 60))),
            (o += ":"),
            (o += ti(Math.trunc(n.o % 60))))),
    s && (o += "[" + n.zone.ianaName + "]"),
    o
  );
}
const bE = { month: 1, day: 1, hour: 0, minute: 0, second: 0, millisecond: 0 },
  gz = {
    weekNumber: 1,
    weekday: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
  },
  pz = { ordinal: 1, hour: 0, minute: 0, second: 0, millisecond: 0 },
  vE = ["year", "month", "day", "hour", "minute", "second", "millisecond"],
  mz = [
    "weekYear",
    "weekNumber",
    "weekday",
    "hour",
    "minute",
    "second",
    "millisecond",
  ],
  Cz = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function Iz(n) {
  const e = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal",
  }[n.toLowerCase()];
  if (!e) throw new wT(n);
  return e;
}
function T9(n) {
  switch (n.toLowerCase()) {
    case "localweekday":
    case "localweekdays":
      return "localWeekday";
    case "localweeknumber":
    case "localweeknumbers":
      return "localWeekNumber";
    case "localweekyear":
    case "localweekyears":
      return "localWeekYear";
    default:
      return Iz(n);
  }
}
function E9(n, e) {
  const t = hl(e.zone, $n.defaultZone),
    i = Cn.fromObject(e),
    r = $n.now();
  let s, o;
  if (_t(n.year)) s = r;
  else {
    for (const c of vE) _t(n[c]) && (n[c] = bE[c]);
    const a = jT(n) || $T(n);
    if (a) return Rt.invalid(a);
    const l = t.offset(r);
    [s, o] = m0(n, l, t);
  }
  return new Rt({ ts: s, zone: t, loc: i, o });
}
function M9(n, e, t) {
  const i = _t(t.round) ? !0 : t.round,
    r = (o, a) => (
      (o = Jb(o, i || t.calendary ? 0 : 2, !0)),
      e.loc.clone(t).relFormatter(t).format(o, a)
    ),
    s = (o) =>
      t.calendary
        ? e.hasSame(n, o)
          ? 0
          : e.startOf(o).diff(n.startOf(o), o).get(o)
        : e.diff(n, o).get(o);
  if (t.unit) return r(s(t.unit), t.unit);
  for (const o of t.units) {
    const a = s(o);
    if (Math.abs(a) >= 1) return r(a, o);
  }
  return r(n > e ? -0 : 0, t.units[t.units.length - 1]);
}
function L9(n) {
  let e = {},
    t;
  return (
    n.length > 0 && typeof n[n.length - 1] == "object"
      ? ((e = n[n.length - 1]), (t = Array.from(n).slice(0, n.length - 1)))
      : (t = Array.from(n)),
    [e, t]
  );
}
class Rt {
  constructor(e) {
    const t = e.zone || $n.defaultZone;
    let i =
      e.invalid ||
      (Number.isNaN(e.ts) ? new js("invalid input") : null) ||
      (t.isValid ? null : Kp(t));
    this.ts = _t(e.ts) ? $n.now() : e.ts;
    let r = null,
      s = null;
    if (!i)
      if (e.old && e.old.ts === this.ts && e.old.zone.equals(t))
        [r, s] = [e.old.c, e.old.o];
      else {
        const a = t.offset(this.ts);
        ((r = jp(this.ts, a)),
          (i = Number.isNaN(r.year) ? new js("invalid input") : null),
          (r = i ? null : r),
          (s = i ? null : a));
      }
    ((this._zone = t),
      (this.loc = e.loc || Cn.create()),
      (this.invalid = i),
      (this.weekData = null),
      (this.localWeekData = null),
      (this.c = r),
      (this.o = s),
      (this.isLuxonDateTime = !0));
  }
  static now() {
    return new Rt({});
  }
  static local() {
    const [e, t] = L9(arguments),
      [i, r, s, o, a, l, c] = t;
    return E9(
      {
        year: i,
        month: r,
        day: s,
        hour: o,
        minute: a,
        second: l,
        millisecond: c,
      },
      e,
    );
  }
  static utc() {
    const [e, t] = L9(arguments),
      [i, r, s, o, a, l, c] = t;
    return (
      (e.zone = dr.utcInstance),
      E9(
        {
          year: i,
          month: r,
          day: s,
          hour: o,
          minute: a,
          second: l,
          millisecond: c,
        },
        e,
      )
    );
  }
  static fromJSDate(e, t = {}) {
    const i = XV(e) ? e.valueOf() : NaN;
    if (Number.isNaN(i)) return Rt.invalid("invalid input");
    const r = hl(t.zone, $n.defaultZone);
    return r.isValid
      ? new Rt({ ts: i, zone: r, loc: Cn.fromObject(t) })
      : Rt.invalid(Kp(r));
  }
  static fromMillis(e, t = {}) {
    if (eu(e))
      return e < -x9 || e > x9
        ? Rt.invalid("Timestamp out of range")
        : new Rt({
            ts: e,
            zone: hl(t.zone, $n.defaultZone),
            loc: Cn.fromObject(t),
          });
    throw new wr(
      `fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`,
    );
  }
  static fromSeconds(e, t = {}) {
    if (eu(e))
      return new Rt({
        ts: e * 1e3,
        zone: hl(t.zone, $n.defaultZone),
        loc: Cn.fromObject(t),
      });
    throw new wr("fromSeconds requires a numerical input");
  }
  static fromObject(e, t = {}) {
    e = e || {};
    const i = hl(t.zone, $n.defaultZone);
    if (!i.isValid) return Rt.invalid(Kp(i));
    const r = Cn.fromObject(t),
      s = bm(e, T9),
      { minDaysInFirstWeek: o, startOfWeek: a } = f9(s, r),
      l = $n.now(),
      c = _t(t.specificOffset) ? i.offset(l) : t.specificOffset,
      u = !_t(s.ordinal),
      h = !_t(s.year),
      d = !_t(s.month) || !_t(s.day),
      f = h || d,
      g = s.weekYear || s.weekNumber;
    if ((f || u) && g)
      throw new Ch(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals",
      );
    if (d && u) throw new Ch("Can't mix ordinal dates with month/day");
    const p = g || (s.weekday && !f);
    let m,
      C,
      A = jp(l, c);
    p
      ? ((m = mz), (C = gz), (A = ym(A, o, a)))
      : u
        ? ((m = Cz), (C = pz), (A = zI(A)))
        : ((m = vE), (C = bE));
    let I = !1;
    for (const b of m) {
      const R = s[b];
      _t(R) ? (I ? (s[b] = C[b]) : (s[b] = A[b])) : (I = !0);
    }
    const y = p ? ZV(s, o, a) : u ? zV(s) : jT(s),
      x = y || $T(s);
    if (x) return Rt.invalid(x);
    const T = p ? h9(s, o, a) : u ? d9(s) : s,
      [S, E] = m0(T, c, i),
      _ = new Rt({ ts: S, zone: i, o: E, loc: r });
    return s.weekday && f && e.weekday !== _.weekday
      ? Rt.invalid(
          "mismatched weekday",
          `you can't specify both a weekday of ${s.weekday} and a date of ${_.toISO()}`,
        )
      : _;
  }
  static fromISO(e, t = {}) {
    const [i, r] = GZ(e);
    return rf(i, r, t, "ISO 8601", e);
  }
  static fromRFC2822(e, t = {}) {
    const [i, r] = FZ(e);
    return rf(i, r, t, "RFC 2822", e);
  }
  static fromHTTP(e, t = {}) {
    const [i, r] = kZ(e);
    return rf(i, r, t, "HTTP", t);
  }
  static fromFormat(e, t, i = {}) {
    if (_t(e) || _t(t))
      throw new wr("fromFormat requires an input string and a format");
    const { locale: r = null, numberingSystem: s = null } = i,
      o = Cn.fromOpts({ locale: r, numberingSystem: s, defaultToEN: !0 }),
      [a, l, c, u] = fz(o, e, t);
    return u ? Rt.invalid(u) : rf(a, l, i, `format ${t}`, e, c);
  }
  static fromString(e, t, i = {}) {
    return Rt.fromFormat(e, t, i);
  }
  static fromSQL(e, t = {}) {
    const [i, r] = zZ(e);
    return rf(i, r, t, "SQL", e);
  }
  static invalid(e, t = null) {
    if (!e) throw new wr("need to specify a reason the DateTime is invalid");
    const i = e instanceof js ? e : new js(e, t);
    if ($n.throwOnInvalid) throw new yV(i);
    return new Rt({ invalid: i });
  }
  static isDateTime(e) {
    return (e && e.isLuxonDateTime) || !1;
  }
  static parseFormatForOpts(e, t = {}) {
    const i = yE(e, Cn.fromObject(t));
    return i ? i.map((r) => (r ? r.val : null)).join("") : null;
  }
  static expandFormat(e, t = {}) {
    return IE(Xi.parseFormat(e), Cn.fromObject(t))
      .map((r) => r.val)
      .join("");
  }
  get(e) {
    return this[e];
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  get zone() {
    return this._zone;
  }
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  get weekYear() {
    return this.isValid ? KI(this).weekYear : NaN;
  }
  get weekNumber() {
    return this.isValid ? KI(this).weekNumber : NaN;
  }
  get weekday() {
    return this.isValid ? KI(this).weekday : NaN;
  }
  get isWeekend() {
    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
  }
  get localWeekday() {
    return this.isValid ? jI(this).weekday : NaN;
  }
  get localWeekNumber() {
    return this.isValid ? jI(this).weekNumber : NaN;
  }
  get localWeekYear() {
    return this.isValid ? jI(this).weekYear : NaN;
  }
  get ordinal() {
    return this.isValid ? zI(this.c).ordinal : NaN;
  }
  get monthShort() {
    return this.isValid
      ? Yp.months("short", { locObj: this.loc })[this.month - 1]
      : null;
  }
  get monthLong() {
    return this.isValid
      ? Yp.months("long", { locObj: this.loc })[this.month - 1]
      : null;
  }
  get weekdayShort() {
    return this.isValid
      ? Yp.weekdays("short", { locObj: this.loc })[this.weekday - 1]
      : null;
  }
  get weekdayLong() {
    return this.isValid
      ? Yp.weekdays("long", { locObj: this.loc })[this.weekday - 1]
      : null;
  }
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  get offsetNameShort() {
    return this.isValid
      ? this.zone.offsetName(this.ts, { format: "short", locale: this.locale })
      : null;
  }
  get offsetNameLong() {
    return this.isValid
      ? this.zone.offsetName(this.ts, { format: "long", locale: this.locale })
      : null;
  }
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  get isInDST() {
    return this.isOffsetFixed
      ? !1
      : this.offset > this.set({ month: 1, day: 1 }).offset ||
          this.offset > this.set({ month: 5 }).offset;
  }
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed) return [this];
    const e = 864e5,
      t = 6e4,
      i = kC(this.c),
      r = this.zone.offset(i - e),
      s = this.zone.offset(i + e),
      o = this.zone.offset(i - r * t),
      a = this.zone.offset(i - s * t);
    if (o === a) return [this];
    const l = i - o * t,
      c = i - a * t,
      u = jp(l, o),
      h = jp(c, a);
    return u.hour === h.hour &&
      u.minute === h.minute &&
      u.second === h.second &&
      u.millisecond === h.millisecond
      ? [ec(this, { ts: l }), ec(this, { ts: c })]
      : [this];
  }
  get isInLeapYear() {
    return hp(this.year);
  }
  get daysInMonth() {
    return _m(this.year, this.month);
  }
  get daysInYear() {
    return this.isValid ? Mh(this.year) : NaN;
  }
  get weeksInWeekYear() {
    return this.isValid ? wg(this.weekYear) : NaN;
  }
  get weeksInLocalWeekYear() {
    return this.isValid
      ? wg(
          this.localWeekYear,
          this.loc.getMinDaysInFirstWeek(),
          this.loc.getStartOfWeek(),
        )
      : NaN;
  }
  resolvedLocaleOptions(e = {}) {
    const {
      locale: t,
      numberingSystem: i,
      calendar: r,
    } = Xi.create(this.loc.clone(e), e).resolvedOptions(this);
    return { locale: t, numberingSystem: i, outputCalendar: r };
  }
  toUTC(e = 0, t = {}) {
    return this.setZone(dr.instance(e), t);
  }
  toLocal() {
    return this.setZone($n.defaultZone);
  }
  setZone(e, { keepLocalTime: t = !1, keepCalendarTime: i = !1 } = {}) {
    if (((e = hl(e, $n.defaultZone)), e.equals(this.zone))) return this;
    if (e.isValid) {
      let r = this.ts;
      if (t || i) {
        const s = e.offset(this.ts),
          o = this.toObject();
        [r] = m0(o, s, e);
      }
      return ec(this, { ts: r, zone: e });
    } else return Rt.invalid(Kp(e));
  }
  reconfigure({ locale: e, numberingSystem: t, outputCalendar: i } = {}) {
    const r = this.loc.clone({
      locale: e,
      numberingSystem: t,
      outputCalendar: i,
    });
    return ec(this, { loc: r });
  }
  setLocale(e) {
    return this.reconfigure({ locale: e });
  }
  set(e) {
    if (!this.isValid) return this;
    const t = bm(e, T9),
      { minDaysInFirstWeek: i, startOfWeek: r } = f9(t, this.loc),
      s = !_t(t.weekYear) || !_t(t.weekNumber) || !_t(t.weekday),
      o = !_t(t.ordinal),
      a = !_t(t.year),
      l = !_t(t.month) || !_t(t.day),
      c = a || l,
      u = t.weekYear || t.weekNumber;
    if ((c || o) && u)
      throw new Ch(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals",
      );
    if (l && o) throw new Ch("Can't mix ordinal dates with month/day");
    let h;
    s
      ? (h = h9({ ...ym(this.c, i, r), ...t }, i, r))
      : _t(t.ordinal)
        ? ((h = { ...this.toObject(), ...t }),
          _t(t.day) && (h.day = Math.min(_m(h.year, h.month), h.day)))
        : (h = d9({ ...zI(this.c), ...t }));
    const [d, f] = m0(h, this.o, this.zone);
    return ec(this, { ts: d, o: f });
  }
  plus(e) {
    if (!this.isValid) return this;
    const t = qt.fromDurationLike(e);
    return ec(this, w9(this, t));
  }
  minus(e) {
    if (!this.isValid) return this;
    const t = qt.fromDurationLike(e).negate();
    return ec(this, w9(this, t));
  }
  startOf(e, { useLocaleWeeks: t = !1 } = {}) {
    if (!this.isValid) return this;
    const i = {},
      r = qt.normalizeUnit(e);
    switch (r) {
      case "years":
        i.month = 1;
      case "quarters":
      case "months":
        i.day = 1;
      case "weeks":
      case "days":
        i.hour = 0;
      case "hours":
        i.minute = 0;
      case "minutes":
        i.second = 0;
      case "seconds":
        i.millisecond = 0;
        break;
    }
    if (r === "weeks")
      if (t) {
        const s = this.loc.getStartOfWeek(),
          { weekday: o } = this;
        (o < s && (i.weekNumber = this.weekNumber - 1), (i.weekday = s));
      } else i.weekday = 1;
    if (r === "quarters") {
      const s = Math.ceil(this.month / 3);
      i.month = (s - 1) * 3 + 1;
    }
    return this.set(i);
  }
  endOf(e, t) {
    return this.isValid
      ? this.plus({ [e]: 1 })
          .startOf(e, t)
          .minus(1)
      : this;
  }
  toFormat(e, t = {}) {
    return this.isValid
      ? Xi.create(this.loc.redefaultToEN(t)).formatDateTimeFromString(this, e)
      : XI;
  }
  toLocaleString(e = Am, t = {}) {
    return this.isValid
      ? Xi.create(this.loc.clone(t), e).formatDateTime(this)
      : XI;
  }
  toLocaleParts(e = {}) {
    return this.isValid
      ? Xi.create(this.loc.clone(e), e).formatDateTimeParts(this)
      : [];
  }
  toISO({
    format: e = "extended",
    suppressSeconds: t = !1,
    suppressMilliseconds: i = !1,
    includeOffset: r = !0,
    extendedZone: s = !1,
  } = {}) {
    if (!this.isValid) return null;
    const o = e === "extended";
    let a = $I(this, o);
    return ((a += "T"), (a += S9(this, o, t, i, r, s)), a);
  }
  toISODate({ format: e = "extended" } = {}) {
    return this.isValid ? $I(this, e === "extended") : null;
  }
  toISOWeekDate() {
    return $p(this, "kkkk-'W'WW-c");
  }
  toISOTime({
    suppressMilliseconds: e = !1,
    suppressSeconds: t = !1,
    includeOffset: i = !0,
    includePrefix: r = !1,
    extendedZone: s = !1,
    format: o = "extended",
  } = {}) {
    return this.isValid
      ? (r ? "T" : "") + S9(this, o === "extended", t, e, i, s)
      : null;
  }
  toRFC2822() {
    return $p(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1);
  }
  toHTTP() {
    return $p(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  toSQLDate() {
    return this.isValid ? $I(this, !0) : null;
  }
  toSQLTime({
    includeOffset: e = !0,
    includeZone: t = !1,
    includeOffsetSpace: i = !0,
  } = {}) {
    let r = "HH:mm:ss.SSS";
    return (
      (t || e) && (i && (r += " "), t ? (r += "z") : e && (r += "ZZ")),
      $p(this, r, !0)
    );
  }
  toSQL(e = {}) {
    return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(e)}` : null;
  }
  toString() {
    return this.isValid ? this.toISO() : XI;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid
      ? `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`
      : `DateTime { Invalid, reason: ${this.invalidReason} }`;
  }
  valueOf() {
    return this.toMillis();
  }
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  toJSON() {
    return this.toISO();
  }
  toBSON() {
    return this.toJSDate();
  }
  toObject(e = {}) {
    if (!this.isValid) return {};
    const t = { ...this.c };
    return (
      e.includeConfig &&
        ((t.outputCalendar = this.outputCalendar),
        (t.numberingSystem = this.loc.numberingSystem),
        (t.locale = this.loc.locale)),
      t
    );
  }
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  diff(e, t = "milliseconds", i = {}) {
    if (!this.isValid || !e.isValid)
      return qt.invalid("created by diffing an invalid DateTime");
    const r = {
        locale: this.locale,
        numberingSystem: this.numberingSystem,
        ...i,
      },
      s = KV(t).map(qt.normalizeUnit),
      o = e.valueOf() > this.valueOf(),
      a = o ? this : e,
      l = o ? e : this,
      c = QZ(a, l, s, r);
    return o ? c.negate() : c;
  }
  diffNow(e = "milliseconds", t = {}) {
    return this.diff(Rt.now(), e, t);
  }
  until(e) {
    return this.isValid ? zn.fromDateTimes(this, e) : this;
  }
  hasSame(e, t, i) {
    if (!this.isValid) return !1;
    const r = e.valueOf(),
      s = this.setZone(e.zone, { keepLocalTime: !0 });
    return s.startOf(t, i) <= r && r <= s.endOf(t, i);
  }
  equals(e) {
    return (
      this.isValid &&
      e.isValid &&
      this.valueOf() === e.valueOf() &&
      this.zone.equals(e.zone) &&
      this.loc.equals(e.loc)
    );
  }
  toRelative(e = {}) {
    if (!this.isValid) return null;
    const t = e.base || Rt.fromObject({}, { zone: this.zone }),
      i = e.padding ? (this < t ? -e.padding : e.padding) : 0;
    let r = ["years", "months", "days", "hours", "minutes", "seconds"],
      s = e.unit;
    return (
      Array.isArray(e.unit) && ((r = e.unit), (s = void 0)),
      M9(t, this.plus(i), { ...e, numeric: "always", units: r, unit: s })
    );
  }
  toRelativeCalendar(e = {}) {
    return this.isValid
      ? M9(e.base || Rt.fromObject({}, { zone: this.zone }), this, {
          ...e,
          numeric: "auto",
          units: ["years", "months", "days"],
          calendary: !0,
        })
      : null;
  }
  static min(...e) {
    if (!e.every(Rt.isDateTime))
      throw new wr("min requires all arguments be DateTimes");
    return g9(e, (t) => t.valueOf(), Math.min);
  }
  static max(...e) {
    if (!e.every(Rt.isDateTime))
      throw new wr("max requires all arguments be DateTimes");
    return g9(e, (t) => t.valueOf(), Math.max);
  }
  static fromFormatExplain(e, t, i = {}) {
    const { locale: r = null, numberingSystem: s = null } = i,
      o = Cn.fromOpts({ locale: r, numberingSystem: s, defaultToEN: !0 });
    return AE(o, e, t);
  }
  static fromStringExplain(e, t, i = {}) {
    return Rt.fromFormatExplain(e, t, i);
  }
  static get DATE_SHORT() {
    return Am;
  }
  static get DATE_MED() {
    return ST;
  }
  static get DATE_MED_WITH_WEEKDAY() {
    return vV;
  }
  static get DATE_FULL() {
    return TT;
  }
  static get DATE_HUGE() {
    return ET;
  }
  static get TIME_SIMPLE() {
    return MT;
  }
  static get TIME_WITH_SECONDS() {
    return LT;
  }
  static get TIME_WITH_SHORT_OFFSET() {
    return RT;
  }
  static get TIME_WITH_LONG_OFFSET() {
    return BT;
  }
  static get TIME_24_SIMPLE() {
    return PT;
  }
  static get TIME_24_WITH_SECONDS() {
    return NT;
  }
  static get TIME_24_WITH_SHORT_OFFSET() {
    return DT;
  }
  static get TIME_24_WITH_LONG_OFFSET() {
    return GT;
  }
  static get DATETIME_SHORT() {
    return FT;
  }
  static get DATETIME_SHORT_WITH_SECONDS() {
    return kT;
  }
  static get DATETIME_MED() {
    return OT;
  }
  static get DATETIME_MED_WITH_SECONDS() {
    return UT;
  }
  static get DATETIME_MED_WITH_WEEKDAY() {
    return xV;
  }
  static get DATETIME_FULL() {
    return HT;
  }
  static get DATETIME_FULL_WITH_SECONDS() {
    return WT;
  }
  static get DATETIME_HUGE() {
    return VT;
  }
  static get DATETIME_HUGE_WITH_SECONDS() {
    return ZT;
  }
}
function sf(n) {
  if (Rt.isDateTime(n)) return n;
  if (n && n.valueOf && eu(n.valueOf())) return Rt.fromJSDate(n);
  if (n && typeof n == "object") return Rt.fromObject(n);
  throw new wr(`Unknown datetime argument: ${n}, of type ${typeof n}`);
}
const Dn = Di;
function Az(n) {
  let e = 0;
  for (; n; ) {
    const t = window.getComputedStyle(n).position === "sticky";
    (t && (n.style.position = "relative"),
      (e += n.offsetTop),
      t && (n.style.position = ""),
      (n = n.offsetParent));
  }
  return e;
}
function nv(n, { accuracy: e = 10, multiplier: t = 0.05 } = {}) {
  const i = Dn(n);
  let r = n,
    s,
    o = !1;
  const a = () => {
    let l = i();
    if ((i(l + (r - l) * t), Math.round(l * e) === Math.round(r * e))) {
      (i(r), (o = !1));
      return;
    }
    s = requestAnimationFrame(a);
  };
  return (
    Ct(() => {
      dn(() => {
        cancelAnimationFrame(s);
      });
    }),
    [
      i,
      (l) => {
        ((r = l), o || ((s = requestAnimationFrame(a)), (o = !0)));
      },
      (l) => {
        ((r = l), i(l));
      },
    ]
  );
}
function R9(n, e, t) {
  return Math.min(Math.max((t - n) / (e - n), 0), 1);
}
function yz(n, e, t) {
  if (n < 0 || n > 1) throw new Error("Value must be between 0 and 1");
  return e + (t - e) * n;
}
function Cr(n, e, t) {
  return Math.min(Math.max(n, e), t);
}
function Ki(n, e) {
  const t = Dn({
    y: 0,
    x: 0,
    height: 0,
    width: 0,
    refresh: () => {
      throw new Error("Page box not defined yet");
    },
  });
  function i() {
    let r = n();
    const s = r.getBoundingClientRect();
    let o = { y: Az(r), x: s.x, height: s.height, width: s.width, refresh: i };
    (e && (o = e(o)), t(o));
  }
  return (
    Ct(
      gr(
        xg,
        () => {
          i();
        },
        { defer: !0 },
      ),
    ),
    rr(() => {
      (window.addEventListener("resize", i),
        i(),
        dn(() => {
          window.removeEventListener("resize", i);
        }));
    }),
    t
  );
}
function xE() {
  const n = Dn(!1);
  return (
    Ct(() => {
      if (document.fonts.status === "loaded") {
        n(!0);
        return;
      }
      document.fonts.ready.then(() => {
        n(!0);
      });
    }),
    n
  );
}
function iv() {
  return No;
}
function HC(n, e = Ki(n)) {
  const t = Qn;
  return (
    rr(() => {
      e().refresh();
    }),
    pe(() => t() + In().height > e().y && t() < e().y + e().height)
  );
}
function nh(n) {
  const e = xT;
  let t = Object.keys(n).reduce((i, r) => {
    const s = Math.abs(e() - i),
      o = Math.abs(e() - Number(r));
    return s < o ? i : r;
  }, 0);
  return n[t];
}
const k0e =
  typeof window > "u"
    ? !1
    : /^((?!chrome|chromium).)*safari/i.test(navigator.userAgent);
function _z(n) {
  const e = {};
  for (let [t, i] of Object.entries(n)) typeof i != "object" && (e[t] = i);
  return e;
}
function O0e(n, e) {
  const [t, i, r] = n
    .toLocaleString("en-US", { timeZone: e, hour12: !1 })
    .split(" ")[1]
    .split(":");
  return `${parseInt(t, 10).toString()?.padStart(2, "0") ?? "00"}:${i?.padStart(2, "0") ?? "00"}:${r?.padStart(2, "0") ?? "00"}`;
}
function Wc(n) {
  return n * (In().width / nh({ [Si.XL]: 1440, [Si.MD]: 390 }));
}
function B9(n, e, t = 100, i = !1) {
  return `${i ? "https://format-3.co/_vercel/image?url=" : ""}${n}${i ? "&" : "?"}w=${e}&q=${t}`;
}
function U0e(n) {
  const e = document.createRange();
  let t = 0;
  const i = [];
  for (const r of n.childNodes)
    if (r.nodeType === Node.TEXT_NODE) {
      const s = r.textContent;
      for (let o = 0; o < s.length; o++) {
        (e.setStart(r, o), e.setEnd(r, o + 1));
        const { y: a } = e.getBoundingClientRect();
        (a !== t && ((t = a), i.push("")), (i[i.length - 1] += s[o]));
      }
    } else if (r.nodeType === Node.ELEMENT_NODE) {
      const { y: s } = r.getBoundingClientRect();
      ((s !== t || typeof i[i.length - 1][0] == "string") &&
        ((t = s), i.push([])),
        i[i.length - 1].push(r));
    }
  return i;
}
function bz(n, e) {
  return e >= 0 ? n[e % n.length] : n[(n.length + (e % n.length)) % n.length];
}
function H0e(n) {
  const e = new AV(n);
  let t = -1;
  const i = Dn(n);
  function r(s) {
    (e.update(s), (t = requestAnimationFrame(r)));
  }
  return (
    e.onUpdate((s) => {
      i({ ...s });
    }),
    rr(() => {
      dn(() => {
        cancelAnimationFrame(t);
      });
    }),
    (i.to = (s, o) => (t === -1 && (t = requestAnimationFrame(r)), e.to(s, o))),
    i
  );
}
function W0e(n) {
  return Rt.fromFormat(n, "yyyy-MM-dd").toFormat("cccc, dd LLLL yyyy");
}
function wE(n) {
  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(n);
}
const go = Dn(!1),
  ky = Dn(!1);
let P9;
function vz() {
  if (!go()) {
    (ky(!0),
      setTimeout(() => {
        (go(!0), clearTimeout(P9));
      }));
    return;
  }
  (go(!1), (P9 = setTimeout(() => ky(!1), 1e3)));
}
const SE = Dn(!1),
  gp = DC,
  TE = "$FETCH",
  EE = Fa({ $type: TE }),
  rv = () => ro(EE),
  V0e = zr,
  xz = eV,
  wz = zb;
function Z0e() {
  return ZW();
}
const Sz = "Location",
  N9 = "content-type";
function Li(n, e = {}) {
  let t = e;
  typeof e == "number" && (t = { status: e });
  let i = new Headers(t.headers);
  return (
    i.has(N9) || i.set(N9, "application/json; charset=utf-8"),
    new Response(JSON.stringify(n), { ...t, headers: i })
  );
}
const Tz = new Set([204, 301, 302, 303, 307, 308]);
function Ez(n) {
  return n && n instanceof Response && Tz.has(n.status);
}
const D9 = new Set(),
  JI = new Map();
function is(n, e = {}) {
  const t = wz(),
    i = rv();
  function r(c) {
    Ez(c) &&
      pb(() => {
        let u = c.headers.get(Sz);
        u && u.startsWith("/")
          ? t(u, { replace: !0 })
          : u && (window.location.href = u);
      });
  }
  const s = async (c) => {
    try {
      let u = i,
        h = await n.call(u, c, u);
      if (h instanceof Response) {
        pg || setTimeout(() => r(h), 0);
        return;
      }
      return h;
    } catch (u) {
      if (u instanceof Response) {
        setTimeout(() => r(u), 0);
        return;
      }
      throw u;
    }
  };
  function o(c) {
    return (u, h) => {
      if (
        h.refetching &&
        h.refetching !== !0 &&
        !Lz(u, h.refetching) &&
        h.value
      )
        return h.value;
      if (u === !0) return c(u, h);
      let d = JI.get(u);
      return d || ((d = c(u, h)), JI.set(u, d), d.finally(() => JI.delete(u)));
    };
  }
  const [a, { refetch: l }] = gb(e.key || !0, o(s), {
    storage: (c) => Mz(c, e.reconcileOptions),
    ...e,
  });
  return (D9.add(l), dn(() => D9.delete(l)), a);
}
function Mz(n, e) {
  const [t, i] = IW({ value: n });
  return [
    () => t.value,
    (r) => {
      const s = zt(() => du(t.value));
      return (
        typeof r == "function" && (r = r(s)),
        i("value", AW(r, e)),
        t.value
      );
    },
  ];
}
function Lz(n, e) {
  return ME(G9(n), G9(e));
}
function G9(n) {
  return Array.isArray(n) ? n : [n];
}
function ME(n, e) {
  return n === e
    ? !0
    : typeof n != typeof e || (n.length && !e.length)
      ? !1
      : n && e && typeof n == "object" && typeof e == "object"
        ? !Object.keys(e).some((t) => !ME(n[t], e[t]))
        : !1;
}
const Rz = xt(
  '<div><div><p id="error-message"></p><button id="reset-errors">Clear errors and retry</button><pre>',
);
function Bz(n) {
  return G($N, {
    fallback: (e, t) =>
      G(Hl, {
        get when() {
          return !n.fallback;
        },
        get fallback() {
          return pe(() => !!n.fallback)() && n.fallback(e, t);
        },
        get children() {
          return G(Pz, { error: e });
        },
      }),
    get children() {
      return n.children;
    },
  });
}
function Pz(n) {
  return (
    Ct(() => console.error(n.error)),
    console.log(n.error),
    (() => {
      const e = ft(Rz),
        t = e.firstChild,
        i = t.firstChild,
        r = i.nextSibling,
        s = r.nextSibling;
      return (
        e.style.setProperty("padding", "16px"),
        t.style.setProperty("background-color", "rgba(252, 165, 165)"),
        t.style.setProperty("color", "rgb(153, 27, 27)"),
        t.style.setProperty("border-radius", "5px"),
        t.style.setProperty("overflow", "scroll"),
        t.style.setProperty("padding", "16px"),
        t.style.setProperty("margin-bottom", "8px"),
        i.style.setProperty("font-weight", "bold"),
        Mn(i, () => n.error.message),
        E7(r, "click", T7, !0),
        r.style.setProperty("color", "rgba(252, 165, 165)"),
        r.style.setProperty("background-color", "rgb(153, 27, 27)"),
        r.style.setProperty("border-radius", "5px"),
        r.style.setProperty("padding", "4px 8px"),
        s.style.setProperty("margin-top", "8px"),
        s.style.setProperty("width", "100%"),
        Mn(s, () => n.error.stack),
        An(),
        e
      );
    })()
  );
}
Qg(["click"]);
const Nz = !1,
  Dz = !1;
function Gz() {
  return Dz;
}
function Fz() {
  return Nz;
}
function kz() {
  return (
    rv(),
    [
      G(ID, {}),
      G(CD, {
        get children() {
          return [G(Gz, {}), pe(() => pg)];
        },
      }),
    ]
  );
}
function Oz() {
  return [G(Fz, {}), G(kz, {})];
}
function Uz(n) {
  return (fn(document.documentElement, n, !1, !0), n.children);
}
function Hz(n) {
  return (fn(document.head, n, !1, !0), n.children);
}
function Wz(n) {
  {
    let e = wC(() => n.children);
    return (
      fn(document.body, n, !1, !0),
      Mn(
        document.body,
        () => {
          let t = e();
          if (t) {
            if (Array.isArray(t)) {
              let i = t.filter((r) => !!r);
              return i.length ? i : null;
            }
            return t;
          }
          return null;
        },
        null,
        [...document.body.childNodes],
      ),
      document.body
    );
  }
}
const F9 = Object.values(Object.assign({}))[0];
F9 && F9.default;
const Vz = typeof navigator > "u" ? !1 : navigator.product === "ReactNative",
  LE = { timeout: Vz ? 6e4 : 12e4 },
  Zz = function (e) {
    const t = { ...LE, ...(typeof e == "string" ? { url: e } : e) },
      { searchParams: i } = new URL(t.url, "http://localhost");
    if (((t.timeout = RE(t.timeout)), t.query)) {
      for (const [o, a] of Object.entries(t.query))
        if (a !== void 0)
          if (Array.isArray(a)) for (const l of a) i.append(o, l);
          else i.append(o, a);
    }
    const [r] = t.url.split("?"),
      s = i.toString();
    return (
      s && (t.url = "".concat(r, "?").concat(s)),
      (t.method =
        t.body && !t.method ? "POST" : (t.method || "GET").toUpperCase()),
      t
    );
  };
function RE(n) {
  if (n === !1 || n === 0) return !1;
  if (n.connect || n.socket) return n;
  const e = Number(n);
  return isNaN(e) ? RE(LE.timeout) : { connect: e, socket: e };
}
const zz = /^https?:\/\//i,
  Yz = function (e) {
    if (!zz.test(e.url))
      throw new Error('"'.concat(e.url, '" is not a valid URL'));
  };
var C0 =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
      ? window
      : typeof global < "u"
        ? global
        : typeof self < "u"
          ? self
          : {};
function pp(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default")
    ? n.default
    : n;
}
function Xz(n) {
  if (n.__esModule) return n;
  var e = n.default;
  if (typeof e == "function") {
    var t = function i() {
      return this instanceof i
        ? Reflect.construct(e, arguments, this.constructor)
        : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return (
    Object.defineProperty(t, "__esModule", { value: !0 }),
    Object.keys(n).forEach(function (i) {
      var r = Object.getOwnPropertyDescriptor(n, i);
      Object.defineProperty(
        t,
        i,
        r.get
          ? r
          : {
              enumerable: !0,
              get: function () {
                return n[i];
              },
            },
      );
    }),
    t
  );
}
var QI = function (n) {
    return n.replace(/^\s+|\s+$/g, "");
  },
  Kz = function (n) {
    return Object.prototype.toString.call(n) === "[object Array]";
  },
  jz = function (n) {
    if (!n) return {};
    for (
      var e = {},
        t = QI(n).split(`
`),
        i = 0;
      i < t.length;
      i++
    ) {
      var r = t[i],
        s = r.indexOf(":"),
        o = QI(r.slice(0, s)).toLowerCase(),
        a = QI(r.slice(s + 1));
      typeof e[o] > "u"
        ? (e[o] = a)
        : Kz(e[o])
          ? e[o].push(a)
          : (e[o] = [e[o], a]);
    }
    return e;
  };
const $z = pp(jz),
  Jz = (n) =>
    function (t, i) {
      const r = t === "onError";
      let s = i;
      for (
        var o = arguments.length, a = new Array(o > 2 ? o - 2 : 0), l = 2;
        l < o;
        l++
      )
        a[l - 2] = arguments[l];
      for (let c = 0; c < n[t].length; c++) {
        const u = n[t][c];
        if (((s = u(s, ...a)), r && !s)) break;
      }
      return s;
    };
function Qz() {
  const n = Object.create(null);
  let e = 0;
  function t(r) {
    const s = e++;
    return (
      (n[s] = r),
      function () {
        delete n[s];
      }
    );
  }
  function i(r) {
    for (const s in n) n[s](r);
  }
  return { publish: i, subscribe: t };
}
const qz = ["request", "response", "progress", "error", "abort"],
  k9 = [
    "processOptions",
    "validateOptions",
    "interceptRequest",
    "finalizeOptions",
    "onRequest",
    "onResponse",
    "onError",
    "onReturn",
    "onHeaders",
  ];
function BE(n, e) {
  const t = [],
    i = k9.reduce((s, o) => ((s[o] = s[o] || []), s), {
      processOptions: [Zz],
      validateOptions: [Yz],
    });
  function r(s) {
    const o = (g, p, m) => {
        let C = g,
          A = p;
        if (!C)
          try {
            A = l("onResponse", p, m);
          } catch (I) {
            ((A = null), (C = I));
          }
        ((C = C && l("onError", C, m)),
          C ? a.error.publish(C) : A && a.response.publish(A));
      },
      a = qz.reduce((g, p) => ((g[p] = Qz()), g), {}),
      l = Jz(i),
      c = l("processOptions", s);
    l("validateOptions", c);
    const u = { options: c, channels: a, applyMiddleware: l };
    let h;
    const d = a.request.subscribe((g) => {
      h = e(g, (p, m) => o(p, m, g));
    });
    a.abort.subscribe(() => {
      (d(), h && h.abort());
    });
    const f = l("onReturn", a, u);
    return (f === a && a.request.publish(u), f);
  }
  return (
    (r.use = function (o) {
      if (!o)
        throw new Error(
          "Tried to add middleware that resolved to falsey value",
        );
      if (typeof o == "function")
        throw new Error(
          "Tried to add middleware that was a function. It probably expects you to pass options to it.",
        );
      if (o.onReturn && i.onReturn.length > 0)
        throw new Error(
          "Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event",
        );
      return (
        k9.forEach((a) => {
          o[a] && i[a].push(o[a]);
        }),
        t.push(o),
        r
      );
    }),
    (r.clone = () => BE(t, e)),
    n.forEach(r.use),
    r
  );
}
var PE = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  ls = (n, e, t) => (
    PE(n, e, "read from private field"),
    t ? t.call(n) : e.get(n)
  ),
  tc = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  Za = (n, e, t, i) => (
    PE(n, e, "write to private field"),
    i ? i.call(n, t) : e.set(n, t),
    t
  ),
  I0,
  A0,
  ih,
  y0,
  il,
  _0,
  b0;
class NE {
  constructor() {
    ((this.readyState = 0),
      (this.responseType = ""),
      tc(this, I0, void 0),
      tc(this, A0, void 0),
      tc(this, ih, void 0),
      tc(this, y0, {}),
      tc(this, il, void 0),
      tc(this, _0, {}),
      tc(this, b0, void 0));
  }
  open(e, t, i) {
    (Za(this, I0, e),
      Za(this, A0, t),
      Za(this, ih, ""),
      (this.readyState = 1),
      this.onreadystatechange(),
      Za(this, il, void 0));
  }
  abort() {
    ls(this, il) && ls(this, il).abort();
  }
  getAllResponseHeaders() {
    return ls(this, ih);
  }
  setRequestHeader(e, t) {
    ls(this, y0)[e] = t;
  }
  setInit(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    (Za(this, _0, e), Za(this, b0, t));
  }
  send(e) {
    const t = this.responseType !== "arraybuffer",
      i = {
        ...ls(this, _0),
        method: ls(this, I0),
        headers: ls(this, y0),
        body: e,
      };
    (typeof AbortController == "function" &&
      ls(this, b0) &&
      (Za(this, il, new AbortController()),
      typeof EventTarget < "u" &&
        ls(this, il).signal instanceof EventTarget &&
        (i.signal = ls(this, il).signal)),
      typeof document < "u" &&
        (i.credentials = this.withCredentials ? "include" : "omit"),
      fetch(ls(this, A0), i)
        .then(
          (r) => (
            r.headers.forEach((s, o) => {
              Za(
                this,
                ih,
                ls(this, ih) +
                  "".concat(o, ": ").concat(
                    s,
                    `\r
`,
                  ),
              );
            }),
            (this.status = r.status),
            (this.statusText = r.statusText),
            (this.readyState = 3),
            t ? r.text() : r.arrayBuffer()
          ),
        )
        .then((r) => {
          (typeof r == "string" ? (this.responseText = r) : (this.response = r),
            (this.readyState = 4),
            this.onreadystatechange());
        })
        .catch((r) => {
          var s;
          if (r.name === "AbortError") {
            this.onabort();
            return;
          }
          (s = this.onerror) == null || s.call(this, r);
        }));
  }
}
I0 = new WeakMap();
A0 = new WeakMap();
ih = new WeakMap();
y0 = new WeakMap();
il = new WeakMap();
_0 = new WeakMap();
b0 = new WeakMap();
const Oy = typeof XMLHttpRequest == "function" ? "xhr" : "fetch",
  eY = Oy === "xhr" ? XMLHttpRequest : NE,
  tY = (n, e) => {
    var t;
    const i = n.options,
      r = n.applyMiddleware("finalizeOptions", i),
      s = {},
      o = n.applyMiddleware("interceptRequest", void 0, {
        adapter: Oy,
        context: n,
      });
    if (o) {
      const y = setTimeout(e, 0, null, o);
      return { abort: () => clearTimeout(y) };
    }
    let a = new eY();
    a instanceof NE &&
      typeof r.fetch == "object" &&
      a.setInit(r.fetch, (t = r.useAbortSignal) != null ? t : !0);
    const l = r.headers,
      c = r.timeout;
    let u = !1,
      h = !1,
      d = !1;
    if (
      ((a.onerror = (y) => {
        C(
          new Error(
            "Request error while attempting to reach "
              .concat(r.url)
              .concat(
                y.lengthComputable
                  ? "("
                      .concat(y.loaded, " of ")
                      .concat(y.total, " bytes transferred)")
                  : "",
              ),
          ),
        );
      }),
      (a.ontimeout = (y) => {
        C(
          new Error(
            "Request timeout while attempting to reach "
              .concat(r.url)
              .concat(
                y.lengthComputable
                  ? "("
                      .concat(y.loaded, " of ")
                      .concat(y.total, " bytes transferred)")
                  : "",
              ),
          ),
        );
      }),
      (a.onabort = () => {
        (m(!0), (u = !0));
      }),
      (a.onreadystatechange = () => {
        (p(), !(u || a.readyState !== 4) && a.status !== 0 && I());
      }),
      a.open(r.method, r.url, !0),
      (a.withCredentials = !!r.withCredentials),
      l && a.setRequestHeader)
    )
      for (const y in l) l.hasOwnProperty(y) && a.setRequestHeader(y, l[y]);
    return (
      r.rawBody && (a.responseType = "arraybuffer"),
      n.applyMiddleware("onRequest", {
        options: r,
        adapter: Oy,
        request: a,
        context: n,
      }),
      a.send(r.body || null),
      c && (s.connect = setTimeout(() => g("ETIMEDOUT"), c.connect)),
      { abort: f }
    );
    function f() {
      ((u = !0), a && a.abort());
    }
    function g(y) {
      ((d = !0), a.abort());
      const x = new Error(
        y === "ESOCKETTIMEDOUT"
          ? "Socket timed out on request to ".concat(r.url)
          : "Connection timed out on request to ".concat(r.url),
      );
      ((x.code = y), n.channels.error.publish(x));
    }
    function p() {
      c && (m(), (s.socket = setTimeout(() => g("ESOCKETTIMEDOUT"), c.socket)));
    }
    function m(y) {
      ((y || u || (a.readyState >= 2 && s.connect)) && clearTimeout(s.connect),
        s.socket && clearTimeout(s.socket));
    }
    function C(y) {
      if (h) return;
      (m(!0), (h = !0), (a = null));
      const x =
        y ||
        new Error("Network error while attempting to reach ".concat(r.url));
      ((x.isNetworkError = !0), (x.request = r), e(x));
    }
    function A() {
      return {
        body:
          a.response ||
          (a.responseType === "" || a.responseType === "text"
            ? a.responseText
            : ""),
        url: r.url,
        method: r.method,
        headers: $z(a.getAllResponseHeaders()),
        statusCode: a.status,
        statusMessage: a.statusText,
      };
    }
    function I() {
      if (!(u || h || d)) {
        if (a.status === 0) {
          C(new Error("Unknown XHR error"));
          return;
        }
        (m(), (h = !0), e(null, A()));
      }
    }
  },
  nY = function () {
    let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
      e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : tY;
    return BE(n, e);
  };
var O9 = { exports: {} },
  qI,
  U9;
function iY() {
  if (U9) return qI;
  U9 = 1;
  var n = 1e3,
    e = n * 60,
    t = e * 60,
    i = t * 24,
    r = i * 7,
    s = i * 365.25;
  qI = function (u, h) {
    h = h || {};
    var d = typeof u;
    if (d === "string" && u.length > 0) return o(u);
    if (d === "number" && isFinite(u)) return h.long ? l(u) : a(u);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" +
        JSON.stringify(u),
    );
  };
  function o(u) {
    if (((u = String(u)), !(u.length > 100))) {
      var h =
        /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          u,
        );
      if (h) {
        var d = parseFloat(h[1]),
          f = (h[2] || "ms").toLowerCase();
        switch (f) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return d * s;
          case "weeks":
          case "week":
          case "w":
            return d * r;
          case "days":
          case "day":
          case "d":
            return d * i;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return d * t;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return d * e;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return d * n;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return d;
          default:
            return;
        }
      }
    }
  }
  function a(u) {
    var h = Math.abs(u);
    return h >= i
      ? Math.round(u / i) + "d"
      : h >= t
        ? Math.round(u / t) + "h"
        : h >= e
          ? Math.round(u / e) + "m"
          : h >= n
            ? Math.round(u / n) + "s"
            : u + "ms";
  }
  function l(u) {
    var h = Math.abs(u);
    return h >= i
      ? c(u, h, i, "day")
      : h >= t
        ? c(u, h, t, "hour")
        : h >= e
          ? c(u, h, e, "minute")
          : h >= n
            ? c(u, h, n, "second")
            : u + " ms";
  }
  function c(u, h, d, f) {
    var g = h >= d * 1.5;
    return Math.round(u / d) + " " + f + (g ? "s" : "");
  }
  return qI;
}
function rY(n) {
  ((t.debug = t),
    (t.default = t),
    (t.coerce = l),
    (t.disable = s),
    (t.enable = r),
    (t.enabled = o),
    (t.humanize = iY()),
    (t.destroy = c),
    Object.keys(n).forEach((u) => {
      t[u] = n[u];
    }),
    (t.names = []),
    (t.skips = []),
    (t.formatters = {}));
  function e(u) {
    let h = 0;
    for (let d = 0; d < u.length; d++)
      ((h = (h << 5) - h + u.charCodeAt(d)), (h |= 0));
    return t.colors[Math.abs(h) % t.colors.length];
  }
  t.selectColor = e;
  function t(u) {
    let h,
      d = null,
      f,
      g;
    function p(...m) {
      if (!p.enabled) return;
      const C = p,
        A = Number(new Date()),
        I = A - (h || A);
      ((C.diff = I),
        (C.prev = h),
        (C.curr = A),
        (h = A),
        (m[0] = t.coerce(m[0])),
        typeof m[0] != "string" && m.unshift("%O"));
      let y = 0;
      ((m[0] = m[0].replace(/%([a-zA-Z%])/g, (T, S) => {
        if (T === "%%") return "%";
        y++;
        const E = t.formatters[S];
        if (typeof E == "function") {
          const _ = m[y];
          ((T = E.call(C, _)), m.splice(y, 1), y--);
        }
        return T;
      })),
        t.formatArgs.call(C, m),
        (C.log || t.log).apply(C, m));
    }
    return (
      (p.namespace = u),
      (p.useColors = t.useColors()),
      (p.color = t.selectColor(u)),
      (p.extend = i),
      (p.destroy = t.destroy),
      Object.defineProperty(p, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: () =>
          d !== null
            ? d
            : (f !== t.namespaces && ((f = t.namespaces), (g = t.enabled(u))),
              g),
        set: (m) => {
          d = m;
        },
      }),
      typeof t.init == "function" && t.init(p),
      p
    );
  }
  function i(u, h) {
    const d = t(this.namespace + (typeof h > "u" ? ":" : h) + u);
    return ((d.log = this.log), d);
  }
  function r(u) {
    (t.save(u), (t.namespaces = u), (t.names = []), (t.skips = []));
    let h;
    const d = (typeof u == "string" ? u : "").split(/[\s,]+/),
      f = d.length;
    for (h = 0; h < f; h++)
      d[h] &&
        ((u = d[h].replace(/\*/g, ".*?")),
        u[0] === "-"
          ? t.skips.push(new RegExp("^" + u.slice(1) + "$"))
          : t.names.push(new RegExp("^" + u + "$")));
  }
  function s() {
    const u = [...t.names.map(a), ...t.skips.map(a).map((h) => "-" + h)].join(
      ",",
    );
    return (t.enable(""), u);
  }
  function o(u) {
    if (u[u.length - 1] === "*") return !0;
    let h, d;
    for (h = 0, d = t.skips.length; h < d; h++)
      if (t.skips[h].test(u)) return !1;
    for (h = 0, d = t.names.length; h < d; h++)
      if (t.names[h].test(u)) return !0;
    return !1;
  }
  function a(u) {
    return u
      .toString()
      .substring(2, u.toString().length - 2)
      .replace(/\.\*\?$/, "*");
  }
  function l(u) {
    return u instanceof Error ? u.stack || u.message : u;
  }
  function c() {
    console.warn(
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
    );
  }
  return (t.enable(t.load()), t);
}
var sY = rY;
(function (n, e) {
  ((e.formatArgs = i),
    (e.save = r),
    (e.load = s),
    (e.useColors = t),
    (e.storage = o()),
    (e.destroy = (() => {
      let l = !1;
      return () => {
        l ||
          ((l = !0),
          console.warn(
            "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
          ));
      };
    })()),
    (e.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33",
    ]));
  function t() {
    return typeof window < "u" &&
      window.process &&
      (window.process.type === "renderer" || window.process.__nwjs)
      ? !0
      : typeof navigator < "u" &&
          navigator.userAgent &&
          navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
        ? !1
        : (typeof document < "u" &&
            document.documentElement &&
            document.documentElement.style &&
            document.documentElement.style.WebkitAppearance) ||
          (typeof window < "u" &&
            window.console &&
            (window.console.firebug ||
              (window.console.exception && window.console.table))) ||
          (typeof navigator < "u" &&
            navigator.userAgent &&
            navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
            parseInt(RegExp.$1, 10) >= 31) ||
          (typeof navigator < "u" &&
            navigator.userAgent &&
            navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
  }
  function i(l) {
    if (
      ((l[0] =
        (this.useColors ? "%c" : "") +
        this.namespace +
        (this.useColors ? " %c" : " ") +
        l[0] +
        (this.useColors ? "%c " : " ") +
        "+" +
        n.exports.humanize(this.diff)),
      !this.useColors)
    )
      return;
    const c = "color: " + this.color;
    l.splice(1, 0, c, "color: inherit");
    let u = 0,
      h = 0;
    (l[0].replace(/%[a-zA-Z%]/g, (d) => {
      d !== "%%" && (u++, d === "%c" && (h = u));
    }),
      l.splice(h, 0, c));
  }
  e.log = console.debug || console.log || (() => {});
  function r(l) {
    try {
      l ? e.storage.setItem("debug", l) : e.storage.removeItem("debug");
    } catch {}
  }
  function s() {
    let l;
    try {
      l = e.storage.getItem("debug");
    } catch {}
    return (
      !l && typeof process < "u" && "env" in process && (l = {}.DEBUG),
      l
    );
  }
  function o() {
    try {
      return localStorage;
    } catch {}
  }
  n.exports = sY(e);
  const { formatters: a } = n.exports;
  a.j = function (l) {
    try {
      return JSON.stringify(l);
    } catch (c) {
      return "[UnexpectedJSONParseError]: " + c.message;
    }
  };
})(O9, O9.exports);
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */ function H9(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
function oY(n) {
  var e, t;
  return H9(n) === !1
    ? !1
    : ((e = n.constructor),
      e === void 0
        ? !0
        : ((t = e.prototype),
          !(H9(t) === !1 || t.hasOwnProperty("isPrototypeOf") === !1)));
}
const aY = typeof Buffer > "u" ? () => !1 : (n) => Buffer.isBuffer(n),
  lY = ["boolean", "string", "number"];
function cY() {
  return {
    processOptions: (n) => {
      const e = n.body;
      return !e ||
        !(
          !(typeof e.pipe == "function") &&
          !aY(e) &&
          (lY.indexOf(typeof e) !== -1 || Array.isArray(e) || oY(e))
        )
        ? n
        : Object.assign({}, n, {
            body: JSON.stringify(n.body),
            headers: Object.assign({}, n.headers, {
              "Content-Type": "application/json",
            }),
          });
    },
  };
}
function uY(n) {
  return {
    onResponse: (t) => {
      const i = t.headers["content-type"] || "",
        r = (n && n.force) || i.indexOf("application/json") !== -1;
      return !t.body || !i || !r
        ? t
        : Object.assign({}, t, { body: e(t.body) });
    },
    processOptions: (t) =>
      Object.assign({}, t, {
        headers: Object.assign({ Accept: "application/json" }, t.headers),
      }),
  };
  function e(t) {
    try {
      return JSON.parse(t);
    } catch (i) {
      throw (
        (i.message = "Failed to parsed response body as JSON: ".concat(
          i.message,
        )),
        i
      );
    }
  }
}
let Lf = {};
typeof globalThis < "u"
  ? (Lf = globalThis)
  : typeof window < "u"
    ? (Lf = window)
    : typeof global < "u"
      ? (Lf = global)
      : typeof self < "u" && (Lf = self);
var hY = Lf;
function dY() {
  const e =
    (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {})
      .implementation || hY.Observable;
  if (!e)
    throw new Error(
      "`Observable` is not available in global scope, and no implementation was passed",
    );
  return {
    onReturn: (t, i) =>
      new e(
        (r) => (
          t.error.subscribe((s) => r.error(s)),
          t.progress.subscribe((s) =>
            r.next(Object.assign({ type: "progress" }, s)),
          ),
          t.response.subscribe((s) => {
            (r.next(Object.assign({ type: "response" }, s)), r.complete());
          }),
          t.request.publish(i),
          () => t.abort.publish()
        ),
      ),
  };
}
function fY() {
  return {
    onRequest: (n) => {
      if (n.adapter !== "xhr") return;
      const e = n.request,
        t = n.context;
      ("upload" in e &&
        "onprogress" in e.upload &&
        (e.upload.onprogress = i("upload")),
        "onprogress" in e && (e.onprogress = i("download")));
      function i(r) {
        return (s) => {
          const o = s.lengthComputable ? (s.loaded / s.total) * 100 : -1;
          t.channels.progress.publish({
            stage: r,
            percent: o,
            total: s.total,
            loaded: s.loaded,
            lengthComputable: s.lengthComputable,
          });
        };
      }
    },
  };
}
class gY {
  constructor(e) {
    ((this.__CANCEL__ = !0), (this.message = e));
  }
  toString() {
    return "Cancel".concat(this.message ? ": ".concat(this.message) : "");
  }
}
const W9 = class {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let t = null;
    ((this.promise = new Promise((i) => {
      t = i;
    })),
      e((i) => {
        this.reason || ((this.reason = new gY(i)), t(this.reason));
      }));
  }
};
W9.source = () => {
  let n;
  return {
    token: new W9((t) => {
      n = t;
    }),
    cancel: n,
  };
};
var DE = (n, e, t) =>
  t.method !== "GET" && t.method !== "HEAD" ? !1 : n.isNetworkError || !1;
const pY = (n) =>
  n !== null && typeof n == "object" && typeof n.pipe == "function";
var mY = (n) => {
  const e = n.maxRetries || 5,
    t = n.retryDelay || CY,
    i = n.shouldRetry;
  return {
    onError: (r, s) => {
      const o = s.options,
        a = o.maxRetries || e,
        l = o.shouldRetry || i,
        c = o.attemptNumber || 0;
      if (pY(o.body) || !l(r, c, o) || c >= a) return r;
      const u = Object.assign({}, s, {
        options: Object.assign({}, o, { attemptNumber: c + 1 }),
      });
      return (setTimeout(() => s.channels.request.publish(u), t(c)), null);
    },
  };
};
function CY(n) {
  return 100 * Math.pow(2, n) + Math.random() * 100;
}
const sv = function () {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return mY({ shouldRetry: DE, ...n });
};
sv.shouldRetry = DE;
var Uy = function (n, e) {
  return (
    (Uy =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (t, i) {
          t.__proto__ = i;
        }) ||
      function (t, i) {
        for (var r in i)
          Object.prototype.hasOwnProperty.call(i, r) && (t[r] = i[r]);
      }),
    Uy(n, e)
  );
};
function ov(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError(
      "Class extends value " + String(e) + " is not a constructor or null",
    );
  Uy(n, e);
  function t() {
    this.constructor = n;
  }
  n.prototype =
    e === null ? Object.create(e) : ((t.prototype = e.prototype), new t());
}
function V9(n) {
  var e = typeof Symbol == "function" && Symbol.iterator,
    t = e && n[e],
    i = 0;
  if (t) return t.call(n);
  if (n && typeof n.length == "number")
    return {
      next: function () {
        return (
          n && i >= n.length && (n = void 0),
          { value: n && n[i++], done: !n }
        );
      },
    };
  throw new TypeError(
    e ? "Object is not iterable." : "Symbol.iterator is not defined.",
  );
}
function vm(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t) return n;
  var i = t.call(n),
    r,
    s = [],
    o;
  try {
    for (; (e === void 0 || e-- > 0) && !(r = i.next()).done; ) s.push(r.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      r && !r.done && (t = i.return) && t.call(i);
    } finally {
      if (o) throw o.error;
    }
  }
  return s;
}
function xm(n, e, t) {
  if (t || arguments.length === 2)
    for (var i = 0, r = e.length, s; i < r; i++)
      (s || !(i in e)) &&
        (s || (s = Array.prototype.slice.call(e, 0, i)), (s[i] = e[i]));
  return n.concat(s || Array.prototype.slice.call(e));
}
function Eo(n) {
  return typeof n == "function";
}
function GE(n) {
  var e = function (i) {
      (Error.call(i), (i.stack = new Error().stack));
    },
    t = n(e);
  return (
    (t.prototype = Object.create(Error.prototype)),
    (t.prototype.constructor = t),
    t
  );
}
var e2 = GE(function (n) {
  return function (t) {
    (n(this),
      (this.message = t
        ? t.length +
          ` errors occurred during unsubscription:
` +
          t.map(function (i, r) {
            return r + 1 + ") " + i.toString();
          }).join(`
  `)
        : ""),
      (this.name = "UnsubscriptionError"),
      (this.errors = t));
  };
});
function Z9(n, e) {
  if (n) {
    var t = n.indexOf(e);
    0 <= t && n.splice(t, 1);
  }
}
var av = (function () {
  function n(e) {
    ((this.initialTeardown = e),
      (this.closed = !1),
      (this._parentage = null),
      (this._finalizers = null));
  }
  return (
    (n.prototype.unsubscribe = function () {
      var e, t, i, r, s;
      if (!this.closed) {
        this.closed = !0;
        var o = this._parentage;
        if (o)
          if (((this._parentage = null), Array.isArray(o)))
            try {
              for (var a = V9(o), l = a.next(); !l.done; l = a.next()) {
                var c = l.value;
                c.remove(this);
              }
            } catch (p) {
              e = { error: p };
            } finally {
              try {
                l && !l.done && (t = a.return) && t.call(a);
              } finally {
                if (e) throw e.error;
              }
            }
          else o.remove(this);
        var u = this.initialTeardown;
        if (Eo(u))
          try {
            u();
          } catch (p) {
            s = p instanceof e2 ? p.errors : [p];
          }
        var h = this._finalizers;
        if (h) {
          this._finalizers = null;
          try {
            for (var d = V9(h), f = d.next(); !f.done; f = d.next()) {
              var g = f.value;
              try {
                z9(g);
              } catch (p) {
                ((s = s ?? []),
                  p instanceof e2
                    ? (s = xm(xm([], vm(s)), vm(p.errors)))
                    : s.push(p));
              }
            }
          } catch (p) {
            i = { error: p };
          } finally {
            try {
              f && !f.done && (r = d.return) && r.call(d);
            } finally {
              if (i) throw i.error;
            }
          }
        }
        if (s) throw new e2(s);
      }
    }),
    (n.prototype.add = function (e) {
      var t;
      if (e && e !== this)
        if (this.closed) z9(e);
        else {
          if (e instanceof n) {
            if (e.closed || e._hasParent(this)) return;
            e._addParent(this);
          }
          (this._finalizers =
            (t = this._finalizers) !== null && t !== void 0 ? t : []).push(e);
        }
    }),
    (n.prototype._hasParent = function (e) {
      var t = this._parentage;
      return t === e || (Array.isArray(t) && t.includes(e));
    }),
    (n.prototype._addParent = function (e) {
      var t = this._parentage;
      this._parentage = Array.isArray(t) ? (t.push(e), t) : t ? [t, e] : e;
    }),
    (n.prototype._removeParent = function (e) {
      var t = this._parentage;
      t === e ? (this._parentage = null) : Array.isArray(t) && Z9(t, e);
    }),
    (n.prototype.remove = function (e) {
      var t = this._finalizers;
      (t && Z9(t, e), e instanceof n && e._removeParent(this));
    }),
    (n.EMPTY = (function () {
      var e = new n();
      return ((e.closed = !0), e);
    })()),
    n
  );
})();
av.EMPTY;
function FE(n) {
  return (
    n instanceof av ||
    (n && "closed" in n && Eo(n.remove) && Eo(n.add) && Eo(n.unsubscribe))
  );
}
function z9(n) {
  Eo(n) ? n() : n.unsubscribe();
}
var kE = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: void 0,
    useDeprecatedSynchronousErrorHandling: !1,
    useDeprecatedNextContext: !1,
  },
  Hy = {
    setTimeout: function (n, e) {
      for (var t = [], i = 2; i < arguments.length; i++)
        t[i - 2] = arguments[i];
      var r = Hy.delegate;
      return r?.setTimeout
        ? r.setTimeout.apply(r, xm([n, e], vm(t)))
        : setTimeout.apply(void 0, xm([n, e], vm(t)));
    },
    clearTimeout: function (n) {
      var e = Hy.delegate;
      return (e?.clearTimeout || clearTimeout)(n);
    },
    delegate: void 0,
  };
function IY(n) {
  Hy.setTimeout(function () {
    throw n;
  });
}
function Y9() {}
function AY(n) {
  n();
}
var lv = (function (n) {
    ov(e, n);
    function e(t) {
      var i = n.call(this) || this;
      return (
        (i.isStopped = !1),
        t ? ((i.destination = t), FE(t) && t.add(i)) : (i.destination = vY),
        i
      );
    }
    return (
      (e.create = function (t, i, r) {
        return new Wy(t, i, r);
      }),
      (e.prototype.next = function (t) {
        this.isStopped || this._next(t);
      }),
      (e.prototype.error = function (t) {
        this.isStopped || ((this.isStopped = !0), this._error(t));
      }),
      (e.prototype.complete = function () {
        this.isStopped || ((this.isStopped = !0), this._complete());
      }),
      (e.prototype.unsubscribe = function () {
        this.closed ||
          ((this.isStopped = !0),
          n.prototype.unsubscribe.call(this),
          (this.destination = null));
      }),
      (e.prototype._next = function (t) {
        this.destination.next(t);
      }),
      (e.prototype._error = function (t) {
        try {
          this.destination.error(t);
        } finally {
          this.unsubscribe();
        }
      }),
      (e.prototype._complete = function () {
        try {
          this.destination.complete();
        } finally {
          this.unsubscribe();
        }
      }),
      e
    );
  })(av),
  yY = Function.prototype.bind;
function t2(n, e) {
  return yY.call(n, e);
}
var _Y = (function () {
    function n(e) {
      this.partialObserver = e;
    }
    return (
      (n.prototype.next = function (e) {
        var t = this.partialObserver;
        if (t.next)
          try {
            t.next(e);
          } catch (i) {
            Jp(i);
          }
      }),
      (n.prototype.error = function (e) {
        var t = this.partialObserver;
        if (t.error)
          try {
            t.error(e);
          } catch (i) {
            Jp(i);
          }
        else Jp(e);
      }),
      (n.prototype.complete = function () {
        var e = this.partialObserver;
        if (e.complete)
          try {
            e.complete();
          } catch (t) {
            Jp(t);
          }
      }),
      n
    );
  })(),
  Wy = (function (n) {
    ov(e, n);
    function e(t, i, r) {
      var s = n.call(this) || this,
        o;
      if (Eo(t) || !t)
        o = { next: t ?? void 0, error: i ?? void 0, complete: r ?? void 0 };
      else {
        var a;
        s && kE.useDeprecatedNextContext
          ? ((a = Object.create(t)),
            (a.unsubscribe = function () {
              return s.unsubscribe();
            }),
            (o = {
              next: t.next && t2(t.next, a),
              error: t.error && t2(t.error, a),
              complete: t.complete && t2(t.complete, a),
            }))
          : (o = t);
      }
      return ((s.destination = new _Y(o)), s);
    }
    return e;
  })(lv);
function Jp(n) {
  IY(n);
}
function bY(n) {
  throw n;
}
var vY = { closed: !0, next: Y9, error: bY, complete: Y9 },
  xY = (function () {
    return (typeof Symbol == "function" && Symbol.observable) || "@@observable";
  })();
function wY(n) {
  return n;
}
function SY(n) {
  return n.length === 0
    ? wY
    : n.length === 1
      ? n[0]
      : function (t) {
          return n.reduce(function (i, r) {
            return r(i);
          }, t);
        };
}
var Sg = (function () {
  function n(e) {
    e && (this._subscribe = e);
  }
  return (
    (n.prototype.lift = function (e) {
      var t = new n();
      return ((t.source = this), (t.operator = e), t);
    }),
    (n.prototype.subscribe = function (e, t, i) {
      var r = this,
        s = EY(e) ? e : new Wy(e, t, i);
      return (
        AY(function () {
          var o = r,
            a = o.operator,
            l = o.source;
          s.add(a ? a.call(s, l) : l ? r._subscribe(s) : r._trySubscribe(s));
        }),
        s
      );
    }),
    (n.prototype._trySubscribe = function (e) {
      try {
        return this._subscribe(e);
      } catch (t) {
        e.error(t);
      }
    }),
    (n.prototype.forEach = function (e, t) {
      var i = this;
      return (
        (t = X9(t)),
        new t(function (r, s) {
          var o = new Wy({
            next: function (a) {
              try {
                e(a);
              } catch (l) {
                (s(l), o.unsubscribe());
              }
            },
            error: s,
            complete: r,
          });
          i.subscribe(o);
        })
      );
    }),
    (n.prototype._subscribe = function (e) {
      var t;
      return (t = this.source) === null || t === void 0
        ? void 0
        : t.subscribe(e);
    }),
    (n.prototype[xY] = function () {
      return this;
    }),
    (n.prototype.pipe = function () {
      for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
      return SY(e)(this);
    }),
    (n.prototype.toPromise = function (e) {
      var t = this;
      return (
        (e = X9(e)),
        new e(function (i, r) {
          var s;
          t.subscribe(
            function (o) {
              return (s = o);
            },
            function (o) {
              return r(o);
            },
            function () {
              return i(s);
            },
          );
        })
      );
    }),
    (n.create = function (e) {
      return new n(e);
    }),
    n
  );
})();
function X9(n) {
  var e;
  return (e = n ?? kE.Promise) !== null && e !== void 0 ? e : Promise;
}
function TY(n) {
  return n && Eo(n.next) && Eo(n.error) && Eo(n.complete);
}
function EY(n) {
  return (n && n instanceof lv) || (TY(n) && FE(n));
}
function MY(n) {
  return Eo(n?.lift);
}
function OE(n) {
  return function (e) {
    if (MY(e))
      return e.lift(function (t) {
        try {
          return n(t, this);
        } catch (i) {
          this.error(i);
        }
      });
    throw new TypeError("Unable to lift unknown Observable type");
  };
}
function UE(n, e, t, i, r) {
  return new LY(n, e, t, i, r);
}
var LY = (function (n) {
    ov(e, n);
    function e(t, i, r, s, o, a) {
      var l = n.call(this, t) || this;
      return (
        (l.onFinalize = o),
        (l.shouldUnsubscribe = a),
        (l._next = i
          ? function (c) {
              try {
                i(c);
              } catch (u) {
                t.error(u);
              }
            }
          : n.prototype._next),
        (l._error = s
          ? function (c) {
              try {
                s(c);
              } catch (u) {
                t.error(u);
              } finally {
                this.unsubscribe();
              }
            }
          : n.prototype._error),
        (l._complete = r
          ? function () {
              try {
                r();
              } catch (c) {
                t.error(c);
              } finally {
                this.unsubscribe();
              }
            }
          : n.prototype._complete),
        l
      );
    }
    return (
      (e.prototype.unsubscribe = function () {
        var t;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
          var i = this.closed;
          (n.prototype.unsubscribe.call(this),
            !i &&
              ((t = this.onFinalize) === null || t === void 0 || t.call(this)));
        }
      }),
      e
    );
  })(lv),
  RY = GE(function (n) {
    return function () {
      (n(this),
        (this.name = "EmptyError"),
        (this.message = "no elements in sequence"));
    };
  });
function Ti(n, e) {
  var t = typeof e == "object";
  return new Promise(function (i, r) {
    var s = !1,
      o;
    n.subscribe({
      next: function (a) {
        ((o = a), (s = !0));
      },
      error: r,
      complete: function () {
        s ? i(o) : t ? i(e.defaultValue) : r(new RY());
      },
    });
  });
}
function fu(n, e) {
  return OE(function (t, i) {
    var r = 0;
    t.subscribe(
      UE(i, function (s) {
        i.next(n.call(e, s, r++));
      }),
    );
  });
}
function mp(n, e) {
  return OE(function (t, i) {
    var r = 0;
    t.subscribe(
      UE(i, function (s) {
        return n.call(e, s, r++) && i.next(s);
      }),
    );
  });
}
const n2 = 5;
class BY extends Error {
  constructor(e) {
    const t = HE(e);
    (super(t.message), (this.statusCode = 400), Object.assign(this, t));
  }
}
class PY extends Error {
  constructor(e) {
    const t = HE(e);
    (super(t.message), (this.statusCode = 500), Object.assign(this, t));
  }
}
function HE(n) {
  const e = n.body,
    t = {
      response: n,
      statusCode: n.statusCode,
      responseBody: GY(e, n),
      message: "",
      details: void 0,
    };
  if (e.error && e.message)
    return ((t.message = "".concat(e.error, " - ").concat(e.message)), t);
  if (NY(e)) {
    const i = e.error.items || [],
      r = i
        .slice(0, n2)
        .map((o) => {
          var a;
          return (a = o.error) == null ? void 0 : a.description;
        })
        .filter(Boolean);
    let s = r.length
      ? `:
- `.concat(
          r.join(`
- `),
        )
      : "";
    return (
      i.length > n2 &&
        (s += `
...and `.concat(i.length - n2, " more")),
      (t.message = "".concat(e.error.description).concat(s)),
      (t.details = e.error),
      t
    );
  }
  return e.error && e.error.description
    ? ((t.message = e.error.description), (t.details = e.error), t)
    : ((t.message = e.error || e.message || DY(n)), t);
}
function NY(n) {
  return (
    K9(n) &&
    K9(n.error) &&
    n.error.type === "mutationError" &&
    typeof n.error.description == "string"
  );
}
function K9(n) {
  return typeof n == "object" && n !== null && !Array.isArray(n);
}
function DY(n) {
  const e = n.statusMessage ? " ".concat(n.statusMessage) : "";
  return ""
    .concat(n.method, "-request to ")
    .concat(n.url, " resulted in HTTP ")
    .concat(n.statusCode)
    .concat(e);
}
function GY(n, e) {
  return (e.headers["content-type"] || "")
    .toLowerCase()
    .indexOf("application/json") !== -1
    ? JSON.stringify(n, null, 2)
    : n;
}
const FY = {
    onResponse: (n) => {
      if (n.statusCode >= 500) throw new PY(n);
      if (n.statusCode >= 400) throw new BY(n);
      return n;
    },
  },
  kY = {
    onResponse: (n) => {
      const e = n.headers["x--warning"];
      return (
        (Array.isArray(e) ? e : [e])
          .filter(Boolean)
          .forEach((i) => console.warn(i)),
        n
      );
    },
  };
function j9(n, e) {
  let { maxRetries: t = 5, retryDelay: i } = e;
  const r = nY([
    t > 0 ? sv({ retryDelay: i, maxRetries: t, shouldRetry: OY }) : {},
    ...n,
    kY,
    cY(),
    uY(),
    fY(),
    FY,
    dY({ implementation: Sg }),
  ]);
  function s(o) {
    return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : r)(
      { maxRedirects: 0, ...o },
    );
  }
  return ((s.defaultRequester = r), s);
}
function OY(n, e, t) {
  const i = t.method === "GET" || t.method === "HEAD",
    s = (t.uri || t.url).startsWith("/data/query"),
    o =
      n.response &&
      (n.response.statusCode === 429 ||
        n.response.statusCode === 502 ||
        n.response.statusCode === 503);
  return (i || s) && o ? !0 : sv.shouldRetry(n, e, t);
}
function WE(n) {
  if (typeof n == "string" || Array.isArray(n)) return { id: n };
  if (
    typeof n == "object" &&
    n !== null &&
    "query" in n &&
    typeof n.query == "string"
  )
    return "params" in n && typeof n.params == "object" && n.params !== null
      ? { query: n.query, params: n.params }
      : { query: n.query };
  const e = [
    "* Document ID (<docId>)",
    "* Array of document IDs",
    "* Object containing `query`",
  ].join(`
`);
  throw new Error(
    `Unknown selection - must be one of:

`.concat(e),
  );
}
const $9 = ["image", "file"],
  J9 = ["before", "after", "replace"],
  VE = (n) => {
    if (!/^(~[a-z0-9]{1}[-\w]{0,63}|[a-z0-9]{1}[-\w]{0,63})$/.test(n))
      throw new Error(
        "Datasets can only contain lowercase characters, numbers, underscores and dashes, and start with tilde, and be maximum 64 characters",
      );
  },
  UY = (n) => {
    if (!/^[-a-z0-9]+$/i.test(n))
      throw new Error("`projectId` can only contain only a-z, 0-9 and dashes");
  },
  HY = (n) => {
    if ($9.indexOf(n) === -1)
      throw new Error(
        "Invalid asset type: "
          .concat(n, ". Must be one of ")
          .concat($9.join(", ")),
      );
  },
  Qf = (n, e) => {
    if (e === null || typeof e != "object" || Array.isArray(e))
      throw new Error("".concat(n, "() takes an object of properties"));
  },
  ZE = (n, e) => {
    if (
      typeof e != "string" ||
      !/^[a-z0-9_][a-z0-9_.-]{0,127}$/i.test(e) ||
      e.includes("..")
    )
      throw new Error(
        "".concat(n, '(): "').concat(e, '" is not a valid document ID'),
      );
  },
  wm = (n, e) => {
    if (!e._id)
      throw new Error(
        "".concat(
          n,
          '() requires that the document contains an ID ("_id" property)',
        ),
      );
    ZE(n, e._id);
  },
  WY = (n, e, t) => {
    const i = "insert(at, selector, items)";
    if (J9.indexOf(n) === -1) {
      const r = J9.map((s) => '"'.concat(s, '"')).join(", ");
      throw new Error(
        "".concat(i, ' takes an "at"-argument which is one of: ').concat(r),
      );
    }
    if (typeof e != "string")
      throw new Error(
        "".concat(i, ' takes a "selector"-argument which must be a string'),
      );
    if (!Array.isArray(t))
      throw new Error(
        "".concat(i, ' takes an "items"-argument which must be an array'),
      );
  },
  zE = (n) => {
    if (!n.dataset)
      throw new Error("`dataset` must be provided to perform queries");
    return n.dataset || "";
  },
  YE = (n) => {
    if (typeof n != "string" || !/^[a-z0-9._-]{1,75}$/i.test(n))
      throw new Error(
        "Tag can only contain alphanumeric characters, underscores, dashes and dots, and be between one and 75 characters long.",
      );
    return n;
  };
var XE = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  Rh = (n, e, t) => (
    XE(n, e, "read from private field"),
    t ? t.call(n) : e.get(n)
  ),
  KE = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  jE = (n, e, t, i) => (
    XE(n, e, "write to private field"),
    i ? i.call(n, t) : e.set(n, t),
    t
  ),
  rh,
  sh;
class $E {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    ((this.selection = e), (this.operations = t));
  }
  set(e) {
    return this._assign("set", e);
  }
  setIfMissing(e) {
    return this._assign("setIfMissing", e);
  }
  diffMatchPatch(e) {
    return (Qf("diffMatchPatch", e), this._assign("diffMatchPatch", e));
  }
  unset(e) {
    if (!Array.isArray(e))
      throw new Error(
        "unset(attrs) takes an array of attributes to unset, non-array given",
      );
    return (
      (this.operations = Object.assign({}, this.operations, { unset: e })),
      this
    );
  }
  inc(e) {
    return this._assign("inc", e);
  }
  dec(e) {
    return this._assign("dec", e);
  }
  insert(e, t, i) {
    return (WY(e, t, i), this._assign("insert", { [e]: t, items: i }));
  }
  append(e, t) {
    return this.insert("after", "".concat(e, "[-1]"), t);
  }
  prepend(e, t) {
    return this.insert("before", "".concat(e, "[0]"), t);
  }
  splice(e, t, i, r) {
    const s = typeof i > "u" || i === -1,
      o = t < 0 ? t - 1 : t,
      a = s ? -1 : Math.max(0, t + i),
      l = o < 0 && a >= 0 ? "" : a,
      c = "".concat(e, "[").concat(o, ":").concat(l, "]");
    return this.insert("replace", c, r || []);
  }
  ifRevisionId(e) {
    return ((this.operations.ifRevisionID = e), this);
  }
  serialize() {
    return { ...WE(this.selection), ...this.operations };
  }
  toJSON() {
    return this.serialize();
  }
  reset() {
    return ((this.operations = {}), this);
  }
  _assign(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
    return (
      Qf(e, t),
      (this.operations = Object.assign({}, this.operations, {
        [e]: Object.assign({}, (i && this.operations[e]) || {}, t),
      })),
      this
    );
  }
  _set(e, t) {
    return this._assign(e, t, !1);
  }
}
const VY = class JE extends $E {
  constructor(e, t, i) {
    (super(e, t), KE(this, rh, void 0), jE(this, rh, i));
  }
  clone() {
    return new JE(this.selection, { ...this.operations }, Rh(this, rh));
  }
  commit(e) {
    if (!Rh(this, rh))
      throw new Error(
        "No `client` passed to patch, either provide one or pass the patch to a clients `mutate()` method",
      );
    const t = typeof this.selection == "string",
      i = Object.assign({ returnFirst: t, returnDocuments: !0 }, e);
    return Rh(this, rh).mutate({ patch: this.serialize() }, i);
  }
};
rh = new WeakMap();
let qf = VY;
const ZY = class QE extends $E {
  constructor(e, t, i) {
    (super(e, t), KE(this, sh, void 0), jE(this, sh, i));
  }
  clone() {
    return new QE(this.selection, { ...this.operations }, Rh(this, sh));
  }
  commit(e) {
    if (!Rh(this, sh))
      throw new Error(
        "No `client` passed to patch, either provide one or pass the patch to a clients `mutate()` method",
      );
    const t = typeof this.selection == "string",
      i = Object.assign({ returnFirst: t, returnDocuments: !0 }, e);
    return Rh(this, sh).mutate({ patch: this.serialize() }, i);
  }
};
sh = new WeakMap();
let eg = ZY;
var qE = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  pl = (n, e, t) => (
    qE(n, e, "read from private field"),
    t ? t.call(n) : e.get(n)
  ),
  eM = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  tM = (n, e, t, i) => (
    qE(n, e, "write to private field"),
    i ? i.call(n, t) : e.set(n, t),
    t
  ),
  Cc,
  Ic;
const nM = { returnDocuments: !1 };
class iM {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
      t = arguments.length > 1 ? arguments[1] : void 0;
    ((this.operations = e), (this.trxId = t));
  }
  create(e) {
    return (Qf("create", e), this._add({ create: e }));
  }
  createIfNotExists(e) {
    const t = "createIfNotExists";
    return (Qf(t, e), wm(t, e), this._add({ [t]: e }));
  }
  createOrReplace(e) {
    const t = "createOrReplace";
    return (Qf(t, e), wm(t, e), this._add({ [t]: e }));
  }
  delete(e) {
    return (ZE("delete", e), this._add({ delete: { id: e } }));
  }
  transactionId(e) {
    return e ? ((this.trxId = e), this) : this.trxId;
  }
  serialize() {
    return [...this.operations];
  }
  toJSON() {
    return this.serialize();
  }
  reset() {
    return ((this.operations = []), this);
  }
  _add(e) {
    return (this.operations.push(e), this);
  }
}
const zY = class rM extends iM {
  constructor(e, t, i) {
    (super(e, i), eM(this, Cc, void 0), tM(this, Cc, t));
  }
  clone() {
    return new rM([...this.operations], pl(this, Cc), this.trxId);
  }
  commit(e) {
    if (!pl(this, Cc))
      throw new Error(
        "No `client` passed to transaction, either provide one or pass the transaction to a clients `mutate()` method",
      );
    return pl(this, Cc).mutate(
      this.serialize(),
      Object.assign({ transactionId: this.trxId }, nM, e || {}),
    );
  }
  patch(e, t) {
    const i = typeof t == "function";
    if (typeof e != "string" && e instanceof eg)
      return this._add({ patch: e.serialize() });
    if (i) {
      const s = t(new eg(e, {}, pl(this, Cc)));
      if (!(s instanceof eg))
        throw new Error("function passed to `patch()` must return the patch");
      return this._add({ patch: s.serialize() });
    }
    return this._add({ patch: { id: e, ...t } });
  }
};
Cc = new WeakMap();
let sM = zY;
const YY = class oM extends iM {
  constructor(e, t, i) {
    (super(e, i), eM(this, Ic, void 0), tM(this, Ic, t));
  }
  clone() {
    return new oM([...this.operations], pl(this, Ic), this.trxId);
  }
  commit(e) {
    if (!pl(this, Ic))
      throw new Error(
        "No `client` passed to transaction, either provide one or pass the transaction to a clients `mutate()` method",
      );
    return pl(this, Ic).mutate(
      this.serialize(),
      Object.assign({ transactionId: this.trxId }, nM, e || {}),
    );
  }
  patch(e, t) {
    const i = typeof t == "function";
    if (typeof e != "string" && e instanceof qf)
      return this._add({ patch: e.serialize() });
    if (i) {
      const s = t(new qf(e, {}, pl(this, Ic)));
      if (!(s instanceof qf))
        throw new Error("function passed to `patch()` must return the patch");
      return this._add({ patch: s.serialize() });
    }
    return this._add({ patch: { id: e, ...t } });
  }
};
Ic = new WeakMap();
let aM = YY;
const XY = "https://local.help/";
function cv(n) {
  return XY + n;
}
function KY(n) {
  let e = !1,
    t;
  return function () {
    return (e || ((t = n(...arguments)), (e = !0)), t);
  };
}
const WC = (n) =>
    KY(function () {
      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
        t[i] = arguments[i];
      return console.warn(n.join(" "), ...t);
    }),
  jY = WC([
    "Since you haven't set a value for `useCdn`, we will deliver content using our",
    "global, edge-cached API-CDN. If you wish to have content delivered faster, set",
    "`useCdn: false` to use the Live API. Note: You may incur higher costs using the live API.",
  ]),
  $Y = WC([
    "The CMS client is configured with the `perspective` set to `previewDrafts`, which doesn't support the API-CDN.",
    "The Live API will be used instead. Set `useCdn: false` in your configuration to hide this warning.",
  ]),
  JY = WC([
    "You have configured CMS client to use a token in the browser. This may cause unintentional security issues.",
    "See ".concat(
      cv("js-client-browser-token"),
      " for more information and how to hide this warning.",
    ),
  ]),
  QY = WC([
    "Using the CMS client without specifying an API version is deprecated.",
    "See ".concat(cv("js-client-api-version")),
  ]),
  qY = "api.local",
  Sm = {
    apiHost: "https://api.local",
    apiVersion: "1",
    useProjectHostname: !0,
  },
  eX = ["localhost", "127.0.0.1", "0.0.0.0"],
  tX = (n) => eX.indexOf(n) !== -1,
  nX = function (e) {
    if (e === "1" || e === "X") return;
    const t = new Date(e);
    if (
      !(/^\d{4}-\d{2}-\d{2}$/.test(e) && t instanceof Date && t.getTime() > 0)
    )
      throw new Error(
        "Invalid API version string, expected `1` or date in format `YYYY-MM-DD`",
      );
  },
  lM = function (e) {
    switch (e) {
      case "previewDrafts":
      case "published":
      case "raw":
        return;
      default:
        throw new TypeError(
          "Invalid API perspective string, expected `published`, `previewDrafts` or `raw`",
        );
    }
  },
  cM = (n, e) => {
    const t = Object.assign({}, e, n);
    t.apiVersion || QY();
    const i = Object.assign({}, Sm, t),
      r = i.useProjectHostname;
    if (typeof Promise > "u") {
      const h = cv("js-client-promise-polyfill");
      throw new Error(
        "No native Promise-implementation found, polyfill needed - see ".concat(
          h,
        ),
      );
    }
    if (r && !i.projectId)
      throw new Error("Configuration must contain `projectId`");
    if (
      (typeof i.perspective == "string" && lM(i.perspective),
      "encodeSourceMapAtPath" in i ||
        "encodeSourceMap" in i ||
        "studioUrl" in i ||
        "logger" in i)
    )
      throw new Error(
        "It looks like you're using options meant for '@/preview-kit/client', such as 'encodeSourceMapAtPath', 'encodeSourceMap', 'studioUrl' and 'logger'. Make sure you're using the right import.",
      );
    if ("stega" in i && i.stega !== void 0 && i.stega !== !1)
      throw new Error(
        "It looks like you're using options meant for '@/client/stega'. Make sure you're using the right import. Or set 'stega' in 'createClient' to 'false'.",
      );
    const s =
        typeof window < "u" && window.location && window.location.hostname,
      o = s && tX(window.location.hostname);
    (s && o && i.token && i.ignoreBrowserTokenWarning !== !0
      ? JY()
      : typeof i.useCdn > "u" && jY(),
      r && UY(i.projectId),
      i.dataset && VE(i.dataset),
      "requestTagPrefix" in i &&
        (i.requestTagPrefix = i.requestTagPrefix
          ? YE(i.requestTagPrefix).replace(/\.+$/, "")
          : void 0),
      (i.apiVersion = "".concat(i.apiVersion).replace(/^v/, "")),
      (i.isDefaultApi = i.apiHost === Sm.apiHost),
      (i.useCdn = i.useCdn !== !1 && !i.withCredentials),
      nX(i.apiVersion));
    const a = i.apiHost.split("://", 2),
      l = a[0],
      c = a[1],
      u = i.isDefaultApi ? qY : c;
    return (
      i.useProjectHostname
        ? ((i.url = ""
            .concat(l, "://")
            .concat(i.projectId, ".")
            .concat(c, "/v")
            .concat(i.apiVersion)),
          (i.cdnUrl = ""
            .concat(l, "://")
            .concat(i.projectId, ".")
            .concat(u, "/v")
            .concat(i.apiVersion)))
        : ((i.url = "".concat(i.apiHost, "/v").concat(i.apiVersion)),
          (i.cdnUrl = i.url)),
      i
    );
  },
  iX = "X-CMS-Project-ID";
function rX(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = {},
    i = e.token || n.token;
  (i && (t.Authorization = "Bearer ".concat(i)),
    !e.useGlobalApi &&
      !n.useProjectHostname &&
      n.projectId &&
      (t[iX] = n.projectId));
  const r = !!(typeof e.withCredentials > "u"
      ? n.token || n.withCredentials
      : e.withCredentials),
    s = typeof e.timeout > "u" ? n.timeout : e.timeout;
  return Object.assign({}, e, {
    headers: Object.assign({}, t, e.headers || {}),
    timeout: typeof s > "u" ? 5 * 60 * 1e3 : s,
    proxy: e.proxy || n.proxy,
    json: !0,
    withCredentials: r,
    fetch:
      typeof e.fetch == "object" && typeof n.fetch == "object"
        ? { ...n.fetch, ...e.fetch }
        : e.fetch || n.fetch,
  });
}
const uM = (n) => {
    let { query: e, params: t = {}, options: i = {} } = n;
    const r = new URLSearchParams(),
      { tag: s, ...o } = i;
    (s && r.append("tag", s), r.append("query", e));
    for (const [a, l] of Object.entries(t))
      r.append("$".concat(a), JSON.stringify(l));
    for (const [a, l] of Object.entries(o)) l && r.append(a, "".concat(l));
    return "?".concat(r);
  },
  sX = (n, e) => (n === !1 ? void 0 : typeof n > "u" ? e : n),
  oX = function () {
    let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return {
      dryRun: n.dryRun,
      returnIds: !0,
      returnDocuments: sX(n.returnDocuments, !0),
      visibility: n.visibility || "sync",
      autoGenerateArrayKeys: n.autoGenerateArrayKeys,
      skipCrossDatasetReferenceValidation:
        n.skipCrossDatasetReferenceValidation,
    };
  },
  uv = (n) => n.type === "response",
  aX = (n) => n.body,
  lX = (n, e) => n.reduce((t, i) => ((t[e(i)] = i), t), Object.create(null)),
  cX = 11264;
function hM(n, e, t, i) {
  let r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  if ("stega" in r && r.stega !== void 0 && r.stega !== !1)
    throw new Error(
      "It looks like you're using options meant for '@/client/stega'. Make sure you're using the right import. Or set 'stega' in 'fetch' to 'false'.",
    );
  const s = r.filterResponse === !1 ? (u) => u : (u) => u.result,
    {
      cache: o,
      next: a,
      ...l
    } = { useAbortSignal: typeof r.signal < "u", ...r },
    c =
      typeof o < "u" || typeof a < "u"
        ? { ...l, fetch: { cache: o, next: a } }
        : l;
  return Cp(n, e, "query", { query: t, params: i }, c).pipe(fu(s));
}
function dM(n, e, t) {
  let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  const r = { uri: kd(n, "doc", t), json: !0, tag: i.tag };
  return Ip(n, e, r).pipe(
    mp(uv),
    fu((s) => s.body.documents && s.body.documents[0]),
  );
}
function fM(n, e, t) {
  let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  const r = { uri: kd(n, "doc", t.join(",")), json: !0, tag: i.tag };
  return Ip(n, e, r).pipe(
    mp(uv),
    fu((s) => {
      const o = lX(s.body.documents || [], (a) => a._id);
      return t.map((a) => o[a] || null);
    }),
  );
}
function gM(n, e, t, i) {
  return (wm("createIfNotExists", t), VC(n, e, t, "createIfNotExists", i));
}
function pM(n, e, t, i) {
  return (wm("createOrReplace", t), VC(n, e, t, "createOrReplace", i));
}
function mM(n, e, t, i) {
  return Cp(n, e, "mutate", { mutations: [{ delete: WE(t) }] }, i);
}
function CM(n, e, t, i) {
  let r;
  t instanceof eg || t instanceof qf
    ? (r = { patch: t.serialize() })
    : t instanceof sM || t instanceof aM
      ? (r = t.serialize())
      : (r = t);
  const s = Array.isArray(r) ? r : [r],
    o = (i && i.transactionId) || void 0;
  return Cp(n, e, "mutate", { mutations: s, transactionId: o }, i);
}
function Cp(n, e, t, i) {
  let r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  const s = t === "mutate",
    o = t === "query",
    a = s ? "" : uM(i),
    l = !s && a.length < cX,
    c = l ? a : "",
    u = r.returnFirst,
    { timeout: h, token: d, tag: f, headers: g } = r,
    p = kd(n, t, c),
    m = {
      method: l ? "GET" : "POST",
      uri: p,
      json: !0,
      body: l ? void 0 : i,
      query: s && oX(r),
      timeout: h,
      headers: g,
      token: d,
      tag: f,
      perspective: r.perspective,
      resultSourceMap: r.resultSourceMap,
      canUseCdn: o,
      signal: r.signal,
      fetch: r.fetch,
      useAbortSignal: r.useAbortSignal,
      useCdn: r.useCdn,
    };
  return Ip(n, e, m).pipe(
    mp(uv),
    fu(aX),
    fu((C) => {
      if (!s) return C;
      const A = C.results || [];
      if (r.returnDocuments)
        return u ? A[0] && A[0].document : A.map((x) => x.document);
      const I = u ? "documentId" : "documentIds",
        y = u ? A[0] && A[0].id : A.map((x) => x.id);
      return { transactionId: C.transactionId, results: A, [I]: y };
    }),
  );
}
function VC(n, e, t, i) {
  let r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  const s = { [i]: t },
    o = Object.assign({ returnFirst: !0, returnDocuments: !0 }, r);
  return Cp(n, e, "mutate", { mutations: [s] }, o);
}
function Ip(n, e, t) {
  var i, r;
  const s = t.url || t.uri,
    o = n.config(),
    a =
      typeof t.canUseCdn > "u"
        ? ["GET", "HEAD"].indexOf(t.method || "GET") >= 0 &&
          s.indexOf("/data/") === 0
        : t.canUseCdn;
  let l = ((i = t.useCdn) != null ? i : o.useCdn) && a;
  const c =
    t.tag && o.requestTagPrefix
      ? [o.requestTagPrefix, t.tag].join(".")
      : t.tag || o.requestTagPrefix;
  if (
    (c && t.tag !== null && (t.query = { tag: YE(c), ...t.query }),
    ["GET", "HEAD", "POST"].indexOf(t.method || "GET") >= 0 &&
      s.indexOf("/data/query/") === 0)
  ) {
    const d = (r = t.resultSourceMap) != null ? r : o.resultSourceMap;
    d !== void 0 && d !== !1 && (t.query = { resultSourceMap: d, ...t.query });
    const f = t.perspective || o.perspective;
    typeof f == "string" &&
      f !== "raw" &&
      (lM(f),
      (t.query = { perspective: f, ...t.query }),
      f === "previewDrafts" && l && ((l = !1), $Y()));
  }
  const u = rX(o, Object.assign({}, t, { url: hv(n, s, l) })),
    h = new Sg((d) => e(u, o.requester).subscribe(d));
  return t.signal ? h.pipe(uX(t.signal)) : h;
}
function io(n, e, t) {
  return Ip(n, e, t).pipe(
    mp((r) => r.type === "response"),
    fu((r) => r.body),
  );
}
function kd(n, e, t) {
  const i = n.config(),
    r = zE(i),
    s = "/".concat(e, "/").concat(r),
    o = t ? "".concat(s, "/").concat(t) : s;
  return "/data".concat(o).replace(/\/($|\?)/, "$1");
}
function hv(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  const { url: i, cdnUrl: r } = n.config(),
    s = t ? r : i;
  return "".concat(s, "/").concat(e.replace(/^\//, ""));
}
function uX(n) {
  return (e) =>
    new Sg((t) => {
      const i = () => t.error(dX(n));
      if (n && n.aborted) {
        i();
        return;
      }
      const r = e.subscribe(t);
      return (
        n.addEventListener("abort", i),
        () => {
          (n.removeEventListener("abort", i), r.unsubscribe());
        }
      );
    });
}
const hX = !!globalThis.DOMException;
function dX(n) {
  var e, t;
  if (hX)
    return new DOMException(
      (e = n?.reason) != null ? e : "The operation was aborted.",
      "AbortError",
    );
  const i = new Error(
    (t = n?.reason) != null ? t : "The operation was aborted.",
  );
  return ((i.name = "AbortError"), i);
}
var IM = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  Tm = (n, e, t) => (
    IM(n, e, "read from private field"),
    t ? t.call(n) : e.get(n)
  ),
  Em = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  Mm = (n, e, t, i) => (
    IM(n, e, "write to private field"),
    i ? i.call(n, t) : e.set(n, t),
    t
  ),
  v0,
  x0,
  w0,
  S0;
class fX {
  constructor(e, t) {
    (Em(this, v0, void 0),
      Em(this, x0, void 0),
      Mm(this, v0, e),
      Mm(this, x0, t));
  }
  upload(e, t, i) {
    return AM(Tm(this, v0), Tm(this, x0), e, t, i);
  }
}
v0 = new WeakMap();
x0 = new WeakMap();
class gX {
  constructor(e, t) {
    (Em(this, w0, void 0),
      Em(this, S0, void 0),
      Mm(this, w0, e),
      Mm(this, S0, t));
  }
  upload(e, t, i) {
    const r = AM(Tm(this, w0), Tm(this, S0), e, t, i);
    return Ti(
      r.pipe(
        mp((s) => s.type === "response"),
        fu((s) => s.body.document),
      ),
    );
  }
}
w0 = new WeakMap();
S0 = new WeakMap();
function AM(n, e, t, i) {
  let r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  HY(t);
  let s = r.extract || void 0;
  s && !s.length && (s = ["none"]);
  const o = zE(n.config()),
    a = t === "image" ? "images" : "files",
    l = pX(r, i),
    {
      tag: c,
      label: u,
      title: h,
      description: d,
      creditLine: f,
      filename: g,
      source: p,
    } = l,
    m = {
      label: u,
      title: h,
      description: d,
      filename: g,
      meta: s,
      creditLine: f,
    };
  return (
    p && ((m.sourceId = p.id), (m.sourceName = p.name), (m.sourceUrl = p.url)),
    Ip(n, e, {
      tag: c,
      method: "POST",
      timeout: l.timeout || 0,
      uri: "assets/".concat(a, "/").concat(o),
      headers: l.contentType ? { "Content-Type": l.contentType } : {},
      query: m,
      body: i,
    })
  );
}
function pX(n, e) {
  return typeof File > "u" || !(e instanceof File)
    ? n
    : Object.assign(
        {
          filename: n.preserveFilename === !1 ? void 0 : e.name,
          contentType: e.type,
        },
        n,
      );
}
var mX = (n, e) =>
  Object.keys(e)
    .concat(Object.keys(n))
    .reduce((t, i) => ((t[i] = typeof n[i] > "u" ? e[i] : n[i]), t), {});
const CX = (n, e) =>
    e.reduce((t, i) => (typeof n[i] > "u" || (t[i] = n[i]), t), {}),
  IX = 16e3 - 1200,
  AX = [
    "includePreviousRevision",
    "includeResult",
    "visibility",
    "effectFormat",
    "tag",
  ],
  yX = { includeResult: !0 };
function yM(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
      url: i,
      token: r,
      withCredentials: s,
      requestTagPrefix: o,
    } = this.config(),
    a = t.tag && o ? [o, t.tag].join(".") : t.tag,
    l = { ...mX(t, yX), tag: a },
    c = CX(l, AX),
    u = uM({ query: n, params: e, options: { tag: a, ...c } }),
    h = "".concat(i).concat(kd(this, "listen", u));
  if (h.length > IX)
    return new Sg((p) => p.error(new Error("Query too large for listener")));
  const d = l.events ? l.events : ["mutation"],
    f = d.indexOf("reconnect") !== -1,
    g = {};
  return (
    (r || s) && (g.withCredentials = !0),
    r && (g.headers = { Authorization: "Bearer ".concat(r) }),
    new Sg((p) => {
      let m;
      _()
        .then((M) => {
          m = M;
        })
        .catch((M) => {
          (p.error(M), R());
        });
      let C,
        A = !1;
      function I() {
        A ||
          (E(),
          !A &&
            m.readyState === m.CLOSED &&
            (S(), clearTimeout(C), (C = setTimeout(b, 100))));
      }
      function y(M) {
        p.error(_X(M));
      }
      function x(M) {
        const L = _M(M);
        return L instanceof Error ? p.error(L) : p.next(L);
      }
      function T() {
        ((A = !0), S(), p.complete());
      }
      function S() {
        m &&
          (m.removeEventListener("error", I),
          m.removeEventListener("channelError", y),
          m.removeEventListener("disconnect", T),
          d.forEach((M) => m.removeEventListener(M, x)),
          m.close());
      }
      function E() {
        f && p.next({ type: "reconnect" });
      }
      async function _() {
        const { default: M } = await lr(
            () => import("./browser-451d90c8.js").then((P) => P.b),
            [],
          ),
          L = new M(h, g);
        return (
          L.addEventListener("error", I),
          L.addEventListener("channelError", y),
          L.addEventListener("disconnect", T),
          d.forEach((P) => L.addEventListener(P, x)),
          L
        );
      }
      function b() {
        _()
          .then((M) => {
            m = M;
          })
          .catch((M) => {
            (p.error(M), R());
          });
      }
      function R() {
        ((A = !0), S());
      }
      return R;
    })
  );
}
function _M(n) {
  try {
    const e = (n.data && JSON.parse(n.data)) || {};
    return Object.assign({ type: n.type }, e);
  } catch (e) {
    return e;
  }
}
function _X(n) {
  if (n instanceof Error) return n;
  const e = _M(n);
  return e instanceof Error ? e : new Error(bX(e));
}
function bX(n) {
  return n.error
    ? n.error.description
      ? n.error.description
      : typeof n.error == "string"
        ? n.error
        : JSON.stringify(n.error, null, 2)
    : n.message || "Unknown listener error";
}
var bM = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  Yi = (n, e, t) => (
    bM(n, e, "read from private field"),
    t ? t.call(n) : e.get(n)
  ),
  Lm = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  Rm = (n, e, t, i) => (
    bM(n, e, "write to private field"),
    i ? i.call(n, t) : e.set(n, t),
    t
  ),
  Ac,
  yc,
  _c,
  bc;
class vX {
  constructor(e, t) {
    (Lm(this, Ac, void 0),
      Lm(this, yc, void 0),
      Rm(this, Ac, e),
      Rm(this, yc, t));
  }
  create(e, t) {
    return Bh(Yi(this, Ac), Yi(this, yc), "PUT", e, t);
  }
  edit(e, t) {
    return Bh(Yi(this, Ac), Yi(this, yc), "PATCH", e, t);
  }
  delete(e) {
    return Bh(Yi(this, Ac), Yi(this, yc), "DELETE", e);
  }
  list() {
    return io(Yi(this, Ac), Yi(this, yc), { uri: "/datasets", tag: null });
  }
}
Ac = new WeakMap();
yc = new WeakMap();
class xX {
  constructor(e, t) {
    (Lm(this, _c, void 0),
      Lm(this, bc, void 0),
      Rm(this, _c, e),
      Rm(this, bc, t));
  }
  create(e, t) {
    return Ti(Bh(Yi(this, _c), Yi(this, bc), "PUT", e, t));
  }
  edit(e, t) {
    return Ti(Bh(Yi(this, _c), Yi(this, bc), "PATCH", e, t));
  }
  delete(e) {
    return Ti(Bh(Yi(this, _c), Yi(this, bc), "DELETE", e));
  }
  list() {
    return Ti(io(Yi(this, _c), Yi(this, bc), { uri: "/datasets", tag: null }));
  }
}
_c = new WeakMap();
bc = new WeakMap();
function Bh(n, e, t, i, r) {
  return (
    VE(i),
    io(n, e, { method: t, uri: "/datasets/".concat(i), body: r, tag: null })
  );
}
var vM = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  ml = (n, e, t) => (
    vM(n, e, "read from private field"),
    t ? t.call(n) : e.get(n)
  ),
  Bm = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  Pm = (n, e, t, i) => (
    vM(n, e, "write to private field"),
    i ? i.call(n, t) : e.set(n, t),
    t
  ),
  Rf,
  Bf,
  Pf,
  Nf;
class wX {
  constructor(e, t) {
    (Bm(this, Rf, void 0),
      Bm(this, Bf, void 0),
      Pm(this, Rf, e),
      Pm(this, Bf, t));
  }
  list(e) {
    const t =
      e?.includeMembers === !1 ? "/projects?includeMembers=false" : "/projects";
    return io(ml(this, Rf), ml(this, Bf), { uri: t });
  }
  getById(e) {
    return io(ml(this, Rf), ml(this, Bf), { uri: "/projects/".concat(e) });
  }
}
Rf = new WeakMap();
Bf = new WeakMap();
class SX {
  constructor(e, t) {
    (Bm(this, Pf, void 0),
      Bm(this, Nf, void 0),
      Pm(this, Pf, e),
      Pm(this, Nf, t));
  }
  list(e) {
    const t =
      e?.includeMembers === !1 ? "/projects?includeMembers=false" : "/projects";
    return Ti(io(ml(this, Pf), ml(this, Nf), { uri: t }));
  }
  getById(e) {
    return Ti(io(ml(this, Pf), ml(this, Nf), { uri: "/projects/".concat(e) }));
  }
}
Pf = new WeakMap();
Nf = new WeakMap();
var xM = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  Nm = (n, e, t) => (
    xM(n, e, "read from private field"),
    t ? t.call(n) : e.get(n)
  ),
  Dm = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  Gm = (n, e, t, i) => (
    xM(n, e, "write to private field"),
    i ? i.call(n, t) : e.set(n, t),
    t
  ),
  T0,
  E0,
  M0,
  L0;
class TX {
  constructor(e, t) {
    (Dm(this, T0, void 0),
      Dm(this, E0, void 0),
      Gm(this, T0, e),
      Gm(this, E0, t));
  }
  getById(e) {
    return io(Nm(this, T0), Nm(this, E0), { uri: "/users/".concat(e) });
  }
}
T0 = new WeakMap();
E0 = new WeakMap();
class EX {
  constructor(e, t) {
    (Dm(this, M0, void 0),
      Dm(this, L0, void 0),
      Gm(this, M0, e),
      Gm(this, L0, t));
  }
  getById(e) {
    return Ti(io(Nm(this, M0), Nm(this, L0), { uri: "/users/".concat(e) }));
  }
}
M0 = new WeakMap();
L0 = new WeakMap();
var wM = (n, e, t) => {
    if (!e.has(n)) throw TypeError("Cannot " + t);
  },
  Dt = (n, e, t) => (
    wM(n, e, "read from private field"),
    t ? t.call(n) : e.get(n)
  ),
  Fm = (n, e, t) => {
    if (e.has(n))
      throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(n) : e.set(n, t);
  },
  km = (n, e, t, i) => (
    wM(n, e, "write to private field"),
    i ? i.call(n, t) : e.set(n, t),
    t
  ),
  vc,
  _i,
  xc,
  ui;
const MX = class Vy {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Sm;
    (Fm(this, vc, void 0),
      Fm(this, _i, void 0),
      (this.listen = yM),
      this.config(t),
      km(this, _i, e),
      (this.assets = new fX(this, Dt(this, _i))),
      (this.datasets = new vX(this, Dt(this, _i))),
      (this.projects = new wX(this, Dt(this, _i))),
      (this.users = new TX(this, Dt(this, _i))));
  }
  clone() {
    return new Vy(Dt(this, _i), this.config());
  }
  config(e) {
    if (e === void 0) return { ...Dt(this, vc) };
    if (Dt(this, vc) && Dt(this, vc).allowReconfigure === !1)
      throw new Error(
        "Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client",
      );
    return (km(this, vc, cM(e, Dt(this, vc) || {})), this);
  }
  withConfig(e) {
    return new Vy(Dt(this, _i), { ...this.config(), ...e });
  }
  fetch(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return hM(this, Dt(this, _i), e, t, i);
  }
  getDocument(e, t) {
    return dM(this, Dt(this, _i), e, t);
  }
  getDocuments(e, t) {
    return fM(this, Dt(this, _i), e, t);
  }
  create(e, t) {
    return VC(this, Dt(this, _i), e, "create", t);
  }
  createIfNotExists(e, t) {
    return gM(this, Dt(this, _i), e, t);
  }
  createOrReplace(e, t) {
    return pM(this, Dt(this, _i), e, t);
  }
  delete(e, t) {
    return mM(this, Dt(this, _i), e, t);
  }
  mutate(e, t) {
    return CM(this, Dt(this, _i), e, t);
  }
  patch(e, t) {
    return new qf(e, t, this);
  }
  transaction(e) {
    return new aM(e, this);
  }
  request(e) {
    return io(this, Dt(this, _i), e);
  }
  getUrl(e, t) {
    return hv(this, e, t);
  }
  getDataUrl(e, t) {
    return kd(this, e, t);
  }
};
vc = new WeakMap();
_i = new WeakMap();
let LX = MX;
const RX = class Zy {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Sm;
    (Fm(this, xc, void 0),
      Fm(this, ui, void 0),
      (this.listen = yM),
      this.config(t),
      km(this, ui, e),
      (this.assets = new gX(this, Dt(this, ui))),
      (this.datasets = new xX(this, Dt(this, ui))),
      (this.projects = new SX(this, Dt(this, ui))),
      (this.users = new EX(this, Dt(this, ui))),
      (this.observable = new LX(e, t)));
  }
  clone() {
    return new Zy(Dt(this, ui), this.config());
  }
  config(e) {
    if (e === void 0) return { ...Dt(this, xc) };
    if (Dt(this, xc) && Dt(this, xc).allowReconfigure === !1)
      throw new Error(
        "Existing client instance cannot be reconfigured - use `withConfig(newConfig)` to return a new client",
      );
    return (
      this.observable && this.observable.config(e),
      km(this, xc, cM(e, Dt(this, xc) || {})),
      this
    );
  }
  withConfig(e) {
    return new Zy(Dt(this, ui), { ...this.config(), ...e });
  }
  fetch(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Ti(hM(this, Dt(this, ui), e, t, i));
  }
  getDocument(e, t) {
    return Ti(dM(this, Dt(this, ui), e, t));
  }
  getDocuments(e, t) {
    return Ti(fM(this, Dt(this, ui), e, t));
  }
  create(e, t) {
    return Ti(VC(this, Dt(this, ui), e, "create", t));
  }
  createIfNotExists(e, t) {
    return Ti(gM(this, Dt(this, ui), e, t));
  }
  createOrReplace(e, t) {
    return Ti(pM(this, Dt(this, ui), e, t));
  }
  delete(e, t) {
    return Ti(mM(this, Dt(this, ui), e, t));
  }
  mutate(e, t) {
    return Ti(CM(this, Dt(this, ui), e, t));
  }
  patch(e, t) {
    return new eg(e, t, this);
  }
  transaction(e) {
    return new sM(e, this);
  }
  request(e) {
    return Ti(io(this, Dt(this, ui), e));
  }
  dataRequest(e, t, i) {
    return Ti(Cp(this, Dt(this, ui), e, t, i));
  }
  getUrl(e, t) {
    return hv(this, e, t);
  }
  getDataUrl(e, t) {
    return kd(this, e, t);
  }
};
xc = new WeakMap();
ui = new WeakMap();
let BX = RX;
function PX(n, e) {
  return {
    requester: j9(n, {}).defaultRequester,
    createClient: (s) =>
      new e(j9(n, { maxRetries: s.maxRetries, retryDelay: s.retryDelay }), s),
  };
}
var NX = [];
const DX = PX(NX, BX),
  SM = DX.createClient;
function zi() {
  return Math.random().toString(36).substring(2, 10);
}
function Df(n) {
  const e = [],
    t = [];
  let i = 0;
  const r = n
      .replace(/&nbsp;/g, " ")
      .replace(/&amp;/g, "&")
      .replace(/&lt;/g, "<")
      .replace(/&gt;/g, ">")
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'")
      .replace(
        /<br\s*\/?>/gi,
        `
`,
      ),
    s = [],
    o = /<(\/)?(\w+)(\s[^>]*)?>/g;
  let a;
  for (; (a = o.exec(r)) !== null; ) {
    const u = a[2].toLowerCase();
    ["strong", "b", "em", "i", "u", "s", "a", "del", "strike"].includes(u) &&
      s.push({ index: a.index, tag: u, isClosing: !!a[1], attrs: a[3] });
  }
  if (s.length === 0) {
    const u = r.replace(/<[^>]*>/g, "");
    return (
      u && e.push({ _type: "span", _key: zi(), text: u, marks: [] }),
      { children: e, markDefs: t }
    );
  }
  const l = new Map();
  let c = [];
  for (let u = 0; u <= s.length; u++) {
    const h = s[u],
      d = h?.index ?? r.length,
      f = r.substring(i, d).replace(/<[^>]*>/g, "");
    if (
      (f && e.push({ _type: "span", _key: zi(), text: f, marks: [...c] }), !h)
    )
      break;
    const { tag: g, isClosing: p, attrs: m } = h;
    if (p)
      if (g === "a") {
        const A = l.get("a");
        A && ((c = c.filter((I) => I !== A)), l.delete("a"));
      } else {
        const A = Q9(g);
        c = c.filter((I) => I !== A);
      }
    else if (g === "a") {
      const A = m?.match(/href=["']([^"']+)["']/);
      if (A) {
        const I = zi();
        (t.push({ _type: "link", _key: I, href: A[1] }),
          c.push(I),
          l.set("a", I));
      }
    } else {
      const A = Q9(g);
      c.includes(A) || c.push(A);
    }
    i = d + h.tag.length + (p ? 3 : 2) + (m?.length || 0);
    const C = r.substring(h.index).match(/<[^>]*>/);
    C && (i = h.index + C[0].length);
  }
  return (
    e.length === 0 &&
      e.push({ _type: "span", _key: zi(), text: "", marks: [] }),
    { children: e, markDefs: t }
  );
}
function Q9(n) {
  switch (n.toLowerCase()) {
    case "strong":
    case "b":
      return "strong";
    case "em":
    case "i":
      return "em";
    case "u":
      return "underline";
    case "s":
    case "del":
    case "strike":
      return "strike-through";
    default:
      return n;
  }
}
function q9(n, e) {
  const t = [],
    i = /<li[^>]*>([\s\S]*?)<\/li>/gi;
  let r;
  for (; (r = i.exec(n)) !== null; ) {
    const s = r[1],
      { children: o, markDefs: a } = Df(s);
    t.push({
      _type: "block",
      _key: zi(),
      style: "normal",
      markDefs: a,
      children: o,
      listItem: e,
      level: 1,
    });
  }
  return t;
}
function GX(n) {
  const e = [],
    t = [],
    i = /<tr[^>]*>([\s\S]*?)<\/tr>/gi;
  let r;
  for (; (r = i.exec(n)) !== null; ) {
    const a = r[1],
      l = [],
      c = /<(th|td)[^>]*>([\s\S]*?)<\/\1>/gi;
    let u;
    for (; (u = c.exec(a)) !== null; ) {
      const h = u[2]
        .replace(/<[^>]*>/g, "")
        .replace(/&nbsp;/g, " ")
        .replace(/&amp;/g, "&")
        .replace(/&lt;/g, "<")
        .replace(/&gt;/g, ">")
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'")
        .trim();
      l.push(h);
    }
    l.length > 0 && t.push(l);
  }
  if (t.length === 0) return e;
  const s = t[0],
    o = t.slice(1);
  for (const a of o) {
    const l = [];
    for (let c = 0; c < a.length; c++) {
      const u = s[c] || "",
        h = a[c] || "";
      u && h ? l.push(`${u}: ${h}`) : h && l.push(h);
    }
    l.length > 0 &&
      e.push({
        _type: "block",
        _key: zi(),
        style: "normal",
        markDefs: [],
        children: [
          { _type: "span", _key: zi(), text: l.join(" | "), marks: [] },
        ],
      });
  }
  return e;
}
function FX(n) {
  const e = [];
  if (!n) return e;
  let t = n
    .replace(
      /\r\n/g,
      `
`,
    )
    .replace(
      /\r/g,
      `
`,
    )
    .trim();
  const i =
    /<(p|h[1-6]|ul|ol|blockquote|div|figure|img|table)[^>]*>([\s\S]*?)<\/\1>|<(img|hr)[^>]*\/?>/gi;
  let r = 0,
    s;
  for (; (s = i.exec(t)) !== null; ) {
    const a = t.substring(r, s.index).trim();
    if (a && !a.match(/^[\s\n]*$/)) {
      const { children: h, markDefs: d } = Df(a);
      h.some((f) => f.text.trim()) &&
        e.push({
          _type: "block",
          _key: zi(),
          style: "normal",
          markDefs: d,
          children: h,
        });
    }
    const l = (s[1] || s[3])?.toLowerCase(),
      c = s[2] || "",
      u = s[0];
    switch (l) {
      case "p":
      case "div": {
        const { children: h, markDefs: d } = Df(c);
        h.some((f) => f.text.trim()) &&
          e.push({
            _type: "block",
            _key: zi(),
            style: "normal",
            markDefs: d,
            children: h,
          });
        break;
      }
      case "h1":
      case "h2":
      case "h3":
      case "h4":
      case "h5":
      case "h6": {
        const { children: h, markDefs: d } = Df(c),
          f = l === "h1" || l === "h2" ? "h2" : "h3";
        e.push({
          _type: "block",
          _key: zi(),
          style: f,
          markDefs: d,
          children: h,
        });
        break;
      }
      case "ul": {
        const h = q9(c, "bullet");
        e.push(...h);
        break;
      }
      case "ol": {
        const h = q9(c, "number");
        e.push(...h);
        break;
      }
      case "blockquote": {
        const h = c.match(/<p[^>]*>([\s\S]*?)<\/p>/i),
          d = h ? h[1].replace(/<[^>]*>/g, "") : c.replace(/<[^>]*>/g, ""),
          f =
            c.match(/<cite[^>]*>([\s\S]*?)<\/cite>/i) ||
            c.match(/<footer[^>]*>([\s\S]*?)<\/footer>/i),
          g = f ? f[1].replace(/<[^>]*>/g, "").trim() : void 0;
        e.push({ _type: "blockquote", _key: zi(), text: d.trim(), author: g });
        break;
      }
      case "figure": {
        const h = c.match(/<img[^>]+src=["']([^"']+)["'][^>]*>/i),
          d = c.match(/<figcaption[^>]*>([\s\S]*?)<\/figcaption>/i);
        h &&
          e.push({
            _type: "media",
            _key: zi(),
            image: { _type: "image", _Asset: `image@${h[1]}` },
            caption: d ? d[1].replace(/<[^>]*>/g, "").trim() : void 0,
          });
        break;
      }
      case "img": {
        const h = u.match(/src=["']([^"']+)["']/i),
          d = u.match(/alt=["']([^"']+)["']/i);
        h &&
          e.push({
            _type: "media",
            _key: zi(),
            image: { _type: "image", _Asset: `image@${h[1]}` },
            caption: d ? d[1] : void 0,
          });
        break;
      }
      case "hr":
        break;
      case "table": {
        const h = GX(u);
        e.push(...h);
        break;
      }
    }
    r = s.index + u.length;
  }
  const o = t.substring(r).trim();
  if (o && !o.match(/^[\s\n]*$/)) {
    const { children: a, markDefs: l } = Df(o);
    a.some((c) => c.text.trim()) &&
      e.push({
        _type: "block",
        _key: zi(),
        style: "normal",
        markDefs: l,
        children: a,
      });
  }
  if (e.length === 0) {
    const a = n.replace(/<[^>]*>/g, "").trim();
    a &&
      e.push({
        _type: "block",
        _key: zi(),
        style: "normal",
        markDefs: [],
        children: [{ _type: "span", _key: zi(), text: a, marks: [] }],
      });
  }
  return e;
}
function kX(n) {
  const t = n
    .replace(/<[^>]*>/g, "")
    .split(/\s+/)
    .filter((r) => r.length > 0).length;
  return `${Math.ceil(t / 300)} min read`;
}
function OX() {
  return SM({
    projectId: "vu4lf9wl",
    dataset: "production",
    apiVersion: "2023-05-04",
    useCdn: !1,
    token: {}._WRITE_TOKEN,
  });
}
function UX(n) {
  return n
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-|-$/g, "")
    .substring(0, 96);
}
function HX(n) {
  return n
    .replace(
      /<p><a[^>]*href="https?:\/\/(www\.)?babylovegrowth\.(ai|com)[^"]*"[^>]*>.*?<\/a><\/p>/gi,
      "",
    )
    .replace(
      /<a[^>]*href="https?:\/\/(www\.)?babylovegrowth\.(ai|com)[^"]*"[^>]*>.*?<\/a>/gi,
      "",
    );
}
async function ex(n, e) {
  const t = await n.fetch(
    '*[_type == "articleCategory" && label == $label][0]._id',
    { label: e },
  );
  return t || (await n.create({ _type: "articleCategory", label: e }))._id;
}
async function WX(n, e) {
  const t = await n.fetch(
    '*[_type == "articleAuthor" && fullName == $name][0]._id',
    { name: e },
  );
  return (
    t ||
    (
      await n.create({
        _type: "articleAuthor",
        fullName: e,
        role: "Contributor",
      })
    )._id
  );
}
async function VX(n, e, t) {
  try {
    const i = await fetch(e);
    if (!i.ok) return (console.error(`Failed to fetch image: ${e}`), null);
    const r = await i.arrayBuffer();
    return (
      await n.assets.upload("image", Buffer.from(r), {
        filename: t || `babylovegrowth-${Date.now()}.jpg`,
      })
    )._id;
  } catch (i) {
    return (console.error("Error uploading image:", i), null);
  }
}
async function ZX({ request: n }) {
  const e = {}.BABYLOVEGROWTH_WEBHOOK_SECRET,
    t = n.headers.get("Authorization"),
    i = n.headers.get("X-Webhook-Secret") || t?.replace("Bearer ", "");
  if (e && i !== e)
    return Li(
      { status: "error", error: "Invalid webhook secret" },
      { status: 401 },
    );
  if (!{}.CMS_WRITE_TOKEN)
    return Li(
      { status: "error", error: "CMS write token not configured" },
      { status: 500 },
    );
  const r = OX();
  let s;
  try {
    const a = await n.text();
    (console.log("[babylovegrowth] Raw request body:", a),
      (s = JSON.parse(a)),
      console.log(
        "[babylovegrowth] Parsed payload:",
        JSON.stringify(s, null, 2),
      ));
  } catch (a) {
    return (
      console.error("[babylovegrowth] JSON parse error:", a),
      Li({ status: "error", error: "Invalid JSON payload" }, { status: 400 })
    );
  }
  if (!s.title)
    return (
      console.error(
        "[babylovegrowth] Missing title. Payload keys:",
        Object.keys(s),
      ),
      Li(
        { status: "error", error: "Missing required field: title" },
        { status: 400 },
      )
    );
  const o = s.content_html || s.content;
  if (!o)
    return (
      console.error(
        "[babylovegrowth] Missing content. Payload keys:",
        Object.keys(s),
      ),
      Li(
        {
          status: "error",
          error: "Missing required field: content or content_html",
        },
        { status: 400 },
      )
    );
  console.log(
    "[babylovegrowth] Validation passed, processing article:",
    s.title,
  );
  try {
    const a = s.slug || UX(s.title),
      l = await r.fetch(
        '*[_type == "article" && slug.current == $slug][0]._id',
        { slug: a },
      ),
      c = HX(o),
      u = FX(c),
      h = kX(c);
    let d = [];
    s.categories && s.categories.length > 0
      ? (d = (await Promise.all(s.categories.map((y) => ex(r, y)))).map(
          (y) => ({
            _type: "reference",
            _ref: y,
            _key: Math.random().toString(36).substring(2, 10),
          }),
        ))
      : (d = [
          {
            _type: "reference",
            _ref: await ex(r, "Blog"),
            _key: Math.random().toString(36).substring(2, 10),
          },
        ]);
    const g = await WX(r, "Hardy Sidhu"),
      p = s.featured_image || s.heroImageUrl;
    let m;
    if (p) {
      const I = await VX(r, p, `${a}-thumbnail.jpg`);
      I && (m = { _type: "image", asset: { _type: "reference", _ref: I } });
    }
    const C = {
      _type: "article",
      title: s.title,
      slug: { _type: "slug", current: a },
      excerpt: s.excerpt || s.metaDescription || s.meta_description || s.title,
      categories: d,
      author: { _type: "reference", _ref: g },
      publishedAt:
        s.published_at || s.createdAt
          ? new Date(s.published_at || s.createdAt).toISOString().split("T")[0]
          : new Date().toISOString().split("T")[0],
      body: u,
      eta: h,
    };
    (m && (C.thumbnail = { src: m, alt: s.featured_image_alt || s.title }),
      s.featured_image_alt && (C.thumbnailCaption = s.featured_image_alt));
    let A;
    return (
      l
        ? (A = await r.patch(l).set(C).commit())
        : (s.status === "draft" &&
            (C._id = `drafts.${Math.random().toString(36).substring(2, 15)}`),
          (A = await r.create(C))),
      Li({
        status: "success",
        message: l ? "Article updated" : "Article created",
        article: { id: A._id, slug: a, title: s.title },
      })
    );
  } catch (a) {
    return (
      console.error("Error creating article:", a),
      Li(
        {
          status: "error",
          error: "Failed to create article",
          details: a.message,
        },
        { status: 500 },
      )
    );
  }
}
async function zX() {
  return Li({
    status: "ok",
    service: "babylovegrowth-webhook",
    timestamp: new Date().toISOString(),
  });
}
function TM(n, e) {
  return function () {
    return n.apply(e, arguments);
  };
}
const { toString: YX } = Object.prototype,
  { getPrototypeOf: dv } = Object,
  ZC = ((n) => (e) => {
    const t = YX.call(e);
    return n[t] || (n[t] = t.slice(8, -1).toLowerCase());
  })(Object.create(null)),
  Wo = (n) => ((n = n.toLowerCase()), (e) => ZC(e) === n),
  zC = (n) => (e) => typeof e === n,
  { isArray: Od } = Array,
  Tg = zC("undefined");
function XX(n) {
  return (
    n !== null &&
    !Tg(n) &&
    n.constructor !== null &&
    !Tg(n.constructor) &&
    Ss(n.constructor.isBuffer) &&
    n.constructor.isBuffer(n)
  );
}
const EM = Wo("ArrayBuffer");
function KX(n) {
  let e;
  return (
    typeof ArrayBuffer < "u" && ArrayBuffer.isView
      ? (e = ArrayBuffer.isView(n))
      : (e = n && n.buffer && EM(n.buffer)),
    e
  );
}
const jX = zC("string"),
  Ss = zC("function"),
  MM = zC("number"),
  YC = (n) => n !== null && typeof n == "object",
  $X = (n) => n === !0 || n === !1,
  R0 = (n) => {
    if (ZC(n) !== "object") return !1;
    const e = dv(n);
    return (
      (e === null ||
        e === Object.prototype ||
        Object.getPrototypeOf(e) === null) &&
      !(Symbol.toStringTag in n) &&
      !(Symbol.iterator in n)
    );
  },
  JX = Wo("Date"),
  QX = Wo("File"),
  qX = Wo("Blob"),
  eK = Wo("FileList"),
  tK = (n) => YC(n) && Ss(n.pipe),
  nK = (n) => {
    let e;
    return (
      n &&
      ((typeof FormData == "function" && n instanceof FormData) ||
        (Ss(n.append) &&
          ((e = ZC(n)) === "formdata" ||
            (e === "object" &&
              Ss(n.toString) &&
              n.toString() === "[object FormData]"))))
    );
  },
  iK = Wo("URLSearchParams"),
  rK = (n) =>
    n.trim ? n.trim() : n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Ap(n, e, { allOwnKeys: t = !1 } = {}) {
  if (n === null || typeof n > "u") return;
  let i, r;
  if ((typeof n != "object" && (n = [n]), Od(n)))
    for (i = 0, r = n.length; i < r; i++) e.call(null, n[i], i, n);
  else {
    const s = t ? Object.getOwnPropertyNames(n) : Object.keys(n),
      o = s.length;
    let a;
    for (i = 0; i < o; i++) ((a = s[i]), e.call(null, n[a], a, n));
  }
}
function LM(n, e) {
  e = e.toLowerCase();
  const t = Object.keys(n);
  let i = t.length,
    r;
  for (; i-- > 0; ) if (((r = t[i]), e === r.toLowerCase())) return r;
  return null;
}
const RM = (() =>
    typeof globalThis < "u"
      ? globalThis
      : typeof self < "u"
        ? self
        : typeof window < "u"
          ? window
          : global)(),
  BM = (n) => !Tg(n) && n !== RM;
function zy() {
  const { caseless: n } = (BM(this) && this) || {},
    e = {},
    t = (i, r) => {
      const s = (n && LM(e, r)) || r;
      R0(e[s]) && R0(i)
        ? (e[s] = zy(e[s], i))
        : R0(i)
          ? (e[s] = zy({}, i))
          : Od(i)
            ? (e[s] = i.slice())
            : (e[s] = i);
    };
  for (let i = 0, r = arguments.length; i < r; i++)
    arguments[i] && Ap(arguments[i], t);
  return e;
}
const sK = (n, e, t, { allOwnKeys: i } = {}) => (
    Ap(
      e,
      (r, s) => {
        t && Ss(r) ? (n[s] = TM(r, t)) : (n[s] = r);
      },
      { allOwnKeys: i },
    ),
    n
  ),
  oK = (n) => (n.charCodeAt(0) === 65279 && (n = n.slice(1)), n),
  aK = (n, e, t, i) => {
    ((n.prototype = Object.create(e.prototype, i)),
      (n.prototype.constructor = n),
      Object.defineProperty(n, "super", { value: e.prototype }),
      t && Object.assign(n.prototype, t));
  },
  lK = (n, e, t, i) => {
    let r, s, o;
    const a = {};
    if (((e = e || {}), n == null)) return e;
    do {
      for (r = Object.getOwnPropertyNames(n), s = r.length; s-- > 0; )
        ((o = r[s]),
          (!i || i(o, n, e)) && !a[o] && ((e[o] = n[o]), (a[o] = !0)));
      n = t !== !1 && dv(n);
    } while (n && (!t || t(n, e)) && n !== Object.prototype);
    return e;
  },
  cK = (n, e, t) => {
    ((n = String(n)),
      (t === void 0 || t > n.length) && (t = n.length),
      (t -= e.length));
    const i = n.indexOf(e, t);
    return i !== -1 && i === t;
  },
  uK = (n) => {
    if (!n) return null;
    if (Od(n)) return n;
    let e = n.length;
    if (!MM(e)) return null;
    const t = new Array(e);
    for (; e-- > 0; ) t[e] = n[e];
    return t;
  },
  hK = (
    (n) => (e) =>
      n && e instanceof n
  )(typeof Uint8Array < "u" && dv(Uint8Array)),
  dK = (n, e) => {
    const i = (n && n[Symbol.iterator]).call(n);
    let r;
    for (; (r = i.next()) && !r.done; ) {
      const s = r.value;
      e.call(n, s[0], s[1]);
    }
  },
  fK = (n, e) => {
    let t;
    const i = [];
    for (; (t = n.exec(e)) !== null; ) i.push(t);
    return i;
  },
  gK = Wo("HTMLFormElement"),
  pK = (n) =>
    n.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (t, i, r) {
      return i.toUpperCase() + r;
    }),
  tx = (
    ({ hasOwnProperty: n }) =>
    (e, t) =>
      n.call(e, t)
  )(Object.prototype),
  mK = Wo("RegExp"),
  PM = (n, e) => {
    const t = Object.getOwnPropertyDescriptors(n),
      i = {};
    (Ap(t, (r, s) => {
      let o;
      (o = e(r, s, n)) !== !1 && (i[s] = o || r);
    }),
      Object.defineProperties(n, i));
  },
  CK = (n) => {
    PM(n, (e, t) => {
      if (Ss(n) && ["arguments", "caller", "callee"].indexOf(t) !== -1)
        return !1;
      const i = n[t];
      if (Ss(i)) {
        if (((e.enumerable = !1), "writable" in e)) {
          e.writable = !1;
          return;
        }
        e.set ||
          (e.set = () => {
            throw Error("Can not rewrite read-only method '" + t + "'");
          });
      }
    });
  },
  IK = (n, e) => {
    const t = {},
      i = (r) => {
        r.forEach((s) => {
          t[s] = !0;
        });
      };
    return (Od(n) ? i(n) : i(String(n).split(e)), t);
  },
  AK = () => {},
  yK = (n, e) => ((n = +n), Number.isFinite(n) ? n : e),
  i2 = "abcdefghijklmnopqrstuvwxyz",
  nx = "0123456789",
  NM = { DIGIT: nx, ALPHA: i2, ALPHA_DIGIT: i2 + i2.toUpperCase() + nx },
  _K = (n = 16, e = NM.ALPHA_DIGIT) => {
    let t = "";
    const { length: i } = e;
    for (; n--; ) t += e[(Math.random() * i) | 0];
    return t;
  };
function bK(n) {
  return !!(
    n &&
    Ss(n.append) &&
    n[Symbol.toStringTag] === "FormData" &&
    n[Symbol.iterator]
  );
}
const vK = (n) => {
    const e = new Array(10),
      t = (i, r) => {
        if (YC(i)) {
          if (e.indexOf(i) >= 0) return;
          if (!("toJSON" in i)) {
            e[r] = i;
            const s = Od(i) ? [] : {};
            return (
              Ap(i, (o, a) => {
                const l = t(o, r + 1);
                !Tg(l) && (s[a] = l);
              }),
              (e[r] = void 0),
              s
            );
          }
        }
        return i;
      };
    return t(n, 0);
  },
  xK = Wo("AsyncFunction"),
  wK = (n) => n && (YC(n) || Ss(n)) && Ss(n.then) && Ss(n.catch),
  he = {
    isArray: Od,
    isArrayBuffer: EM,
    isBuffer: XX,
    isFormData: nK,
    isArrayBufferView: KX,
    isString: jX,
    isNumber: MM,
    isBoolean: $X,
    isObject: YC,
    isPlainObject: R0,
    isUndefined: Tg,
    isDate: JX,
    isFile: QX,
    isBlob: qX,
    isRegExp: mK,
    isFunction: Ss,
    isStream: tK,
    isURLSearchParams: iK,
    isTypedArray: hK,
    isFileList: eK,
    forEach: Ap,
    merge: zy,
    extend: sK,
    trim: rK,
    stripBOM: oK,
    inherits: aK,
    toFlatObject: lK,
    kindOf: ZC,
    kindOfTest: Wo,
    endsWith: cK,
    toArray: uK,
    forEachEntry: dK,
    matchAll: fK,
    isHTMLForm: gK,
    hasOwnProperty: tx,
    hasOwnProp: tx,
    reduceDescriptors: PM,
    freezeMethods: CK,
    toObjectSet: IK,
    toCamelCase: pK,
    noop: AK,
    toFiniteNumber: yK,
    findKey: LM,
    global: RM,
    isContextDefined: BM,
    ALPHABET: NM,
    generateString: _K,
    isSpecCompliantForm: bK,
    toJSONObject: vK,
    isAsyncFn: xK,
    isThenable: wK,
  };
function jt(n, e, t, i, r) {
  (Error.call(this),
    Error.captureStackTrace
      ? Error.captureStackTrace(this, this.constructor)
      : (this.stack = new Error().stack),
    (this.message = n),
    (this.name = "AxiosError"),
    e && (this.code = e),
    t && (this.config = t),
    i && (this.request = i),
    r && (this.response = r));
}
he.inherits(jt, Error, {
  toJSON: function () {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: he.toJSONObject(this.config),
      code: this.code,
      status:
        this.response && this.response.status ? this.response.status : null,
    };
  },
});
const DM = jt.prototype,
  GM = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL",
].forEach((n) => {
  GM[n] = { value: n };
});
Object.defineProperties(jt, GM);
Object.defineProperty(DM, "isAxiosError", { value: !0 });
jt.from = (n, e, t, i, r, s) => {
  const o = Object.create(DM);
  return (
    he.toFlatObject(
      n,
      o,
      function (l) {
        return l !== Error.prototype;
      },
      (a) => a !== "isAxiosError",
    ),
    jt.call(o, n.message, e, t, i, r),
    (o.cause = n),
    (o.name = n.name),
    s && Object.assign(o, s),
    o
  );
};
const SK = null;
function Yy(n) {
  return he.isPlainObject(n) || he.isArray(n);
}
function FM(n) {
  return he.endsWith(n, "[]") ? n.slice(0, -2) : n;
}
function ix(n, e, t) {
  return n
    ? n
        .concat(e)
        .map(function (r, s) {
          return ((r = FM(r)), !t && s ? "[" + r + "]" : r);
        })
        .join(t ? "." : "")
    : e;
}
function TK(n) {
  return he.isArray(n) && !n.some(Yy);
}
const EK = he.toFlatObject(he, {}, null, function (e) {
  return /^is[A-Z]/.test(e);
});
function XC(n, e, t) {
  if (!he.isObject(n)) throw new TypeError("target must be an object");
  ((e = e || new FormData()),
    (t = he.toFlatObject(
      t,
      { metaTokens: !0, dots: !1, indexes: !1 },
      !1,
      function (p, m) {
        return !he.isUndefined(m[p]);
      },
    )));
  const i = t.metaTokens,
    r = t.visitor || u,
    s = t.dots,
    o = t.indexes,
    l = (t.Blob || (typeof Blob < "u" && Blob)) && he.isSpecCompliantForm(e);
  if (!he.isFunction(r)) throw new TypeError("visitor must be a function");
  function c(g) {
    if (g === null) return "";
    if (he.isDate(g)) return g.toISOString();
    if (!l && he.isBlob(g))
      throw new jt("Blob is not supported. Use a Buffer instead.");
    return he.isArrayBuffer(g) || he.isTypedArray(g)
      ? l && typeof Blob == "function"
        ? new Blob([g])
        : Buffer.from(g)
      : g;
  }
  function u(g, p, m) {
    let C = g;
    if (g && !m && typeof g == "object") {
      if (he.endsWith(p, "{}"))
        ((p = i ? p : p.slice(0, -2)), (g = JSON.stringify(g)));
      else if (
        (he.isArray(g) && TK(g)) ||
        ((he.isFileList(g) || he.endsWith(p, "[]")) && (C = he.toArray(g)))
      )
        return (
          (p = FM(p)),
          C.forEach(function (I, y) {
            !(he.isUndefined(I) || I === null) &&
              e.append(
                o === !0 ? ix([p], y, s) : o === null ? p : p + "[]",
                c(I),
              );
          }),
          !1
        );
    }
    return Yy(g) ? !0 : (e.append(ix(m, p, s), c(g)), !1);
  }
  const h = [],
    d = Object.assign(EK, {
      defaultVisitor: u,
      convertValue: c,
      isVisitable: Yy,
    });
  function f(g, p) {
    if (!he.isUndefined(g)) {
      if (h.indexOf(g) !== -1)
        throw Error("Circular reference detected in " + p.join("."));
      (h.push(g),
        he.forEach(g, function (C, A) {
          (!(he.isUndefined(C) || C === null) &&
            r.call(e, C, he.isString(A) ? A.trim() : A, p, d)) === !0 &&
            f(C, p ? p.concat(A) : [A]);
        }),
        h.pop());
    }
  }
  if (!he.isObject(n)) throw new TypeError("data must be an object");
  return (f(n), e);
}
function rx(n) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0",
  };
  return encodeURIComponent(n).replace(/[!'()~]|%20|%00/g, function (i) {
    return e[i];
  });
}
function fv(n, e) {
  ((this._pairs = []), n && XC(n, this, e));
}
const kM = fv.prototype;
kM.append = function (e, t) {
  this._pairs.push([e, t]);
};
kM.toString = function (e) {
  const t = e
    ? function (i) {
        return e.call(this, i, rx);
      }
    : rx;
  return this._pairs
    .map(function (r) {
      return t(r[0]) + "=" + t(r[1]);
    }, "")
    .join("&");
};
function MK(n) {
  return encodeURIComponent(n)
    .replace(/%3A/gi, ":")
    .replace(/%24/g, "$")
    .replace(/%2C/gi, ",")
    .replace(/%20/g, "+")
    .replace(/%5B/gi, "[")
    .replace(/%5D/gi, "]");
}
function OM(n, e, t) {
  if (!e) return n;
  const i = (t && t.encode) || MK,
    r = t && t.serialize;
  let s;
  if (
    (r
      ? (s = r(e, t))
      : (s = he.isURLSearchParams(e) ? e.toString() : new fv(e, t).toString(i)),
    s)
  ) {
    const o = n.indexOf("#");
    (o !== -1 && (n = n.slice(0, o)),
      (n += (n.indexOf("?") === -1 ? "?" : "&") + s));
  }
  return n;
}
let LK = class {
  constructor() {
    this.handlers = [];
  }
  use(e, t, i) {
    return (
      this.handlers.push({
        fulfilled: e,
        rejected: t,
        synchronous: i ? i.synchronous : !1,
        runWhen: i ? i.runWhen : null,
      }),
      this.handlers.length - 1
    );
  }
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  clear() {
    this.handlers && (this.handlers = []);
  }
  forEach(e) {
    he.forEach(this.handlers, function (i) {
      i !== null && e(i);
    });
  }
};
const sx = LK,
  UM = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1,
  },
  RK = typeof URLSearchParams < "u" ? URLSearchParams : fv,
  BK = typeof FormData < "u" ? FormData : null,
  PK = typeof Blob < "u" ? Blob : null,
  NK = (() => {
    let n;
    return typeof navigator < "u" &&
      ((n = navigator.product) === "ReactNative" ||
        n === "NativeScript" ||
        n === "NS")
      ? !1
      : typeof window < "u" && typeof document < "u";
  })(),
  DK = (() =>
    typeof WorkerGlobalScope < "u" &&
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts == "function")(),
  bo = {
    isBrowser: !0,
    classes: { URLSearchParams: RK, FormData: BK, Blob: PK },
    isStandardBrowserEnv: NK,
    isStandardBrowserWebWorkerEnv: DK,
    protocols: ["http", "https", "file", "blob", "url", "data"],
  };
function GK(n, e) {
  return XC(
    n,
    new bo.classes.URLSearchParams(),
    Object.assign(
      {
        visitor: function (t, i, r, s) {
          return bo.isNode && he.isBuffer(t)
            ? (this.append(i, t.toString("base64")), !1)
            : s.defaultVisitor.apply(this, arguments);
        },
      },
      e,
    ),
  );
}
function FK(n) {
  return he
    .matchAll(/\w+|\[(\w*)]/g, n)
    .map((e) => (e[0] === "[]" ? "" : e[1] || e[0]));
}
function kK(n) {
  const e = {},
    t = Object.keys(n);
  let i;
  const r = t.length;
  let s;
  for (i = 0; i < r; i++) ((s = t[i]), (e[s] = n[s]));
  return e;
}
function HM(n) {
  function e(t, i, r, s) {
    let o = t[s++];
    const a = Number.isFinite(+o),
      l = s >= t.length;
    return (
      (o = !o && he.isArray(r) ? r.length : o),
      l
        ? (he.hasOwnProp(r, o) ? (r[o] = [r[o], i]) : (r[o] = i), !a)
        : ((!r[o] || !he.isObject(r[o])) && (r[o] = []),
          e(t, i, r[o], s) && he.isArray(r[o]) && (r[o] = kK(r[o])),
          !a)
    );
  }
  if (he.isFormData(n) && he.isFunction(n.entries)) {
    const t = {};
    return (
      he.forEachEntry(n, (i, r) => {
        e(FK(i), r, t, 0);
      }),
      t
    );
  }
  return null;
}
function OK(n, e, t) {
  if (he.isString(n))
    try {
      return ((e || JSON.parse)(n), he.trim(n));
    } catch (i) {
      if (i.name !== "SyntaxError") throw i;
    }
  return (t || JSON.stringify)(n);
}
const gv = {
  transitional: UM,
  adapter: ["xhr", "http"],
  transformRequest: [
    function (e, t) {
      const i = t.getContentType() || "",
        r = i.indexOf("application/json") > -1,
        s = he.isObject(e);
      if ((s && he.isHTMLForm(e) && (e = new FormData(e)), he.isFormData(e)))
        return r && r ? JSON.stringify(HM(e)) : e;
      if (
        he.isArrayBuffer(e) ||
        he.isBuffer(e) ||
        he.isStream(e) ||
        he.isFile(e) ||
        he.isBlob(e)
      )
        return e;
      if (he.isArrayBufferView(e)) return e.buffer;
      if (he.isURLSearchParams(e))
        return (
          t.setContentType(
            "application/x-www-form-urlencoded;charset=utf-8",
            !1,
          ),
          e.toString()
        );
      let a;
      if (s) {
        if (i.indexOf("application/x-www-form-urlencoded") > -1)
          return GK(e, this.formSerializer).toString();
        if ((a = he.isFileList(e)) || i.indexOf("multipart/form-data") > -1) {
          const l = this.env && this.env.FormData;
          return XC(
            a ? { "files[]": e } : e,
            l && new l(),
            this.formSerializer,
          );
        }
      }
      return s || r ? (t.setContentType("application/json", !1), OK(e)) : e;
    },
  ],
  transformResponse: [
    function (e) {
      const t = this.transitional || gv.transitional,
        i = t && t.forcedJSONParsing,
        r = this.responseType === "json";
      if (e && he.isString(e) && ((i && !this.responseType) || r)) {
        const o = !(t && t.silentJSONParsing) && r;
        try {
          return JSON.parse(e);
        } catch (a) {
          if (o)
            throw a.name === "SyntaxError"
              ? jt.from(a, jt.ERR_BAD_RESPONSE, this, null, this.response)
              : a;
        }
      }
      return e;
    },
  ],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: { FormData: bo.classes.FormData, Blob: bo.classes.Blob },
  validateStatus: function (e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0,
    },
  },
};
he.forEach(["delete", "get", "head", "post", "put", "patch"], (n) => {
  gv.headers[n] = {};
});
const pv = gv,
  UK = he.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent",
  ]),
  HK = (n) => {
    const e = {};
    let t, i, r;
    return (
      n &&
        n
          .split(
            `
`,
          )
          .forEach(function (o) {
            ((r = o.indexOf(":")),
              (t = o.substring(0, r).trim().toLowerCase()),
              (i = o.substring(r + 1).trim()),
              !(!t || (e[t] && UK[t])) &&
                (t === "set-cookie"
                  ? e[t]
                    ? e[t].push(i)
                    : (e[t] = [i])
                  : (e[t] = e[t] ? e[t] + ", " + i : i)));
          }),
      e
    );
  },
  ox = Symbol("internals");
function of(n) {
  return n && String(n).trim().toLowerCase();
}
function B0(n) {
  return n === !1 || n == null ? n : he.isArray(n) ? n.map(B0) : String(n);
}
function WK(n) {
  const e = Object.create(null),
    t = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let i;
  for (; (i = t.exec(n)); ) e[i[1]] = i[2];
  return e;
}
const VK = (n) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(n.trim());
function r2(n, e, t, i, r) {
  if (he.isFunction(i)) return i.call(this, e, t);
  if ((r && (e = t), !!he.isString(e))) {
    if (he.isString(i)) return e.indexOf(i) !== -1;
    if (he.isRegExp(i)) return i.test(e);
  }
}
function ZK(n) {
  return n
    .trim()
    .toLowerCase()
    .replace(/([a-z\d])(\w*)/g, (e, t, i) => t.toUpperCase() + i);
}
function zK(n, e) {
  const t = he.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((i) => {
    Object.defineProperty(n, i + t, {
      value: function (r, s, o) {
        return this[i].call(this, e, r, s, o);
      },
      configurable: !0,
    });
  });
}
let KC = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, t, i) {
    const r = this;
    function s(a, l, c) {
      const u = of(l);
      if (!u) throw new Error("header name must be a non-empty string");
      const h = he.findKey(r, u);
      (!h || r[h] === void 0 || c === !0 || (c === void 0 && r[h] !== !1)) &&
        (r[h || l] = B0(a));
    }
    const o = (a, l) => he.forEach(a, (c, u) => s(c, u, l));
    return (
      he.isPlainObject(e) || e instanceof this.constructor
        ? o(e, t)
        : he.isString(e) && (e = e.trim()) && !VK(e)
          ? o(HK(e), t)
          : e != null && s(t, e, i),
      this
    );
  }
  get(e, t) {
    if (((e = of(e)), e)) {
      const i = he.findKey(this, e);
      if (i) {
        const r = this[i];
        if (!t) return r;
        if (t === !0) return WK(r);
        if (he.isFunction(t)) return t.call(this, r, i);
        if (he.isRegExp(t)) return t.exec(r);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, t) {
    if (((e = of(e)), e)) {
      const i = he.findKey(this, e);
      return !!(i && this[i] !== void 0 && (!t || r2(this, this[i], i, t)));
    }
    return !1;
  }
  delete(e, t) {
    const i = this;
    let r = !1;
    function s(o) {
      if (((o = of(o)), o)) {
        const a = he.findKey(i, o);
        a && (!t || r2(i, i[a], a, t)) && (delete i[a], (r = !0));
      }
    }
    return (he.isArray(e) ? e.forEach(s) : s(e), r);
  }
  clear(e) {
    const t = Object.keys(this);
    let i = t.length,
      r = !1;
    for (; i--; ) {
      const s = t[i];
      (!e || r2(this, this[s], s, e, !0)) && (delete this[s], (r = !0));
    }
    return r;
  }
  normalize(e) {
    const t = this,
      i = {};
    return (
      he.forEach(this, (r, s) => {
        const o = he.findKey(i, s);
        if (o) {
          ((t[o] = B0(r)), delete t[s]);
          return;
        }
        const a = e ? ZK(s) : String(s).trim();
        (a !== s && delete t[s], (t[a] = B0(r)), (i[a] = !0));
      }),
      this
    );
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const t = Object.create(null);
    return (
      he.forEach(this, (i, r) => {
        i != null && i !== !1 && (t[r] = e && he.isArray(i) ? i.join(", ") : i);
      }),
      t
    );
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, t]) => e + ": " + t).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...t) {
    const i = new this(e);
    return (t.forEach((r) => i.set(r)), i);
  }
  static accessor(e) {
    const i = (this[ox] = this[ox] = { accessors: {} }).accessors,
      r = this.prototype;
    function s(o) {
      const a = of(o);
      i[a] || (zK(r, o), (i[a] = !0));
    }
    return (he.isArray(e) ? e.forEach(s) : s(e), this);
  }
};
KC.accessor([
  "Content-Type",
  "Content-Length",
  "Accept",
  "Accept-Encoding",
  "User-Agent",
  "Authorization",
]);
he.reduceDescriptors(KC.prototype, ({ value: n }, e) => {
  let t = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => n,
    set(i) {
      this[t] = i;
    },
  };
});
he.freezeMethods(KC);
const xa = KC;
function s2(n, e) {
  const t = this || pv,
    i = e || t,
    r = xa.from(i.headers);
  let s = i.data;
  return (
    he.forEach(n, function (a) {
      s = a.call(t, s, r.normalize(), e ? e.status : void 0);
    }),
    r.normalize(),
    s
  );
}
function WM(n) {
  return !!(n && n.__CANCEL__);
}
function yp(n, e, t) {
  (jt.call(this, n ?? "canceled", jt.ERR_CANCELED, e, t),
    (this.name = "CanceledError"));
}
he.inherits(yp, jt, { __CANCEL__: !0 });
function YK(n, e, t) {
  const i = t.config.validateStatus;
  !t.status || !i || i(t.status)
    ? n(t)
    : e(
        new jt(
          "Request failed with status code " + t.status,
          [jt.ERR_BAD_REQUEST, jt.ERR_BAD_RESPONSE][
            Math.floor(t.status / 100) - 4
          ],
          t.config,
          t.request,
          t,
        ),
      );
}
const XK = bo.isStandardBrowserEnv
  ? (function () {
      return {
        write: function (t, i, r, s, o, a) {
          const l = [];
          (l.push(t + "=" + encodeURIComponent(i)),
            he.isNumber(r) && l.push("expires=" + new Date(r).toGMTString()),
            he.isString(s) && l.push("path=" + s),
            he.isString(o) && l.push("domain=" + o),
            a === !0 && l.push("secure"),
            (document.cookie = l.join("; ")));
        },
        read: function (t) {
          const i = document.cookie.match(
            new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"),
          );
          return i ? decodeURIComponent(i[3]) : null;
        },
        remove: function (t) {
          this.write(t, "", Date.now() - 864e5);
        },
      };
    })()
  : (function () {
      return {
        write: function () {},
        read: function () {
          return null;
        },
        remove: function () {},
      };
    })();
function KK(n) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(n);
}
function jK(n, e) {
  return e ? n.replace(/\/+$/, "") + "/" + e.replace(/^\/+/, "") : n;
}
function VM(n, e) {
  return n && !KK(e) ? jK(n, e) : e;
}
const $K = bo.isStandardBrowserEnv
  ? (function () {
      const e = /(msie|trident)/i.test(navigator.userAgent),
        t = document.createElement("a");
      let i;
      function r(s) {
        let o = s;
        return (
          e && (t.setAttribute("href", o), (o = t.href)),
          t.setAttribute("href", o),
          {
            href: t.href,
            protocol: t.protocol ? t.protocol.replace(/:$/, "") : "",
            host: t.host,
            search: t.search ? t.search.replace(/^\?/, "") : "",
            hash: t.hash ? t.hash.replace(/^#/, "") : "",
            hostname: t.hostname,
            port: t.port,
            pathname:
              t.pathname.charAt(0) === "/" ? t.pathname : "/" + t.pathname,
          }
        );
      }
      return (
        (i = r(window.location.href)),
        function (o) {
          const a = he.isString(o) ? r(o) : o;
          return a.protocol === i.protocol && a.host === i.host;
        }
      );
    })()
  : (function () {
      return function () {
        return !0;
      };
    })();
function JK(n) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(n);
  return (e && e[1]) || "";
}
function QK(n, e) {
  n = n || 10;
  const t = new Array(n),
    i = new Array(n);
  let r = 0,
    s = 0,
    o;
  return (
    (e = e !== void 0 ? e : 1e3),
    function (l) {
      const c = Date.now(),
        u = i[s];
      (o || (o = c), (t[r] = l), (i[r] = c));
      let h = s,
        d = 0;
      for (; h !== r; ) ((d += t[h++]), (h = h % n));
      if (((r = (r + 1) % n), r === s && (s = (s + 1) % n), c - o < e)) return;
      const f = u && c - u;
      return f ? Math.round((d * 1e3) / f) : void 0;
    }
  );
}
function ax(n, e) {
  let t = 0;
  const i = QK(50, 250);
  return (r) => {
    const s = r.loaded,
      o = r.lengthComputable ? r.total : void 0,
      a = s - t,
      l = i(a),
      c = s <= o;
    t = s;
    const u = {
      loaded: s,
      total: o,
      progress: o ? s / o : void 0,
      bytes: a,
      rate: l || void 0,
      estimated: l && o && c ? (o - s) / l : void 0,
      event: r,
    };
    ((u[e ? "download" : "upload"] = !0), n(u));
  };
}
const qK = typeof XMLHttpRequest < "u",
  ej =
    qK &&
    function (n) {
      return new Promise(function (t, i) {
        let r = n.data;
        const s = xa.from(n.headers).normalize(),
          o = n.responseType;
        let a;
        function l() {
          (n.cancelToken && n.cancelToken.unsubscribe(a),
            n.signal && n.signal.removeEventListener("abort", a));
        }
        let c;
        he.isFormData(r) &&
          (bo.isStandardBrowserEnv || bo.isStandardBrowserWebWorkerEnv
            ? s.setContentType(!1)
            : s.getContentType(/^\s*multipart\/form-data/)
              ? he.isString((c = s.getContentType())) &&
                s.setContentType(
                  c.replace(/^\s*(multipart\/form-data);+/, "$1"),
                )
              : s.setContentType("multipart/form-data"));
        let u = new XMLHttpRequest();
        if (n.auth) {
          const g = n.auth.username || "",
            p = n.auth.password
              ? unescape(encodeURIComponent(n.auth.password))
              : "";
          s.set("Authorization", "Basic " + btoa(g + ":" + p));
        }
        const h = VM(n.baseURL, n.url);
        (u.open(
          n.method.toUpperCase(),
          OM(h, n.params, n.paramsSerializer),
          !0,
        ),
          (u.timeout = n.timeout));
        function d() {
          if (!u) return;
          const g = xa.from(
              "getAllResponseHeaders" in u && u.getAllResponseHeaders(),
            ),
            m = {
              data:
                !o || o === "text" || o === "json"
                  ? u.responseText
                  : u.response,
              status: u.status,
              statusText: u.statusText,
              headers: g,
              config: n,
              request: u,
            };
          (YK(
            function (A) {
              (t(A), l());
            },
            function (A) {
              (i(A), l());
            },
            m,
          ),
            (u = null));
        }
        if (
          ("onloadend" in u
            ? (u.onloadend = d)
            : (u.onreadystatechange = function () {
                !u ||
                  u.readyState !== 4 ||
                  (u.status === 0 &&
                    !(u.responseURL && u.responseURL.indexOf("file:") === 0)) ||
                  setTimeout(d);
              }),
          (u.onabort = function () {
            u &&
              (i(new jt("Request aborted", jt.ECONNABORTED, n, u)), (u = null));
          }),
          (u.onerror = function () {
            (i(new jt("Network Error", jt.ERR_NETWORK, n, u)), (u = null));
          }),
          (u.ontimeout = function () {
            let p = n.timeout
              ? "timeout of " + n.timeout + "ms exceeded"
              : "timeout exceeded";
            const m = n.transitional || UM;
            (n.timeoutErrorMessage && (p = n.timeoutErrorMessage),
              i(
                new jt(
                  p,
                  m.clarifyTimeoutError ? jt.ETIMEDOUT : jt.ECONNABORTED,
                  n,
                  u,
                ),
              ),
              (u = null));
          }),
          bo.isStandardBrowserEnv)
        ) {
          const g =
            (n.withCredentials || $K(h)) &&
            n.xsrfCookieName &&
            XK.read(n.xsrfCookieName);
          g && s.set(n.xsrfHeaderName, g);
        }
        (r === void 0 && s.setContentType(null),
          "setRequestHeader" in u &&
            he.forEach(s.toJSON(), function (p, m) {
              u.setRequestHeader(m, p);
            }),
          he.isUndefined(n.withCredentials) ||
            (u.withCredentials = !!n.withCredentials),
          o && o !== "json" && (u.responseType = n.responseType),
          typeof n.onDownloadProgress == "function" &&
            u.addEventListener("progress", ax(n.onDownloadProgress, !0)),
          typeof n.onUploadProgress == "function" &&
            u.upload &&
            u.upload.addEventListener("progress", ax(n.onUploadProgress)),
          (n.cancelToken || n.signal) &&
            ((a = (g) => {
              u &&
                (i(!g || g.type ? new yp(null, n, u) : g),
                u.abort(),
                (u = null));
            }),
            n.cancelToken && n.cancelToken.subscribe(a),
            n.signal &&
              (n.signal.aborted
                ? a()
                : n.signal.addEventListener("abort", a))));
        const f = JK(h);
        if (f && bo.protocols.indexOf(f) === -1) {
          i(new jt("Unsupported protocol " + f + ":", jt.ERR_BAD_REQUEST, n));
          return;
        }
        u.send(r || null);
      });
    },
  Xy = { http: SK, xhr: ej };
he.forEach(Xy, (n, e) => {
  if (n) {
    try {
      Object.defineProperty(n, "name", { value: e });
    } catch {}
    Object.defineProperty(n, "adapterName", { value: e });
  }
});
const lx = (n) => `- ${n}`,
  tj = (n) => he.isFunction(n) || n === null || n === !1,
  ZM = {
    getAdapter: (n) => {
      n = he.isArray(n) ? n : [n];
      const { length: e } = n;
      let t, i;
      const r = {};
      for (let s = 0; s < e; s++) {
        t = n[s];
        let o;
        if (
          ((i = t),
          !tj(t) && ((i = Xy[(o = String(t)).toLowerCase()]), i === void 0))
        )
          throw new jt(`Unknown adapter '${o}'`);
        if (i) break;
        r[o || "#" + s] = i;
      }
      if (!i) {
        const s = Object.entries(r).map(
          ([a, l]) =>
            `adapter ${a} ` +
            (l === !1
              ? "is not supported by the environment"
              : "is not available in the build"),
        );
        let o = e
          ? s.length > 1
            ? `since :
` +
              s.map(lx).join(`
`)
            : " " + lx(s[0])
          : "as no adapter specified";
        throw new jt(
          "There is no suitable adapter to dispatch the request " + o,
          "ERR_NOT_SUPPORT",
        );
      }
      return i;
    },
    adapters: Xy,
  };
function o2(n) {
  if (
    (n.cancelToken && n.cancelToken.throwIfRequested(),
    n.signal && n.signal.aborted)
  )
    throw new yp(null, n);
}
function cx(n) {
  return (
    o2(n),
    (n.headers = xa.from(n.headers)),
    (n.data = s2.call(n, n.transformRequest)),
    ["post", "put", "patch"].indexOf(n.method) !== -1 &&
      n.headers.setContentType("application/x-www-form-urlencoded", !1),
    ZM.getAdapter(n.adapter || pv.adapter)(n).then(
      function (i) {
        return (
          o2(n),
          (i.data = s2.call(n, n.transformResponse, i)),
          (i.headers = xa.from(i.headers)),
          i
        );
      },
      function (i) {
        return (
          WM(i) ||
            (o2(n),
            i &&
              i.response &&
              ((i.response.data = s2.call(n, n.transformResponse, i.response)),
              (i.response.headers = xa.from(i.response.headers)))),
          Promise.reject(i)
        );
      },
    )
  );
}
const ux = (n) => (n instanceof xa ? n.toJSON() : n);
function td(n, e) {
  e = e || {};
  const t = {};
  function i(c, u, h) {
    return he.isPlainObject(c) && he.isPlainObject(u)
      ? he.merge.call({ caseless: h }, c, u)
      : he.isPlainObject(u)
        ? he.merge({}, u)
        : he.isArray(u)
          ? u.slice()
          : u;
  }
  function r(c, u, h) {
    if (he.isUndefined(u)) {
      if (!he.isUndefined(c)) return i(void 0, c, h);
    } else return i(c, u, h);
  }
  function s(c, u) {
    if (!he.isUndefined(u)) return i(void 0, u);
  }
  function o(c, u) {
    if (he.isUndefined(u)) {
      if (!he.isUndefined(c)) return i(void 0, c);
    } else return i(void 0, u);
  }
  function a(c, u, h) {
    if (h in e) return i(c, u);
    if (h in n) return i(void 0, c);
  }
  const l = {
    url: s,
    method: s,
    data: s,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: a,
    headers: (c, u) => r(ux(c), ux(u), !0),
  };
  return (
    he.forEach(Object.keys(Object.assign({}, n, e)), function (u) {
      const h = l[u] || r,
        d = h(n[u], e[u], u);
      (he.isUndefined(d) && h !== a) || (t[u] = d);
    }),
    t
  );
}
const zM = "1.5.1",
  mv = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(
  (n, e) => {
    mv[n] = function (i) {
      return typeof i === n || "a" + (e < 1 ? "n " : " ") + n;
    };
  },
);
const hx = {};
mv.transitional = function (e, t, i) {
  function r(s, o) {
    return (
      "[Axios v" +
      zM +
      "] Transitional option '" +
      s +
      "'" +
      o +
      (i ? ". " + i : "")
    );
  }
  return (s, o, a) => {
    if (e === !1)
      throw new jt(
        r(o, " has been removed" + (t ? " in " + t : "")),
        jt.ERR_DEPRECATED,
      );
    return (
      t &&
        !hx[o] &&
        ((hx[o] = !0),
        console.warn(
          r(
            o,
            " has been deprecated since v" +
              t +
              " and will be removed in the near future",
          ),
        )),
      e ? e(s, o, a) : !0
    );
  };
};
function nj(n, e, t) {
  if (typeof n != "object")
    throw new jt("options must be an object", jt.ERR_BAD_OPTION_VALUE);
  const i = Object.keys(n);
  let r = i.length;
  for (; r-- > 0; ) {
    const s = i[r],
      o = e[s];
    if (o) {
      const a = n[s],
        l = a === void 0 || o(a, s, n);
      if (l !== !0)
        throw new jt("option " + s + " must be " + l, jt.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (t !== !0) throw new jt("Unknown option " + s, jt.ERR_BAD_OPTION);
  }
}
const Ky = { assertOptions: nj, validators: mv },
  za = Ky.validators;
let Om = class {
  constructor(e) {
    ((this.defaults = e),
      (this.interceptors = { request: new sx(), response: new sx() }));
  }
  request(e, t) {
    (typeof e == "string" ? ((t = t || {}), (t.url = e)) : (t = e || {}),
      (t = td(this.defaults, t)));
    const { transitional: i, paramsSerializer: r, headers: s } = t;
    (i !== void 0 &&
      Ky.assertOptions(
        i,
        {
          silentJSONParsing: za.transitional(za.boolean),
          forcedJSONParsing: za.transitional(za.boolean),
          clarifyTimeoutError: za.transitional(za.boolean),
        },
        !1,
      ),
      r != null &&
        (he.isFunction(r)
          ? (t.paramsSerializer = { serialize: r })
          : Ky.assertOptions(
              r,
              { encode: za.function, serialize: za.function },
              !0,
            )),
      (t.method = (t.method || this.defaults.method || "get").toLowerCase()));
    let o = s && he.merge(s.common, s[t.method]);
    (s &&
      he.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (g) => {
          delete s[g];
        },
      ),
      (t.headers = xa.concat(o, s)));
    const a = [];
    let l = !0;
    this.interceptors.request.forEach(function (p) {
      (typeof p.runWhen == "function" && p.runWhen(t) === !1) ||
        ((l = l && p.synchronous), a.unshift(p.fulfilled, p.rejected));
    });
    const c = [];
    this.interceptors.response.forEach(function (p) {
      c.push(p.fulfilled, p.rejected);
    });
    let u,
      h = 0,
      d;
    if (!l) {
      const g = [cx.bind(this), void 0];
      for (
        g.unshift.apply(g, a),
          g.push.apply(g, c),
          d = g.length,
          u = Promise.resolve(t);
        h < d;
      )
        u = u.then(g[h++], g[h++]);
      return u;
    }
    d = a.length;
    let f = t;
    for (h = 0; h < d; ) {
      const g = a[h++],
        p = a[h++];
      try {
        f = g(f);
      } catch (m) {
        p.call(this, m);
        break;
      }
    }
    try {
      u = cx.call(this, f);
    } catch (g) {
      return Promise.reject(g);
    }
    for (h = 0, d = c.length; h < d; ) u = u.then(c[h++], c[h++]);
    return u;
  }
  getUri(e) {
    e = td(this.defaults, e);
    const t = VM(e.baseURL, e.url);
    return OM(t, e.params, e.paramsSerializer);
  }
};
he.forEach(["delete", "get", "head", "options"], function (e) {
  Om.prototype[e] = function (t, i) {
    return this.request(
      td(i || {}, { method: e, url: t, data: (i || {}).data }),
    );
  };
});
he.forEach(["post", "put", "patch"], function (e) {
  function t(i) {
    return function (s, o, a) {
      return this.request(
        td(a || {}, {
          method: e,
          headers: i ? { "Content-Type": "multipart/form-data" } : {},
          url: s,
          data: o,
        }),
      );
    };
  }
  ((Om.prototype[e] = t()), (Om.prototype[e + "Form"] = t(!0)));
});
const P0 = Om;
let ij = class YM {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let t;
    this.promise = new Promise(function (s) {
      t = s;
    });
    const i = this;
    (this.promise.then((r) => {
      if (!i._listeners) return;
      let s = i._listeners.length;
      for (; s-- > 0; ) i._listeners[s](r);
      i._listeners = null;
    }),
      (this.promise.then = (r) => {
        let s;
        const o = new Promise((a) => {
          (i.subscribe(a), (s = a));
        }).then(r);
        return (
          (o.cancel = function () {
            i.unsubscribe(s);
          }),
          o
        );
      }),
      e(function (s, o, a) {
        i.reason || ((i.reason = new yp(s, o, a)), t(i.reason));
      }));
  }
  throwIfRequested() {
    if (this.reason) throw this.reason;
  }
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : (this._listeners = [e]);
  }
  unsubscribe(e) {
    if (!this._listeners) return;
    const t = this._listeners.indexOf(e);
    t !== -1 && this._listeners.splice(t, 1);
  }
  static source() {
    let e;
    return {
      token: new YM(function (r) {
        e = r;
      }),
      cancel: e,
    };
  }
};
const rj = ij;
function sj(n) {
  return function (t) {
    return n.apply(null, t);
  };
}
function oj(n) {
  return he.isObject(n) && n.isAxiosError === !0;
}
const jy = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};
Object.entries(jy).forEach(([n, e]) => {
  jy[e] = n;
});
const aj = jy;
function XM(n) {
  const e = new P0(n),
    t = TM(P0.prototype.request, e);
  return (
    he.extend(t, P0.prototype, e, { allOwnKeys: !0 }),
    he.extend(t, e, null, { allOwnKeys: !0 }),
    (t.create = function (r) {
      return XM(td(n, r));
    }),
    t
  );
}
const oi = XM(pv);
oi.Axios = P0;
oi.CanceledError = yp;
oi.CancelToken = rj;
oi.isCancel = WM;
oi.VERSION = zM;
oi.toFormData = XC;
oi.AxiosError = jt;
oi.Cancel = oi.CanceledError;
oi.all = function (e) {
  return Promise.all(e);
};
oi.spread = sj;
oi.isAxiosError = oj;
oi.mergeConfig = td;
oi.AxiosHeaders = xa;
oi.formToJSON = (n) => HM(he.isHTMLForm(n) ? new FormData(n) : n);
oi.getAdapter = ZM.getAdapter;
oi.HttpStatusCode = aj;
oi.default = oi;
const lj = oi;
var Cv = { exports: {} },
  Iv = { exports: {} };
function KM(n, e) {
  return function () {
    return n.apply(e, arguments);
  };
}
const { toString: cj } = Object.prototype,
  { getPrototypeOf: Av } = Object,
  jC = ((n) => (e) => {
    const t = cj.call(e);
    return n[t] || (n[t] = t.slice(8, -1).toLowerCase());
  })(Object.create(null)),
  Vo = (n) => ((n = n.toLowerCase()), (e) => jC(e) === n),
  $C = (n) => (e) => typeof e === n,
  { isArray: Ud } = Array,
  Eg = $C("undefined");
function uj(n) {
  return (
    n !== null &&
    !Eg(n) &&
    n.constructor !== null &&
    !Eg(n.constructor) &&
    Ts(n.constructor.isBuffer) &&
    n.constructor.isBuffer(n)
  );
}
const jM = Vo("ArrayBuffer");
function hj(n) {
  let e;
  return (
    typeof ArrayBuffer < "u" && ArrayBuffer.isView
      ? (e = ArrayBuffer.isView(n))
      : (e = n && n.buffer && jM(n.buffer)),
    e
  );
}
const dj = $C("string"),
  Ts = $C("function"),
  $M = $C("number"),
  JC = (n) => n !== null && typeof n == "object",
  fj = (n) => n === !0 || n === !1,
  N0 = (n) => {
    if (jC(n) !== "object") return !1;
    const e = Av(n);
    return (
      (e === null ||
        e === Object.prototype ||
        Object.getPrototypeOf(e) === null) &&
      !(Symbol.toStringTag in n) &&
      !(Symbol.iterator in n)
    );
  },
  gj = Vo("Date"),
  pj = Vo("File"),
  mj = Vo("Blob"),
  Cj = Vo("FileList"),
  Ij = (n) => JC(n) && Ts(n.pipe),
  Aj = (n) => {
    let e;
    return (
      n &&
      ((typeof FormData == "function" && n instanceof FormData) ||
        (Ts(n.append) &&
          ((e = jC(n)) === "formdata" ||
            (e === "object" &&
              Ts(n.toString) &&
              n.toString() === "[object FormData]"))))
    );
  },
  yj = Vo("URLSearchParams"),
  _j = (n) =>
    n.trim ? n.trim() : n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function _p(n, e, { allOwnKeys: t = !1 } = {}) {
  if (n === null || typeof n > "u") return;
  let i, r;
  if ((typeof n != "object" && (n = [n]), Ud(n)))
    for (i = 0, r = n.length; i < r; i++) e.call(null, n[i], i, n);
  else {
    const s = t ? Object.getOwnPropertyNames(n) : Object.keys(n),
      o = s.length;
    let a;
    for (i = 0; i < o; i++) ((a = s[i]), e.call(null, n[a], a, n));
  }
}
function JM(n, e) {
  e = e.toLowerCase();
  const t = Object.keys(n);
  let i = t.length,
    r;
  for (; i-- > 0; ) if (((r = t[i]), e === r.toLowerCase())) return r;
  return null;
}
const QM = (() =>
    typeof globalThis < "u"
      ? globalThis
      : typeof self < "u"
        ? self
        : typeof window < "u"
          ? window
          : C0)(),
  qM = (n) => !Eg(n) && n !== QM;
function $y() {
  const { caseless: n } = (qM(this) && this) || {},
    e = {},
    t = (i, r) => {
      const s = (n && JM(e, r)) || r;
      N0(e[s]) && N0(i)
        ? (e[s] = $y(e[s], i))
        : N0(i)
          ? (e[s] = $y({}, i))
          : Ud(i)
            ? (e[s] = i.slice())
            : (e[s] = i);
    };
  for (let i = 0, r = arguments.length; i < r; i++)
    arguments[i] && _p(arguments[i], t);
  return e;
}
const bj = (n, e, t, { allOwnKeys: i } = {}) => (
    _p(
      e,
      (r, s) => {
        t && Ts(r) ? (n[s] = KM(r, t)) : (n[s] = r);
      },
      { allOwnKeys: i },
    ),
    n
  ),
  vj = (n) => (n.charCodeAt(0) === 65279 && (n = n.slice(1)), n),
  xj = (n, e, t, i) => {
    ((n.prototype = Object.create(e.prototype, i)),
      (n.prototype.constructor = n),
      Object.defineProperty(n, "super", { value: e.prototype }),
      t && Object.assign(n.prototype, t));
  },
  wj = (n, e, t, i) => {
    let r, s, o;
    const a = {};
    if (((e = e || {}), n == null)) return e;
    do {
      for (r = Object.getOwnPropertyNames(n), s = r.length; s-- > 0; )
        ((o = r[s]),
          (!i || i(o, n, e)) && !a[o] && ((e[o] = n[o]), (a[o] = !0)));
      n = t !== !1 && Av(n);
    } while (n && (!t || t(n, e)) && n !== Object.prototype);
    return e;
  },
  Sj = (n, e, t) => {
    ((n = String(n)),
      (t === void 0 || t > n.length) && (t = n.length),
      (t -= e.length));
    const i = n.indexOf(e, t);
    return i !== -1 && i === t;
  },
  Tj = (n) => {
    if (!n) return null;
    if (Ud(n)) return n;
    let e = n.length;
    if (!$M(e)) return null;
    const t = new Array(e);
    for (; e-- > 0; ) t[e] = n[e];
    return t;
  },
  Ej = (
    (n) => (e) =>
      n && e instanceof n
  )(typeof Uint8Array < "u" && Av(Uint8Array)),
  Mj = (n, e) => {
    const i = (n && n[Symbol.iterator]).call(n);
    let r;
    for (; (r = i.next()) && !r.done; ) {
      const s = r.value;
      e.call(n, s[0], s[1]);
    }
  },
  Lj = (n, e) => {
    let t;
    const i = [];
    for (; (t = n.exec(e)) !== null; ) i.push(t);
    return i;
  },
  Rj = Vo("HTMLFormElement"),
  Bj = (n) =>
    n.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (t, i, r) {
      return i.toUpperCase() + r;
    }),
  dx = (
    ({ hasOwnProperty: n }) =>
    (e, t) =>
      n.call(e, t)
  )(Object.prototype),
  Pj = Vo("RegExp"),
  eL = (n, e) => {
    const t = Object.getOwnPropertyDescriptors(n),
      i = {};
    (_p(t, (r, s) => {
      let o;
      (o = e(r, s, n)) !== !1 && (i[s] = o || r);
    }),
      Object.defineProperties(n, i));
  },
  Nj = (n) => {
    eL(n, (e, t) => {
      if (Ts(n) && ["arguments", "caller", "callee"].indexOf(t) !== -1)
        return !1;
      const i = n[t];
      if (Ts(i)) {
        if (((e.enumerable = !1), "writable" in e)) {
          e.writable = !1;
          return;
        }
        e.set ||
          (e.set = () => {
            throw Error("Can not rewrite read-only method '" + t + "'");
          });
      }
    });
  },
  Dj = (n, e) => {
    const t = {},
      i = (r) => {
        r.forEach((s) => {
          t[s] = !0;
        });
      };
    return (Ud(n) ? i(n) : i(String(n).split(e)), t);
  },
  Gj = () => {},
  Fj = (n, e) => ((n = +n), Number.isFinite(n) ? n : e),
  a2 = "abcdefghijklmnopqrstuvwxyz",
  fx = "0123456789",
  tL = { DIGIT: fx, ALPHA: a2, ALPHA_DIGIT: a2 + a2.toUpperCase() + fx },
  kj = (n = 16, e = tL.ALPHA_DIGIT) => {
    let t = "";
    const { length: i } = e;
    for (; n--; ) t += e[(Math.random() * i) | 0];
    return t;
  };
function Oj(n) {
  return !!(
    n &&
    Ts(n.append) &&
    n[Symbol.toStringTag] === "FormData" &&
    n[Symbol.iterator]
  );
}
const Uj = (n) => {
    const e = new Array(10),
      t = (i, r) => {
        if (JC(i)) {
          if (e.indexOf(i) >= 0) return;
          if (!("toJSON" in i)) {
            e[r] = i;
            const s = Ud(i) ? [] : {};
            return (
              _p(i, (o, a) => {
                const l = t(o, r + 1);
                !Eg(l) && (s[a] = l);
              }),
              (e[r] = void 0),
              s
            );
          }
        }
        return i;
      };
    return t(n, 0);
  },
  Hj = Vo("AsyncFunction"),
  Wj = (n) => n && (JC(n) || Ts(n)) && Ts(n.then) && Ts(n.catch);
var de = {
  isArray: Ud,
  isArrayBuffer: jM,
  isBuffer: uj,
  isFormData: Aj,
  isArrayBufferView: hj,
  isString: dj,
  isNumber: $M,
  isBoolean: fj,
  isObject: JC,
  isPlainObject: N0,
  isUndefined: Eg,
  isDate: gj,
  isFile: pj,
  isBlob: mj,
  isRegExp: Pj,
  isFunction: Ts,
  isStream: Ij,
  isURLSearchParams: yj,
  isTypedArray: Ej,
  isFileList: Cj,
  forEach: _p,
  merge: $y,
  extend: bj,
  trim: _j,
  stripBOM: vj,
  inherits: xj,
  toFlatObject: wj,
  kindOf: jC,
  kindOfTest: Vo,
  endsWith: Sj,
  toArray: Tj,
  forEachEntry: Mj,
  matchAll: Lj,
  isHTMLForm: Rj,
  hasOwnProperty: dx,
  hasOwnProp: dx,
  reduceDescriptors: eL,
  freezeMethods: Nj,
  toObjectSet: Dj,
  toCamelCase: Bj,
  noop: Gj,
  toFiniteNumber: Fj,
  findKey: JM,
  global: QM,
  isContextDefined: qM,
  ALPHABET: tL,
  generateString: kj,
  isSpecCompliantForm: Oj,
  toJSONObject: Uj,
  isAsyncFn: Hj,
  isThenable: Wj,
};
function $t(n, e, t, i, r) {
  (Error.call(this),
    Error.captureStackTrace
      ? Error.captureStackTrace(this, this.constructor)
      : (this.stack = new Error().stack),
    (this.message = n),
    (this.name = "AxiosError"),
    e && (this.code = e),
    t && (this.config = t),
    i && (this.request = i),
    r && (this.response = r));
}
de.inherits($t, Error, {
  toJSON: function () {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: de.toJSONObject(this.config),
      code: this.code,
      status:
        this.response && this.response.status ? this.response.status : null,
    };
  },
});
const nL = $t.prototype,
  iL = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL",
].forEach((n) => {
  iL[n] = { value: n };
});
Object.defineProperties($t, iL);
Object.defineProperty(nL, "isAxiosError", { value: !0 });
$t.from = (n, e, t, i, r, s) => {
  const o = Object.create(nL);
  return (
    de.toFlatObject(
      n,
      o,
      function (l) {
        return l !== Error.prototype;
      },
      (a) => a !== "isAxiosError",
    ),
    $t.call(o, n.message, e, t, i, r),
    (o.cause = n),
    (o.name = n.name),
    s && Object.assign(o, s),
    o
  );
};
var Vj = null;
function Jy(n) {
  return de.isPlainObject(n) || de.isArray(n);
}
function rL(n) {
  return de.endsWith(n, "[]") ? n.slice(0, -2) : n;
}
function gx(n, e, t) {
  return n
    ? n
        .concat(e)
        .map(function (r, s) {
          return ((r = rL(r)), !t && s ? "[" + r + "]" : r);
        })
        .join(t ? "." : "")
    : e;
}
function Zj(n) {
  return de.isArray(n) && !n.some(Jy);
}
const zj = de.toFlatObject(de, {}, null, function (e) {
  return /^is[A-Z]/.test(e);
});
function QC(n, e, t) {
  if (!de.isObject(n)) throw new TypeError("target must be an object");
  ((e = e || new FormData()),
    (t = de.toFlatObject(
      t,
      { metaTokens: !0, dots: !1, indexes: !1 },
      !1,
      function (p, m) {
        return !de.isUndefined(m[p]);
      },
    )));
  const i = t.metaTokens,
    r = t.visitor || u,
    s = t.dots,
    o = t.indexes,
    l = (t.Blob || (typeof Blob < "u" && Blob)) && de.isSpecCompliantForm(e);
  if (!de.isFunction(r)) throw new TypeError("visitor must be a function");
  function c(g) {
    if (g === null) return "";
    if (de.isDate(g)) return g.toISOString();
    if (!l && de.isBlob(g))
      throw new $t("Blob is not supported. Use a Buffer instead.");
    return de.isArrayBuffer(g) || de.isTypedArray(g)
      ? l && typeof Blob == "function"
        ? new Blob([g])
        : Buffer.from(g)
      : g;
  }
  function u(g, p, m) {
    let C = g;
    if (g && !m && typeof g == "object") {
      if (de.endsWith(p, "{}"))
        ((p = i ? p : p.slice(0, -2)), (g = JSON.stringify(g)));
      else if (
        (de.isArray(g) && Zj(g)) ||
        ((de.isFileList(g) || de.endsWith(p, "[]")) && (C = de.toArray(g)))
      )
        return (
          (p = rL(p)),
          C.forEach(function (I, y) {
            !(de.isUndefined(I) || I === null) &&
              e.append(
                o === !0 ? gx([p], y, s) : o === null ? p : p + "[]",
                c(I),
              );
          }),
          !1
        );
    }
    return Jy(g) ? !0 : (e.append(gx(m, p, s), c(g)), !1);
  }
  const h = [],
    d = Object.assign(zj, {
      defaultVisitor: u,
      convertValue: c,
      isVisitable: Jy,
    });
  function f(g, p) {
    if (!de.isUndefined(g)) {
      if (h.indexOf(g) !== -1)
        throw Error("Circular reference detected in " + p.join("."));
      (h.push(g),
        de.forEach(g, function (C, A) {
          (!(de.isUndefined(C) || C === null) &&
            r.call(e, C, de.isString(A) ? A.trim() : A, p, d)) === !0 &&
            f(C, p ? p.concat(A) : [A]);
        }),
        h.pop());
    }
  }
  if (!de.isObject(n)) throw new TypeError("data must be an object");
  return (f(n), e);
}
function px(n) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0",
  };
  return encodeURIComponent(n).replace(/[!'()~]|%20|%00/g, function (i) {
    return e[i];
  });
}
function yv(n, e) {
  ((this._pairs = []), n && QC(n, this, e));
}
const sL = yv.prototype;
sL.append = function (e, t) {
  this._pairs.push([e, t]);
};
sL.toString = function (e) {
  const t = e
    ? function (i) {
        return e.call(this, i, px);
      }
    : px;
  return this._pairs
    .map(function (r) {
      return t(r[0]) + "=" + t(r[1]);
    }, "")
    .join("&");
};
function Yj(n) {
  return encodeURIComponent(n)
    .replace(/%3A/gi, ":")
    .replace(/%24/g, "$")
    .replace(/%2C/gi, ",")
    .replace(/%20/g, "+")
    .replace(/%5B/gi, "[")
    .replace(/%5D/gi, "]");
}
function oL(n, e, t) {
  if (!e) return n;
  const i = (t && t.encode) || Yj,
    r = t && t.serialize;
  let s;
  if (
    (r
      ? (s = r(e, t))
      : (s = de.isURLSearchParams(e) ? e.toString() : new yv(e, t).toString(i)),
    s)
  ) {
    const o = n.indexOf("#");
    (o !== -1 && (n = n.slice(0, o)),
      (n += (n.indexOf("?") === -1 ? "?" : "&") + s));
  }
  return n;
}
class Xj {
  constructor() {
    this.handlers = [];
  }
  use(e, t, i) {
    return (
      this.handlers.push({
        fulfilled: e,
        rejected: t,
        synchronous: i ? i.synchronous : !1,
        runWhen: i ? i.runWhen : null,
      }),
      this.handlers.length - 1
    );
  }
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  clear() {
    this.handlers && (this.handlers = []);
  }
  forEach(e) {
    de.forEach(this.handlers, function (i) {
      i !== null && e(i);
    });
  }
}
var mx = Xj,
  aL = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1,
  },
  Kj = typeof URLSearchParams < "u" ? URLSearchParams : yv,
  jj = typeof FormData < "u" ? FormData : null,
  $j = typeof Blob < "u" ? Blob : null,
  Jj = {
    isBrowser: !0,
    classes: { URLSearchParams: Kj, FormData: jj, Blob: $j },
    protocols: ["http", "https", "file", "blob", "url", "data"],
  };
const lL = typeof window < "u" && typeof document < "u",
  Qj = ((n) => lL && ["ReactNative", "NativeScript", "NS"].indexOf(n) < 0)(
    typeof navigator < "u" && navigator.product,
  ),
  qj = (() =>
    typeof WorkerGlobalScope < "u" &&
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts == "function")();
var e$ = Object.freeze({
    __proto__: null,
    hasBrowserEnv: lL,
    hasStandardBrowserWebWorkerEnv: qj,
    hasStandardBrowserEnv: Qj,
  }),
  vo = { ...e$, ...Jj };
function t$(n, e) {
  return QC(
    n,
    new vo.classes.URLSearchParams(),
    Object.assign(
      {
        visitor: function (t, i, r, s) {
          return vo.isNode && de.isBuffer(t)
            ? (this.append(i, t.toString("base64")), !1)
            : s.defaultVisitor.apply(this, arguments);
        },
      },
      e,
    ),
  );
}
function n$(n) {
  return de
    .matchAll(/\w+|\[(\w*)]/g, n)
    .map((e) => (e[0] === "[]" ? "" : e[1] || e[0]));
}
function i$(n) {
  const e = {},
    t = Object.keys(n);
  let i;
  const r = t.length;
  let s;
  for (i = 0; i < r; i++) ((s = t[i]), (e[s] = n[s]));
  return e;
}
function cL(n) {
  function e(t, i, r, s) {
    let o = t[s++];
    const a = Number.isFinite(+o),
      l = s >= t.length;
    return (
      (o = !o && de.isArray(r) ? r.length : o),
      l
        ? (de.hasOwnProp(r, o) ? (r[o] = [r[o], i]) : (r[o] = i), !a)
        : ((!r[o] || !de.isObject(r[o])) && (r[o] = []),
          e(t, i, r[o], s) && de.isArray(r[o]) && (r[o] = i$(r[o])),
          !a)
    );
  }
  if (de.isFormData(n) && de.isFunction(n.entries)) {
    const t = {};
    return (
      de.forEachEntry(n, (i, r) => {
        e(n$(i), r, t, 0);
      }),
      t
    );
  }
  return null;
}
function r$(n, e, t) {
  if (de.isString(n))
    try {
      return ((e || JSON.parse)(n), de.trim(n));
    } catch (i) {
      if (i.name !== "SyntaxError") throw i;
    }
  return (t || JSON.stringify)(n);
}
const _v = {
  transitional: aL,
  adapter: ["xhr", "http"],
  transformRequest: [
    function (e, t) {
      const i = t.getContentType() || "",
        r = i.indexOf("application/json") > -1,
        s = de.isObject(e);
      if ((s && de.isHTMLForm(e) && (e = new FormData(e)), de.isFormData(e)))
        return r && r ? JSON.stringify(cL(e)) : e;
      if (
        de.isArrayBuffer(e) ||
        de.isBuffer(e) ||
        de.isStream(e) ||
        de.isFile(e) ||
        de.isBlob(e)
      )
        return e;
      if (de.isArrayBufferView(e)) return e.buffer;
      if (de.isURLSearchParams(e))
        return (
          t.setContentType(
            "application/x-www-form-urlencoded;charset=utf-8",
            !1,
          ),
          e.toString()
        );
      let a;
      if (s) {
        if (i.indexOf("application/x-www-form-urlencoded") > -1)
          return t$(e, this.formSerializer).toString();
        if ((a = de.isFileList(e)) || i.indexOf("multipart/form-data") > -1) {
          const l = this.env && this.env.FormData;
          return QC(
            a ? { "files[]": e } : e,
            l && new l(),
            this.formSerializer,
          );
        }
      }
      return s || r ? (t.setContentType("application/json", !1), r$(e)) : e;
    },
  ],
  transformResponse: [
    function (e) {
      const t = this.transitional || _v.transitional,
        i = t && t.forcedJSONParsing,
        r = this.responseType === "json";
      if (e && de.isString(e) && ((i && !this.responseType) || r)) {
        const o = !(t && t.silentJSONParsing) && r;
        try {
          return JSON.parse(e);
        } catch (a) {
          if (o)
            throw a.name === "SyntaxError"
              ? $t.from(a, $t.ERR_BAD_RESPONSE, this, null, this.response)
              : a;
        }
      }
      return e;
    },
  ],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: { FormData: vo.classes.FormData, Blob: vo.classes.Blob },
  validateStatus: function (e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0,
    },
  },
};
de.forEach(["delete", "get", "head", "post", "put", "patch"], (n) => {
  _v.headers[n] = {};
});
var bv = _v;
const s$ = de.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent",
]);
var o$ = (n) => {
  const e = {};
  let t, i, r;
  return (
    n &&
      n
        .split(
          `
`,
        )
        .forEach(function (o) {
          ((r = o.indexOf(":")),
            (t = o.substring(0, r).trim().toLowerCase()),
            (i = o.substring(r + 1).trim()),
            !(!t || (e[t] && s$[t])) &&
              (t === "set-cookie"
                ? e[t]
                  ? e[t].push(i)
                  : (e[t] = [i])
                : (e[t] = e[t] ? e[t] + ", " + i : i)));
        }),
    e
  );
};
const Cx = Symbol("internals");
function af(n) {
  return n && String(n).trim().toLowerCase();
}
function D0(n) {
  return n === !1 || n == null ? n : de.isArray(n) ? n.map(D0) : String(n);
}
function a$(n) {
  const e = Object.create(null),
    t = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let i;
  for (; (i = t.exec(n)); ) e[i[1]] = i[2];
  return e;
}
const l$ = (n) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(n.trim());
function l2(n, e, t, i, r) {
  if (de.isFunction(i)) return i.call(this, e, t);
  if ((r && (e = t), !!de.isString(e))) {
    if (de.isString(i)) return e.indexOf(i) !== -1;
    if (de.isRegExp(i)) return i.test(e);
  }
}
function c$(n) {
  return n
    .trim()
    .toLowerCase()
    .replace(/([a-z\d])(\w*)/g, (e, t, i) => t.toUpperCase() + i);
}
function u$(n, e) {
  const t = de.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((i) => {
    Object.defineProperty(n, i + t, {
      value: function (r, s, o) {
        return this[i].call(this, e, r, s, o);
      },
      configurable: !0,
    });
  });
}
class qC {
  constructor(e) {
    e && this.set(e);
  }
  set(e, t, i) {
    const r = this;
    function s(a, l, c) {
      const u = af(l);
      if (!u) throw new Error("header name must be a non-empty string");
      const h = de.findKey(r, u);
      (!h || r[h] === void 0 || c === !0 || (c === void 0 && r[h] !== !1)) &&
        (r[h || l] = D0(a));
    }
    const o = (a, l) => de.forEach(a, (c, u) => s(c, u, l));
    return (
      de.isPlainObject(e) || e instanceof this.constructor
        ? o(e, t)
        : de.isString(e) && (e = e.trim()) && !l$(e)
          ? o(o$(e), t)
          : e != null && s(t, e, i),
      this
    );
  }
  get(e, t) {
    if (((e = af(e)), e)) {
      const i = de.findKey(this, e);
      if (i) {
        const r = this[i];
        if (!t) return r;
        if (t === !0) return a$(r);
        if (de.isFunction(t)) return t.call(this, r, i);
        if (de.isRegExp(t)) return t.exec(r);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, t) {
    if (((e = af(e)), e)) {
      const i = de.findKey(this, e);
      return !!(i && this[i] !== void 0 && (!t || l2(this, this[i], i, t)));
    }
    return !1;
  }
  delete(e, t) {
    const i = this;
    let r = !1;
    function s(o) {
      if (((o = af(o)), o)) {
        const a = de.findKey(i, o);
        a && (!t || l2(i, i[a], a, t)) && (delete i[a], (r = !0));
      }
    }
    return (de.isArray(e) ? e.forEach(s) : s(e), r);
  }
  clear(e) {
    const t = Object.keys(this);
    let i = t.length,
      r = !1;
    for (; i--; ) {
      const s = t[i];
      (!e || l2(this, this[s], s, e, !0)) && (delete this[s], (r = !0));
    }
    return r;
  }
  normalize(e) {
    const t = this,
      i = {};
    return (
      de.forEach(this, (r, s) => {
        const o = de.findKey(i, s);
        if (o) {
          ((t[o] = D0(r)), delete t[s]);
          return;
        }
        const a = e ? c$(s) : String(s).trim();
        (a !== s && delete t[s], (t[a] = D0(r)), (i[a] = !0));
      }),
      this
    );
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const t = Object.create(null);
    return (
      de.forEach(this, (i, r) => {
        i != null && i !== !1 && (t[r] = e && de.isArray(i) ? i.join(", ") : i);
      }),
      t
    );
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, t]) => e + ": " + t).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...t) {
    const i = new this(e);
    return (t.forEach((r) => i.set(r)), i);
  }
  static accessor(e) {
    const i = (this[Cx] = this[Cx] = { accessors: {} }).accessors,
      r = this.prototype;
    function s(o) {
      const a = af(o);
      i[a] || (u$(r, o), (i[a] = !0));
    }
    return (de.isArray(e) ? e.forEach(s) : s(e), this);
  }
}
qC.accessor([
  "Content-Type",
  "Content-Length",
  "Accept",
  "Accept-Encoding",
  "User-Agent",
  "Authorization",
]);
de.reduceDescriptors(qC.prototype, ({ value: n }, e) => {
  let t = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => n,
    set(i) {
      this[t] = i;
    },
  };
});
de.freezeMethods(qC);
var wa = qC;
function c2(n, e) {
  const t = this || bv,
    i = e || t,
    r = wa.from(i.headers);
  let s = i.data;
  return (
    de.forEach(n, function (a) {
      s = a.call(t, s, r.normalize(), e ? e.status : void 0);
    }),
    r.normalize(),
    s
  );
}
function uL(n) {
  return !!(n && n.__CANCEL__);
}
function bp(n, e, t) {
  ($t.call(this, n ?? "canceled", $t.ERR_CANCELED, e, t),
    (this.name = "CanceledError"));
}
de.inherits(bp, $t, { __CANCEL__: !0 });
function h$(n, e, t) {
  const i = t.config.validateStatus;
  !t.status || !i || i(t.status)
    ? n(t)
    : e(
        new $t(
          "Request failed with status code " + t.status,
          [$t.ERR_BAD_REQUEST, $t.ERR_BAD_RESPONSE][
            Math.floor(t.status / 100) - 4
          ],
          t.config,
          t.request,
          t,
        ),
      );
}
var d$ = vo.hasStandardBrowserEnv
  ? {
      write(n, e, t, i, r, s) {
        const o = [n + "=" + encodeURIComponent(e)];
        (de.isNumber(t) && o.push("expires=" + new Date(t).toGMTString()),
          de.isString(i) && o.push("path=" + i),
          de.isString(r) && o.push("domain=" + r),
          s === !0 && o.push("secure"),
          (document.cookie = o.join("; ")));
      },
      read(n) {
        const e = document.cookie.match(
          new RegExp("(^|;\\s*)(" + n + ")=([^;]*)"),
        );
        return e ? decodeURIComponent(e[3]) : null;
      },
      remove(n) {
        this.write(n, "", Date.now() - 864e5);
      },
    }
  : {
      write() {},
      read() {
        return null;
      },
      remove() {},
    };
function f$(n) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(n);
}
function g$(n, e) {
  return e ? n.replace(/\/+$/, "") + "/" + e.replace(/^\/+/, "") : n;
}
function hL(n, e) {
  return n && !f$(e) ? g$(n, e) : e;
}
var p$ = vo.hasStandardBrowserEnv
  ? (function () {
      const e = /(msie|trident)/i.test(navigator.userAgent),
        t = document.createElement("a");
      let i;
      function r(s) {
        let o = s;
        return (
          e && (t.setAttribute("href", o), (o = t.href)),
          t.setAttribute("href", o),
          {
            href: t.href,
            protocol: t.protocol ? t.protocol.replace(/:$/, "") : "",
            host: t.host,
            search: t.search ? t.search.replace(/^\?/, "") : "",
            hash: t.hash ? t.hash.replace(/^#/, "") : "",
            hostname: t.hostname,
            port: t.port,
            pathname:
              t.pathname.charAt(0) === "/" ? t.pathname : "/" + t.pathname,
          }
        );
      }
      return (
        (i = r(window.location.href)),
        function (o) {
          const a = de.isString(o) ? r(o) : o;
          return a.protocol === i.protocol && a.host === i.host;
        }
      );
    })()
  : (function () {
      return function () {
        return !0;
      };
    })();
function m$(n) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(n);
  return (e && e[1]) || "";
}
function C$(n, e) {
  n = n || 10;
  const t = new Array(n),
    i = new Array(n);
  let r = 0,
    s = 0,
    o;
  return (
    (e = e !== void 0 ? e : 1e3),
    function (l) {
      const c = Date.now(),
        u = i[s];
      (o || (o = c), (t[r] = l), (i[r] = c));
      let h = s,
        d = 0;
      for (; h !== r; ) ((d += t[h++]), (h = h % n));
      if (((r = (r + 1) % n), r === s && (s = (s + 1) % n), c - o < e)) return;
      const f = u && c - u;
      return f ? Math.round((d * 1e3) / f) : void 0;
    }
  );
}
function Ix(n, e) {
  let t = 0;
  const i = C$(50, 250);
  return (r) => {
    const s = r.loaded,
      o = r.lengthComputable ? r.total : void 0,
      a = s - t,
      l = i(a),
      c = s <= o;
    t = s;
    const u = {
      loaded: s,
      total: o,
      progress: o ? s / o : void 0,
      bytes: a,
      rate: l || void 0,
      estimated: l && o && c ? (o - s) / l : void 0,
      event: r,
    };
    ((u[e ? "download" : "upload"] = !0), n(u));
  };
}
const I$ = typeof XMLHttpRequest < "u";
var A$ =
  I$ &&
  function (n) {
    return new Promise(function (t, i) {
      let r = n.data;
      const s = wa.from(n.headers).normalize();
      let { responseType: o, withXSRFToken: a } = n,
        l;
      function c() {
        (n.cancelToken && n.cancelToken.unsubscribe(l),
          n.signal && n.signal.removeEventListener("abort", l));
      }
      let u;
      if (de.isFormData(r)) {
        if (vo.hasStandardBrowserEnv || vo.hasStandardBrowserWebWorkerEnv)
          s.setContentType(!1);
        else if ((u = s.getContentType()) !== !1) {
          const [p, ...m] = u
            ? u
                .split(";")
                .map((C) => C.trim())
                .filter(Boolean)
            : [];
          s.setContentType([p || "multipart/form-data", ...m].join("; "));
        }
      }
      let h = new XMLHttpRequest();
      if (n.auth) {
        const p = n.auth.username || "",
          m = n.auth.password
            ? unescape(encodeURIComponent(n.auth.password))
            : "";
        s.set("Authorization", "Basic " + btoa(p + ":" + m));
      }
      const d = hL(n.baseURL, n.url);
      (h.open(n.method.toUpperCase(), oL(d, n.params, n.paramsSerializer), !0),
        (h.timeout = n.timeout));
      function f() {
        if (!h) return;
        const p = wa.from(
            "getAllResponseHeaders" in h && h.getAllResponseHeaders(),
          ),
          C = {
            data:
              !o || o === "text" || o === "json" ? h.responseText : h.response,
            status: h.status,
            statusText: h.statusText,
            headers: p,
            config: n,
            request: h,
          };
        (h$(
          function (I) {
            (t(I), c());
          },
          function (I) {
            (i(I), c());
          },
          C,
        ),
          (h = null));
      }
      if (
        ("onloadend" in h
          ? (h.onloadend = f)
          : (h.onreadystatechange = function () {
              !h ||
                h.readyState !== 4 ||
                (h.status === 0 &&
                  !(h.responseURL && h.responseURL.indexOf("file:") === 0)) ||
                setTimeout(f);
            }),
        (h.onabort = function () {
          h &&
            (i(new $t("Request aborted", $t.ECONNABORTED, n, h)), (h = null));
        }),
        (h.onerror = function () {
          (i(new $t("Network Error", $t.ERR_NETWORK, n, h)), (h = null));
        }),
        (h.ontimeout = function () {
          let m = n.timeout
            ? "timeout of " + n.timeout + "ms exceeded"
            : "timeout exceeded";
          const C = n.transitional || aL;
          (n.timeoutErrorMessage && (m = n.timeoutErrorMessage),
            i(
              new $t(
                m,
                C.clarifyTimeoutError ? $t.ETIMEDOUT : $t.ECONNABORTED,
                n,
                h,
              ),
            ),
            (h = null));
        }),
        vo.hasStandardBrowserEnv &&
          (a && de.isFunction(a) && (a = a(n)), a || (a !== !1 && p$(d))))
      ) {
        const p =
          n.xsrfHeaderName && n.xsrfCookieName && d$.read(n.xsrfCookieName);
        p && s.set(n.xsrfHeaderName, p);
      }
      (r === void 0 && s.setContentType(null),
        "setRequestHeader" in h &&
          de.forEach(s.toJSON(), function (m, C) {
            h.setRequestHeader(C, m);
          }),
        de.isUndefined(n.withCredentials) ||
          (h.withCredentials = !!n.withCredentials),
        o && o !== "json" && (h.responseType = n.responseType),
        typeof n.onDownloadProgress == "function" &&
          h.addEventListener("progress", Ix(n.onDownloadProgress, !0)),
        typeof n.onUploadProgress == "function" &&
          h.upload &&
          h.upload.addEventListener("progress", Ix(n.onUploadProgress)),
        (n.cancelToken || n.signal) &&
          ((l = (p) => {
            h &&
              (i(!p || p.type ? new bp(null, n, h) : p), h.abort(), (h = null));
          }),
          n.cancelToken && n.cancelToken.subscribe(l),
          n.signal &&
            (n.signal.aborted ? l() : n.signal.addEventListener("abort", l))));
      const g = m$(d);
      if (g && vo.protocols.indexOf(g) === -1) {
        i(new $t("Unsupported protocol " + g + ":", $t.ERR_BAD_REQUEST, n));
        return;
      }
      h.send(r || null);
    });
  };
const Qy = { http: Vj, xhr: A$ };
de.forEach(Qy, (n, e) => {
  if (n) {
    try {
      Object.defineProperty(n, "name", { value: e });
    } catch {}
    Object.defineProperty(n, "adapterName", { value: e });
  }
});
const Ax = (n) => `- ${n}`,
  y$ = (n) => de.isFunction(n) || n === null || n === !1;
var dL = {
  getAdapter: (n) => {
    n = de.isArray(n) ? n : [n];
    const { length: e } = n;
    let t, i;
    const r = {};
    for (let s = 0; s < e; s++) {
      t = n[s];
      let o;
      if (
        ((i = t),
        !y$(t) && ((i = Qy[(o = String(t)).toLowerCase()]), i === void 0))
      )
        throw new $t(`Unknown adapter '${o}'`);
      if (i) break;
      r[o || "#" + s] = i;
    }
    if (!i) {
      const s = Object.entries(r).map(
        ([a, l]) =>
          `adapter ${a} ` +
          (l === !1
            ? "is not supported by the environment"
            : "is not available in the build"),
      );
      let o = e
        ? s.length > 1
          ? `since :
` +
            s.map(Ax).join(`
`)
          : " " + Ax(s[0])
        : "as no adapter specified";
      throw new $t(
        "There is no suitable adapter to dispatch the request " + o,
        "ERR_NOT_SUPPORT",
      );
    }
    return i;
  },
  adapters: Qy,
};
function u2(n) {
  if (
    (n.cancelToken && n.cancelToken.throwIfRequested(),
    n.signal && n.signal.aborted)
  )
    throw new bp(null, n);
}
function yx(n) {
  return (
    u2(n),
    (n.headers = wa.from(n.headers)),
    (n.data = c2.call(n, n.transformRequest)),
    ["post", "put", "patch"].indexOf(n.method) !== -1 &&
      n.headers.setContentType("application/x-www-form-urlencoded", !1),
    dL
      .getAdapter(n.adapter || bv.adapter)(n)
      .then(
        function (i) {
          return (
            u2(n),
            (i.data = c2.call(n, n.transformResponse, i)),
            (i.headers = wa.from(i.headers)),
            i
          );
        },
        function (i) {
          return (
            uL(i) ||
              (u2(n),
              i &&
                i.response &&
                ((i.response.data = c2.call(
                  n,
                  n.transformResponse,
                  i.response,
                )),
                (i.response.headers = wa.from(i.response.headers)))),
            Promise.reject(i)
          );
        },
      )
  );
}
const _x = (n) => (n instanceof wa ? n.toJSON() : n);
function nd(n, e) {
  e = e || {};
  const t = {};
  function i(c, u, h) {
    return de.isPlainObject(c) && de.isPlainObject(u)
      ? de.merge.call({ caseless: h }, c, u)
      : de.isPlainObject(u)
        ? de.merge({}, u)
        : de.isArray(u)
          ? u.slice()
          : u;
  }
  function r(c, u, h) {
    if (de.isUndefined(u)) {
      if (!de.isUndefined(c)) return i(void 0, c, h);
    } else return i(c, u, h);
  }
  function s(c, u) {
    if (!de.isUndefined(u)) return i(void 0, u);
  }
  function o(c, u) {
    if (de.isUndefined(u)) {
      if (!de.isUndefined(c)) return i(void 0, c);
    } else return i(void 0, u);
  }
  function a(c, u, h) {
    if (h in e) return i(c, u);
    if (h in n) return i(void 0, c);
  }
  const l = {
    url: s,
    method: s,
    data: s,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: a,
    headers: (c, u) => r(_x(c), _x(u), !0),
  };
  return (
    de.forEach(Object.keys(Object.assign({}, n, e)), function (u) {
      const h = l[u] || r,
        d = h(n[u], e[u], u);
      (de.isUndefined(d) && h !== a) || (t[u] = d);
    }),
    t
  );
}
const fL = "1.6.2",
  vv = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(
  (n, e) => {
    vv[n] = function (i) {
      return typeof i === n || "a" + (e < 1 ? "n " : " ") + n;
    };
  },
);
const bx = {};
vv.transitional = function (e, t, i) {
  function r(s, o) {
    return (
      "[Axios v" +
      fL +
      "] Transitional option '" +
      s +
      "'" +
      o +
      (i ? ". " + i : "")
    );
  }
  return (s, o, a) => {
    if (e === !1)
      throw new $t(
        r(o, " has been removed" + (t ? " in " + t : "")),
        $t.ERR_DEPRECATED,
      );
    return (
      t &&
        !bx[o] &&
        ((bx[o] = !0),
        console.warn(
          r(
            o,
            " has been deprecated since v" +
              t +
              " and will be removed in the near future",
          ),
        )),
      e ? e(s, o, a) : !0
    );
  };
};
function _$(n, e, t) {
  if (typeof n != "object")
    throw new $t("options must be an object", $t.ERR_BAD_OPTION_VALUE);
  const i = Object.keys(n);
  let r = i.length;
  for (; r-- > 0; ) {
    const s = i[r],
      o = e[s];
    if (o) {
      const a = n[s],
        l = a === void 0 || o(a, s, n);
      if (l !== !0)
        throw new $t("option " + s + " must be " + l, $t.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (t !== !0) throw new $t("Unknown option " + s, $t.ERR_BAD_OPTION);
  }
}
var qy = { assertOptions: _$, validators: vv };
const Ya = qy.validators;
class Um {
  constructor(e) {
    ((this.defaults = e),
      (this.interceptors = { request: new mx(), response: new mx() }));
  }
  request(e, t) {
    (typeof e == "string" ? ((t = t || {}), (t.url = e)) : (t = e || {}),
      (t = nd(this.defaults, t)));
    const { transitional: i, paramsSerializer: r, headers: s } = t;
    (i !== void 0 &&
      qy.assertOptions(
        i,
        {
          silentJSONParsing: Ya.transitional(Ya.boolean),
          forcedJSONParsing: Ya.transitional(Ya.boolean),
          clarifyTimeoutError: Ya.transitional(Ya.boolean),
        },
        !1,
      ),
      r != null &&
        (de.isFunction(r)
          ? (t.paramsSerializer = { serialize: r })
          : qy.assertOptions(
              r,
              { encode: Ya.function, serialize: Ya.function },
              !0,
            )),
      (t.method = (t.method || this.defaults.method || "get").toLowerCase()));
    let o = s && de.merge(s.common, s[t.method]);
    (s &&
      de.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (g) => {
          delete s[g];
        },
      ),
      (t.headers = wa.concat(o, s)));
    const a = [];
    let l = !0;
    this.interceptors.request.forEach(function (p) {
      (typeof p.runWhen == "function" && p.runWhen(t) === !1) ||
        ((l = l && p.synchronous), a.unshift(p.fulfilled, p.rejected));
    });
    const c = [];
    this.interceptors.response.forEach(function (p) {
      c.push(p.fulfilled, p.rejected);
    });
    let u,
      h = 0,
      d;
    if (!l) {
      const g = [yx.bind(this), void 0];
      for (
        g.unshift.apply(g, a),
          g.push.apply(g, c),
          d = g.length,
          u = Promise.resolve(t);
        h < d;
      )
        u = u.then(g[h++], g[h++]);
      return u;
    }
    d = a.length;
    let f = t;
    for (h = 0; h < d; ) {
      const g = a[h++],
        p = a[h++];
      try {
        f = g(f);
      } catch (m) {
        p.call(this, m);
        break;
      }
    }
    try {
      u = yx.call(this, f);
    } catch (g) {
      return Promise.reject(g);
    }
    for (h = 0, d = c.length; h < d; ) u = u.then(c[h++], c[h++]);
    return u;
  }
  getUri(e) {
    e = nd(this.defaults, e);
    const t = hL(e.baseURL, e.url);
    return oL(t, e.params, e.paramsSerializer);
  }
}
de.forEach(["delete", "get", "head", "options"], function (e) {
  Um.prototype[e] = function (t, i) {
    return this.request(
      nd(i || {}, { method: e, url: t, data: (i || {}).data }),
    );
  };
});
de.forEach(["post", "put", "patch"], function (e) {
  function t(i) {
    return function (s, o, a) {
      return this.request(
        nd(a || {}, {
          method: e,
          headers: i ? { "Content-Type": "multipart/form-data" } : {},
          url: s,
          data: o,
        }),
      );
    };
  }
  ((Um.prototype[e] = t()), (Um.prototype[e + "Form"] = t(!0)));
});
var G0 = Um;
class xv {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let t;
    this.promise = new Promise(function (s) {
      t = s;
    });
    const i = this;
    (this.promise.then((r) => {
      if (!i._listeners) return;
      let s = i._listeners.length;
      for (; s-- > 0; ) i._listeners[s](r);
      i._listeners = null;
    }),
      (this.promise.then = (r) => {
        let s;
        const o = new Promise((a) => {
          (i.subscribe(a), (s = a));
        }).then(r);
        return (
          (o.cancel = function () {
            i.unsubscribe(s);
          }),
          o
        );
      }),
      e(function (s, o, a) {
        i.reason || ((i.reason = new bp(s, o, a)), t(i.reason));
      }));
  }
  throwIfRequested() {
    if (this.reason) throw this.reason;
  }
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : (this._listeners = [e]);
  }
  unsubscribe(e) {
    if (!this._listeners) return;
    const t = this._listeners.indexOf(e);
    t !== -1 && this._listeners.splice(t, 1);
  }
  static source() {
    let e;
    return {
      token: new xv(function (r) {
        e = r;
      }),
      cancel: e,
    };
  }
}
var b$ = xv;
function v$(n) {
  return function (t) {
    return n.apply(null, t);
  };
}
function x$(n) {
  return de.isObject(n) && n.isAxiosError === !0;
}
const e_ = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};
Object.entries(e_).forEach(([n, e]) => {
  e_[e] = n;
});
var w$ = e_;
function gL(n) {
  const e = new G0(n),
    t = KM(G0.prototype.request, e);
  return (
    de.extend(t, G0.prototype, e, { allOwnKeys: !0 }),
    de.extend(t, e, null, { allOwnKeys: !0 }),
    (t.create = function (r) {
      return gL(nd(n, r));
    }),
    t
  );
}
const ai = gL(bv);
ai.Axios = G0;
ai.CanceledError = bp;
ai.CancelToken = b$;
ai.isCancel = uL;
ai.VERSION = fL;
ai.toFormData = QC;
ai.AxiosError = $t;
ai.Cancel = ai.CanceledError;
ai.all = function (e) {
  return Promise.all(e);
};
ai.spread = v$;
ai.isAxiosError = x$;
ai.mergeConfig = nd;
ai.AxiosHeaders = wa;
ai.formToJSON = (n) => cL(de.isHTMLForm(n) ? new FormData(n) : n);
ai.getAdapter = dL.getAdapter;
ai.HttpStatusCode = w$;
ai.default = ai;
var S$ = ai;
const T$ = "@sendgrid/client",
  E$ = "Twilio SendGrid NodeJS API client",
  M$ = "8.1.0",
  L$ = "Twilio SendGrid <help@twilio.com> (sendgrid.com)",
  R$ = [
    "Kyle Partridge <kyle.partridge@sendgrid.com>",
    "David Tomberlin <david.tomberlin@sendgrid.com>",
    "Swift <swift@sendgrid.com>",
    "Brandon West <brandon.west@sendgrid.com>",
    "Scott Motte <scott.motte@sendgrid.com>",
    "Robert Acosta <robert.acosta@sendgrid.com>",
    "Elmer Thomas <ethomas@twilio.com>",
    "Adam Reis <adam@reis.nz>",
  ],
  B$ = "MIT",
  P$ = "https://sendgrid.com",
  N$ = { type: "git", url: "git://github.com/sendgrid/sendgrid-nodejs.git" },
  D$ = { access: "public" },
  G$ = "index.js",
  F$ = { node: ">=12.*" },
  k$ = { "@sendgrid/helpers": "^8.0.0", axios: "^1.6.0" },
  O$ = { chai: "4.2.0", nock: "^10.0.6" },
  U$ = { chai: "4.2.0" },
  H$ = ["http", "rest", "api", "mail", "sendgrid"],
  W$ = "2d4d51214d63961d3138421c297790b479c12c26",
  V$ = {
    name: T$,
    description: E$,
    version: M$,
    author: L$,
    contributors: R$,
    license: B$,
    homepage: P$,
    repository: N$,
    publishConfig: D$,
    main: G$,
    engines: F$,
    dependencies: k$,
    devDependencies: O$,
    resolutions: U$,
    tags: H$,
    gitHead: W$,
  };
var wv = function n(e, t, i) {
    if (typeof e != "object" || e === null)
      throw new Error("Non object passed to convertKeys: " + e);
    if (Array.isArray(e)) return e;
    Array.isArray(i) || (i = []);
    for (const r in e)
      if (e.hasOwnProperty(r)) {
        const s = t(r);
        (typeof e[r] == "object" &&
          e[r] !== null &&
          !i.includes(r) &&
          !i.includes(s) &&
          (e[r] = n(e[r], t, i)),
          s !== r && ((e[s] = e[r]), delete e[r]));
      }
    return e;
  },
  Z$ = function (e) {
    if (typeof e != "string")
      throw new Error("String expected for conversion to snake case");
    return e
      .trim()
      .replace(/_+|\-+/g, " ")
      .replace(/(?:^\w|[A-Z]|\b\w|\s+)/g, function (t, i) {
        return Number(t) === 0
          ? ""
          : i === 0
            ? t.toLowerCase()
            : t.toUpperCase();
      });
  };
const z$ = wv,
  Y$ = Z$;
var vp = function (e, t) {
    return z$(e, Y$, t);
  },
  X$ = function (e) {
    if (typeof e != "string")
      throw new Error("String expected for conversion to snake case");
    return e
      .trim()
      .replace(/(\s*\-*\b\w|[A-Z])/g, function (t) {
        return (
          (t = t.trim().toLowerCase().replace("-", "")),
          (t[0] === "_" ? "" : "_") + t
        );
      })
      .slice(1);
  };
const K$ = wv,
  j$ = X$;
var eI = function (e, t) {
    return K$(e, j$, t);
  },
  xp = function (e) {
    return JSON.parse(JSON.stringify(e));
  };
const $$ = {},
  J$ = Object.freeze(
    Object.defineProperty(
      { __proto__: null, default: $$ },
      Symbol.toStringTag,
      { value: "Module" },
    ),
  ),
  Sv = Xz(J$),
  Q$ = vp,
  q$ = eI,
  eJ = xp,
  tJ = Sv,
  nJ = Sv;
let iJ = class {
  constructor(e) {
    e && this.fromData(e);
  }
  fromData(e) {
    if (typeof e != "object") throw new Error("Expecting object for Mail data");
    ((e = eJ(e)), (e = Q$(e)));
    const {
      content: t,
      filename: i,
      type: r,
      disposition: s,
      contentId: o,
      filePath: a,
    } = e;
    if (typeof t < "u" && typeof a < "u")
      throw new Error(
        "The props 'content' and 'filePath' cannot be used together.",
      );
    (this.setFilename(i),
      this.setType(r),
      this.setDisposition(s),
      this.setContentId(o),
      this.setContent(a ? this.readFile(a) : t));
  }
  readFile(e) {
    return tJ.readFileSync(nJ.resolve(e));
  }
  setContent(e) {
    if (typeof e == "string") {
      this.content = e;
      return;
    } else if (e instanceof Buffer && e.toString !== void 0) {
      ((this.content = e.toString()),
        this.disposition === "attachment" &&
          (this.content = e.toString("base64")));
      return;
    }
    throw new Error("`content` expected to be either Buffer or string");
  }
  setFileContent(e) {
    if (e instanceof Buffer && e.toString !== void 0) {
      this.content = e.toString("base64");
      return;
    }
    throw new Error("`content` expected to be Buffer");
  }
  setFilename(e) {
    if (!(typeof e > "u")) {
      if (e && typeof e != "string")
        throw new Error("String expected for `filename`");
      this.filename = e;
    }
  }
  setType(e) {
    if (!(typeof e > "u")) {
      if (typeof e != "string") throw new Error("String expected for `type`");
      this.type = e;
    }
  }
  setDisposition(e) {
    if (!(typeof e > "u")) {
      if (typeof e != "string")
        throw new Error("String expected for `disposition`");
      this.disposition = e;
    }
  }
  setContentId(e) {
    if (!(typeof e > "u")) {
      if (typeof e != "string")
        throw new Error("String expected for `contentId`");
      this.contentId = e;
    }
  }
  toJSON() {
    const {
        content: e,
        filename: t,
        type: i,
        disposition: r,
        contentId: s,
      } = this,
      o = { content: e, filename: t };
    return (
      typeof i < "u" && (o.type = i),
      typeof r < "u" && (o.disposition = r),
      typeof s < "u" && (o.contentId = s),
      q$(o)
    );
  }
};
var rJ = iJ,
  pL = function (e) {
    if (e.indexOf("<") === -1) return ["", e];
    let [t, i] = e.split("<");
    return ((t = t.trim()), (i = i.replace(">", "").trim()), [t, i]);
  };
const sJ = pL;
let oJ = class t_ {
  constructor(e) {
    e && this.fromData(e);
  }
  fromData(e) {
    if (typeof e == "string") {
      const [r, s] = sJ(e);
      e = { name: r, email: s };
    }
    if (typeof e != "object")
      throw new Error("Expecting object or string for EmailAddress data");
    const { name: t, email: i } = e;
    (this.setEmail(i), this.setName(t));
  }
  setName(e) {
    if (!(typeof e > "u")) {
      if (typeof e != "string") throw new Error("String expected for `name`");
      this.name = e;
    }
  }
  setEmail(e) {
    if (typeof e > "u") throw new Error("Must provide `email`");
    if (typeof e != "string") throw new Error("String expected for `email`");
    this.email = e;
  }
  toJSON() {
    const { email: e, name: t } = this,
      i = { email: e };
    return (t !== "" && (i.name = t), i);
  }
  static create(e) {
    return Array.isArray(e)
      ? e.filter((t) => !!t).map((t) => this.create(t))
      : e instanceof t_
        ? e
        : new t_(e);
  }
};
var Tv = oJ,
  aJ = function (e) {
    return lJ(e) && !cJ(e);
  };
function lJ(n) {
  return !!n && typeof n == "object";
}
function cJ(n) {
  var e = Object.prototype.toString.call(n);
  return e === "[object RegExp]" || e === "[object Date]" || dJ(n);
}
var uJ = typeof Symbol == "function" && Symbol.for,
  hJ = uJ ? Symbol.for("react.element") : 60103;
function dJ(n) {
  return n.$$typeof === hJ;
}
function fJ(n) {
  return Array.isArray(n) ? [] : {};
}
function Mg(n, e) {
  return e.clone !== !1 && e.isMergeableObject(n) ? id(fJ(n), n, e) : n;
}
function gJ(n, e, t) {
  return n.concat(e).map(function (i) {
    return Mg(i, t);
  });
}
function pJ(n, e) {
  if (!e.customMerge) return id;
  var t = e.customMerge(n);
  return typeof t == "function" ? t : id;
}
function mJ(n) {
  return Object.getOwnPropertySymbols
    ? Object.getOwnPropertySymbols(n).filter(function (e) {
        return Object.propertyIsEnumerable.call(n, e);
      })
    : [];
}
function vx(n) {
  return Object.keys(n).concat(mJ(n));
}
function mL(n, e) {
  try {
    return e in n;
  } catch {
    return !1;
  }
}
function CJ(n, e) {
  return (
    mL(n, e) &&
    !(
      Object.hasOwnProperty.call(n, e) && Object.propertyIsEnumerable.call(n, e)
    )
  );
}
function IJ(n, e, t) {
  var i = {};
  return (
    t.isMergeableObject(n) &&
      vx(n).forEach(function (r) {
        i[r] = Mg(n[r], t);
      }),
    vx(e).forEach(function (r) {
      CJ(n, r) ||
        (mL(n, r) && t.isMergeableObject(e[r])
          ? (i[r] = pJ(r, t)(n[r], e[r], t))
          : (i[r] = Mg(e[r], t)));
    }),
    i
  );
}
function id(n, e, t) {
  ((t = t || {}),
    (t.arrayMerge = t.arrayMerge || gJ),
    (t.isMergeableObject = t.isMergeableObject || aJ),
    (t.cloneUnlessOtherwiseSpecified = Mg));
  var i = Array.isArray(e),
    r = Array.isArray(n),
    s = i === r;
  return s ? (i ? t.arrayMerge(n, e, t) : IJ(n, e, t)) : Mg(e, t);
}
id.all = function (e, t) {
  if (!Array.isArray(e)) throw new Error("first argument should be an array");
  return e.reduce(function (i, r) {
    return id(i, r, t);
  }, {});
};
var AJ = id,
  yJ = AJ,
  CL = function n(e, t = "{{", i = "}}") {
    if (Array.isArray(e)) return e.map((s) => n(s, t, i));
    const r = {};
    for (const s in e) e.hasOwnProperty(s) && (r[t + s + i] = String(e[s]));
    return r;
  };
const nc = Tv,
  _J = vp,
  bJ = eI,
  vJ = xp,
  xJ = yJ,
  wJ = CL;
let SJ = class {
  constructor(e) {
    ((this.to = []),
      (this.cc = []),
      (this.bcc = []),
      (this.headers = {}),
      (this.customArgs = {}),
      (this.substitutions = {}),
      (this.substitutionWrappers = ["{{", "}}"]),
      (this.dynamicTemplateData = {}),
      e && this.fromData(e));
  }
  fromData(e) {
    if (typeof e != "object") throw new Error("Expecting object for Mail data");
    ((e = vJ(e)),
      (e = _J(e, [
        "substitutions",
        "dynamicTemplateData",
        "customArgs",
        "headers",
      ])));
    const {
      to: t,
      from: i,
      cc: r,
      bcc: s,
      subject: o,
      headers: a,
      customArgs: l,
      sendAt: c,
      substitutions: u,
      substitutionWrappers: h,
      dynamicTemplateData: d,
    } = e;
    (this.setTo(t),
      this.setFrom(i),
      this.setCc(r),
      this.setBcc(s),
      this.setSubject(o),
      this.setHeaders(a),
      this.setSubstitutions(u),
      this.setSubstitutionWrappers(h),
      this.setCustomArgs(l),
      this.setDynamicTemplateData(d),
      this.setSendAt(c));
  }
  setSubject(e) {
    if (!(typeof e > "u")) {
      if (typeof e != "string")
        throw new Error("String expected for `subject`");
      this.subject = e;
    }
  }
  setSendAt(e) {
    if (!(typeof e > "u")) {
      if (!Number.isInteger(e))
        throw new Error("Integer expected for `sendAt`");
      this.sendAt = e;
    }
  }
  setTo(e) {
    typeof e > "u" || (Array.isArray(e) || (e = [e]), (this.to = nc.create(e)));
  }
  setFrom(e) {
    typeof e > "u" || (this.from = nc.create(e));
  }
  addTo(e) {
    typeof e > "u" || this.to.push(nc.create(e));
  }
  setCc(e) {
    typeof e > "u" || (Array.isArray(e) || (e = [e]), (this.cc = nc.create(e)));
  }
  addCc(e) {
    typeof e > "u" || this.cc.push(nc.create(e));
  }
  setBcc(e) {
    typeof e > "u" ||
      (Array.isArray(e) || (e = [e]), (this.bcc = nc.create(e)));
  }
  addBcc(e) {
    typeof e > "u" || this.bcc.push(nc.create(e));
  }
  setHeaders(e) {
    if (!(typeof e > "u")) {
      if (typeof e != "object" || e === null)
        throw new Error("Object expected for `headers`");
      this.headers = e;
    }
  }
  addHeader(e, t) {
    if (typeof e != "string") throw new Error("String expected for header key");
    if (typeof t != "string")
      throw new Error("String expected for header value");
    this.headers[e] = t;
  }
  setCustomArgs(e) {
    if (!(typeof e > "u")) {
      if (typeof e != "object" || e === null)
        throw new Error("Object expected for `customArgs`");
      this.customArgs = e;
    }
  }
  addCustomArg(e, t) {
    if (typeof e != "string")
      throw new Error("String expected for custom arg key");
    if (typeof t != "string")
      throw new Error("String expected for custom arg value");
    this.customArgs[e] = t;
  }
  setSubstitutions(e) {
    if (!(typeof e > "u")) {
      if (typeof e != "object")
        throw new Error("Object expected for `substitutions`");
      this.substitutions = e;
    }
  }
  addSubstitution(e, t) {
    if (typeof e != "string")
      throw new Error("String expected for substitution key");
    if (typeof t != "string" && typeof t != "number")
      throw new Error("String or Number expected for substitution value");
    this.substitutions[e] = t;
  }
  reverseMergeSubstitutions(e) {
    if (!(typeof e > "u" || e === null)) {
      if (typeof e != "object")
        throw new Error(
          "Object expected for `substitutions` in reverseMergeSubstitutions",
        );
      this.substitutions = Object.assign({}, e, this.substitutions);
    }
  }
  setSubstitutionWrappers(e) {
    if (!(typeof e > "u" || e === null)) {
      if (!Array.isArray(e) || e.length !== 2)
        throw new Error(
          "Array expected with two elements for `substitutionWrappers`",
        );
      this.substitutionWrappers = e;
    }
  }
  deepMergeDynamicTemplateData(e) {
    if (!(typeof e > "u" || e === null)) {
      if (typeof e != "object")
        throw new Error(
          "Object expected for `dynamicTemplateData` in deepMergeDynamicTemplateData",
        );
      this.dynamicTemplateData = xJ(e, this.dynamicTemplateData);
    }
  }
  setDynamicTemplateData(e) {
    if (!(typeof e > "u")) {
      if (typeof e != "object")
        throw new Error("Object expected for `dynamicTemplateData`");
      this.dynamicTemplateData = e;
    }
  }
  toJSON() {
    const {
        to: e,
        from: t,
        cc: i,
        bcc: r,
        subject: s,
        headers: o,
        customArgs: a,
        sendAt: l,
        substitutions: c,
        substitutionWrappers: u,
        dynamicTemplateData: h,
      } = this,
      d = { to: e };
    if (
      (Array.isArray(i) && i.length > 0 && (d.cc = i),
      Array.isArray(r) && r.length > 0 && (d.bcc = r),
      Object.keys(o).length > 0 && (d.headers = o),
      c && Object.keys(c).length > 0)
    ) {
      const [f, g] = u;
      d.substitutions = wJ(c, f, g);
    }
    return (
      Object.keys(a).length > 0 && (d.customArgs = a),
      h && Object.keys(h).length > 0 && (d.dynamicTemplateData = h),
      typeof s < "u" && (d.subject = s),
      typeof l < "u" && (d.sendAt = l),
      typeof t < "u" && (d.from = t),
      bJ(d, ["substitutions", "dynamicTemplateData", "customArgs", "headers"])
    );
  }
};
var IL = SJ,
  AL = function (e) {
    return e.map((t) =>
      typeof t == "object" && t !== null && typeof t.toJSON == "function"
        ? t.toJSON()
        : t,
    );
  };
const TJ = `
Content with characters ', " or & may need to be escaped with three brackets
{{{ content }}}
See https://sendgrid.com/docs/for-developers/sending-email/using-handlebars/ for more information.`;
var EJ = { DYNAMIC_TEMPLATE_CHAR_WARNING: TJ };
const bn = (n, e, t, i) => {
  if (!(typeof n > "u" || typeof n[t] > "u") && typeof n[t] !== i)
    throw new Error(`${i} expected for \`${e}.${t}\``);
};
var MJ = {
  validateMailSettings(n) {
    if (typeof n != "object")
      throw new Error("Object expected for `mailSettings`");
    const {
      bcc: e,
      bypassListManagement: t,
      bypassSpamManagement: i,
      bypassBounceManagement: r,
      bypassUnsubscribeManagement: s,
      footer: o,
      sandboxMode: a,
      spamCheck: l,
    } = n;
    (bn(e, "bcc", "enable", "boolean"),
      bn(e, "bcc", "email", "string"),
      bn(t, "bypassListManagement", "enable", "boolean"),
      bn(i, "bypassSpamManagement", "enable", "boolean"),
      bn(r, "bypassBounceManagement", "enable", "boolean"),
      bn(s, "bypassUnsubscribeManagement", "enable", "boolean"),
      bn(o, "footer", "enable", "boolean"),
      bn(o, "footer", "text", "string"),
      bn(o, "footer", "html", "string"),
      bn(a, "sandboxMode", "enable", "boolean"),
      bn(l, "spamCheck", "enable", "boolean"),
      bn(l, "spamCheck", "threshold", "number"),
      bn(l, "spamCheck", "postToUrl", "string"));
  },
  validateTrackingSettings(n) {
    if (typeof n != "object")
      throw new Error("Object expected for `trackingSettings`");
    const {
      clickTracking: e,
      openTracking: t,
      subscriptionTracking: i,
      ganalytics: r,
    } = n;
    (bn(e, "clickTracking", "enable", "boolean"),
      bn(e, "clickTracking", "enableText", "boolean"),
      bn(t, "openTracking", "enable", "boolean"),
      bn(t, "openTracking", "substitutionTag", "string"),
      bn(i, "subscriptionTracking", "enable", "boolean"),
      bn(i, "subscriptionTracking", "text", "string"),
      bn(i, "subscriptionTracking", "html", "string"),
      bn(i, "subscriptionTracking", "substitutionTag", "string"),
      bn(r, "ganalytics", "enable", "boolean"),
      bn(r, "ganalytics", "utm_source", "string"),
      bn(r, "ganalytics", "utm_medium", "string"),
      bn(r, "ganalytics", "utm_term", "string"),
      bn(r, "ganalytics", "utm_content", "string"),
      bn(r, "ganalytics", "utm_campaign", "string"));
  },
};
const xx = Tv,
  lf = IL,
  LJ = vp,
  RJ = eI,
  BJ = xp,
  h2 = AL,
  { DYNAMIC_TEMPLATE_CHAR_WARNING: PJ } = EJ,
  { validateMailSettings: NJ, validateTrackingSettings: DJ } = MJ;
let GJ = class n_ {
  constructor(e) {
    ((this.isDynamic = !1),
      (this.hideWarnings = !1),
      (this.personalizations = []),
      (this.attachments = []),
      (this.content = []),
      (this.categories = []),
      (this.headers = {}),
      (this.sections = {}),
      (this.customArgs = {}),
      (this.trackingSettings = {}),
      (this.mailSettings = {}),
      (this.asm = {}),
      (this.substitutions = null),
      (this.substitutionWrappers = null),
      (this.dynamicTemplateData = null),
      e && this.fromData(e));
  }
  fromData(e) {
    if (typeof e != "object") throw new Error("Expecting object for Mail data");
    ((e = BJ(e)),
      (e = LJ(e, [
        "substitutions",
        "dynamicTemplateData",
        "customArgs",
        "headers",
        "sections",
      ])));
    const {
      to: t,
      from: i,
      replyTo: r,
      cc: s,
      bcc: o,
      sendAt: a,
      subject: l,
      text: c,
      html: u,
      content: h,
      templateId: d,
      personalizations: f,
      attachments: g,
      ipPoolName: p,
      batchId: m,
      sections: C,
      headers: A,
      categories: I,
      category: y,
      customArgs: x,
      asm: T,
      mailSettings: S,
      trackingSettings: E,
      substitutions: _,
      substitutionWrappers: b,
      dynamicTemplateData: R,
      isMultiple: M,
      hideWarnings: L,
      replyToList: P,
    } = e;
    (this.setFrom(i),
      this.setReplyTo(r),
      this.setSubject(l),
      this.setSendAt(a),
      this.setTemplateId(d),
      this.setBatchId(m),
      this.setIpPoolName(p),
      this.setAttachments(g),
      this.setContent(h),
      this.setSections(C),
      this.setHeaders(A),
      this.setCategories(y),
      this.setCategories(I),
      this.setCustomArgs(x),
      this.setAsm(T),
      this.setMailSettings(S),
      this.setTrackingSettings(E),
      this.setHideWarnings(L),
      this.setReplyToList(P),
      this.isDynamic
        ? this.setDynamicTemplateData(R)
        : (this.setSubstitutions(_), this.setSubstitutionWrappers(b)),
      this.addTextContent(c),
      this.addHtmlContent(u),
      f
        ? this.setPersonalizations(f)
        : M && Array.isArray(t)
          ? t.forEach((U) => this.addTo(U, s, o))
          : this.addTo(t, s, o));
  }
  setFrom(e) {
    if (this._checkProperty("from", e, [this._checkUndefined])) {
      if (typeof e != "string" && typeof e.email != "string")
        throw new Error("String or address object expected for `from`");
      this.from = xx.create(e);
    }
  }
  setReplyTo(e) {
    if (this._checkProperty("replyTo", e, [this._checkUndefined])) {
      if (typeof e != "string" && typeof e.email != "string")
        throw new Error("String or address object expected for `replyTo`");
      this.replyTo = xx.create(e);
    }
  }
  setSubject(e) {
    this._setProperty("subject", e, "string");
  }
  setSendAt(e) {
    this._checkProperty("sendAt", e, [
      this._checkUndefined,
      this._createCheckThatThrows(
        Number.isInteger,
        "Integer expected for `sendAt`",
      ),
    ]) && (this.sendAt = e);
  }
  setTemplateId(e) {
    this._setProperty("templateId", e, "string") &&
      e.indexOf("d-") === 0 &&
      (this.isDynamic = !0);
  }
  setBatchId(e) {
    this._setProperty("batchId", e, "string");
  }
  setIpPoolName(e) {
    this._setProperty("ipPoolName", e, "string");
  }
  setAsm(e) {
    if (
      this._checkProperty("asm", e, [
        this._checkUndefined,
        this._createTypeCheck("object"),
      ])
    ) {
      if (typeof e.groupId != "number")
        throw new Error(
          "Expected `asm` to include an integer in its `groupId` field",
        );
      if (
        e.groupsToDisplay &&
        (!Array.isArray(e.groupsToDisplay) ||
          !e.groupsToDisplay.every((t) => typeof t == "number"))
      )
        throw new Error("Array of integers expected for `asm.groupsToDisplay`");
      this.asm = e;
    }
  }
  setPersonalizations(e) {
    if (this._doArrayCheck("personalizations", e)) {
      if (!e.every((t) => typeof t == "object"))
        throw new Error("Array of objects expected for `personalizations`");
      ((this.personalizations = []),
        e.forEach((t) => this.addPersonalization(t)));
    }
  }
  addPersonalization(e) {
    (this.isDynamic && e.substitutions
      ? delete e.substitutions
      : !this.isDynamic &&
        e.dynamicTemplateData &&
        delete e.dynamicTemplateData,
      e instanceof lf || (e = new lf(e)),
      this.isDynamic
        ? this.applyDynamicTemplateData(e)
        : this.applySubstitutions(e),
      this.personalizations.push(e));
  }
  addTo(e, t, i) {
    if (typeof e > "u" && typeof t > "u" && typeof i > "u")
      throw new Error("Provide at least one of to, cc or bcc");
    this.addPersonalization(new lf({ to: e, cc: t, bcc: i }));
  }
  setSubstitutions(e) {
    this._setProperty("substitutions", e, "object");
  }
  setSubstitutionWrappers(e) {
    let t = (i, r) => {
      if (!Array.isArray(r) || r.length !== 2)
        throw new Error("Array expected with two elements for `" + i + "`");
    };
    this._checkProperty("substitutionWrappers", e, [this._checkUndefined, t]) &&
      (this.substitutionWrappers = e);
  }
  applySubstitutions(e) {
    e instanceof lf &&
      (e.reverseMergeSubstitutions(this.substitutions),
      e.setSubstitutionWrappers(this.substitutionWrappers));
  }
  applyDynamicTemplateData(e) {
    e instanceof lf && e.deepMergeDynamicTemplateData(this.dynamicTemplateData);
  }
  setDynamicTemplateData(e) {
    if (!(typeof e > "u")) {
      if (typeof e != "object")
        throw new Error("Object expected for `dynamicTemplateData`");
      (this.hideWarnings ||
        Object.values(e).forEach((t) => {
          /['"&]/.test(t) && console.warn(PJ);
        }),
        (this.dynamicTemplateData = e));
    }
  }
  setContent(e) {
    if (this._doArrayCheck("content", e)) {
      if (!e.every((t) => typeof t == "object"))
        throw new Error("Expected each entry in `content` to be an object");
      if (!e.every((t) => typeof t.type == "string"))
        throw new Error(
          "Expected each `content` entry to contain a `type` string",
        );
      if (!e.every((t) => typeof t.value == "string"))
        throw new Error(
          "Expected each `content` entry to contain a `value` string",
        );
      this.content = e;
    }
  }
  addContent(e) {
    this._checkProperty("content", e, [this._createTypeCheck("object")]) &&
      this.content.push(e);
  }
  addTextContent(e) {
    this._checkProperty("text", e, [
      this._checkUndefined,
      this._createTypeCheck("string"),
    ]) && this.addContent({ value: e, type: "text/plain" });
  }
  addHtmlContent(e) {
    this._checkProperty("html", e, [
      this._checkUndefined,
      this._createTypeCheck("string"),
    ]) && this.addContent({ value: e, type: "text/html" });
  }
  setAttachments(e) {
    if (this._doArrayCheck("attachments", e)) {
      if (!e.every((t) => typeof t.content == "string"))
        throw new Error(
          "Expected each attachment to contain a `content` string",
        );
      if (!e.every((t) => typeof t.filename == "string"))
        throw new Error(
          "Expected each attachment to contain a `filename` string",
        );
      if (!e.every((t) => !t.type || typeof t.type == "string"))
        throw new Error(
          "Expected the attachment's `type` field to be a string",
        );
      if (!e.every((t) => !t.disposition || typeof t.disposition == "string"))
        throw new Error(
          "Expected the attachment's `disposition` field to be a string",
        );
      this.attachments = e;
    }
  }
  addAttachment(e) {
    this._checkProperty("attachment", e, [
      this._checkUndefined,
      this._createTypeCheck("object"),
    ]) && this.attachments.push(e);
  }
  setCategories(e) {
    let t = (i, r) => {
      if (!Array.isArray(r) || !r.every((s) => typeof s == "string"))
        throw new Error("Array of strings expected for `" + i + "`");
    };
    (typeof e == "string" && (e = [e]),
      this._checkProperty("categories", e, [this._checkUndefined, t]) &&
        (this.categories = e));
  }
  addCategory(e) {
    this._checkProperty("category", e, [this._createTypeCheck("string")]) &&
      this.categories.push(e);
  }
  setHeaders(e) {
    this._setProperty("headers", e, "object");
  }
  addHeader(e, t) {
    this._checkProperty("key", e, [this._createTypeCheck("string")]) &&
      this._checkProperty("value", t, [this._createTypeCheck("string")]) &&
      (this.headers[e] = t);
  }
  setSections(e) {
    this._setProperty("sections", e, "object");
  }
  setCustomArgs(e) {
    this._setProperty("customArgs", e, "object");
  }
  setTrackingSettings(e) {
    typeof e > "u" || (DJ(e), (this.trackingSettings = e));
  }
  setMailSettings(e) {
    typeof e > "u" || (NJ(e), (this.mailSettings = e));
  }
  setHideWarnings(e) {
    if (!(typeof e > "u")) {
      if (typeof e != "boolean")
        throw new Error("Boolean expected for `hideWarnings`");
      this.hideWarnings = e;
    }
  }
  toJSON() {
    const {
        from: e,
        replyTo: t,
        sendAt: i,
        subject: r,
        content: s,
        templateId: o,
        personalizations: a,
        attachments: l,
        ipPoolName: c,
        batchId: u,
        asm: h,
        sections: d,
        headers: f,
        categories: g,
        customArgs: p,
        mailSettings: m,
        trackingSettings: C,
        replyToList: A,
      } = this,
      I = { from: e, subject: r, personalizations: h2(a) };
    return (
      Array.isArray(l) && l.length > 0 && (I.attachments = h2(l)),
      Array.isArray(g) &&
        g.length > 0 &&
        (I.categories = g.filter((y) => y !== "")),
      Array.isArray(s) && s.length > 0 && (I.content = h2(s)),
      Object.keys(f).length > 0 && (I.headers = f),
      Object.keys(m).length > 0 && (I.mailSettings = m),
      Object.keys(C).length > 0 && (I.trackingSettings = C),
      Object.keys(p).length > 0 && (I.customArgs = p),
      Object.keys(d).length > 0 && (I.sections = d),
      Object.keys(h).length > 0 && (I.asm = h),
      typeof t < "u" && (I.replyTo = t),
      typeof i < "u" && (I.sendAt = i),
      typeof u < "u" && (I.batchId = u),
      typeof o < "u" && (I.templateId = o),
      typeof c < "u" && (I.ipPoolName = c),
      typeof A < "u" && (I.replyToList = A),
      RJ(I, [
        "substitutions",
        "dynamicTemplateData",
        "customArgs",
        "headers",
        "sections",
      ])
    );
  }
  static create(e) {
    return Array.isArray(e)
      ? e.filter((t) => !!t).map((t) => this.create(t))
      : e instanceof n_
        ? e
        : new n_(e);
  }
  _checkProperty(e, t, i) {
    return !i.some((r) => r(e, t));
  }
  _setProperty(e, t, i) {
    let r = this._checkProperty(e, t, [
      this._checkUndefined,
      this._createTypeCheck(i),
    ]);
    return (r && (this[e] = t), r);
  }
  _checkUndefined(e, t) {
    return typeof t > "u";
  }
  _createTypeCheck(e) {
    return (t, i) => {
      if (typeof i !== e) throw new Error(e + " expected for `" + t + "`");
    };
  }
  _createCheckThatThrows(e, t) {
    return (i, r) => {
      if (!e(r)) throw new Error(t);
    };
  }
  _setArrayProperty(e, t) {
    this._doArrayCheck(e, t) && (this[e] = t);
  }
  _doArrayCheck(e, t) {
    return this._checkProperty(e, t, [
      this._checkUndefined,
      this._createCheckThatThrows(
        Array.isArray,
        "Array expected for`" + e + "`",
      ),
    ]);
  }
  setReplyToList(e) {
    if (this._doArrayCheck("replyToList", e) && e.length) {
      if (!e.every((t) => t && typeof t.email == "string"))
        throw new Error("Expected each replyTo to contain an `email` string");
      this.replyToList = e;
    }
  }
};
var FJ = GJ;
let kJ = class {
  constructor(e, t, i) {
    ((this.statusCode = e), (this.body = t), (this.headers = i));
  }
  toString() {
    return "HTTP " + this.statusCode + " " + this.body;
  }
};
var OJ = kJ;
let UJ = class extends Error {
  constructor(e) {
    super();
    const { headers: t, status: i, statusText: r, data: s } = e;
    ((this.code = i),
      (this.message = r),
      (this.response = { headers: t, body: s }),
      this.stack || Error.captureStackTrace(this, this.constructor));
    const o = new RegExp(process.cwd() + "/", "gi");
    this.stack = this.stack.replace(o, "");
  }
  toString() {
    const { body: e } = this.response;
    let t = `${this.message} (${this.code})`;
    return (
      e &&
        Array.isArray(e.errors) &&
        e.errors.forEach((i) => {
          const r = i.message,
            s = i.field,
            o = i.help;
          t += `
  ${r}
    ${s}
    ${o}`;
        }),
      t
    );
  }
  toJSON() {
    const { message: e, code: t, response: i } = this;
    return { message: e, code: t, response: i };
  }
};
var HJ = UJ;
const WJ = vp,
  VJ = xp,
  ZJ = ["day", "week", "month"],
  zJ = ["us", "ca"],
  Qp = ["desc", "asc"];
let YJ = class {
  constructor(e) {
    ((this.startDate = null),
      (this.endDate = null),
      (this.aggregatedBy = null),
      e && this.fromData(e));
  }
  fromData(e) {
    if (typeof e != "object")
      throw new Error("Expecting object for Statistics data");
    ((e = VJ(e)), (e = WJ(e, ["substitutions", "customArgs"])));
    const { startDate: t, endDate: i, aggregatedBy: r } = e;
    (this.setStartDate(t), this.setEndDate(i), this.setAggregatedBy(r));
  }
  setStartDate(e) {
    if (typeof e > "u") throw new Error("Date expected for `startDate`");
    if (new Date(e) === "Invalid Date" || isNaN(new Date(e)))
      throw new Error("Date expected for `startDate`");
    (console.log(e), (this.startDate = new Date(e).toISOString().slice(0, 10)));
  }
  setEndDate(e) {
    if (typeof e > "u") {
      this.endDate = new Date().toISOString().slice(0, 10);
      return;
    }
    if (new Date(e) === "Invalid Date" || isNaN(new Date(e)))
      throw new Error("Date expected for `endDate`");
    this.endDate = new Date(e).toISOString().slice(0, 10);
  }
  setAggregatedBy(e) {
    if (!(typeof e > "u"))
      if (typeof e == "string" && ZJ.includes(e.toLowerCase()))
        this.aggregatedBy = e;
      else throw new Error("Incorrect value for `aggregatedBy`");
  }
  getGlobal() {
    const { startDate: e, endDate: t, aggregatedBy: i } = this;
    return { startDate: e, endDate: t, aggregatedBy: i };
  }
  getAdvanced(e) {
    const t = this.getGlobal();
    return (
      typeof e > "u" ||
        (typeof e == "string" &&
          zJ.includes(e.toLowerCase()) &&
          (t.country = e)),
      t
    );
  }
  getAdvancedMailboxProviders(e) {
    const t = this.getGlobal();
    if (typeof e > "u") return t;
    if (Array.isArray(e) && e.some((i) => typeof i != "string"))
      throw new Error("Array of strings expected for `mailboxProviders`");
    return ((t.mailBoxProviders = e), t);
  }
  getAdvancedBrowsers(e) {
    const t = this.getGlobal();
    if (typeof e > "u") return t;
    if (Array.isArray(e) && e.some((i) => typeof i != "string"))
      throw new Error("Array of strings expected for `browsers`");
    return ((t.browsers = e), t);
  }
  getCategories(e) {
    if (typeof e > "u")
      throw new Error("Array of strings expected for `categories`");
    if (!this._isValidArrayOfStrings(e))
      throw new Error("Array of strings expected for `categories`");
    const t = this.getGlobal();
    return ((t.categories = e), t);
  }
  getSubuser(e) {
    if (typeof e > "u")
      throw new Error("Array of strings expected for `subusers`");
    if (!this._isValidArrayOfStrings(e))
      throw new Error("Array of strings expected for `subusers`");
    const t = this.getGlobal();
    return ((t.subusers = e), t);
  }
  getSubuserSum(e = "delivered", t = Qp[0], i = 5, r = 0) {
    if (typeof e != "string")
      throw new Error("string expected for `sortByMetric`");
    if (!Qp.includes(t.toLowerCase()))
      throw new Error("desc or asc expected for `sortByDirection`");
    if (typeof i != "number") throw new Error("number expected for `limit`");
    if (typeof r != "number") throw new Error("number expected for `offset`");
    const s = this.getGlobal();
    return (
      (s.sortByMetric = e),
      (s.sortByDirection = t),
      (s.limit = i),
      (s.offset = r),
      s
    );
  }
  getSubuserMonthly(e = "delivered", t = Qp[0], i = 5, r = 0) {
    if (typeof e != "string")
      throw new Error("string expected for `sortByMetric`");
    if (!Qp.includes(t.toLowerCase()))
      throw new Error("desc or asc expected for `sortByDirection`");
    if (typeof i != "number") throw new Error("number expected for `limit`");
    if (typeof r != "number") throw new Error("number expected for `offset`");
    const s = this.getGlobal();
    return (
      (s.sortByMetric = e),
      (s.sortByDirection = t),
      (s.limit = i),
      (s.offset = r),
      s
    );
  }
  _isValidArrayOfStrings(e) {
    return !(
      !Array.isArray(e) ||
      e.length < 1 ||
      e.some((t) => typeof t != "string")
    );
  }
};
var XJ = YJ;
const KJ = rJ,
  jJ = Tv,
  $J = FJ,
  JJ = IL,
  QJ = OJ,
  qJ = HJ,
  eQ = XJ;
var tQ = {
    Attachment: KJ,
    EmailAddress: jJ,
    Mail: $J,
    Personalization: JJ,
    Response: QJ,
    ResponseError: qJ,
    Statistics: eQ,
  },
  nQ = function (e, t) {
    if (typeof e != "object" || e === null)
      throw new Error("Not an object provided for base");
    if (typeof t != "object" || t === null)
      throw new Error("Not an object provided for data");
    const i = Object.assign({}, e);
    for (const r in t)
      t.hasOwnProperty(r) &&
        (t[r] && Array.isArray(t[r])
          ? (i[r] = t[r])
          : t[r] && typeof t[r] == "object"
            ? (i[r] = Object.assign({}, t[r]))
            : t[r] && (i[r] = t[r]));
    return i;
  };
const iQ = AL,
  rQ = wv,
  sQ = xp,
  oQ = nQ,
  aQ = pL,
  lQ = vp,
  cQ = eI,
  uQ = CL;
var hQ = {
  arrayToJSON: iQ,
  convertKeys: rQ,
  deepClone: sQ,
  mergeData: oQ,
  splitNameEmail: aQ,
  toCamelCase: lQ,
  toSnakeCase: cQ,
  wrapSubstitutions: uQ,
};
const dQ = tQ,
  fQ = hQ;
var yL = { classes: dQ, helpers: fQ };
const gQ = S$,
  pQ = V$,
  {
    helpers: { mergeData: wx },
    classes: { Response: mQ, ResponseError: CQ },
  } = yL,
  Sx = "SG.",
  IQ = "https://api.sendgrid.com/",
  AQ = "https://email.twilio.com/",
  yQ = "global",
  d2 = {
    eu: "https://api.eu.sendgrid.com/",
    global: "https://api.sendgrid.com/",
  };
let _Q = class {
  constructor() {
    ((this.auth = ""),
      (this.impersonateSubuser = ""),
      (this.sendgrid_region = yQ),
      (this.defaultHeaders = {
        Accept: "application/json",
        "Content-Type": "application/json",
        "User-Agent": "sendgrid/" + pQ.version + ";nodejs",
      }),
      (this.defaultRequest = {
        baseUrl: IQ,
        url: "",
        method: "GET",
        headers: {},
        maxContentLength: 1 / 0,
        maxBodyLength: 1 / 0,
      }));
  }
  setApiKey(e) {
    ((this.auth = "Bearer " + e),
      this.setDefaultRequest("baseUrl", d2[this.sendgrid_region]),
      this.isValidApiKey(e) ||
        console.warn(`API key does not start with "${Sx}".`));
  }
  setTwilioEmailAuth(e, t) {
    const i = Buffer.from(e + ":" + t).toString("base64");
    ((this.auth = "Basic " + i),
      this.setDefaultRequest("baseUrl", AQ),
      this.isValidTwilioAuth(e, t) ||
        console.warn("Twilio Email credentials must be non-empty strings."));
  }
  isValidApiKey(e) {
    return this.isString(e) && e.trim().startsWith(Sx);
  }
  isValidTwilioAuth(e, t) {
    return this.isString(e) && e && this.isString(t) && t;
  }
  isString(e) {
    return typeof e == "string" || e instanceof String;
  }
  setImpersonateSubuser(e) {
    this.impersonateSubuser = e;
  }
  setDefaultHeader(e, t) {
    return e !== null && typeof e == "object"
      ? (Object.assign(this.defaultHeaders, e), this)
      : ((this.defaultHeaders[e] = t), this);
  }
  setDefaultRequest(e, t) {
    return e !== null && typeof e == "object"
      ? (Object.assign(this.defaultRequest, e), this)
      : ((this.defaultRequest[e] = t), this);
  }
  setDataResidency(e) {
    return (
      d2.hasOwnProperty(e)
        ? ((this.sendgrid_region = e), this.setDefaultRequest("baseUrl", d2[e]))
        : console.warn('Region can only be "global" or "eu".'),
      this
    );
  }
  createHeaders(e) {
    const t = wx(this.defaultHeaders, e);
    return (
      typeof t.Authorization > "u" &&
        this.auth &&
        (t.Authorization = this.auth),
      this.impersonateSubuser && (t["On-Behalf-Of"] = this.impersonateSubuser),
      t
    );
  }
  createRequest(e) {
    let t = {
      url: e.uri || e.url,
      baseUrl: e.baseUrl,
      method: e.method,
      data: e.body,
      params: e.qs,
      headers: e.headers,
    };
    return (
      (t = wx(this.defaultRequest, t)),
      (t.headers = this.createHeaders(t.headers)),
      (t.baseURL = t.baseUrl),
      delete t.baseUrl,
      t
    );
  }
  request(e, t) {
    e = this.createRequest(e);
    const i = new Promise((r, s) => {
      gQ(e)
        .then((o) => r([new mQ(o.status, o.data, o.headers), o.data]))
        .catch((o) =>
          o.response && o.response.status >= 400 ? s(new CQ(o.response)) : s(o),
        );
    });
    if (t && typeof t != "function")
      throw new Error("Callback passed is not a function.");
    return t ? i.then((r) => t(null, r)).catch((r) => t(r, null)) : i;
  }
};
var _L = _Q;
const bQ = _L;
var vQ = new bQ();
const xQ = vQ,
  wQ = _L;
Iv.exports = xQ;
Iv.exports.Client = wQ;
var SQ = Iv.exports;
const { Client: TQ } = SQ,
  {
    classes: { Mail: EQ },
  } = yL;
let MQ = class {
  constructor() {
    (this.setClient(new TQ()),
      this.setSubstitutionWrappers("{{", "}}"),
      (this.secretRules = []));
  }
  setClient(e) {
    return ((this.client = e), this);
  }
  setApiKey(e) {
    return (this.client.setApiKey(e), this);
  }
  setTwilioEmailAuth(e, t) {
    this.client.setTwilioEmailAuth(e, t);
  }
  setTimeout(e) {
    typeof e > "u" || this.client.setDefaultRequest("timeout", e);
  }
  setSubstitutionWrappers(e, t) {
    if (typeof e > "u" || typeof t > "u")
      throw new Error("Must provide both left and right side wrappers");
    return (
      Array.isArray(this.substitutionWrappers) ||
        (this.substitutionWrappers = []),
      (this.substitutionWrappers[0] = e),
      (this.substitutionWrappers[1] = t),
      this
    );
  }
  setSecretRules(e) {
    e instanceof Array || (e = [e]);
    const t = e.map(function (i) {
      const r = typeof i;
      if (r === "string") return { pattern: new RegExp(i) };
      if (r === "object") {
        i instanceof RegExp
          ? (i = { pattern: i })
          : i.hasOwnProperty("pattern") &&
            typeof i.pattern == "string" &&
            (i.pattern = new RegExp(i.pattern));
        try {
          return (i.pattern.test(""), i);
        } catch {}
      }
    });
    this.secretRules = t.filter(function (i) {
      return i;
    });
  }
  filterSecrets(e) {
    if (typeof e == "object" && !e.hasOwnProperty("content")) return;
    const t = this;
    e.content.forEach(function (i) {
      t.secretRules.forEach(function (r) {
        if (r.hasOwnProperty("pattern") && !r.pattern.test(i.value)) return;
        let s = `The pattern '${r.pattern}'`;
        throw (
          r.name && (s += `identified by '${r.name}'`),
          (s += " was found in the Mail content!"),
          new Error(s)
        );
      });
    });
  }
  send(e, t = !1, i) {
    if ((typeof t == "function" && ((i = t), (t = !1)), Array.isArray(e))) {
      const r = Promise.all(e.map((s) => this.send(s, t)));
      return (i && r.then((s) => i(null, s)).catch((s) => i(s, null)), r);
    }
    try {
      (typeof e.isMultiple > "u" && (e.isMultiple = t),
        typeof e.substitutionWrappers > "u" &&
          (e.substitutionWrappers = this.substitutionWrappers));
      const r = EQ.create(e),
        s = r.toJSON();
      this.filterSecrets(s);
      const o = {
        method: "POST",
        url: "/v3/mail/send",
        headers: r.headers,
        body: s,
      };
      return this.client.request(o, i);
    } catch (r) {
      return (i && i(r, null), Promise.reject(r));
    }
  }
  sendMultiple(e, t) {
    return this.send(e, !0, t);
  }
};
var bL = MQ;
const LQ = bL;
var RQ = new LQ();
const BQ = RQ,
  PQ = bL;
Cv.exports = BQ;
Cv.exports.MailService = PQ;
var NQ = Cv.exports;
const Hm = pp(NQ);
async function DQ({ request: n }) {
  const e = "YOUR_SENDGRID_API_KEY",
    t = await new Response(n.body).json(),
    i = [
      "type",
      "categories",
      "topic",
      "fullName",
      "company",
      "email",
      "website",
      "message",
    ];
  for (let r = 0; r < i.length; r += 1) {
    const s = t[i[r]];
    if (s == null) continue;
    if ((Array.isArray(s) ? s.join(",") : s).length > 1024)
      return Li(
        { status: "FIELDS_TOO_LONG", error: `Filed is too long: ${i[r]}` },
        { status: 400 },
      );
  }
  try {
    const r = await lj({
      method: "post",
      url: "https://vu4lf9wl.api.local/v2022-10-03/data/mutate/production",
      headers: {
        Authorization: "Bearer REMOVED_TOKEN",
        "Content-Type": "application/json",
      },
      data: JSON.stringify({
        mutations: [
          {
            create: {
              _id: "drafts.",
              _type: "contactEntry",
              type: t.type,
              categories: t.categories,
              email: t.email,
              fullName: t.fullName,
              company: t.company,
              website: t.website,
              message: t.message,
              topic: t.topic,
            },
          },
        ],
      }),
    });
    if (r.data.results[0].operation !== "create")
      return Li(
        {
          status: "UNEXPECTED_STORAGE_STATUS",
          error: "Unexpected storage status",
          info: { status: r.data.results[0].operation },
        },
        { status: 500 },
      );
  } catch (r) {
    return Li(
      {
        status: "UNEXPECTED_ERROR",
        message: "Unexpected error",
        info: { error: r.message },
      },
      { status: 500 },
    );
  }
  try {
    (Hm.setApiKey(e),
      await Hm.send({
        to: "hello@format-3.co",
        from: "hello@format-3.co",
        subject: "Message via Fokus",
        replyTo: t.email,
        text: `${t.fullName} (${t.company}) says: 
"${t.message || "No message content"}"

Email: ${t.email || "N/A"}
Website: ${t.website || "N/A"}`,
        html: `
        <h1 style="margin-bottom: 24px;">New Contact</h1>
        <ul>
          <li><strong>From:</strong> ${t.fullName} (${t.company})</li>
          <li><strong>Email:</strong> ${t.email}</li>
          <li><strong>Website:</strong> ${t.website}</li>
          <li><strong>Message:</strong> ${t.message || "No message content"}</li>
        </ul>
      `,
      }));
  } catch (r) {
    return (
      console.error(r.response.body.errors),
      Li(
        {
          status: "UNEXPECTED_ERROR",
          message: "Unexpected error",
          info: { error: r.message },
        },
        { status: 500 },
      )
    );
  }
  return Li({ status: "OK" });
}
async function GQ({ request: n }) {
  try {
    const e = "YOUR_SENDGRID_API_KEY";
    Hm.setApiKey(e);
    const t = await n.json();
    if (!t)
      return Li({ status: "error", error: "Invalid request" }, { status: 400 });
    const { email: i } = t;
    if (!i || !wE(i))
      return Li(
        { status: "error", error: "Email is invalid or missing" },
        { status: 400 },
      );
    if (
      !(
        await fetch("https://api.sendgrid.com/v3/marketing/contacts", {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${e}`,
          },
          body: JSON.stringify({ contacts: [{ email: i }] }),
        })
      ).ok
    )
      return Li(
        { status: "error", error: "Failed to submit form" },
        { status: 500 },
      );
    const s = {
      to: "hello@format-3.co",
      from: "hello@format-3.co",
      subject: "New contact added!",
      text: `A new contact was added: ${i}`,
      html: `
        <h1 style="margin-bottom: 24px;">Newsletter Form Submission</h1>
        <p style="font-size: 16px; line-height: 1.5;">
          <strong>New sign-up email:</strong> ${i}
        </p>
      `,
    };
    return (await Hm.send(s), Li({ status: "ok" }));
  } catch (e) {
    return (
      console.error(e.message),
      Li({ status: "error", error: "Failed to submit form" }, { status: 500 })
    );
  }
}
const FQ = [
  { GET: "skip", path: "/about" },
  { GET: "skip", path: "/contact" },
  { GET: "skip", path: "/" },
  { GET: "skip", path: "/services" },
  { GET: "skip", path: "/sitemap" },
  { GET: "skip", path: "/ai/" },
  { GET: zX, POST: ZX, path: "/api/babylovegrowth" },
  { POST: DQ, path: "/api/contact" },
  { POST: GQ, path: "/api/newsLetter" },
  { GET: "skip", path: "/curiosity/:slug" },
  { GET: "skip", path: "/curiosity/" },
  { GET: "skip", path: "/industries/:slug" },
  { GET: "skip", path: "/legal/:slug" },
  { GET: "skip", path: "/offerings/:slug" },
  { GET: "skip", path: "/vault/" },
  { GET: "skip", path: "/work/:slug" },
  { GET: "skip", path: "/work/" },
];
function vL(n) {
  let e = /(\/?\:[^\/]+)\?/.exec(n);
  if (!e) return [n];
  let t = n.slice(0, e.index),
    i = n.slice(e.index + e[0].length);
  const r = [t, (t += e[1])];
  for (; (e = /^(\/\:[^\/]+)\?/.exec(i)); )
    (r.push((t += e[1])), (i = i.slice(e[0].length)));
  return vL(i).reduce((s, o) => [...s, ...r.map((a) => a + o)], []);
}
function kQ(n) {
  const e = n.path.split("/").filter(Boolean),
    t = [],
    i = [];
  let r = 0,
    s = !1;
  for (const [o, a] of e.entries())
    if (a[0] === ":") {
      const l = a.slice(1);
      ((r += 3), t.push({ type: ":", name: l, index: o }), i.push(null));
    } else
      a[0] === "*"
        ? ((r -= 1),
          t.push({ type: "*", name: a.slice(1), index: o }),
          (s = !0))
        : ((r += 4), i.push(a));
  return { ...n, score: r, params: t, matchSegments: i, wildcard: s };
}
FQ.flatMap((n) => vL(n.path).map((t) => ({ ...n, path: t })))
  .map(kQ)
  .sort((n, e) => e.score - n.score);
const OQ = SM({
    dataset: "production",
    projectId: "vu4lf9wl",
    useCdn: !0,
    apiVersion: "2023-05-04",
  }),
  Bs = {
    title: !0,
    path: !0,
    description: !0,
    keywords: !0,
    "...image": {
      '"image": asset->': {
        '"src": url': !0,
        "...metadata.dimensions": { width: !0, height: !0 },
      },
    },
  },
  Ji = { label: !0, href: !0, isExternal: !0 },
  Ye = () => ({
    alt: !0,
    type: !0,
    video: { '"src": file.asset->url': !0, width: !0, height: !0 },
    "...src.asset->": {
      '"src": url': !0,
      "...metadata.dimensions": { width: !0, height: !0 },
    },
  });
function i_(n) {
  return Object.entries(n)
    .map(([e, t]) =>
      t === !0
        ? e
        : Array.isArray(t)
          ? `${e}[] { ${i_(t[0])} }`
          : `${e} { ${i_(t)} }`,
    )
    .join(", ");
}
function rs(n, e) {
  return OQ.fetch(i_(n), e);
}
const xL = Fa(null);
let nme = (function (n) {
  return ((n.Video = "video"), (n.Image = "image"), n);
})({});
function Ev() {
  return ro(xL);
}
function ime(n, e) {
  const t = n();
  return t() === null
    ? G(nV, { href: "/" })
    : G(Hl, {
        get when() {
          return t();
        },
        get children() {
          return G(xL.Provider, {
            get value() {
              return t();
            },
            get children() {
              return G(e, {});
            },
          });
        },
      });
}
const wL = Fa(null);
function tI() {
  return ro(wL);
}
const SL = (n) => {
  const [e, t] = Dr(n, ["isMenu"]),
    i = pe(() => Qn() > 100),
    r = nI(),
    s = gp(),
    o = tI();
  return G(
    $.Generic,
    jn(
      {
        get css() {
          return [
            {
              position: "sticky",
              top: "0px",
              zIndex: "20",
              userSelect: "none",
              mixBlendMode: "difference",
            },
            va,
            nt.sohne.body3,
          ];
        },
        as: "nav",
      },
      t,
      {
        get children() {
          return G($.Generic, {
            get css() {
              return [
                {
                  display: "flex",
                  transformOrigin: "left",
                  "--tw-translate-y": "-100%",
                  transform:
                    "translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))",
                  "--tw-skew-y": "-5deg",
                  alignItems: "center",
                  justifyContent: "space-between",
                  paddingTop: "32rem",
                  paddingBottom: "32rem",
                  opacity: "0",
                  transitionProperty: "opacity, transform",
                  transitionTimingFunction: "cubic-bezier(0.4, 0, 0.2, 1)",
                  transitionDuration: "1s",
                  "@media (max-width: 767px)": {
                    paddingTop: "24rem",
                    paddingBottom: "24rem",
                  },
                },
                {
                  ...(s.pathname !== "/" && {
                    transitionDelay: "1s",
                    transitionDuration: "2s",
                    transitionTimingFunction: "cubic-bezier(0.16, 1, 0.3, 1)",
                  }),
                  ...(r() && {
                    "--tw-translate-y": "0px",
                    transform:
                      "translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))",
                    "--tw-skew-y": "0deg",
                    opacity: "1",
                  }),
                },
              ];
            },
            as: "div",
            get children() {
              return [
                G($.Generic, {
                  href: "/",
                  css: { pointerEvents: "auto" },
                  as: zr,
                  get children() {
                    return G($.Generic, {
                      css: {
                        height: "auto",
                        width: "124.17rem",
                        fill: "#FFF",
                        "@media (max-width: 767px)": { width: "99rem" },
                      },
                      as: vT,
                    });
                  },
                }),
                pe(() => [
                  G($.Generic, {
                    css: {
                      display: "flex",
                      gap: "86rem",
                      "@media (max-width: 767px)": { display: "none" },
                    },
                    as: "ul",
                    get children() {
                      return G(Yn, {
                        get each() {
                          return o.navbar.links;
                        },
                        children: ({ label: a, href: l, isExternal: c }, u) =>
                          G($.Generic, {
                            get css() {
                              return [
                                {
                                  transitionProperty: "transform, opacity",
                                  transitionTimingFunction:
                                    "cubic-bezier(0.4, 0, 0.2, 1)",
                                  transitionDuration: "500ms",
                                },
                                {
                                  transitionDelay: `${0.025 * u()}s`,
                                  ...((i() || e.isMenu) && {
                                    "--tw-translate-y": "-100%",
                                    transform:
                                      "translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))",
                                    opacity: "0",
                                  }),
                                },
                              ];
                            },
                            as: "li",
                            get children() {
                              return l === "#archive"
                                ? G($.Generic, {
                                    css: { pointerEvents: "auto" },
                                    as: "button",
                                    onClick: () => {
                                      SE(!0);
                                    },
                                    children: a,
                                  })
                                : G($.Generic, {
                                    href: l,
                                    target: c ? "_blank" : void 0,
                                    css: {
                                      pointerEvents: "auto",
                                      transitionProperty: "opacity",
                                      transitionTimingFunction:
                                        "cubic-bezier(0.4, 0, 0.2, 1)",
                                      transitionDuration: "500ms",
                                      "&:hover": { opacity: "0.5" },
                                    },
                                    as: zr,
                                    children: a,
                                  });
                            },
                          }),
                      });
                    },
                  }),
                  G($.Generic, {
                    href: "https://wa.me/5511912768263?text=Quero%20saber%20mais%20sobre%20a%20Fokus...",
                    target: "_blank",
                    rel: "noopener",
                    get css() {
                      return [
                        {
                          pointerEvents: "auto",
                          transitionProperty: "transform, opacity",
                          transitionTimingFunction:
                            "cubic-bezier(0.4, 0, 0.2, 1)",
                          transitionDuration: "500ms",
                          "&:hover": { opacity: "0.5" },
                          "@media (max-width: 767px)": { display: "none" },
                        },
                        {
                          ...((i() || e.isMenu) && {
                            "--tw-translate-x": "-84rem",
                            transform:
                              "translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))",
                          }),
                        },
                      ];
                    },
                    as: zr,
                    children: "Work with us",
                  }),
                ]),
                G($.Generic, {
                  get css() {
                    return [
                      {
                        pointerEvents: "none",
                        position: "absolute",
                        right: "0px",
                        opacity: "0",
                        transitionProperty: "opacity",
                        transitionTimingFunction:
                          "cubic-bezier(0.4, 0, 0.2, 1)",
                        transitionDuration: "500ms",
                        "&:hover": { opacity: "0.5" },
                        "@media (max-width: 767px)": {
                          pointerEvents: "auto",
                          position: "static",
                          display: "block",
                          opacity: "1",
                        },
                      },
                      {
                        ...((i() || e.isMenu) && {
                          pointerEvents: "auto",
                          opacity: "1",
                        }),
                      },
                    ];
                  },
                  as: "button",
                  onClick: () => {
                    vz();
                  },
                  get children() {
                    return e.isMenu ? "Close" : "Menu";
                  },
                }),
              ];
            },
          });
        },
      },
    ),
  );
};
var UQ = 4,
  HQ = 0.001,
  WQ = 1e-7,
  VQ = 10,
  Gf = 11,
  qp = 1 / (Gf - 1),
  ZQ = typeof Float32Array == "function";
function TL(n, e) {
  return 1 - 3 * e + 3 * n;
}
function EL(n, e) {
  return 3 * e - 6 * n;
}
function ML(n) {
  return 3 * n;
}
function Wm(n, e, t) {
  return ((TL(e, t) * n + EL(e, t)) * n + ML(e)) * n;
}
function LL(n, e, t) {
  return 3 * TL(e, t) * n * n + 2 * EL(e, t) * n + ML(e);
}
function zQ(n, e, t, i, r) {
  var s,
    o,
    a = 0;
  do ((o = e + (t - e) / 2), (s = Wm(o, i, r) - n), s > 0 ? (t = o) : (e = o));
  while (Math.abs(s) > WQ && ++a < VQ);
  return o;
}
function YQ(n, e, t, i) {
  for (var r = 0; r < UQ; ++r) {
    var s = LL(e, t, i);
    if (s === 0) return e;
    var o = Wm(e, t, i) - n;
    e -= o / s;
  }
  return e;
}
function XQ(n) {
  return n;
}
var KQ = function (e, t, i, r) {
  if (!(0 <= e && e <= 1 && 0 <= i && i <= 1))
    throw new Error("bezier x values must be in [0, 1] range");
  if (e === t && i === r) return XQ;
  for (var s = ZQ ? new Float32Array(Gf) : new Array(Gf), o = 0; o < Gf; ++o)
    s[o] = Wm(o * qp, e, i);
  function a(l) {
    for (var c = 0, u = 1, h = Gf - 1; u !== h && s[u] <= l; ++u) c += qp;
    --u;
    var d = (l - s[u]) / (s[u + 1] - s[u]),
      f = c + d * qp,
      g = LL(f, e, i);
    return g >= HQ ? YQ(l, f, e, i) : g === 0 ? f : zQ(l, c, c + qp, e, i);
  }
  return function (c) {
    return c === 0 ? 0 : c === 1 ? 1 : Wm(a(c), t, r);
  };
};
const Hd = pp(KQ),
  jQ = xt("<div>%"),
  ll = Di(!Xb),
  Vc = Di(0),
  $Q = Hd(0.8, 0, 1, 0.49),
  r_ = Di(!Xb),
  la = pe(() => $Q(Cr(Vc(), 0, 1))),
  s_ = Di(!1),
  JQ = () => {
    const e = gp().pathname === "/",
      [t, i] = nv(0, { multiplier: 0.05, accuracy: 100 });
    rr(() => {
      (Eh(0),
        setTimeout(() => {
          (i(0.33),
            setTimeout(() => {
              (i(0.66),
                setTimeout(() => {
                  i(1);
                }, 700));
            }, 1e3));
        }, 300));
    });
    const r = pe(() => Cr(t(), 0, 1));
    Ct(
      gr(
        r,
        (u) => {
          u === 1 && ll(!0);
        },
        { defer: !0 },
      ),
    );
    let s = 0,
      o = -1;
    function a(u) {
      (Vc((u - s) / 500),
        Vc() > 1 && (r_(!0), Eh(-1)),
        Vc() < 2 && (o = requestAnimationFrame(a)));
    }
    (Ct(
      gr(
        ll,
        (u) => {
          u &&
            (setTimeout(() => {
              ((s = performance.now()), (o = requestAnimationFrame(a)));
            }, 500),
            dn(() => {
              cancelAnimationFrame(o);
            }));
        },
        { defer: !0 },
      ),
    ),
      Ct(
        gr(
          la,
          (u) => {
            u > 0.5 && s_(!0);
          },
          { defer: !0 },
        ),
      ));
    const l = xE(),
      c = "Format3";
    return G($.Generic, {
      css: {
        position: "fixed",
        inset: "0px",
        zIndex: "20",
        display: "flex",
        userSelect: "none",
        alignItems: "center",
        justifyContent: "center",
        "--tw-bg-opacity": "1",
        backgroundColor: "rgb(0 0 0 / var(--tw-bg-opacity))",
      },
      as: "div",
      get style() {
        return e ? {} : { opacity: 1 - Vc() };
      },
      get children() {
        return [
          G($.Generic, {
            get css() {
              return [
                {
                  display: "flex",
                  gap: "13rem",
                  fontFamily: "Sohne Breit, sans-serif",
                  fontSize: "62.5rem",
                  lineHeight: "1",
                  letterSpacing: "0em",
                  opacity: "0",
                  transitionProperty: "opacity",
                  transitionTimingFunction: "cubic-bezier(0.4, 0, 0.2, 1)",
                  transitionDuration: "500ms",
                },
                { ...(l() && { opacity: "1" }), ...(ll() && { opacity: "0" }) },
              ];
            },
            as: "div",
            get children() {
              return [pe(() => Math.round(r() * 100)), ft(jQ)];
            },
          }),
          G($.Generic, {
            width: "130",
            height: "130",
            viewBox: "0 0 19 18",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
            get css() {
              return [
                {
                  position: "absolute",
                  "--tw-translate-x": "4rem",
                  transform:
                    "translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))",
                  "--tw-translate-y": "4rem",
                  opacity: "0.3",
                  transitionProperty: "opacity",
                  transitionTimingFunction: "cubic-bezier(0.4, 0, 0.2, 1)",
                  transitionDuration: "500ms",
                },
                { ...(ll() && { opacity: "0" }) },
              ];
            },
            as: "svg",
            get children() {
              return [
                G($.Generic, {
                  d: `M7.67567 0.26967C7.8109 0.196416 8.01859 0.108673 8.13853 0.0748636C8.25767 0.0418592 10.737 0.0104648 18.9406 0L18.8939 0.221371C18.8682 0.342923 18.6243 1.00382 18.3522 1.69047C17.9223 2.77317 17.8056 2.98891 17.4731 3.32056C17.1962 3.59667 16.9716 3.73674 16.6665 3.82448C16.3115 3.92671 15.5106 3.94603 11.6555 3.94442C7.91153 3.94281 6.99304 3.96374 6.66461 4.05793C6.39896 4.1344 6.13734 4.29218 5.89665 4.5216C5.62859 4.77678 5.46035 5.04242 5.26876 5.51414C5.12548 5.86834 4.92745 6.33523 4.83005 6.55177C4.73184 6.76911 4.50725 7.06937 4.33015 7.21991C4.15305 7.37124 3.82703 7.54753 3.60566 7.61193C3.29977 7.70129 2.81758 7.72463 1.5932 7.70853C0.573287 7.69565 -0.0103264 7.65782 0.000138362 7.6071C0.00899319 7.56283 0.20219 7.00095 0.429195 6.35938C0.656201 5.7178 0.897696 5.08348 0.965315 4.95065C1.03293 4.81783 1.20198 4.58841 1.34044 4.44029C1.4797 4.29298 1.7381 4.09496 1.9152 4.00077C2.19533 3.85185 2.4167 3.82368 3.60566 3.78665C4.89444 3.74559 4.99507 3.7311 5.33638 3.53308C5.53521 3.41716 5.81052 3.1821 5.94656 3.00984C6.0826 2.83757 6.34422 2.31675 6.52776 1.85146C6.74591 1.29844 6.95923 0.901583 7.14518 0.704361C7.30135 0.538535 7.53962 0.342923 7.67567 0.26967Z`,
                  fill: "none",
                  stroke: "white",
                  "stroke-width": "0.2",
                  css: { strokeDasharray: "0 22 11 7 22" },
                  as: "path",
                  get style() {
                    return { "stroke-dashoffset": (40 * t()).toString() };
                  },
                }),
                G($.Generic, {
                  d: `M10.1432 6.15138C10.3203 6.0411 10.5828 5.91713 10.7269 5.87688C10.871 5.83663 12.501 5.80041 14.3493 5.79638C16.1975 5.79236 17.7093 5.81651 17.7085 5.84951C17.7069 5.88252 17.5853 6.21739 17.438 6.59412C17.2899 6.97086 17.05 7.58586 16.9059 7.9626C16.761 8.33933 16.5252 8.79173 16.3827 8.96883C16.2394 9.14592 15.9456 9.38178 15.3354 9.69331L12.357 9.73356C9.71419 9.76898 9.34229 9.78991 9.05652 9.91871C8.87942 9.9984 8.63229 10.1618 8.50752 10.281C8.38275 10.4009 8.2129 10.607 8.13079 10.7398C8.04868 10.8726 7.87158 11.2711 7.73876 11.6253C7.60513 11.9795 7.34754 12.6492 7.16481 13.1145C6.98288 13.5798 6.67779 14.3767 6.4862 14.8855C6.29542 15.3942 6.0491 15.9923 5.93881 16.2137C5.82934 16.4351 5.59831 16.7345 5.42604 16.8786C5.25297 17.0227 4.94868 17.1925 4.74985 17.2561C4.4987 17.3358 3.88852 17.3793 2.76396 17.3962C1.87123 17.4099 1.11776 17.4026 1.09039 17.3809C1.06302 17.3592 1.12581 17.1233 1.23127 16.8577C1.33672 16.592 1.63215 15.8128 1.88813 15.127C2.14412 14.4411 2.60779 13.2272 2.91932 12.4303C3.23085 11.6333 3.54801 10.8549 3.62368 10.6995C3.70015 10.5442 3.88449 10.314 4.03422 10.1868C4.18475 10.0596 4.45201 9.87926 4.6291 9.7875C4.90441 9.6434 5.13061 9.61523 6.19882 9.58705C7.24208 9.56049 7.49968 9.52829 7.76855 9.39386C7.94564 9.30531 8.21129 9.11936 8.3594 8.9801C8.50672 8.84083 8.68462 8.61866 8.75465 8.48584C8.82388 8.35301 9.00339 7.93684 9.15231 7.5601C9.30204 7.18337 9.51295 6.75834 9.62242 6.61425C9.7319 6.47016 9.96615 6.26247 10.1432 6.15138Z`,
                  fill: "none",
                  stroke: "white",
                  "stroke-width": "0.2",
                  css: { strokeDasharray: "0 22 11 7 22" },
                  as: "path",
                  get style() {
                    return { "stroke-dashoffset": (40 * t()).toString() };
                  },
                }),
              ];
            },
          }),
          G($.Generic, {
            get css() {
              return [
                {
                  position: "absolute",
                  opacity: "0",
                  transitionProperty: "opacity",
                  transitionTimingFunction: "cubic-bezier(0.4, 0, 0.2, 1)",
                  transitionDuration: "500ms",
                },
                { ...(ll() && { opacity: "1" }) },
              ];
            },
            as: "div",
            get children() {
              return G($.Generic, {
                css: { fill: "#FFF" },
                as: dV,
                get style() {
                  return {
                    opacity: 1 - la(),
                    transform: `translateX(${(1 - la()) * 4}rem) scale(${1 + (e ? (No() ? 0.9 : 1.9) : 5) * la()}) translateY(${(1 - la()) * 4}rem)`,
                  };
                },
              });
            },
          }),
          G($.Generic, {
            css: {
              position: "absolute",
              display: "flex",
              alignItems: "center",
              fontFamily: "Sohne Breit, sans-serif",
              fontSize: "175rem",
              textTransform: "uppercase",
              letterSpacing: "-1rem",
              WebkitTextFillColor: "transparent",
              WebkitTextStrokeColor: "white",
              WebkitTextStrokeWidth: "1px",
            },
            as: "div",
            get style() {
              return {
                transform: `${No() ? "rotate(90deg) scale(0.6) " : ""}scale(${0.5 + 0.5 * la()}) translateY(-6.5rem) translateX(${yz(la(), 9, 9)}rem)`,
              };
            },
            get children() {
              return G(Yn, {
                get each() {
                  return c.split("");
                },
                children: (u, h) =>
                  G($.Generic, {
                    get css() {
                      return [
                        {
                          "--tw-translate-x": "50rem",
                          transform:
                            "translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))",
                          opacity: "0",
                          transitionProperty: "opacity, transform",
                          transitionTimingFunction:
                            "cubic-bezier(0.4, 0, 0.2, 1)",
                          transitionDuration: "500ms",
                        },
                        {
                          ...(u === "F" && {
                            "--tw-translate-x": "5rem",
                            transform:
                              "translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))",
                          }),
                          ...(u === "o" && {
                            "--tw-translate-x": "1rem",
                            transform:
                              "translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))",
                          }),
                          ...(u === "" && {
                            marginLeft: "-10rem",
                            "--tw-translate-y": "-12rem",
                            transform:
                              "translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))",
                          }),
                          ...(u === "t" && { marginLeft: "-23rem" }),
                          ...(ll() && {
                            "--tw-translate-x": "0px",
                            transform:
                              "translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))",
                            opacity: "1",
                          }),
                        },
                      ];
                    },
                    as: "div",
                    get style() {
                      return { "transition-delay": `${0.1 + h() * 0.05}s` };
                    },
                    children: u,
                  }),
              });
            },
          }),
        ];
      },
    });
  },
  QQ = () =>
    G($.Generic, {
      css: {
        display: "flex",
        height: "24rem",
        width: "24rem",
        "@keyframes spin": { to: { transform: "rotate(360deg)" } },
        animation: "spin 1s linear infinite",
        alignItems: "center",
        justifyContent: "center",
        borderRadius: "9999px",
      },
      as: "div",
      style: {
        background:
          "conic-gradient(#5553E2 0deg 15deg, transparent 15deg 100deg, #5553E2 100deg 360deg)",
      },
      get children() {
        return G($.Generic, {
          css: {
            height: "21rem",
            width: "21rem",
            borderRadius: "9999px",
            "--tw-bg-opacity": "1",
            backgroundColor: "rgb(0 0 0 / var(--tw-bg-opacity))",
          },
          as: "div",
        });
      },
    }),
  Tx = () => {
    const [n, e] = Jt(!1),
      [t, i] = Jt({ state: "", message: "" }),
      r = async (s) => {
        if ((s.preventDefault(), n())) return;
        (e(!0), i({ state: "", message: "" }));
        const o = new FormData(s.target),
          a = Object.fromEntries(o.entries()),
          { email: l } = a;
        try {
          if (!wE(l.toString()))
            throw new Error("Please enter a valid email address");
          if (
            !(
              await fetch("/api/newsLetter", {
                method: "POST",
                body: JSON.stringify(a),
                headers: { "Content-Type": "application/json" },
              })
            ).ok
          )
            throw new Error("Failed to submit form");
          (i({ state: "success", message: "Thank you for signing up" }),
            setTimeout(() => {
              i({ state: "", message: "" });
            }, 3e3));
        } catch (c) {
          i({ state: "error", message: c.message });
        } finally {
          e(!1);
        }
      };
    return G($.Generic, {
      css: {
        marginTop: "40rem",
        display: "flex",
        width: "100%",
        maxWidth: "416rem",
        flexDirection: "column",
        gap: "28rem",
      },
      as: "div",
      get children() {
        return [
          G($.Generic, {
            get css() {
              return [nt.sohne.body2, nt.m.sohne.body2];
            },
            as: "h2",
            children:
              "Receive exclusive insights on strategy, culture, and technology directly in your inbox.",
          }),
          G($.Generic, {
            css: { position: "relative" },
            as: "form",
            onSubmit: r,
            get children() {
              return [
                G($.Generic, {
                  css: {
                    position: "relative",
                    height: "64rem",
                    width: "100%",
                    borderBottomWidth: "1rem",
                    "--tw-border-opacity": "1",
                    borderColor: "rgb(255 255 255 / var(--tw-border-opacity))",
                    "--tw-bg-opacity": "1",
                    backgroundColor: "rgb(0 0 0 / var(--tw-bg-opacity))",
                  },
                  as: "div",
                  get children() {
                    return [
                      G($.Generic, {
                        class: "placeholder-opacity-50 input",
                        get css() {
                          return [
                            nt.sohne.body2,
                            nt.m.sohne.body2,
                            {
                              height: "100%",
                              width: "100%",
                              backgroundColor: "transparent",
                              "--tw-text-opacity": "1",
                              color:
                                "rgb(255 255 255 / var(--tw-text-opacity))",
                              outline: "2px solid transparent",
                              outlineOffset: "2px",
                            },
                          ];
                        },
                        as: "input",
                        name: "email",
                        placeholder: "Your email here",
                        required: !0,
                      }),
                      G($.Generic, {
                        get css() {
                          return [
                            {
                              position: "absolute",
                              right: "0px",
                              top: "50%",
                              display: "flex",
                              width: "40rem",
                              "--tw-translate-y": "-50%",
                              transform:
                                "translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))",
                              alignItems: "center",
                              justifyContent: "flex-end",
                              mixBlendMode: "difference",
                            },
                            nt.sohne.body2,
                            nt.m.sohne.body2,
                          ];
                        },
                        as: "button",
                        get disabled() {
                          return n();
                        },
                        get children() {
                          return pe(() => !!n())() ? G(QQ, {}) : "";
                        },
                      }),
                    ];
                  },
                }),
                G($.Generic, {
                  get css() {
                    return [
                      nt.sohne.body6,
                      { position: "absolute", top: "108%" },
                    ];
                  },
                  as: "p",
                  get style() {
                    return { color: t().state === "error" ? "red" : "green" };
                  },
                  get children() {
                    return t().message;
                  },
                }),
              ];
            },
          }),
          G($.Generic, {
            get css() {
              return [
                {
                  "--tw-text-opacity": "0.5",
                  color: "rgb(255 255 255 / var(--tw-text-opacity))",
                },
                nt.sohne.body6,
              ];
            },
            as: "p",
            get children() {
              return [
                "By signing up to receive emails from Fokus,",
                " ",
                "you agree to our",
                " ",
                G($.Generic, {
                  css: { "text-decoration": "underline" },
                  as: zr,
                  href: "/legal/privacy-policy",
                  children: "Privacy Policy.",
                }),
                " ",
                "We treat your info responsibly. Unsubscribe anytime.",
              ];
            },
          }),
        ];
      },
    });
  },
  Ex = xt("<ul>"),
  qQ = xt("<div>"),
  cf = xt("<li>"),
  eq = () => {
    const n = tI();
    let e = null;
    const t = Ki(() => e),
      i = HC(() => e, t),
      r = pe(() => Cr(1 - (t().y - Qn()) / In().height, 0, 1));
    return G($.Generic, {
      css: [
        {
          position: "relative",
          height: "100vh",
          "--tw-bg-opacity": "1",
          backgroundColor: "rgb(0 0 0 / var(--tw-bg-opacity))",
        },
        {
          a: {
            transitionProperty: "opacity",
            transitionTimingFunction: "cubic-bezier(0.4, 0, 0.2, 1)",
            transitionDuration: "500ms",
            "&:hover": { opacity: "0.5" },
          },
          "&": { height: "100lvh" },
        },
      ],
      as: "div",
      ref(s) {
        const o = e;
        typeof o == "function" ? o(s) : (e = s);
      },
      get children() {
        return G($.Generic, {
          get css() {
            return [
              {
                position: "relative",
                bottom: "0px",
                zIndex: "10",
                display: "flex",
                minHeight: "100vh",
                width: "100%",
                userSelect: "none",
                flexDirection: "column",
                overflow: "hidden",
                "--tw-bg-opacity": "1",
                backgroundColor: "rgb(0 0 0 / var(--tw-bg-opacity))",
                paddingTop: "64rem",
                paddingBottom: "64rem",
                "@media (max-width: 767px)": {
                  paddingTop: "40rem",
                  paddingBottom: "40rem",
                },
              },
              nt.sohne.body3,
              { "&": { minHeight: "100lvh" } },
            ];
          },
          as: "footer",
          get style() {
            return { opacity: r() };
          },
          get children() {
            return [
              G($.Generic, {
                css: [va],
                as: "div",
                get children() {
                  return [
                    G($.Generic, {
                      css: [
                        Im,
                        {
                          borderBottomWidth: "1px",
                          "--tw-border-opacity": "0.2",
                          borderColor:
                            "rgb(255 255 255 / var(--tw-border-opacity))",
                          paddingBottom: "64rem",
                          "@media (max-width: 767px)": {
                            display: "flex",
                            flexDirection: "column",
                            gap: "24rem",
                            paddingBottom: "24rem",
                          },
                        },
                      ],
                      as: "div",
                      get children() {
                        return [
                          G($.Generic, {
                            css: {
                              gridColumn: "span 6 / span 6",
                              display: "flex",
                              flexDirection: "column",
                              alignItems: "flex-start",
                              justifyContent: "space-between",
                              "@media (max-width: 767px)": {
                                borderBottomWidth: "1px",
                                "--tw-border-opacity": "0.2",
                                borderColor:
                                  "rgb(255 255 255 / var(--tw-border-opacity))",
                                paddingBottom: "24rem",
                              },
                            },
                            as: "div",
                            get children() {
                              return [
                                G($.Generic, {
                                  css: {
                                    height: "24rem",
                                    width: "auto",
                                    fill: "#FFF",
                                    "@media (max-width: 767px)": {
                                      height: "16rem",
                                    },
                                  },
                                  as: vT,
                                }),
                                G($.Generic, {
                                  css: {
                                    "@media (max-width: 767px)": {
                                      display: "none",
                                    },
                                  },
                                  as: "div",
                                  get children() {
                                    return G(Tx, {});
                                  },
                                }),
                              ];
                            },
                          }),
                          G($.Generic, {
                            css: [
                              Im,
                              {
                                gridColumn: "span 6 / span 6",
                                gridTemplateColumns:
                                  "repeat(6, minmax(0, 1fr))",
                                "@media (max-width: 767px)": {
                                  gridTemplateColumns:
                                    "repeat(2, minmax(0, 1fr))",
                                },
                              },
                            ],
                            as: "div",
                            get children() {
                              return [
                                G(Yn, {
                                  get each() {
                                    return n.footer.linkSections;
                                  },
                                  children: (s) =>
                                    G($.Generic, {
                                      css: {
                                        gridColumn: "span 2 / span 2",
                                        textAlign: "right",
                                        "@media (max-width: 767px)": {
                                          gridColumn: "span 1 / span 1",
                                          textAlign: "left",
                                        },
                                      },
                                      as: "div",
                                      get children() {
                                        return [
                                          G($.Generic, {
                                            css: {
                                              marginBottom: "12rem",
                                              "--tw-text-opacity": "0.5",
                                              color:
                                                "rgb(255 255 255 / var(--tw-text-opacity))",
                                            },
                                            as: "div",
                                            get children() {
                                              return s.title;
                                            },
                                          }),
                                          (() => {
                                            const o = ft(Ex);
                                            return (
                                              Mn(
                                                o,
                                                G(Yn, {
                                                  get each() {
                                                    return s.links;
                                                  },
                                                  children: (a) =>
                                                    (() => {
                                                      const l = ft(cf);
                                                      return (
                                                        Mn(
                                                          l,
                                                          G(zr, {
                                                            get href() {
                                                              return a.href;
                                                            },
                                                            get target() {
                                                              return a.isExternal
                                                                ? "_blank"
                                                                : void 0;
                                                            },
                                                            get children() {
                                                              return a.label;
                                                            },
                                                          }),
                                                        ),
                                                        l
                                                      );
                                                    })(),
                                                }),
                                              ),
                                              o
                                            );
                                          })(),
                                        ];
                                      },
                                    }),
                                }),
                                G($.Generic, {
                                  css: {
                                    gridColumn: "span 2 / span 2",
                                    textAlign: "right",
                                    "@media (max-width: 767px)": {
                                      display: "none",
                                    },
                                  },
                                  as: "div",
                                  get children() {
                                    return [
                                      G($.Generic, {
                                        css: {
                                          marginBottom: "12rem",
                                          "--tw-text-opacity": "0.5",
                                          color:
                                            "rgb(255 255 255 / var(--tw-text-opacity))",
                                        },
                                        as: "div",
                                        children: "Socials",
                                      }),
                                      (() => {
                                        const s = ft(Ex);
                                        return (
                                          Mn(
                                            s,
                                            G(Yn, {
                                              get each() {
                                                return n.socials.links;
                                              },
                                              children: (o) =>
                                                (() => {
                                                  const a = ft(cf);
                                                  return (
                                                    Mn(
                                                      a,
                                                      G(zr, {
                                                        get href() {
                                                          return o.href;
                                                        },
                                                        get target() {
                                                          return o.isExternal
                                                            ? "_blank"
                                                            : void 0;
                                                        },
                                                        get children() {
                                                          return o.label;
                                                        },
                                                      }),
                                                    ),
                                                    a
                                                  );
                                                })(),
                                            }),
                                          ),
                                          s
                                        );
                                      })(),
                                    ];
                                  },
                                }),
                                G($.Generic, {
                                  css: {
                                    gridColumn: "1 / -1",
                                    display: "flex",
                                    width: "100%",
                                    justifyContent: "flex-end",
                                    gap: "16rem",
                                    paddingTop: "64rem",
                                    "@media (max-width: 767px)": {
                                      justifyContent: "flex-start",
                                    },
                                  },
                                  as: "ul",
                                  get children() {
                                    return G(Yn, {
                                      get each() {
                                        return n.footer.awards.slice(0, 4);
                                      },
                                      children: (s) =>
                                        (() => {
                                          const o = ft(cf);
                                          return (
                                            Mn(
                                              o,
                                              G($.Generic, {
                                                get src() {
                                                  return s.src;
                                                },
                                                get alt() {
                                                  return s.alt;
                                                },
                                                css: {
                                                  height: "64rem",
                                                  width: "auto",
                                                  objectFit: "contain",
                                                  "@media (max-width: 767px)": {
                                                    height: "48rem",
                                                  },
                                                },
                                                as: "img",
                                              }),
                                            ),
                                            o
                                          );
                                        })(),
                                    });
                                  },
                                }),
                              ];
                            },
                          }),
                        ];
                      },
                    }),
                    G($.Generic, {
                      css: {
                        display: "none",
                        "@media (max-width: 767px)": { display: "block" },
                      },
                      as: "div",
                      get children() {
                        return G(Tx, {});
                      },
                    }),
                  ];
                },
              }),
              G($.Generic, {
                get css() {
                  return [
                    nt.breit.h0,
                    nt.m.breit.h0,
                    {
                      marginTop: "auto",
                      marginBottom: "auto",
                      display: "flex",
                      whiteSpace: "nowrap",
                      paddingBottom: "clamp(10rem, 2vh, 20rem)",
                      paddingLeft: "64rem",
                      fontSize: "clamp(10rem, 24vh, 300rem)",
                      "@media (max-width: 767px)": {
                        display: "none",
                        paddingLeft: "24rem",
                        fontSize: "clamp(10rem, 15vh, 300rem)",
                      },
                    },
                  ];
                },
                as: "div",
                get children() {
                  return G($.Generic, {
                    get style() {
                      return {
                        "animation-play-state": i() ? "running" : "paused",
                      };
                    },
                    css: [
                      {
                        display: "flex",
                        animation: "footer-marquee 15s infinite linear",
                      },
                      {
                        div: {
                          "&::after": {
                            "--tw-content": "'\\00a0'",
                            content: "var(--tw-content)",
                          },
                        },
                        "@keyframes footer-marquee": {
                          "0%": { transform: "translateX(0%)" },
                          "100%": { transform: "translateX(-100%)" },
                        },
                      },
                    ],
                    as: "div",
                    get children() {
                      return [
                        (() => {
                          const s = ft(qQ);
                          return (Mn(s, () => n.footer.tickerText), s);
                        })(),
                        G($.Generic, {
                          css: { width: "0px" },
                          as: "div",
                          get children() {
                            return n.footer.tickerText;
                          },
                        }),
                      ];
                    },
                  });
                },
              }),
              G($.Generic, {
                css: [
                  {
                    display: "none",
                    "@media (max-width: 767px)": { display: "block" },
                  },
                  va,
                ],
                as: "div",
                get children() {
                  return [
                    G($.Generic, {
                      css: {
                        marginBottom: "8rem",
                        borderTopWidth: "1px",
                        "--tw-border-opacity": "0.2",
                        borderColor:
                          "rgb(255 255 255 / var(--tw-border-opacity))",
                        paddingTop: "24rem",
                        "--tw-text-opacity": "0.5",
                        color: "rgb(255 255 255 / var(--tw-text-opacity))",
                        "@media (max-width: 767px)": {
                          "--tw-border-opacity": "0",
                        },
                      },
                      as: "div",
                      children: "Socials",
                    }),
                    G($.Generic, {
                      css: {
                        display: "grid",
                        gridTemplateColumns: "repeat(4, minmax(0, 1fr))",
                        "@media (max-width: 767px)": {
                          display: "flex",
                          gap: "15rem",
                        },
                      },
                      as: "ul",
                      get children() {
                        return G(Yn, {
                          get each() {
                            return n.socials.links;
                          },
                          children: (s) =>
                            (() => {
                              const o = ft(cf);
                              return (
                                Mn(
                                  o,
                                  G(zr, {
                                    get href() {
                                      return s.href;
                                    },
                                    get target() {
                                      return s.isExternal ? "_blank" : void 0;
                                    },
                                    get children() {
                                      return s.label;
                                    },
                                  }),
                                ),
                                o
                              );
                            })(),
                        });
                      },
                    }),
                  ];
                },
              }),
              G($.Generic, {
                css: [va],
                as: "div",
                get children() {
                  return G($.Generic, {
                    css: {
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "space-between",
                      borderTopWidth: "1px",
                      "--tw-border-opacity": "0.2",
                      borderColor:
                        "rgb(255 255 255 / var(--tw-border-opacity))",
                      paddingTop: "64rem",
                      "@media (max-width: 767px)": {
                        marginTop: "24rem",
                        flexDirection: "column",
                        alignItems: "flex-start",
                        paddingTop: "24rem",
                      },
                    },
                    as: "div",
                    get children() {
                      return [
                        G($.Generic, {
                          get css() {
                            return [
                              nt.sohne.body3,
                              {
                                display: "flex",
                                alignItems: "center",
                                gap: "32rem",
                                "--tw-text-opacity": "0.5",
                                color:
                                  "rgb(255 255 255 / var(--tw-text-opacity))",
                                "@media (max-width: 767px)": {
                                  flexDirection: "column-reverse",
                                  alignItems: "flex-start",
                                  gap: "16rem",
                                },
                              },
                            ];
                          },
                          as: "ul",
                          get children() {
                            return [
                              G($.Generic, {
                                css: {
                                  "@media (max-width: 767px)": { order: "1" },
                                },
                                as: "li",
                                get children() {
                                  return [
                                    " ",
                                    pe(() => new Date().getFullYear()),
                                    ", Fokus. All Rights Reserved.",
                                  ];
                                },
                              }),
                              G(Yn, {
                                get each() {
                                  return n.footer.footLinks;
                                },
                                children: ({
                                  label: s,
                                  href: o,
                                  isExternal: a,
                                }) =>
                                  (() => {
                                    const l = ft(cf);
                                    return (
                                      Mn(
                                        l,
                                        G(zr, {
                                          href: o,
                                          target: a ? "_blank" : void 0,
                                          children: s,
                                        }),
                                      ),
                                      l
                                    );
                                  })(),
                              }),
                            ];
                          },
                        }),
                        G($.Generic, {
                          get css() {
                            return [
                              nt.sohne.body1,
                              nt.m.sohne.body2,
                              {
                                transitionProperty: "opacity",
                                transitionTimingFunction:
                                  "cubic-bezier(0.4, 0, 0.2, 1)",
                                transitionDuration: "500ms",
                                "&:hover": { opacity: "0.5" },
                                "@media (max-width: 767px)": {
                                  marginTop: "16rem",
                                },
                              },
                            ];
                          },
                          as: "button",
                          onClick: () => {
                            window.scrollTo(0, 0);
                          },
                          children: "Voltar ao topo ",
                        }),
                      ];
                    },
                  });
                },
              }),
            ];
          },
        });
      },
    });
  },
  tq = () => {
    const e = Ev().seo ?? {};
    return [
      G(wW, {
        get children() {
          return e.title ?? "";
        },
      }),
      G(bi, {
        name: "title",
        get content() {
          return e.title ?? "";
        },
      }),
      G(bi, {
        name: "description",
        get content() {
          return e.description ?? "";
        },
      }),
      G(bi, { property: "og:type", content: "website" }),
      G(bi, { property: "og:url", content: "https://format-3.co/" }),
      G(bi, {
        property: "og:title",
        get content() {
          return e.title ?? "";
        },
      }),
      G(bi, {
        property: "og:description",
        get content() {
          return e.description ?? "";
        },
      }),
      G(bi, {
        property: "keywords",
        get content() {
          return e.keywords ?? "";
        },
      }),
      G(Q4, {
        rel: "canonical",
        get href() {
          return `https://format-3.co${e.path ?? ""}`;
        },
      }),
      G(Q4, { rel: "preconnect", href: "https://www.googletagmanager.com" }),
      pe(
        (() => {
          const t = pe(() => !!e.image);
          return () =>
            t() && [
              G(bi, {
                property: "og:image",
                get content() {
                  return e?.image.src;
                },
              }),
              G(bi, {
                property: "og:image:width",
                get content() {
                  return e?.image.width.toString();
                },
              }),
              G(bi, {
                property: "og:image:height",
                get content() {
                  return e?.image.height.toString();
                },
              }),
            ];
        })(),
      ),
      G(bi, { property: "twitter:card", content: "summary_large_image" }),
      G(bi, { property: "twitter:url", content: "https://format-3.co/" }),
      G(bi, {
        property: "twitter:title",
        get content() {
          return e.title ?? "";
        },
      }),
      G(bi, {
        property: "twitter:description",
        get content() {
          return e.description ?? "";
        },
      }),
      pe(
        (() => {
          const t = pe(() => !!e.image);
          return () =>
            t() &&
            G(bi, {
              property: "twitter:image",
              get content() {
                return e?.image.src;
              },
            });
        })(),
      ),
    ];
  },
  nq = xt(
    "<p>We use cookies and similar technologies to personalize your experience. By continuing, you agree to our use of cookies. <!#><!/> | <!#><!/>",
  ),
  RL = "f3-cookie-consent";
function iq() {
  return localStorage.getItem(RL);
}
function rq(n) {
  localStorage.setItem(RL, n);
}
const sq = () => {
    const [n, e] = Jt(!1),
      [t, i] = Jt(!1);
    rr(() => {
      iq() || setTimeout(() => e(!0), 1500);
    });
    const r = (s) => {
      (i(!0),
        setTimeout(() => {
          (rq(s), e(!1));
        }, 300));
    };
    return G(Hl, {
      get when() {
        return n();
      },
      get children() {
        return G($.Generic, {
          css: {
            pointerEvents: "none",
            position: "fixed",
            bottom: "0px",
            left: "0px",
            right: "0px",
            zIndex: "9999",
          },
          as: "div",
          get children() {
            return G($.Generic, {
              get css() {
                return [
                  va,
                  nt.sohne.body5,
                  nt.m.sohne.body3,
                  {
                    "@keyframes slideUp": {
                      from: { transform: "translateY(100%)", opacity: 0 },
                      to: { transform: "translateY(0)", opacity: 1 },
                    },
                    "@keyframes slideDown": {
                      from: { transform: "translateY(0)", opacity: 1 },
                      to: { transform: "translateY(100%)", opacity: 0 },
                    },
                  },
                  {
                    paddingBottom: "24rem",
                    "@media (max-width: 767px)": { paddingBottom: "16rem" },
                  },
                ];
              },
              as: "div",
              get children() {
                return G($.Generic, {
                  get css() {
                    return [
                      {
                        pointerEvents: "auto",
                        display: "flex",
                        alignItems: "center",
                        gap: "32rem",
                        borderRadius: "16rem",
                        borderWidth: "1px",
                        "--tw-border-opacity": "0.1",
                        borderColor:
                          "rgb(255 255 255 / var(--tw-border-opacity))",
                        "--tw-bg-opacity": "1",
                        backgroundColor: "rgb(10 10 10 / var(--tw-bg-opacity))",
                        padding: "24rem",
                        "--tw-backdrop-blur": "blur(24px)",
                        backdropFilter:
                          "var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)",
                        "@media (max-width: 767px)": {
                          flexDirection: "column",
                          alignItems: "stretch",
                          gap: "16rem",
                          padding: "16rem",
                        },
                      },
                      {
                        animation: t()
                          ? "slideDown 0.3s ease-out forwards"
                          : "slideUp 0.4s cubic-bezier(0.16, 1, 0.3, 1) forwards",
                      },
                    ];
                  },
                  as: "div",
                  get children() {
                    return [
                      G($.Generic, {
                        css: {
                          flex: "1 1 0%",
                          "--tw-text-opacity": "0.7",
                          color: "rgb(255 255 255 / var(--tw-text-opacity))",
                        },
                        as: "div",
                        get children() {
                          const s = ft(nq),
                            o = s.firstChild,
                            a = o.nextSibling,
                            [l, c] = Xc(a.nextSibling),
                            u = l.nextSibling,
                            h = u.nextSibling,
                            [d, f] = Xc(h.nextSibling);
                          return (
                            Mn(
                              s,
                              G($.Generic, {
                                href: "/legal/privacy-policy",
                                css: {
                                  "--tw-text-opacity": "1",
                                  color:
                                    "rgb(255 255 255 / var(--tw-text-opacity))",
                                  textDecorationLine: "underline",
                                  textUnderlineOffset: "2px",
                                  transitionProperty:
                                    "color, background-color, border-color, text-decoration-color, fill, stroke",
                                  transitionTimingFunction:
                                    "cubic-bezier(0.4, 0, 0.2, 1)",
                                  transitionDuration: "500ms",
                                  "&:hover": { "--tw-text-opacity": "0.5" },
                                },
                                as: zr,
                                children: "Privacy Policy",
                              }),
                              l,
                              c,
                            ),
                            Mn(
                              s,
                              G($.Generic, {
                                href: "https://app.retention.com/optout",
                                target: "_blank",
                                rel: "noopener noreferrer",
                                css: {
                                  "--tw-text-opacity": "1",
                                  color:
                                    "rgb(255 255 255 / var(--tw-text-opacity))",
                                  textDecorationLine: "underline",
                                  textUnderlineOffset: "2px",
                                  transitionProperty:
                                    "color, background-color, border-color, text-decoration-color, fill, stroke",
                                  transitionTimingFunction:
                                    "cubic-bezier(0.4, 0, 0.2, 1)",
                                  transitionDuration: "500ms",
                                  "&:hover": { "--tw-text-opacity": "0.5" },
                                },
                                as: "a",
                                children: "Opt Out",
                              }),
                              d,
                              f,
                            ),
                            s
                          );
                        },
                      }),
                      G($.Generic, {
                        css: {
                          display: "flex",
                          flexShrink: "0",
                          alignItems: "center",
                          gap: "12rem",
                          "@media (max-width: 767px)": { gap: "8rem" },
                        },
                        as: "div",
                        get children() {
                          return [
                            G($.Button, {
                              onClick: () => r("declined"),
                              get css() {
                                return [
                                  {
                                    cursor: "pointer",
                                    borderRadius: "9999px",
                                    borderWidth: "1px",
                                    "--tw-border-opacity": "0.2",
                                    borderColor:
                                      "rgb(255 255 255 / var(--tw-border-opacity))",
                                    backgroundColor: "transparent",
                                    paddingLeft: "24rem",
                                    paddingRight: "24rem",
                                    paddingTop: "12rem",
                                    paddingBottom: "12rem",
                                    "--tw-text-opacity": "0.7",
                                    color:
                                      "rgb(255 255 255 / var(--tw-text-opacity))",
                                    transitionProperty: "all",
                                    transitionTimingFunction:
                                      "cubic-bezier(0.4, 0, 0.2, 1)",
                                    transitionDuration: "200ms",
                                    "&:hover": {
                                      "--tw-border-opacity": "0.4",
                                      "--tw-text-opacity": "1",
                                    },
                                    "@media (max-width: 767px)": {
                                      paddingLeft: "16rem",
                                      paddingRight: "16rem",
                                      paddingTop: "10rem",
                                      paddingBottom: "10rem",
                                    },
                                  },
                                  nt.sohne.body5,
                                  nt.m.sohne.body3,
                                ];
                              },
                              children: "Decline",
                            }),
                            G($.Button, {
                              onClick: () => r("accepted"),
                              get css() {
                                return [
                                  {
                                    cursor: "pointer",
                                    borderRadius: "9999px",
                                    borderWidth: "1px",
                                    borderColor: "transparent",
                                    "--tw-bg-opacity": "1",
                                    backgroundColor:
                                      "rgb(255 255 255 / var(--tw-bg-opacity))",
                                    paddingLeft: "24rem",
                                    paddingRight: "24rem",
                                    paddingTop: "12rem",
                                    paddingBottom: "12rem",
                                    "--tw-text-opacity": "1",
                                    color:
                                      "rgb(0 0 0 / var(--tw-text-opacity))",
                                    transitionProperty: "all",
                                    transitionTimingFunction:
                                      "cubic-bezier(0.4, 0, 0.2, 1)",
                                    transitionDuration: "200ms",
                                    "&:hover": { "--tw-bg-opacity": "0.9" },
                                    "@media (max-width: 767px)": {
                                      paddingLeft: "16rem",
                                      paddingRight: "16rem",
                                      paddingTop: "10rem",
                                      paddingBottom: "10rem",
                                    },
                                  },
                                  nt.sohne.body5,
                                  nt.m.sohne.body3,
                                ];
                              },
                              children: "Accept",
                            }),
                          ];
                        },
                      }),
                    ];
                  },
                });
              },
            });
          },
        });
      },
    });
  },
  oq = xt("<div><!#><!/><!#><!/><!#><!/>"),
  BL = Fa();
function nI() {
  return ro(BL) ?? (() => !0);
}
const rme = (n) => {
  const [e, t] = Dr(n, ["children"]),
    i = Dn(!1),
    r = gp();
  (rr(() => {
    (window.scrollTo(0, 0),
      Qn(0),
      r.pathname !== "/" && (s_(!0), Vc(1), ll(!0), r_(!0)));
  }),
    Ct(() => {
      r_() && i(!0);
    }));
  const s = Ev();
  return G(BL.Provider, {
    value: i,
    get children() {
      return [
        pe(() => pe(() => !!s?.seo)() && G(tq, {})),
        (() => {
          const o = ft(oq),
            a = o.firstChild,
            [l, c] = Xc(a.nextSibling),
            u = l.nextSibling,
            [h, d] = Xc(u.nextSibling),
            f = h.nextSibling,
            [g, p] = Xc(f.nextSibling);
          return (
            fn(o, t, !1, !0),
            Mn(
              o,
              G($.Generic, {
                css: {
                  position: "relative",
                  zIndex: "10",
                  "--tw-bg-opacity": "1",
                  backgroundColor: "rgb(0 0 0 / var(--tw-bg-opacity))",
                },
                as: "main",
                get children() {
                  return [
                    G(SL, {}),
                    pe(() => e.children),
                    pe(() => pe(() => !!(!s_() && Xb))() && G(JQ, {})),
                  ];
                },
              }),
              l,
              c,
            ),
            Mn(o, G(eq, {}), h, d),
            Mn(o, G(sq, {}), g, p),
            An(),
            o
          );
        })(),
      ];
    },
  });
};
var aq = Object.defineProperty,
  lq = (n, e, t) =>
    e in n
      ? aq(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  kt = (n, e, t) => lq(n, typeof e != "symbol" ? e + "" : e, t),
  cq = class {
    requestAnimationFrame(n) {
      return requestAnimationFrame(n);
    }
    cancelAnimationFrame(n) {
      cancelAnimationFrame(n);
    }
  },
  uq = class {
    constructor() {
      (kt(this, "_lastHandleId", 0), kt(this, "_lastImmediate", null));
    }
    requestAnimationFrame(n) {
      return (
        this._lastHandleId >= Number.MAX_SAFE_INTEGER &&
          (this._lastHandleId = 0),
        (this._lastHandleId += 1),
        (this._lastImmediate = setImmediate(() => {
          n(Date.now());
        })),
        this._lastHandleId
      );
    }
    cancelAnimationFrame(n) {
      this._lastImmediate && clearImmediate(this._lastImmediate);
    }
  },
  hq = class {
    constructor() {
      (kt(this, "_strategy"),
        (this._strategy =
          typeof requestAnimationFrame == "function" ? new cq() : new uq()));
    }
    requestAnimationFrame(n) {
      return this._strategy.requestAnimationFrame(n);
    }
    cancelAnimationFrame(n) {
      this._strategy.cancelAnimationFrame(n);
    }
  },
  Gc = typeof window < "u" && typeof window.document < "u",
  f2 = new Uint8Array([80, 75, 3, 4]),
  dq = ["v", "ip", "op", "layers", "fr", "w", "h"],
  PL = "0.30.3",
  NL = "@lottiefiles/dotlottie-web",
  fq = (() => {
    var n = typeof document < "u" ? document.currentScript?.src : void 0;
    return function (e = {}) {
      var t = e,
        i,
        r,
        s = new Promise((v, w) => {
          ((i = v), (r = w));
        }),
        o = Object.assign({}, t),
        a = "./this.program",
        l = "";
      (typeof document < "u" &&
        document.currentScript &&
        (l = document.currentScript.src),
        n && (l = n),
        l.startsWith("blob:")
          ? (l = "")
          : (l = l.substr(0, l.replace(/[?#].*/, "").lastIndexOf("/") + 1)));
      var c = t.print || console.log.bind(console),
        u = t.printErr || console.error.bind(console);
      (Object.assign(t, o), (o = null), t.thisProgram && (a = t.thisProgram));
      var h;
      t.wasmBinary && (h = t.wasmBinary);
      var d,
        f = !1,
        g,
        p,
        m,
        C,
        A,
        I,
        y,
        x;
      function T() {
        var v = d.buffer;
        ((t.HEAP8 = g = new Int8Array(v)),
          (t.HEAP16 = m = new Int16Array(v)),
          (t.HEAPU8 = p = new Uint8Array(v)),
          (t.HEAPU16 = C = new Uint16Array(v)),
          (t.HEAP32 = A = new Int32Array(v)),
          (t.HEAPU32 = I = new Uint32Array(v)),
          (t.HEAPF32 = y = new Float32Array(v)),
          (t.HEAPF64 = x = new Float64Array(v)));
      }
      var S = [],
        E = [],
        _ = [];
      function b() {
        var v = t.preRun.shift();
        S.unshift(v);
      }
      var R = 0,
        M = null;
      function L(v) {
        throw (
          t.onAbort?.(v),
          (v = "Aborted(" + v + ")"),
          u(v),
          (f = !0),
          (v = new WebAssembly.RuntimeError(
            v + ". Build with -sASSERTIONS for more info.",
          )),
          r(v),
          v
        );
      }
      var P = (v) => v.startsWith("data:application/octet-stream;base64,"),
        U;
      if (((U = "DotLottiePlayer.wasm"), !P(U))) {
        var O = U;
        U = t.locateFile ? t.locateFile(O, l) : l + O;
      }
      function V(v) {
        if (v == U && h) return new Uint8Array(h);
        throw "both async and sync fetching of the wasm failed";
      }
      function W(v) {
        return h || typeof fetch != "function"
          ? Promise.resolve().then(() => V(v))
          : fetch(v, { credentials: "same-origin" })
              .then((w) => {
                if (!w.ok) throw `failed to load wasm binary file at '${v}'`;
                return w.arrayBuffer();
              })
              .catch(() => V(v));
      }
      function re(v, w, D) {
        return W(v)
          .then((F) => WebAssembly.instantiate(F, w))
          .then(D, (F) => {
            (u(`failed to asynchronously prepare wasm: ${F}`), L(F));
          });
      }
      function Z(v, w) {
        var D = U;
        return h ||
          typeof WebAssembly.instantiateStreaming != "function" ||
          P(D) ||
          typeof fetch != "function"
          ? re(D, v, w)
          : fetch(D, { credentials: "same-origin" }).then((F) =>
              WebAssembly.instantiateStreaming(F, v).then(w, function (z) {
                return (
                  u(`wasm streaming compile failed: ${z}`),
                  u("falling back to ArrayBuffer instantiation"),
                  re(D, v, w)
                );
              }),
            );
      }
      var te = (v) => {
          for (; 0 < v.length; ) v.shift()(t);
        },
        ge = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0,
        be = (v, w, D) => {
          var F = w + D;
          for (D = w; v[D] && !(D >= F); ) ++D;
          if (16 < D - w && v.buffer && ge) return ge.decode(v.subarray(w, D));
          for (F = ""; w < D; ) {
            var z = v[w++];
            if (z & 128) {
              var Q = v[w++] & 63;
              if ((z & 224) == 192)
                F += String.fromCharCode(((z & 31) << 6) | Q);
              else {
                var xe = v[w++] & 63;
                ((z =
                  (z & 240) == 224
                    ? ((z & 15) << 12) | (Q << 6) | xe
                    : ((z & 7) << 18) | (Q << 12) | (xe << 6) | (v[w++] & 63)),
                  65536 > z
                    ? (F += String.fromCharCode(z))
                    : ((z -= 65536),
                      (F += String.fromCharCode(
                        55296 | (z >> 10),
                        56320 | (z & 1023),
                      ))));
              }
            } else F += String.fromCharCode(z);
          }
          return F;
        };
      class J {
        constructor(w) {
          this.ya = w - 24;
        }
      }
      var se = 0,
        ce = (v) => {
          for (var w = 0, D = 0; D < v.length; ++D) {
            var F = v.charCodeAt(D);
            127 >= F
              ? w++
              : 2047 >= F
                ? (w += 2)
                : 55296 <= F && 57343 >= F
                  ? ((w += 4), ++D)
                  : (w += 3);
          }
          return w;
        },
        ae = (v, w, D, F) => {
          if (0 < F) {
            F = D + F - 1;
            for (var z = 0; z < v.length; ++z) {
              var Q = v.charCodeAt(z);
              if (55296 <= Q && 57343 >= Q) {
                var xe = v.charCodeAt(++z);
                Q = (65536 + ((Q & 1023) << 10)) | (xe & 1023);
              }
              if (127 >= Q) {
                if (D >= F) break;
                w[D++] = Q;
              } else {
                if (2047 >= Q) {
                  if (D + 1 >= F) break;
                  w[D++] = 192 | (Q >> 6);
                } else {
                  if (65535 >= Q) {
                    if (D + 2 >= F) break;
                    w[D++] = 224 | (Q >> 12);
                  } else {
                    if (D + 3 >= F) break;
                    ((w[D++] = 240 | (Q >> 18)),
                      (w[D++] = 128 | ((Q >> 12) & 63)));
                  }
                  w[D++] = 128 | ((Q >> 6) & 63);
                }
                w[D++] = 128 | (Q & 63);
              }
            }
            w[D] = 0;
          }
        },
        Ce = {},
        $e = (v) => {
          for (; v.length; ) {
            var w = v.pop();
            v.pop()(w);
          }
        };
      function Te(v) {
        return this.fromWireType(I[v >> 2]);
      }
      var it = {},
        ct = {},
        qe = {},
        H,
        tn = (v, w, D) => {
          function F(ue) {
            if (((ue = D(ue)), ue.length !== v.length))
              throw new H("Mismatched type converter count");
            for (var We = 0; We < v.length; ++We) Ze(v[We], ue[We]);
          }
          v.forEach(function (ue) {
            qe[ue] = w;
          });
          var z = Array(w.length),
            Q = [],
            xe = 0;
          (w.forEach((ue, We) => {
            ct.hasOwnProperty(ue)
              ? (z[We] = ct[ue])
              : (Q.push(ue),
                it.hasOwnProperty(ue) || (it[ue] = []),
                it[ue].push(() => {
                  ((z[We] = ct[ue]), ++xe, xe === Q.length && F(z));
                }));
          }),
            Q.length === 0 && F(z));
        },
        Mt,
        ot = (v) => {
          for (var w = ""; p[v]; ) w += Mt[p[v++]];
          return w;
        },
        Ae;
      function _n(v, w, D = {}) {
        var F = w.name;
        if (!v)
          throw new Ae(
            `type "${F}" must have a positive integer typeid pointer`,
          );
        if (ct.hasOwnProperty(v)) {
          if (D.ib) return;
          throw new Ae(`Cannot register type '${F}' twice`);
        }
        ((ct[v] = w),
          delete qe[v],
          it.hasOwnProperty(v) &&
            ((w = it[v]), delete it[v], w.forEach((z) => z())));
      }
      function Ze(v, w, D = {}) {
        if (!("argPackAdvance" in w))
          throw new TypeError(
            "registerType registeredInstance requires argPackAdvance",
          );
        return _n(v, w, D);
      }
      var k = (v) => {
          throw new Ae(v.ma.za.xa.name + " instance already deleted");
        },
        B = !1,
        q = () => {},
        fe = (v, w, D) =>
          w === D
            ? v
            : D.Ca === void 0
              ? null
              : ((v = fe(v, w, D.Ca)), v === null ? null : D.ab(v)),
        Ie = {},
        le = [],
        Ke = () => {
          for (; le.length; ) {
            var v = le.pop();
            ((v.ma.Ka = !1), v.delete());
          }
        },
        Ee,
        rt = {},
        pt = (v, w) => {
          if (w === void 0) throw new Ae("ptr should not be undefined");
          for (; v.Ca; ) ((w = v.Na(w)), (v = v.Ca));
          return rt[w];
        },
        ye = (v, w) => {
          if (!w.za || !w.ya)
            throw new H("makeClassHandle requires ptr and ptrType");
          if (!!w.Da != !!w.Aa)
            throw new H("Both smartPtrType and smartPtr must be specified");
          return (
            (w.count = { value: 1 }),
            Ue(Object.create(v, { ma: { value: w, writable: !0 } }))
          );
        },
        Ue = (v) =>
          typeof FinalizationRegistry > "u"
            ? ((Ue = (w) => w), v)
            : ((B = new FinalizationRegistry((w) => {
                ((w = w.ma),
                  --w.count.value,
                  w.count.value === 0 &&
                    (w.Aa ? w.Da.Fa(w.Aa) : w.za.xa.Fa(w.ya)));
              })),
              (Ue = (w) => {
                var D = w.ma;
                return (D.Aa && B.register(w, { ma: D }, w), w);
              }),
              (q = (w) => {
                B.unregister(w);
              }),
              Ue(v));
      function ut() {}
      var ht = (v, w) => Object.defineProperty(w, "name", { value: v }),
        ze = (v, w, D) => {
          if (v[w].Ba === void 0) {
            var F = v[w];
            ((v[w] = function (...z) {
              if (!v[w].Ba.hasOwnProperty(z.length))
                throw new Ae(
                  `Function '${D}' called with an invalid number of arguments (${z.length}) - expects one of (${v[w].Ba})!`,
                );
              return v[w].Ba[z.length].apply(this, z);
            }),
              (v[w].Ba = []),
              (v[w].Ba[F.Oa] = F));
          }
        },
        Ft = (v, w, D) => {
          if (t.hasOwnProperty(v)) {
            if (D === void 0 || (t[v].Ba !== void 0 && t[v].Ba[D] !== void 0))
              throw new Ae(`Cannot register public name '${v}' twice`);
            if ((ze(t, v, v), t.hasOwnProperty(D)))
              throw new Ae(
                `Cannot register multiple overloads of a function with the same number of arguments (${D})!`,
              );
            t[v].Ba[D] = w;
          } else ((t[v] = w), D !== void 0 && (t[v].vb = D));
        },
        Lt = (v) => {
          if (v === void 0) return "_unknown";
          v = v.replace(/[^a-zA-Z0-9_]/g, "$");
          var w = v.charCodeAt(0);
          return 48 <= w && 57 >= w ? `_${v}` : v;
        };
      function pn(v, w, D, F, z, Q, xe, ue) {
        ((this.name = v),
          (this.constructor = w),
          (this.La = D),
          (this.Fa = F),
          (this.Ca = z),
          (this.cb = Q),
          (this.Na = xe),
          (this.ab = ue),
          (this.kb = []));
      }
      var Y = (v, w, D) => {
        for (; w !== D; ) {
          if (!w.Na)
            throw new Ae(
              `Expected null or instance of ${D.name}, got an instance of ${w.name}`,
            );
          ((v = w.Na(v)), (w = w.Ca));
        }
        return v;
      };
      function Fe(v, w) {
        if (w === null) {
          if (this.Ta) throw new Ae(`null is not a valid ${this.name}`);
          return 0;
        }
        if (!w.ma) throw new Ae(`Cannot pass "${tf(w)}" as a ${this.name}`);
        if (!w.ma.ya)
          throw new Ae(
            `Cannot pass deleted object as a pointer of type ${this.name}`,
          );
        return Y(w.ma.ya, w.ma.za.xa, this.xa);
      }
      function oe(v, w) {
        if (w === null) {
          if (this.Ta) throw new Ae(`null is not a valid ${this.name}`);
          if (this.Qa) {
            var D = this.Ua();
            return (v !== null && v.push(this.Fa, D), D);
          }
          return 0;
        }
        if (!w || !w.ma)
          throw new Ae(`Cannot pass "${tf(w)}" as a ${this.name}`);
        if (!w.ma.ya)
          throw new Ae(
            `Cannot pass deleted object as a pointer of type ${this.name}`,
          );
        if (!this.Pa && w.ma.za.Pa)
          throw new Ae(
            `Cannot convert argument of type ${w.ma.Da ? w.ma.Da.name : w.ma.za.name} to parameter type ${this.name}`,
          );
        if (((D = Y(w.ma.ya, w.ma.za.xa, this.xa)), this.Qa)) {
          if (w.ma.Aa === void 0)
            throw new Ae("Passing raw pointer to smart pointer is illegal");
          switch (this.pb) {
            case 0:
              if (w.ma.Da === this) D = w.ma.Aa;
              else
                throw new Ae(
                  `Cannot convert argument of type ${w.ma.Da ? w.ma.Da.name : w.ma.za.name} to parameter type ${this.name}`,
                );
              break;
            case 1:
              D = w.ma.Aa;
              break;
            case 2:
              if (w.ma.Da === this) D = w.ma.Aa;
              else {
                var F = w.clone();
                ((D = this.lb(
                  D,
                  $l(() => F.delete()),
                )),
                  v !== null && v.push(this.Fa, D));
              }
              break;
            default:
              throw new Ae("Unsupporting sharing policy");
          }
        }
        return D;
      }
      function me(v, w) {
        if (w === null) {
          if (this.Ta) throw new Ae(`null is not a valid ${this.name}`);
          return 0;
        }
        if (!w.ma) throw new Ae(`Cannot pass "${tf(w)}" as a ${this.name}`);
        if (!w.ma.ya)
          throw new Ae(
            `Cannot pass deleted object as a pointer of type ${this.name}`,
          );
        if (w.ma.za.Pa)
          throw new Ae(
            `Cannot convert argument of type ${w.ma.za.name} to parameter type ${this.name}`,
          );
        return Y(w.ma.ya, w.ma.za.xa, this.xa);
      }
      function Re(v, w, D, F, z, Q, xe, ue, We, we, Ve) {
        ((this.name = v),
          (this.xa = w),
          (this.Ta = D),
          (this.Pa = F),
          (this.Qa = z),
          (this.jb = Q),
          (this.pb = xe),
          (this.Za = ue),
          (this.Ua = We),
          (this.lb = we),
          (this.Fa = Ve),
          z || w.Ca !== void 0
            ? (this.toWireType = oe)
            : ((this.toWireType = F ? Fe : me), (this.Ea = null)));
      }
      var Ge = (v, w, D) => {
          if (!t.hasOwnProperty(v))
            throw new H("Replacing nonexistent public symbol");
          t[v].Ba !== void 0 && D !== void 0
            ? (t[v].Ba[D] = w)
            : ((t[v] = w), (t[v].Oa = D));
        },
        at,
        Bn = (v, w, D = []) => (
          v.includes("j")
            ? ((v = v.replace(/p/g, "i")),
              (w = (0, t["dynCall_" + v])(w, ...D)))
            : (w = at.get(w)(...D)),
          w
        ),
        Ii =
          (v, w) =>
          (...D) =>
            Bn(v, w, D),
        yt = (v, w) => {
          v = ot(v);
          var D = v.includes("j") ? Ii(v, w) : at.get(w);
          if (typeof D != "function")
            throw new Ae(`unknown function pointer with signature ${v}: ${w}`);
          return D;
        },
        Ar,
        ss = (v) => {
          v = sr(v);
          var w = ot(v);
          return (En(v), w);
        },
        Kl = (v, w) => {
          function D(Q) {
            z[Q] ||
              ct[Q] ||
              (qe[Q] ? qe[Q].forEach(D) : (F.push(Q), (z[Q] = !0)));
          }
          var F = [],
            z = {};
          throw (w.forEach(D), new Ar(`${v}: ` + F.map(ss).join([", "])));
        },
        Mu = (v, w) => {
          for (var D = [], F = 0; F < v; F++) D.push(I[(w + 4 * F) >> 2]);
          return D;
        };
      function Xo(v) {
        for (var w = 1; w < v.length; ++w)
          if (v[w] !== null && v[w].Ea === void 0) return !0;
        return !1;
      }
      function jl(v, w, D, F, z) {
        var Q = w.length;
        if (2 > Q)
          throw new Ae(
            "argTypes array size mismatch! Must at least get return value and 'this' types!",
          );
        var xe = w[1] !== null && D !== null,
          ue = Xo(w),
          We = w[0].name !== "void",
          we = Q - 2,
          Ve = Array(we),
          Yt = [],
          un = [];
        return ht(v, function (...ie) {
          if (ie.length !== we)
            throw new Ae(
              `function ${v} called with ${ie.length} arguments, expected ${we}`,
            );
          if (((un.length = 0), (Yt.length = xe ? 2 : 1), (Yt[0] = z), xe)) {
            var mt = w[1].toWireType(un, this);
            Yt[1] = mt;
          }
          for (var wt = 0; wt < we; ++wt)
            ((Ve[wt] = w[wt + 2].toWireType(un, ie[wt])), Yt.push(Ve[wt]));
          if (((ie = F(...Yt)), ue)) $e(un);
          else
            for (wt = xe ? 1 : 2; wt < w.length; wt++) {
              var ci = wt === 1 ? mt : Ve[wt - 2];
              w[wt].Ea !== null && w[wt].Ea(ci);
            }
          return ((mt = We ? w[0].fromWireType(ie) : void 0), mt);
        });
      }
      var Qd = (v) => {
          v = v.trim();
          let w = v.indexOf("(");
          return w !== -1 ? v.substr(0, w) : v;
        },
        Lu = [],
        yr = [],
        Ru = (v) => {
          9 < v && --yr[v + 1] === 0 && ((yr[v] = void 0), Lu.push(v));
        },
        Oa = (v) => {
          if (!v) throw new Ae("Cannot use deleted val. handle = " + v);
          return yr[v];
        },
        $l = (v) => {
          switch (v) {
            case void 0:
              return 2;
            case null:
              return 4;
            case !0:
              return 6;
            case !1:
              return 8;
            default:
              let w = Lu.pop() || yr.length;
              return ((yr[w] = v), (yr[w + 1] = 1), w);
          }
        },
        qd = {
          name: "emscripten::val",
          fromWireType: (v) => {
            var w = Oa(v);
            return (Ru(v), w);
          },
          toWireType: (v, w) => $l(w),
          argPackAdvance: 8,
          readValueFromPointer: Te,
          Ea: null,
        },
        bI = (v, w, D) => {
          switch (w) {
            case 1:
              return D
                ? function (F) {
                    return this.fromWireType(g[F]);
                  }
                : function (F) {
                    return this.fromWireType(p[F]);
                  };
            case 2:
              return D
                ? function (F) {
                    return this.fromWireType(m[F >> 1]);
                  }
                : function (F) {
                    return this.fromWireType(C[F >> 1]);
                  };
            case 4:
              return D
                ? function (F) {
                    return this.fromWireType(A[F >> 2]);
                  }
                : function (F) {
                    return this.fromWireType(I[F >> 2]);
                  };
            default:
              throw new TypeError(`invalid integer width (${w}): ${v}`);
          }
        },
        ef = (v, w) => {
          var D = ct[v];
          if (D === void 0)
            throw ((v = `${w} has unknown type ${ss(v)}`), new Ae(v));
          return D;
        },
        tf = (v) => {
          if (v === null) return "null";
          var w = typeof v;
          return w === "object" || w === "array" || w === "function"
            ? v.toString()
            : "" + v;
        },
        vI = (v, w) => {
          switch (w) {
            case 4:
              return function (D) {
                return this.fromWireType(y[D >> 2]);
              };
            case 8:
              return function (D) {
                return this.fromWireType(x[D >> 3]);
              };
            default:
              throw new TypeError(`invalid float width (${w}): ${v}`);
          }
        },
        xI = (v, w, D) => {
          switch (w) {
            case 1:
              return D ? (F) => g[F] : (F) => p[F];
            case 2:
              return D ? (F) => m[F >> 1] : (F) => C[F >> 1];
            case 4:
              return D ? (F) => A[F >> 2] : (F) => I[F >> 2];
            default:
              throw new TypeError(`invalid integer width (${w}): ${v}`);
          }
        },
        Np = typeof TextDecoder < "u" ? new TextDecoder("utf-16le") : void 0,
        N = (v, w) => {
          for (var D = v >> 1, F = D + w / 2; !(D >= F) && C[D]; ) ++D;
          if (((D <<= 1), 32 < D - v && Np)) return Np.decode(p.subarray(v, D));
          for (D = "", F = 0; !(F >= w / 2); ++F) {
            var z = m[(v + 2 * F) >> 1];
            if (z == 0) break;
            D += String.fromCharCode(z);
          }
          return D;
        },
        K = (v, w, D) => {
          if ((D ?? (D = 2147483647), 2 > D)) return 0;
          D -= 2;
          var F = w;
          D = D < 2 * v.length ? D / 2 : v.length;
          for (var z = 0; z < D; ++z) ((m[w >> 1] = v.charCodeAt(z)), (w += 2));
          return ((m[w >> 1] = 0), w - F);
        },
        ee = (v) => 2 * v.length,
        ne = (v, w) => {
          for (var D = 0, F = ""; !(D >= w / 4); ) {
            var z = A[(v + 4 * D) >> 2];
            if (z == 0) break;
            (++D,
              65536 <= z
                ? ((z -= 65536),
                  (F += String.fromCharCode(
                    55296 | (z >> 10),
                    56320 | (z & 1023),
                  )))
                : (F += String.fromCharCode(z)));
          }
          return F;
        },
        j = (v, w, D) => {
          if ((D ?? (D = 2147483647), 4 > D)) return 0;
          var F = w;
          D = F + D - 4;
          for (var z = 0; z < v.length; ++z) {
            var Q = v.charCodeAt(z);
            if (55296 <= Q && 57343 >= Q) {
              var xe = v.charCodeAt(++z);
              Q = (65536 + ((Q & 1023) << 10)) | (xe & 1023);
            }
            if (((A[w >> 2] = Q), (w += 4), w + 4 > D)) break;
          }
          return ((A[w >> 2] = 0), w - F);
        },
        _e = (v) => {
          for (var w = 0, D = 0; D < v.length; ++D) {
            var F = v.charCodeAt(D);
            (55296 <= F && 57343 >= F && ++D, (w += 4));
          }
          return w;
        },
        Le = [],
        He = (v) => {
          var w = Le.length;
          return (Le.push(v), w);
        },
        Xe = (v, w) => {
          for (var D = Array(v), F = 0; F < v; ++F)
            D[F] = ef(I[(w + 4 * F) >> 2], "parameter " + F);
          return D;
        },
        It = Reflect.construct,
        gt = {},
        st = () => {
          if (!Ot) {
            var v = {
                USER: "web_user",
                LOGNAME: "web_user",
                PATH: "/",
                PWD: "/",
                HOME: "/home/web_user",
                LANG:
                  (
                    (typeof navigator == "object" &&
                      navigator.languages &&
                      navigator.languages[0]) ||
                    "C"
                  ).replace("-", "_") + ".UTF-8",
                _: a || "./this.program",
              },
              w;
            for (w in gt) gt[w] === void 0 ? delete v[w] : (v[w] = gt[w]);
            var D = [];
            for (w in v) D.push(`${w}=${v[w]}`);
            Ot = D;
          }
          return Ot;
        },
        Ot,
        nn = [null, [], []],
        Vn = () => {
          if (
            typeof crypto == "object" &&
            typeof crypto.getRandomValues == "function"
          )
            return (v) => crypto.getRandomValues(v);
          L("initRandomDevice");
        },
        Tn = (v) => (Tn = Vn())(v),
        Ut = (v) => v % 4 === 0 && (v % 100 !== 0 || v % 400 === 0),
        lt = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        qn = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function rn(v) {
        var w = Array(ce(v) + 1);
        return (ae(v, w, 0, w.length), w);
      }
      var Gr = (v, w, D, F) => {
        function z(ie, mt, wt) {
          for (
            ie = typeof ie == "number" ? ie.toString() : ie || "";
            ie.length < mt;
          )
            ie = wt[0] + ie;
          return ie;
        }
        function Q(ie, mt) {
          return z(ie, mt, "0");
        }
        function xe(ie, mt) {
          function wt(Ua) {
            return 0 > Ua ? -1 : 0 < Ua ? 1 : 0;
          }
          var ci;
          return (
            (ci = wt(ie.getFullYear() - mt.getFullYear())) === 0 &&
              (ci = wt(ie.getMonth() - mt.getMonth())) === 0 &&
              (ci = wt(ie.getDate() - mt.getDate())),
            ci
          );
        }
        function ue(ie) {
          switch (ie.getDay()) {
            case 0:
              return new Date(ie.getFullYear() - 1, 11, 29);
            case 1:
              return ie;
            case 2:
              return new Date(ie.getFullYear(), 0, 3);
            case 3:
              return new Date(ie.getFullYear(), 0, 2);
            case 4:
              return new Date(ie.getFullYear(), 0, 1);
            case 5:
              return new Date(ie.getFullYear() - 1, 11, 31);
            case 6:
              return new Date(ie.getFullYear() - 1, 11, 30);
          }
        }
        function We(ie) {
          var mt = ie.Ia;
          for (
            ie = new Date(new Date(ie.Ja + 1900, 0, 1).getTime());
            0 < mt;
          ) {
            var wt = ie.getMonth(),
              ci = (Ut(ie.getFullYear()) ? lt : qn)[wt];
            if (mt > ci - ie.getDate())
              ((mt -= ci - ie.getDate() + 1),
                ie.setDate(1),
                11 > wt
                  ? ie.setMonth(wt + 1)
                  : (ie.setMonth(0), ie.setFullYear(ie.getFullYear() + 1)));
            else {
              ie.setDate(ie.getDate() + mt);
              break;
            }
          }
          return (
            (wt = new Date(ie.getFullYear() + 1, 0, 4)),
            (mt = ue(new Date(ie.getFullYear(), 0, 4))),
            (wt = ue(wt)),
            0 >= xe(mt, ie)
              ? 0 >= xe(wt, ie)
                ? ie.getFullYear() + 1
                : ie.getFullYear()
              : ie.getFullYear() - 1
          );
        }
        var we = I[(F + 40) >> 2];
        ((F = {
          sb: A[F >> 2],
          rb: A[(F + 4) >> 2],
          Ra: A[(F + 8) >> 2],
          Va: A[(F + 12) >> 2],
          Sa: A[(F + 16) >> 2],
          Ja: A[(F + 20) >> 2],
          Ga: A[(F + 24) >> 2],
          Ia: A[(F + 28) >> 2],
          wb: A[(F + 32) >> 2],
          qb: A[(F + 36) >> 2],
          tb: we && we ? be(p, we) : "",
        }),
          (D = D ? be(p, D) : ""),
          (we = {
            "%c": "%a %b %d %H:%M:%S %Y",
            "%D": "%m/%d/%y",
            "%F": "%Y-%m-%d",
            "%h": "%b",
            "%r": "%I:%M:%S %p",
            "%R": "%H:%M",
            "%T": "%H:%M:%S",
            "%x": "%m/%d/%y",
            "%X": "%H:%M:%S",
            "%Ec": "%c",
            "%EC": "%C",
            "%Ex": "%m/%d/%y",
            "%EX": "%H:%M:%S",
            "%Ey": "%y",
            "%EY": "%Y",
            "%Od": "%d",
            "%Oe": "%e",
            "%OH": "%H",
            "%OI": "%I",
            "%Om": "%m",
            "%OM": "%M",
            "%OS": "%S",
            "%Ou": "%u",
            "%OU": "%U",
            "%OV": "%V",
            "%Ow": "%w",
            "%OW": "%W",
            "%Oy": "%y",
          }));
        for (var Ve in we) D = D.replace(new RegExp(Ve, "g"), we[Ve]);
        var Yt =
            "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(
              " ",
            ),
          un =
            "January February March April May June July August September October November December".split(
              " ",
            );
        ((we = {
          "%a": (ie) => Yt[ie.Ga].substring(0, 3),
          "%A": (ie) => Yt[ie.Ga],
          "%b": (ie) => un[ie.Sa].substring(0, 3),
          "%B": (ie) => un[ie.Sa],
          "%C": (ie) => Q(((ie.Ja + 1900) / 100) | 0, 2),
          "%d": (ie) => Q(ie.Va, 2),
          "%e": (ie) => z(ie.Va, 2, " "),
          "%g": (ie) => We(ie).toString().substring(2),
          "%G": We,
          "%H": (ie) => Q(ie.Ra, 2),
          "%I": (ie) => (
            (ie = ie.Ra),
            ie == 0 ? (ie = 12) : 12 < ie && (ie -= 12),
            Q(ie, 2)
          ),
          "%j": (ie) => {
            for (
              var mt = 0, wt = 0;
              wt <= ie.Sa - 1;
              mt += (Ut(ie.Ja + 1900) ? lt : qn)[wt++]
            );
            return Q(ie.Va + mt, 3);
          },
          "%m": (ie) => Q(ie.Sa + 1, 2),
          "%M": (ie) => Q(ie.rb, 2),
          "%n": () => `
`,
          "%p": (ie) => (0 <= ie.Ra && 12 > ie.Ra ? "AM" : "PM"),
          "%S": (ie) => Q(ie.sb, 2),
          "%t": () => "	",
          "%u": (ie) => ie.Ga || 7,
          "%U": (ie) => Q(Math.floor((ie.Ia + 7 - ie.Ga) / 7), 2),
          "%V": (ie) => {
            var mt = Math.floor((ie.Ia + 7 - ((ie.Ga + 6) % 7)) / 7);
            if ((2 >= (ie.Ga + 371 - ie.Ia - 2) % 7 && mt++, mt))
              mt == 53 &&
                ((wt = (ie.Ga + 371 - ie.Ia) % 7),
                wt == 4 || (wt == 3 && Ut(ie.Ja)) || (mt = 1));
            else {
              mt = 52;
              var wt = (ie.Ga + 7 - ie.Ia - 1) % 7;
              (wt == 4 || (wt == 5 && Ut((ie.Ja % 400) - 1))) && mt++;
            }
            return Q(mt, 2);
          },
          "%w": (ie) => ie.Ga,
          "%W": (ie) => Q(Math.floor((ie.Ia + 7 - ((ie.Ga + 6) % 7)) / 7), 2),
          "%y": (ie) => (ie.Ja + 1900).toString().substring(2),
          "%Y": (ie) => ie.Ja + 1900,
          "%z": (ie) => {
            ie = ie.qb;
            var mt = 0 <= ie;
            return (
              (ie = Math.abs(ie) / 60),
              (mt ? "+" : "-") +
                ("0000" + ((ie / 60) * 100 + (ie % 60))).slice(-4)
            );
          },
          "%Z": (ie) => ie.tb,
          "%%": () => "%",
        }),
          (D = D.replace(/%%/g, "\0\0")));
        for (Ve in we)
          D.includes(Ve) && (D = D.replace(new RegExp(Ve, "g"), we[Ve](F)));
        return (
          (D = D.replace(/\0\0/g, "%")),
          (Ve = rn(D)),
          Ve.length > w ? 0 : (g.set(Ve, v), Ve.length - 1)
        );
      };
      H = t.InternalError = class extends Error {
        constructor(v) {
          (super(v), (this.name = "InternalError"));
        }
      };
      for (var Ko = Array(256), Ai = 0; 256 > Ai; ++Ai)
        Ko[Ai] = String.fromCharCode(Ai);
      ((Mt = Ko),
        (Ae = t.BindingError =
          class extends Error {
            constructor(v) {
              (super(v), (this.name = "BindingError"));
            }
          }),
        Object.assign(ut.prototype, {
          isAliasOf: function (v) {
            if (!(this instanceof ut && v instanceof ut)) return !1;
            var w = this.ma.za.xa,
              D = this.ma.ya;
            v.ma = v.ma;
            var F = v.ma.za.xa;
            for (v = v.ma.ya; w.Ca; ) ((D = w.Na(D)), (w = w.Ca));
            for (; F.Ca; ) ((v = F.Na(v)), (F = F.Ca));
            return w === F && D === v;
          },
          clone: function () {
            if ((this.ma.ya || k(this), this.ma.Ma))
              return ((this.ma.count.value += 1), this);
            var v = Ue,
              w = Object,
              D = w.create,
              F = Object.getPrototypeOf(this),
              z = this.ma;
            return (
              (v = v(
                D.call(w, F, {
                  ma: {
                    value: {
                      count: z.count,
                      Ka: z.Ka,
                      Ma: z.Ma,
                      ya: z.ya,
                      za: z.za,
                      Aa: z.Aa,
                      Da: z.Da,
                    },
                  },
                }),
              )),
              (v.ma.count.value += 1),
              (v.ma.Ka = !1),
              v
            );
          },
          delete() {
            if ((this.ma.ya || k(this), this.ma.Ka && !this.ma.Ma))
              throw new Ae("Object already scheduled for deletion");
            q(this);
            var v = this.ma;
            (--v.count.value,
              v.count.value === 0 && (v.Aa ? v.Da.Fa(v.Aa) : v.za.xa.Fa(v.ya)),
              this.ma.Ma || ((this.ma.Aa = void 0), (this.ma.ya = void 0)));
          },
          isDeleted: function () {
            return !this.ma.ya;
          },
          deleteLater: function () {
            if ((this.ma.ya || k(this), this.ma.Ka && !this.ma.Ma))
              throw new Ae("Object already scheduled for deletion");
            return (
              le.push(this),
              le.length === 1 && Ee && Ee(Ke),
              (this.ma.Ka = !0),
              this
            );
          },
        }),
        (t.getInheritedInstanceCount = () => Object.keys(rt).length),
        (t.getLiveInheritedInstances = () => {
          var v = [],
            w;
          for (w in rt) rt.hasOwnProperty(w) && v.push(rt[w]);
          return v;
        }),
        (t.flushPendingDeletes = Ke),
        (t.setDelayFunction = (v) => {
          ((Ee = v), le.length && Ee && Ee(Ke));
        }),
        Object.assign(Re.prototype, {
          eb(v) {
            return (this.Za && (v = this.Za(v)), v);
          },
          Xa(v) {
            this.Fa?.(v);
          },
          argPackAdvance: 8,
          readValueFromPointer: Te,
          fromWireType: function (v) {
            function w() {
              return this.Qa
                ? ye(this.xa.La, { za: this.jb, ya: D, Da: this, Aa: v })
                : ye(this.xa.La, { za: this, ya: v });
            }
            var D = this.eb(v);
            if (!D) return (this.Xa(v), null);
            var F = pt(this.xa, D);
            if (F !== void 0)
              return F.ma.count.value === 0
                ? ((F.ma.ya = D), (F.ma.Aa = v), F.clone())
                : ((F = F.clone()), this.Xa(v), F);
            if (((F = this.xa.cb(D)), (F = Ie[F]), !F)) return w.call(this);
            F = this.Pa ? F.$a : F.pointerType;
            var z = fe(D, this.xa, F.xa);
            return z === null
              ? w.call(this)
              : this.Qa
                ? ye(F.xa.La, { za: F, ya: z, Da: this, Aa: v })
                : ye(F.xa.La, { za: F, ya: z });
          },
        }),
        (Ar = t.UnboundTypeError =
          ((v, w) => {
            var D = ht(w, function (F) {
              ((this.name = w),
                (this.message = F),
                (F = Error(F).stack),
                F !== void 0 &&
                  (this.stack =
                    this.toString() +
                    `
` +
                    F.replace(/^Error(:[^\n]*)?\n/, "")));
            });
            return (
              (D.prototype = Object.create(v.prototype)),
              (D.prototype.constructor = D),
              (D.prototype.toString = function () {
                return this.message === void 0
                  ? this.name
                  : `${this.name}: ${this.message}`;
              }),
              D
            );
          })(Error, "UnboundTypeError")),
        yr.push(0, 1, void 0, 1, null, 1, !0, 1, !1, 1),
        (t.count_emval_handles = () => yr.length / 2 - 5 - Lu.length));
      var Jl = {
          c: (v, w, D, F) => {
            L(
              `Assertion failed: ${v ? be(p, v) : ""}, at: ` +
                [
                  w ? (w ? be(p, w) : "") : "unknown filename",
                  D,
                  F ? (F ? be(p, F) : "") : "unknown function",
                ],
            );
          },
          m: (v, w, D) => {
            var F = new J(v);
            throw (
              (I[(F.ya + 16) >> 2] = 0),
              (I[(F.ya + 4) >> 2] = w),
              (I[(F.ya + 8) >> 2] = D),
              (se = v),
              se
            );
          },
          B: function () {
            return 0;
          },
          P: () => {},
          M: () => {},
          R: function () {
            return 0;
          },
          N: () => {},
          A: function () {},
          O: () => {},
          v: (v) => {
            var w = Ce[v];
            delete Ce[v];
            var D = w.Ua,
              F = w.Fa,
              z = w.Ya,
              Q = z.map((xe) => xe.hb).concat(z.map((xe) => xe.nb));
            tn([v], Q, (xe) => {
              var ue = {};
              return (
                z.forEach((We, we) => {
                  var Ve = xe[we],
                    Yt = We.fb,
                    un = We.gb,
                    ie = xe[we + z.length],
                    mt = We.mb,
                    wt = We.ob;
                  ue[We.bb] = {
                    read: (ci) => Ve.fromWireType(Yt(un, ci)),
                    write: (ci, Ua) => {
                      var Fr = [];
                      (mt(wt, ci, ie.toWireType(Fr, Ua)), $e(Fr));
                    },
                  };
                }),
                [
                  {
                    name: w.name,
                    fromWireType: (We) => {
                      var we = {},
                        Ve;
                      for (Ve in ue) we[Ve] = ue[Ve].read(We);
                      return (F(We), we);
                    },
                    toWireType: (We, we) => {
                      for (var Ve in ue)
                        if (!(Ve in we))
                          throw new TypeError(`Missing field: "${Ve}"`);
                      var Yt = D();
                      for (Ve in ue) ue[Ve].write(Yt, we[Ve]);
                      return (We !== null && We.push(F, Yt), Yt);
                    },
                    argPackAdvance: 8,
                    readValueFromPointer: Te,
                    Ea: F,
                  },
                ]
              );
            });
          },
          I: () => {},
          Y: (v, w, D, F) => {
            ((w = ot(w)),
              Ze(v, {
                name: w,
                fromWireType: function (z) {
                  return !!z;
                },
                toWireType: function (z, Q) {
                  return Q ? D : F;
                },
                argPackAdvance: 8,
                readValueFromPointer: function (z) {
                  return this.fromWireType(p[z]);
                },
                Ea: null,
              }));
          },
          r: (v, w, D, F, z, Q, xe, ue, We, we, Ve, Yt, un) => {
            ((Ve = ot(Ve)),
              (Q = yt(z, Q)),
              ue && (ue = yt(xe, ue)),
              we && (we = yt(We, we)),
              (un = yt(Yt, un)));
            var ie = Lt(Ve);
            (Ft(ie, function () {
              Kl(`Cannot construct ${Ve} due to unbound types`, [F]);
            }),
              tn([v, w, D], F ? [F] : [], (mt) => {
                if (((mt = mt[0]), F))
                  var wt = mt.xa,
                    ci = wt.La;
                else ci = ut.prototype;
                mt = ht(Ve, function (...wI) {
                  if (Object.getPrototypeOf(this) !== Ua)
                    throw new Ae("Use 'new' to construct " + Ve);
                  if (Fr.Ha === void 0)
                    throw new Ae(Ve + " has no accessible constructor");
                  var D5 = Fr.Ha[wI.length];
                  if (D5 === void 0)
                    throw new Ae(
                      `Tried to invoke ctor of ${Ve} with invalid number of parameters (${wI.length}) - expected (${Object.keys(Fr.Ha).toString()}) parameters instead!`,
                    );
                  return D5.apply(this, wI);
                });
                var Ua = Object.create(ci, { constructor: { value: mt } });
                mt.prototype = Ua;
                var Fr = new pn(Ve, mt, Ua, un, wt, Q, ue, we);
                if (Fr.Ca) {
                  var nf;
                  ((nf = Fr.Ca).Wa ?? (nf.Wa = []), Fr.Ca.Wa.push(Fr));
                }
                return (
                  (wt = new Re(Ve, Fr, !0, !1, !1)),
                  (nf = new Re(Ve + "*", Fr, !1, !1, !1)),
                  (ci = new Re(Ve + " const*", Fr, !1, !0, !1)),
                  (Ie[v] = { pointerType: nf, $a: ci }),
                  Ge(ie, mt),
                  [wt, nf, ci]
                );
              }));
          },
          q: (v, w, D, F, z, Q) => {
            var xe = Mu(w, D);
            ((z = yt(F, z)),
              tn([], [v], (ue) => {
                ue = ue[0];
                var We = `constructor ${ue.name}`;
                if (
                  (ue.xa.Ha === void 0 && (ue.xa.Ha = []),
                  ue.xa.Ha[w - 1] !== void 0)
                )
                  throw new Ae(
                    `Cannot register multiple constructors with identical number of parameters (${w - 1}) for class '${ue.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`,
                  );
                return (
                  (ue.xa.Ha[w - 1] = () => {
                    Kl(`Cannot construct ${ue.name} due to unbound types`, xe);
                  }),
                  tn(
                    [],
                    xe,
                    (we) => (
                      we.splice(1, 0, null),
                      (ue.xa.Ha[w - 1] = jl(We, we, null, z, Q)),
                      []
                    ),
                  ),
                  []
                );
              }));
          },
          f: (v, w, D, F, z, Q, xe, ue) => {
            var We = Mu(D, F);
            ((w = ot(w)),
              (w = Qd(w)),
              (Q = yt(z, Q)),
              tn([], [v], (we) => {
                function Ve() {
                  Kl(`Cannot call ${Yt} due to unbound types`, We);
                }
                we = we[0];
                var Yt = `${we.name}.${w}`;
                (w.startsWith("@@") && (w = Symbol[w.substring(2)]),
                  ue && we.xa.kb.push(w));
                var un = we.xa.La,
                  ie = un[w];
                return (
                  ie === void 0 ||
                  (ie.Ba === void 0 &&
                    ie.className !== we.name &&
                    ie.Oa === D - 2)
                    ? ((Ve.Oa = D - 2), (Ve.className = we.name), (un[w] = Ve))
                    : (ze(un, w, Yt), (un[w].Ba[D - 2] = Ve)),
                  tn(
                    [],
                    We,
                    (mt) => (
                      (mt = jl(Yt, mt, we, Q, xe)),
                      un[w].Ba === void 0
                        ? ((mt.Oa = D - 2), (un[w] = mt))
                        : (un[w].Ba[D - 2] = mt),
                      []
                    ),
                  ),
                  []
                );
              }));
          },
          X: (v) => Ze(v, qd),
          x: (v, w, D, F) => {
            function z() {}
            ((w = ot(w)),
              (z.values = {}),
              Ze(v, {
                name: w,
                constructor: z,
                fromWireType: function (Q) {
                  return this.constructor.values[Q];
                },
                toWireType: (Q, xe) => xe.value,
                argPackAdvance: 8,
                readValueFromPointer: bI(w, D, F),
                Ea: null,
              }),
              Ft(w, z));
          },
          k: (v, w, D) => {
            var F = ef(v, "enum");
            ((w = ot(w)),
              (v = F.constructor),
              (F = Object.create(F.constructor.prototype, {
                value: { value: D },
                constructor: { value: ht(`${F.name}_${w}`, function () {}) },
              })),
              (v.values[D] = F),
              (v[w] = F));
          },
          C: (v, w, D) => {
            ((w = ot(w)),
              Ze(v, {
                name: w,
                fromWireType: (F) => F,
                toWireType: (F, z) => z,
                argPackAdvance: 8,
                readValueFromPointer: vI(w, D),
                Ea: null,
              }));
          },
          E: (v, w, D, F, z, Q) => {
            var xe = Mu(w, D);
            ((v = ot(v)),
              (v = Qd(v)),
              (z = yt(F, z)),
              Ft(
                v,
                function () {
                  Kl(`Cannot call ${v} due to unbound types`, xe);
                },
                w - 1,
              ),
              tn(
                [],
                xe,
                (ue) => (
                  Ge(
                    v,
                    jl(v, [ue[0], null].concat(ue.slice(1)), null, z, Q),
                    w - 1,
                  ),
                  []
                ),
              ));
          },
          l: (v, w, D, F, z) => {
            if (
              ((w = ot(w)),
              z === -1 && (z = 4294967295),
              (z = (ue) => ue),
              F === 0)
            ) {
              var Q = 32 - 8 * D;
              z = (ue) => (ue << Q) >>> Q;
            }
            var xe = w.includes("unsigned")
              ? function (ue, We) {
                  return We >>> 0;
                }
              : function (ue, We) {
                  return We;
                };
            Ze(v, {
              name: w,
              fromWireType: z,
              toWireType: xe,
              argPackAdvance: 8,
              readValueFromPointer: xI(w, D, F !== 0),
              Ea: null,
            });
          },
          g: (v, w, D) => {
            function F(Q) {
              return new z(g.buffer, I[(Q + 4) >> 2], I[Q >> 2]);
            }
            var z = [
              Int8Array,
              Uint8Array,
              Int16Array,
              Uint16Array,
              Int32Array,
              Uint32Array,
              Float32Array,
              Float64Array,
            ][w];
            ((D = ot(D)),
              Ze(
                v,
                {
                  name: D,
                  fromWireType: F,
                  argPackAdvance: 8,
                  readValueFromPointer: F,
                },
                { ib: !0 },
              ));
          },
          w: (v) => {
            Ze(v, qd);
          },
          ca: (v, w, D, F, z, Q, xe, ue, We, we, Ve, Yt) => {
            ((D = ot(D)),
              (Q = yt(z, Q)),
              (ue = yt(xe, ue)),
              (we = yt(We, we)),
              (Yt = yt(Ve, Yt)),
              tn(
                [v],
                [w],
                (un) => (
                  (un = un[0]),
                  [new Re(D, un.xa, !1, !1, !0, un, F, Q, ue, we, Yt)]
                ),
              ));
          },
          D: (v, w) => {
            w = ot(w);
            var D = w === "std::string";
            Ze(v, {
              name: w,
              fromWireType: function (F) {
                var z = I[F >> 2],
                  Q = F + 4;
                if (D)
                  for (var xe = Q, ue = 0; ue <= z; ++ue) {
                    var We = Q + ue;
                    if (ue == z || p[We] == 0) {
                      if (((xe = xe ? be(p, xe, We - xe) : ""), we === void 0))
                        var we = xe;
                      else ((we += "\0"), (we += xe));
                      xe = We + 1;
                    }
                  }
                else {
                  for (we = Array(z), ue = 0; ue < z; ++ue)
                    we[ue] = String.fromCharCode(p[Q + ue]);
                  we = we.join("");
                }
                return (En(F), we);
              },
              toWireType: function (F, z) {
                z instanceof ArrayBuffer && (z = new Uint8Array(z));
                var Q = typeof z == "string";
                if (
                  !(
                    Q ||
                    z instanceof Uint8Array ||
                    z instanceof Uint8ClampedArray ||
                    z instanceof Int8Array
                  )
                )
                  throw new Ae("Cannot pass non-string to std::string");
                var xe = D && Q ? ce(z) : z.length,
                  ue = Ui(4 + xe + 1),
                  We = ue + 4;
                if (((I[ue >> 2] = xe), D && Q)) ae(z, p, We, xe + 1);
                else if (Q)
                  for (Q = 0; Q < xe; ++Q) {
                    var we = z.charCodeAt(Q);
                    if (255 < we)
                      throw (
                        En(We),
                        new Ae(
                          "String has UTF-16 code units that do not fit in 8 bits",
                        )
                      );
                    p[We + Q] = we;
                  }
                else for (Q = 0; Q < xe; ++Q) p[We + Q] = z[Q];
                return (F !== null && F.push(En, ue), ue);
              },
              argPackAdvance: 8,
              readValueFromPointer: Te,
              Ea(F) {
                En(F);
              },
            });
          },
          u: (v, w, D) => {
            if (((D = ot(D)), w === 2))
              var F = N,
                z = K,
                Q = ee,
                xe = (ue) => C[ue >> 1];
            else
              w === 4 &&
                ((F = ne), (z = j), (Q = _e), (xe = (ue) => I[ue >> 2]));
            Ze(v, {
              name: D,
              fromWireType: (ue) => {
                for (
                  var We = I[ue >> 2], we, Ve = ue + 4, Yt = 0;
                  Yt <= We;
                  ++Yt
                ) {
                  var un = ue + 4 + Yt * w;
                  (Yt == We || xe(un) == 0) &&
                    ((Ve = F(Ve, un - Ve)),
                    we === void 0 ? (we = Ve) : ((we += "\0"), (we += Ve)),
                    (Ve = un + w));
                }
                return (En(ue), we);
              },
              toWireType: (ue, We) => {
                if (typeof We != "string")
                  throw new Ae(
                    `Cannot pass non-string to C++ string type ${D}`,
                  );
                var we = Q(We),
                  Ve = Ui(4 + we + w);
                return (
                  (I[Ve >> 2] = we / w),
                  z(We, Ve + 4, we + w),
                  ue !== null && ue.push(En, Ve),
                  Ve
                );
              },
              argPackAdvance: 8,
              readValueFromPointer: Te,
              Ea(ue) {
                En(ue);
              },
            });
          },
          s: (v, w, D, F, z, Q) => {
            Ce[v] = { name: ot(w), Ua: yt(D, F), Fa: yt(z, Q), Ya: [] };
          },
          j: (v, w, D, F, z, Q, xe, ue, We, we) => {
            Ce[v].Ya.push({
              bb: ot(w),
              hb: D,
              fb: yt(F, z),
              gb: Q,
              nb: xe,
              mb: yt(ue, We),
              ob: we,
            });
          },
          Z: (v, w) => {
            ((w = ot(w)),
              Ze(v, {
                ub: !0,
                name: w,
                argPackAdvance: 0,
                fromWireType: () => {},
                toWireType: () => {},
              }));
          },
          J: () => {
            throw 1 / 0;
          },
          aa: (v, w, D, F) => ((v = Le[v]), (w = Oa(w)), v(null, w, D, F)),
          F: Ru,
          $: (v, w, D) => {
            var F = Xe(v, w),
              z = F.shift();
            v--;
            var Q = Array(v);
            return (
              (w = `methodCaller<(${F.map((xe) => xe.name).join(", ")}) => ${z.name}>`),
              He(
                ht(w, (xe, ue, We, we) => {
                  for (var Ve = 0, Yt = 0; Yt < v; ++Yt)
                    ((Q[Yt] = F[Yt].readValueFromPointer(we + Ve)),
                      (Ve += F[Yt].argPackAdvance));
                  return (
                    (ue = D === 1 ? It(ue, Q) : ue.apply(xe, Q)),
                    (xe = []),
                    (ue = z.toWireType(xe, ue)),
                    xe.length && (I[We >> 2] = $l(xe)),
                    ue
                  );
                }),
              )
            );
          },
          ba: (v) => {
            9 < v && (yr[v + 1] += 1);
          },
          _: (v) => {
            var w = Oa(v);
            ($e(w), Ru(v));
          },
          o: (v, w) => (
            (v = ef(v, "_emval_take_value")),
            (v = v.readValueFromPointer(w)),
            $l(v)
          ),
          W: () => {
            L("");
          },
          V: () => performance.now(),
          L: (v) => {
            var w = p.length;
            if (((v >>>= 0), 2147483648 < v)) return !1;
            for (var D = 1; 4 >= D; D *= 2) {
              var F = w * (1 + 0.2 / D);
              F = Math.min(F, v + 100663296);
              var z = Math;
              F = Math.max(v, F);
              e: {
                z =
                  (z.min.call(
                    z,
                    2147483648,
                    F + ((65536 - (F % 65536)) % 65536),
                  ) -
                    d.buffer.byteLength +
                    65535) /
                  65536;
                try {
                  (d.grow(z), T());
                  var Q = 1;
                  break e;
                } catch {}
                Q = void 0;
              }
              if (Q) return !0;
            }
            return !1;
          },
          S: (v, w) => {
            var D = 0;
            return (
              st().forEach((F, z) => {
                var Q = w + D;
                for (z = I[(v + 4 * z) >> 2] = Q, Q = 0; Q < F.length; ++Q)
                  g[z++] = F.charCodeAt(Q);
                ((g[z] = 0), (D += F.length + 1));
              }),
              0
            );
          },
          T: (v, w) => {
            var D = st();
            I[v >> 2] = D.length;
            var F = 0;
            return (D.forEach((z) => (F += z.length + 1)), (I[w >> 2] = F), 0);
          },
          t: () => 52,
          z: () => 52,
          H: function () {
            return 70;
          },
          Q: (v, w, D, F) => {
            for (var z = 0, Q = 0; Q < D; Q++) {
              var xe = I[w >> 2],
                ue = I[(w + 4) >> 2];
              w += 8;
              for (var We = 0; We < ue; We++) {
                var we = p[xe + We],
                  Ve = nn[v];
                we === 0 || we === 10
                  ? ((v === 1 ? c : u)(be(Ve, 0)), (Ve.length = 0))
                  : Ve.push(we);
              }
              z += ue;
            }
            return ((I[F >> 2] = z), 0);
          },
          U: (v, w) => (Tn(p.subarray(v, v + w)), 0),
          i: TN,
          d: SN,
          e: wN,
          p: EN,
          y: RN,
          b: vN,
          a: xN,
          h: LN,
          n: MN,
          G: BN,
          K: (v, w, D, F) => Gr(v, w, D, F),
        },
        At = (function () {
          function v(D) {
            return (
              (At = D.exports),
              (d = At.da),
              T(),
              (at = At.ha),
              E.unshift(At.ea),
              R--,
              t.monitorRunDependencies?.(R),
              R == 0 && M && ((D = M), (M = null), D()),
              At
            );
          }
          var w = { a: Jl };
          if ((R++, t.monitorRunDependencies?.(R), t.instantiateWasm))
            try {
              return t.instantiateWasm(w, v);
            } catch (D) {
              (u(`Module.instantiateWasm callback failed with error: ${D}`),
                r(D));
            }
          return (
            Z(w, function (D) {
              v(D.instance);
            }).catch(r),
            {}
          );
        })(),
        Ui = (v) => (Ui = At.fa)(v),
        sr = (v) => (sr = At.ga)(v),
        En = (v) => (En = At.ia)(v),
        Sn = (v, w) => (Sn = At.ja)(v, w),
        or = (v) => (or = At.ka)(v),
        li = () => (li = At.la)();
      ((t.dynCall_iijj = (v, w, D, F, z, Q) =>
        (t.dynCall_iijj = At.na)(v, w, D, F, z, Q)),
        (t.dynCall_vijj = (v, w, D, F, z, Q) =>
          (t.dynCall_vijj = At.oa)(v, w, D, F, z, Q)),
        (t.dynCall_jiii = (v, w, D, F) => (t.dynCall_jiii = At.pa)(v, w, D, F)),
        (t.dynCall_jii = (v, w, D) => (t.dynCall_jii = At.qa)(v, w, D)));
      var P5 = (t.dynCall_viiij = (v, w, D, F, z, Q) =>
        (P5 = t.dynCall_viiij = At.ra)(v, w, D, F, z, Q));
      ((t.dynCall_jiji = (v, w, D, F, z) =>
        (t.dynCall_jiji = At.sa)(v, w, D, F, z)),
        (t.dynCall_viijii = (v, w, D, F, z, Q, xe) =>
          (t.dynCall_viijii = At.ta)(v, w, D, F, z, Q, xe)),
        (t.dynCall_iiiiij = (v, w, D, F, z, Q, xe) =>
          (t.dynCall_iiiiij = At.ua)(v, w, D, F, z, Q, xe)),
        (t.dynCall_iiiiijj = (v, w, D, F, z, Q, xe, ue, We) =>
          (t.dynCall_iiiiijj = At.va)(v, w, D, F, z, Q, xe, ue, We)),
        (t.dynCall_iiiiiijj = (v, w, D, F, z, Q, xe, ue, We, we) =>
          (t.dynCall_iiiiiijj = At.wa)(v, w, D, F, z, Q, xe, ue, We, we)));
      function vN(v, w) {
        var D = li();
        try {
          at.get(v)(w);
        } catch (F) {
          if ((or(D), F !== F + 0)) throw F;
          Sn(1, 0);
        }
      }
      function xN(v, w, D) {
        var F = li();
        try {
          at.get(v)(w, D);
        } catch (z) {
          if ((or(F), z !== z + 0)) throw z;
          Sn(1, 0);
        }
      }
      function wN(v, w, D, F) {
        var z = li();
        try {
          return at.get(v)(w, D, F);
        } catch (Q) {
          if ((or(z), Q !== Q + 0)) throw Q;
          Sn(1, 0);
        }
      }
      function SN(v, w, D) {
        var F = li();
        try {
          return at.get(v)(w, D);
        } catch (z) {
          if ((or(F), z !== z + 0)) throw z;
          Sn(1, 0);
        }
      }
      function TN(v, w) {
        var D = li();
        try {
          return at.get(v)(w);
        } catch (F) {
          if ((or(D), F !== F + 0)) throw F;
          Sn(1, 0);
        }
      }
      function EN(v, w, D, F, z, Q) {
        var xe = li();
        try {
          return at.get(v)(w, D, F, z, Q);
        } catch (ue) {
          if ((or(xe), ue !== ue + 0)) throw ue;
          Sn(1, 0);
        }
      }
      function MN(v, w, D, F, z) {
        var Q = li();
        try {
          at.get(v)(w, D, F, z);
        } catch (xe) {
          if ((or(Q), xe !== xe + 0)) throw xe;
          Sn(1, 0);
        }
      }
      function LN(v, w, D, F) {
        var z = li();
        try {
          at.get(v)(w, D, F);
        } catch (Q) {
          if ((or(z), Q !== Q + 0)) throw Q;
          Sn(1, 0);
        }
      }
      function RN(v) {
        var w = li();
        try {
          at.get(v)();
        } catch (D) {
          if ((or(w), D !== D + 0)) throw D;
          Sn(1, 0);
        }
      }
      function BN(v, w, D, F, z, Q) {
        var xe = li();
        try {
          P5(v, w, D, F, z, Q);
        } catch (ue) {
          if ((or(xe), ue !== ue + 0)) throw ue;
          Sn(1, 0);
        }
      }
      var Dp;
      M = function v() {
        (Dp || N5(), Dp || (M = v));
      };
      function N5() {
        function v() {
          if (!Dp && ((Dp = !0), (t.calledRun = !0), !f)) {
            if (
              (te(E),
              i(t),
              t.onRuntimeInitialized && t.onRuntimeInitialized(),
              t.postRun)
            )
              for (
                typeof t.postRun == "function" && (t.postRun = [t.postRun]);
                t.postRun.length;
              ) {
                var w = t.postRun.shift();
                _.unshift(w);
              }
            te(_);
          }
        }
        if (!(0 < R)) {
          if (t.preRun)
            for (
              typeof t.preRun == "function" && (t.preRun = [t.preRun]);
              t.preRun.length;
            )
              b();
          (te(S),
            0 < R ||
              (t.setStatus
                ? (t.setStatus("Running..."),
                  setTimeout(function () {
                    (setTimeout(function () {
                      t.setStatus("");
                    }, 1),
                      v());
                  }, 1))
                : v()));
        }
      }
      if (t.preInit)
        for (
          typeof t.preInit == "function" && (t.preInit = [t.preInit]);
          0 < t.preInit.length;
        )
          t.preInit.pop()();
      return (N5(), s);
    };
  })(),
  gq = fq,
  Vm = class {
    constructor() {
      throw new Error(
        "RendererLoader is a static class and cannot be instantiated.",
      );
    }
    static async _tryLoad(n) {
      return await gq({ locateFile: () => n });
    }
    static async _loadWithBackup() {
      return (
        this._ModulePromise ||
          (this._ModulePromise = this._tryLoad(this._wasmURL).catch(
            async (n) => {
              let e = `https://unpkg.com/${NL}@${PL}/dist/dotlottie-player.wasm`;
              (console.warn(
                `Primary WASM load failed from ${this._wasmURL}. Error: ${n.message}`,
              ),
                console.warn(`Attempting to load WASM from backup URL: ${e}`));
              try {
                return await this._tryLoad(e);
              } catch (t) {
                throw (
                  console.error(`Primary WASM URL failed: ${n.message}`),
                  console.error(`Backup WASM URL failed: ${t.message}`),
                  new Error("WASM loading failed from all sources.")
                );
              }
            },
          )),
        this._ModulePromise
      );
    }
    static async load() {
      return this._loadWithBackup();
    }
    static setWasmUrl(n) {
      ((this._wasmURL = n), (this._ModulePromise = null));
    }
  };
(kt(Vm, "_ModulePromise", null),
  kt(
    Vm,
    "_wasmURL",
    `https://cdn.jsdelivr.net/npm/${NL}@${PL}/dist/dotlottie-player.wasm`,
  ));
var DL = class {
  constructor() {
    kt(this, "_eventListeners", new Map());
  }
  addEventListener(n, e) {
    let t = this._eventListeners.get(n);
    (t || ((t = new Set()), this._eventListeners.set(n, t)), t.add(e));
  }
  removeEventListener(n, e) {
    let t = this._eventListeners.get(n);
    t &&
      (e
        ? (t.delete(e), t.size === 0 && this._eventListeners.delete(n))
        : this._eventListeners.delete(n));
  }
  dispatch(n) {
    this._eventListeners.get(n.type)?.forEach((e) => e(n));
  }
  removeAllEventListeners() {
    this._eventListeners.clear();
  }
};
function pq(n) {
  return /^#([\da-f]{6}|[\da-f]{8})$/iu.test(n);
}
function mq(n) {
  if (!pq(n)) return 0;
  let e = n.replace("#", "");
  return ((e = e.length === 6 ? `${e}ff` : e), parseInt(e, 16));
}
function Mx(n) {
  if (n.byteLength < 4) return !1;
  let e = new Uint8Array(n.slice(0, f2.byteLength));
  for (let t = 0; t < f2.length; t += 1) if (f2[t] !== e[t]) return !1;
  return !0;
}
function Lx(n) {
  return dq.every((e) => Object.prototype.hasOwnProperty.call(n, e));
}
function Rx(n) {
  if (typeof n == "string")
    try {
      return Lx(JSON.parse(n));
    } catch {
      return !1;
    }
  else return Lx(n);
}
var g2 = (n, e) =>
    n === "reverse"
      ? e.Mode.Reverse
      : n === "bounce"
        ? e.Mode.Bounce
        : n === "reverse-bounce"
          ? e.Mode.ReverseBounce
          : e.Mode.Forward,
  p2 = (n, e) =>
    n === "contain"
      ? e.Fit.Contain
      : n === "cover"
        ? e.Fit.Cover
        : n === "fill"
          ? e.Fit.Fill
          : n === "fit-height"
            ? e.Fit.FitHeight
            : n === "fit-width"
              ? e.Fit.FitWidth
              : e.Fit.None,
  m2 = (n, e) => {
    let t = new e.VectorFloat();
    return (t.push_back(n[0]), t.push_back(n[1]), t);
  },
  C2 = (n, e) => {
    let t = new e.VectorFloat();
    return (n.length !== 2 || (t.push_back(n[0]), t.push_back(n[1])), t);
  },
  GL = class Pn {
    constructor(e) {
      (kt(this, "_canvas"),
        kt(this, "_context", null),
        kt(this, "_eventManager"),
        kt(this, "_animationFrameId", null),
        kt(this, "_frameManager"),
        kt(this, "_dotLottieCore", null),
        kt(this, "_renderConfig", {}),
        kt(this, "_isFrozen", !1),
        kt(this, "_backgroundColor", null),
        kt(this, "_pointerUpMethod"),
        kt(this, "_pointerDownMethod"),
        kt(this, "_pointerMoveMethod"),
        kt(this, "_pointerEnterMethod"),
        kt(this, "_pointerExitMethod"),
        kt(this, "_onCompleteMethod"),
        (this._canvas = e.canvas),
        (this._context = this._canvas.getContext("2d")),
        (this._eventManager = new DL()),
        (this._frameManager = new hq()),
        (this._renderConfig = e.renderConfig ?? {}),
        Vm.load()
          .then((t) => {
            ((Pn._wasmModule = t),
              (this._dotLottieCore = new t.DotLottiePlayer({
                autoplay: e.autoplay ?? !1,
                backgroundColor: 0,
                loopAnimation: e.loop ?? !1,
                mode: g2(e.mode ?? "forward", t),
                segment: C2(e.segment ?? [], t),
                speed: e.speed ?? 1,
                useFrameInterpolation: e.useFrameInterpolation ?? !0,
                marker: e.marker ?? "",
                layout: e.layout
                  ? { align: m2(e.layout.align, t), fit: p2(e.layout.fit, t) }
                  : t.createDefaultLayout(),
              })),
              this._eventManager.dispatch({ type: "ready" }),
              e.data
                ? this._loadFromData(e.data)
                : e.src && this._loadFromSrc(e.src),
              e.backgroundColor && this.setBackgroundColor(e.backgroundColor));
          })
          .catch((t) => {
            this._eventManager.dispatch({
              type: "loadError",
              error: new Error(`Failed to load wasm module: ${t}`),
            });
          }),
        (this._pointerUpMethod = this._onPointerUp.bind(this)),
        (this._pointerDownMethod = this._onPointerDown.bind(this)),
        (this._pointerMoveMethod = this._onPointerMove.bind(this)),
        (this._pointerEnterMethod = this._onPointerEnter.bind(this)),
        (this._pointerExitMethod = this._onPointerLeave.bind(this)),
        (this._onCompleteMethod = this._onComplete.bind(this)));
    }
    _dispatchError(e) {
      (console.error(e),
        this._eventManager.dispatch({
          type: "loadError",
          error: new Error(e),
        }));
    }
    async _fetchData(e) {
      let t = await fetch(e);
      if (!t.ok)
        throw new Error(
          `Failed to fetch animation data from URL: ${e}. ${t.status}: ${t.statusText}`,
        );
      let i = await t.arrayBuffer();
      return Mx(i) ? i : new TextDecoder().decode(i);
    }
    _loadFromData(e) {
      if (this._dotLottieCore === null) return;
      let t = this._canvas.width,
        i = this._canvas.height,
        r = !1;
      if (typeof e == "string") {
        if (!Rx(e)) {
          this._dispatchError(
            "Invalid Lottie JSON string: The provided string does not conform to the Lottie JSON format.",
          );
          return;
        }
        r = this._dotLottieCore.loadAnimationData(e, t, i);
      } else if (e instanceof ArrayBuffer) {
        if (!Mx(e)) {
          this._dispatchError(
            "Invalid dotLottie ArrayBuffer: The provided ArrayBuffer does not conform to the dotLottie format.",
          );
          return;
        }
        r = this._dotLottieCore.loadDotLottieData(e, t, i);
      } else if (typeof e == "object") {
        if (!Rx(e)) {
          this._dispatchError(
            "Invalid Lottie JSON object: The provided object does not conform to the Lottie JSON format.",
          );
          return;
        }
        r = this._dotLottieCore.loadAnimationData(JSON.stringify(e), t, i);
      } else {
        this
          ._dispatchError(`Unsupported data type for animation data. Expected: 
          - string (Lottie JSON),
          - ArrayBuffer (dotLottie),
          - object (Lottie JSON). 
          Received: ${typeof e}`);
        return;
      }
      r
        ? (this._eventManager.dispatch({ type: "load" }),
          Gc && this.resize(),
          this._eventManager.dispatch({
            type: "frame",
            currentFrame: this._dotLottieCore.currentFrame(),
          }),
          this._render(),
          this._dotLottieCore.config().autoplay &&
            (this._dotLottieCore.play(),
            this._dotLottieCore.isPlaying()
              ? (this._eventManager.dispatch({ type: "play" }),
                (this._animationFrameId =
                  this._frameManager.requestAnimationFrame(
                    this._draw.bind(this),
                  )))
              : console.error(
                  "something went wrong, the animation was suppose to autoplay",
                )))
        : this._dispatchError("Failed to load animation data");
    }
    _loadFromSrc(e) {
      this._fetchData(e)
        .then((t) => this._loadFromData(t))
        .catch((t) =>
          this._dispatchError(
            `Failed to load animation data from URL: ${e}. ${t}`,
          ),
        );
    }
    get activeAnimationId() {
      return this._dotLottieCore?.activeAnimationId();
    }
    get activeThemeId() {
      return this._dotLottieCore?.activeThemeId();
    }
    get layout() {
      let e = this._dotLottieCore?.config().layout;
      if (e)
        return {
          align: [e.align.get(0), e.align.get(1)],
          fit: (() => {
            switch (e.fit) {
              case Pn._wasmModule?.Fit.Contain:
                return "contain";
              case Pn._wasmModule?.Fit.Cover:
                return "cover";
              case Pn._wasmModule?.Fit.Fill:
                return "fill";
              case Pn._wasmModule?.Fit.FitHeight:
                return "fit-height";
              case Pn._wasmModule?.Fit.FitWidth:
                return "fit-width";
              case Pn._wasmModule?.Fit.None:
                return "none";
              default:
                return "contain";
            }
          })(),
        };
    }
    get marker() {
      return this._dotLottieCore?.config().marker;
    }
    get manifest() {
      try {
        let e = this._dotLottieCore?.manifestString();
        if (this._dotLottieCore === null || !e) return null;
        let t = JSON.parse(e);
        return Object.keys(t).length === 0 ? null : t;
      } catch {
        return null;
      }
    }
    get renderConfig() {
      return this._renderConfig;
    }
    get segment() {
      let e = this._dotLottieCore?.config().segment;
      if (e && e.size() === 2) return [e.get(0), e.get(1)];
    }
    get loop() {
      return this._dotLottieCore?.config().loopAnimation ?? !1;
    }
    get mode() {
      let e = this._dotLottieCore?.config().mode;
      return e === Pn._wasmModule?.Mode.Reverse
        ? "reverse"
        : e === Pn._wasmModule?.Mode.Bounce
          ? "bounce"
          : e === Pn._wasmModule?.Mode.ReverseBounce
            ? "reverse-bounce"
            : "forward";
    }
    get isFrozen() {
      return this._isFrozen;
    }
    get backgroundColor() {
      return this._backgroundColor ?? "";
    }
    get autoplay() {
      return this._dotLottieCore?.config().autoplay ?? !1;
    }
    get useFrameInterpolation() {
      return this._dotLottieCore?.config().useFrameInterpolation ?? !1;
    }
    get speed() {
      return this._dotLottieCore?.config().speed ?? 0;
    }
    get isReady() {
      return this._dotLottieCore !== null;
    }
    get isLoaded() {
      return this._dotLottieCore?.isLoaded() ?? !1;
    }
    get isPlaying() {
      return this._dotLottieCore?.isPlaying() ?? !1;
    }
    get isPaused() {
      return this._dotLottieCore?.isPaused() ?? !1;
    }
    get isStopped() {
      return this._dotLottieCore?.isStopped() ?? !1;
    }
    get currentFrame() {
      return this._dotLottieCore?.currentFrame() ?? 0;
    }
    get loopCount() {
      return this._dotLottieCore?.loopCount() ?? 0;
    }
    get totalFrames() {
      return this._dotLottieCore?.totalFrames() ?? 0;
    }
    get duration() {
      return this._dotLottieCore?.duration() ?? 0;
    }
    get segmentDuration() {
      return this._dotLottieCore?.segmentDuration() ?? 0;
    }
    get canvas() {
      return this._canvas;
    }
    load(e) {
      this._dotLottieCore === null ||
        Pn._wasmModule === null ||
        (this._dotLottieCore.setConfig({
          autoplay: e.autoplay ?? !1,
          backgroundColor: 0,
          loopAnimation: e.loop ?? !1,
          mode: g2(e.mode ?? "forward", Pn._wasmModule),
          segment: C2(e.segment ?? [], Pn._wasmModule),
          speed: e.speed ?? 1,
          useFrameInterpolation: e.useFrameInterpolation ?? !0,
          marker: e.marker ?? "",
          layout: e.layout
            ? {
                align: m2(e.layout.align, Pn._wasmModule),
                fit: p2(e.layout.fit, Pn._wasmModule),
              }
            : Pn._wasmModule.createDefaultLayout(),
        }),
        e.data ? this._loadFromData(e.data) : e.src && this._loadFromSrc(e.src),
        this.setBackgroundColor(e.backgroundColor ?? ""));
    }
    _render() {
      if (this._dotLottieCore === null || this._context === null) return !1;
      if (this._dotLottieCore.render()) {
        let e = this._dotLottieCore.buffer(),
          t = new Uint8ClampedArray(
            e,
            0,
            this._canvas.width * this._canvas.height * 4,
          ),
          i = null;
        return (
          typeof ImageData > "u"
            ? ((i = this._context.createImageData(
                this._canvas.width,
                this._canvas.height,
              )),
              i.data.set(t))
            : (i = new ImageData(t, this._canvas.width, this._canvas.height)),
          this._context.putImageData(i, 0, 0),
          this._eventManager.dispatch({
            type: "render",
            currentFrame: this._dotLottieCore.currentFrame(),
          }),
          !0
        );
      }
      return !1;
    }
    _draw() {
      if (
        this._dotLottieCore === null ||
        this._context === null ||
        !this._dotLottieCore.isPlaying()
      )
        return;
      let e = this._dotLottieCore.requestFrame();
      (this._dotLottieCore.setFrame(e) &&
        (this._eventManager.dispatch({
          type: "frame",
          currentFrame: this._dotLottieCore.currentFrame(),
        }),
        this._render() &&
          this._dotLottieCore.isComplete() &&
          (this._dotLottieCore.config().loopAnimation
            ? this._eventManager.dispatch({
                type: "loop",
                loopCount: this._dotLottieCore.loopCount(),
              })
            : this._eventManager.dispatch({ type: "complete" }))),
        (this._animationFrameId = this._frameManager.requestAnimationFrame(
          this._draw.bind(this),
        )));
    }
    play() {
      this._dotLottieCore !== null &&
        (this._dotLottieCore.play() || this._dotLottieCore.isPlaying()) &&
        ((this._isFrozen = !1),
        this._eventManager.dispatch({ type: "play" }),
        (this._animationFrameId = this._frameManager.requestAnimationFrame(
          this._draw.bind(this),
        )));
    }
    pause() {
      this._dotLottieCore !== null &&
        (this._dotLottieCore.pause() || this._dotLottieCore.isPaused()) &&
        this._eventManager.dispatch({ type: "pause" });
    }
    stop() {
      this._dotLottieCore !== null &&
        this._dotLottieCore.stop() &&
        (this._eventManager.dispatch({
          type: "frame",
          currentFrame: this._dotLottieCore.currentFrame(),
        }),
        this._render(),
        this._eventManager.dispatch({ type: "stop" }));
    }
    setFrame(e) {
      this._dotLottieCore === null ||
        e < 0 ||
        e > this._dotLottieCore.totalFrames() ||
        (this._dotLottieCore.seek(e) &&
          (this._eventManager.dispatch({
            type: "frame",
            currentFrame: this._dotLottieCore.currentFrame(),
          }),
          this._render()));
    }
    setSpeed(e) {
      this._dotLottieCore !== null &&
        this._dotLottieCore.setConfig({
          ...this._dotLottieCore.config(),
          speed: e,
        });
    }
    setBackgroundColor(e) {
      this._dotLottieCore !== null &&
        (Gc && this._canvas instanceof HTMLCanvasElement
          ? (this._canvas.style.backgroundColor = e)
          : this._dotLottieCore.setConfig({
              ...this._dotLottieCore.config(),
              backgroundColor: mq(e),
            }),
        (this._backgroundColor = e));
    }
    setLoop(e) {
      this._dotLottieCore !== null &&
        this._dotLottieCore.setConfig({
          ...this._dotLottieCore.config(),
          loopAnimation: e,
        });
    }
    setUseFrameInterpolation(e) {
      this._dotLottieCore !== null &&
        this._dotLottieCore.setConfig({
          ...this._dotLottieCore.config(),
          useFrameInterpolation: e,
        });
    }
    addEventListener(e, t) {
      this._eventManager.addEventListener(e, t);
    }
    removeEventListener(e, t) {
      this._eventManager.removeEventListener(e, t);
    }
    destroy() {
      (this._dotLottieCore?.delete(),
        (this._dotLottieCore = null),
        (this._context = null),
        this._eventManager.dispatch({ type: "destroy" }),
        this._eventManager.removeAllEventListeners(),
        this._cleanupStateMachineListeners());
    }
    freeze() {
      this._animationFrameId !== null &&
        (this._frameManager.cancelAnimationFrame(this._animationFrameId),
        (this._animationFrameId = null),
        (this._isFrozen = !0),
        this._eventManager.dispatch({ type: "freeze" }));
    }
    unfreeze() {
      this._animationFrameId === null &&
        ((this._animationFrameId = this._frameManager.requestAnimationFrame(
          this._draw.bind(this),
        )),
        (this._isFrozen = !1),
        this._eventManager.dispatch({ type: "unfreeze" }));
    }
    resize() {
      if (Gc && this._canvas instanceof HTMLCanvasElement) {
        let e =
            this._renderConfig.devicePixelRatio || window.devicePixelRatio || 1,
          { height: t, width: i } = this._canvas.getBoundingClientRect();
        ((this._canvas.width = i * e), (this._canvas.height = t * e));
      }
      this._dotLottieCore?.resize(this._canvas.width, this._canvas.height) &&
        this._render();
    }
    setSegment(e, t) {
      this._dotLottieCore === null ||
        Pn._wasmModule === null ||
        this._dotLottieCore.setConfig({
          ...this._dotLottieCore.config(),
          segment: C2([e, t], Pn._wasmModule),
        });
    }
    setMode(e) {
      this._dotLottieCore === null ||
        Pn._wasmModule === null ||
        this._dotLottieCore.setConfig({
          ...this._dotLottieCore.config(),
          mode: g2(e, Pn._wasmModule),
        });
    }
    setRenderConfig(e) {
      this._renderConfig = e;
    }
    loadAnimation(e) {
      this._dotLottieCore === null ||
        this._dotLottieCore.activeAnimationId() === e ||
        (this._dotLottieCore.loadAnimation(
          e,
          this._canvas.width,
          this._canvas.height,
        )
          ? (this._eventManager.dispatch({ type: "load" }), this.resize())
          : this._eventManager.dispatch({
              type: "loadError",
              error: new Error(`Failed to animation :${e}`),
            }));
    }
    setMarker(e) {
      this._dotLottieCore !== null &&
        this._dotLottieCore.setConfig({
          ...this._dotLottieCore.config(),
          marker: e,
        });
    }
    markers() {
      let e = this._dotLottieCore?.markers();
      if (e) {
        let t = [];
        for (let i = 0; i < e.size(); i += 1) {
          let r = e.get(i);
          t.push({ name: r.name, time: r.time, duration: r.duration });
        }
        return t;
      }
      return [];
    }
    loadTheme(e) {
      if (this._dotLottieCore === null) return !1;
      let t = this._dotLottieCore.loadTheme(e);
      return (this._render(), t);
    }
    loadThemeData(e) {
      if (this._dotLottieCore === null) return !1;
      let t = this._dotLottieCore.loadThemeData(e);
      return (this._render(), t);
    }
    setLayout(e) {
      this._dotLottieCore === null ||
        Pn._wasmModule === null ||
        this._dotLottieCore.setConfig({
          ...this._dotLottieCore.config(),
          layout: {
            align: m2(e.align, Pn._wasmModule),
            fit: p2(e.fit, Pn._wasmModule),
          },
        });
    }
    setViewport(e, t, i, r) {
      return this._dotLottieCore === null
        ? !1
        : this._dotLottieCore.setViewport(e, t, i, r);
    }
    static setWasmUrl(e) {
      Vm.setWasmUrl(e);
    }
    loadStateMachine(e) {
      return this._dotLottieCore?.loadStateMachine(e) ?? !1;
    }
    startStateMachine() {
      let e = this._dotLottieCore?.startStateMachine() ?? !1;
      return (e && this._setupStateMachineListeners(), e);
    }
    stopStateMachine() {
      let e = this._dotLottieCore?.stopStateMachine() ?? !1;
      return (e && this._cleanupStateMachineListeners(), e);
    }
    _getPointerPosition(e) {
      let t = this._canvas.getBoundingClientRect(),
        i = this._canvas.width / t.width,
        r = this._canvas.height / t.height,
        s = this._renderConfig.devicePixelRatio || window.devicePixelRatio || 1,
        o = ((e.clientX - t.left) * i) / s,
        a = ((e.clientY - t.top) * r) / s;
      return { x: o, y: a };
    }
    _onPointerUp(e) {
      let { x: t, y: i } = this._getPointerPosition(e);
      this.postStateMachineEvent(`OnPointerUp: ${t} ${i}`);
    }
    _onPointerDown(e) {
      let { x: t, y: i } = this._getPointerPosition(e);
      this.postStateMachineEvent(`OnPointerDown: ${t} ${i}`);
    }
    _onPointerMove(e) {
      let { x: t, y: i } = this._getPointerPosition(e);
      this.postStateMachineEvent(`OnPointerMove: ${t} ${i}`);
    }
    _onPointerEnter(e) {
      let { x: t, y: i } = this._getPointerPosition(e);
      this.postStateMachineEvent(`OnPointerEnter: ${t} ${i}`);
    }
    _onPointerLeave(e) {
      let { x: t, y: i } = this._getPointerPosition(e);
      this.postStateMachineEvent(`OnPointerExit: ${t} ${i}`);
    }
    _onComplete() {
      this.postStateMachineEvent("OnComplete");
    }
    postStateMachineEvent(e) {
      let t = this._dotLottieCore?.postEventPayload(e) ?? 1;
      return (
        t === 2
          ? this.play()
          : t === 3
            ? this.pause()
            : t === 4 && this._render(),
        t
      );
    }
    getStateMachineListeners() {
      if (!this._dotLottieCore) return [];
      let e = this._dotLottieCore.stateMachineFrameworkSetup(),
        t = [];
      for (let i = 0; i < e.size(); i += 1) t.push(e.get(i));
      return t;
    }
    _setupStateMachineListeners() {
      if (
        Gc &&
        this._canvas instanceof HTMLCanvasElement &&
        this._dotLottieCore !== null &&
        this.isLoaded
      ) {
        let e = this.getStateMachineListeners();
        (e.includes("PointerUp") &&
          this._canvas.addEventListener("pointerup", this._pointerUpMethod),
          e.includes("PointerDown") &&
            this._canvas.addEventListener(
              "pointerdown",
              this._pointerDownMethod,
            ),
          e.includes("PointerMove") &&
            this._canvas.addEventListener(
              "pointermove",
              this._pointerMoveMethod,
            ),
          e.includes("PointerEnter") &&
            this._canvas.addEventListener(
              "pointerenter",
              this._pointerEnterMethod,
            ),
          e.includes("PointerExit") &&
            this._canvas.addEventListener(
              "pointerleave",
              this._pointerExitMethod,
            ),
          e.includes("Complete") &&
            this.addEventListener("complete", this._onCompleteMethod));
      }
    }
    _cleanupStateMachineListeners() {
      Gc &&
        this._canvas instanceof HTMLCanvasElement &&
        (this._canvas.removeEventListener("pointerup", this._pointerUpMethod),
        this._canvas.removeEventListener(
          "pointerdown",
          this._pointerDownMethod,
        ),
        this._canvas.removeEventListener(
          "pointermove",
          this._pointerMoveMethod,
        ),
        this._canvas.removeEventListener(
          "pointerenter",
          this._pointerEnterMethod,
        ),
        this._canvas.removeEventListener(
          "pointerleave",
          this._pointerExitMethod,
        ),
        this.removeEventListener("complete", this._onCompleteMethod));
    }
    loadStateMachineData(e) {
      return this._dotLottieCore?.loadStateMachineData(e) ?? !1;
    }
    animationSize() {
      let e = this._dotLottieCore?.animationSize().get(0) ?? 0,
        t = this._dotLottieCore?.animationSize().get(1) ?? 0;
      return { width: e, height: t };
    }
    setStateMachineBooleanContext(e, t) {
      return this._dotLottieCore?.setStateMachineBooleanContext(e, t) ?? !1;
    }
    setStateMachineNumericContext(e, t) {
      return this._dotLottieCore?.setStateMachineNumericContext(e, t) ?? !1;
    }
    setStateMachineStringContext(e, t) {
      return this._dotLottieCore?.setStateMachineStringContext(e, t) ?? !1;
    }
  };
kt(GL, "_wasmModule", null);
var sme = GL,
  Cq = class {
    constructor() {
      if (typeof window > "u")
        throw new Error("Worker is not available in this environment.");
      return new Worker(
        "data:application/javascript;base64,InVzZSBzdHJpY3QiOwooKCkgPT4gewogIHZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7CiAgdmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlOwogIHZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gInN5bWJvbCIgPyBrZXkgKyAiIiA6IGtleSwgdmFsdWUpOwoKICAvLyBzcmMvYW5pbWF0aW9uLWZyYW1lLW1hbmFnZXIudHMKICB2YXIgV2ViQW5pbWF0aW9uRnJhbWVTdHJhdGVneSA9IGNsYXNzIHsKICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjaykgewogICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTsKICAgIH0KICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKSB7CiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGlkKTsKICAgIH0KICB9OwogIHZhciBOb2RlQW5pbWF0aW9uRnJhbWVTdHJhdGVneSA9IGNsYXNzIHsKICAgIGNvbnN0cnVjdG9yKCkgewogICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsICJfbGFzdEhhbmRsZUlkIiwgMCk7CiAgICAgIF9fcHVibGljRmllbGQodGhpcywgIl9sYXN0SW1tZWRpYXRlIiwgbnVsbCk7CiAgICB9CiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spIHsKICAgICAgaWYgKHRoaXMuX2xhc3RIYW5kbGVJZCA+PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikgewogICAgICAgIHRoaXMuX2xhc3RIYW5kbGVJZCA9IDA7CiAgICAgIH0KICAgICAgdGhpcy5fbGFzdEhhbmRsZUlkICs9IDE7CiAgICAgIHRoaXMuX2xhc3RJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGUoKCkgPT4gewogICAgICAgIGNhbGxiYWNrKERhdGUubm93KCkpOwogICAgICB9KTsKICAgICAgcmV0dXJuIHRoaXMuX2xhc3RIYW5kbGVJZDsKICAgIH0KICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKF9pZCkgewogICAgICBpZiAodGhpcy5fbGFzdEltbWVkaWF0ZSkgewogICAgICAgIGNsZWFySW1tZWRpYXRlKHRoaXMuX2xhc3RJbW1lZGlhdGUpOwogICAgICB9CiAgICB9CiAgfTsKICB2YXIgQW5pbWF0aW9uRnJhbWVNYW5hZ2VyID0gY2xhc3MgewogICAgY29uc3RydWN0b3IoKSB7CiAgICAgIF9fcHVibGljRmllbGQodGhpcywgIl9zdHJhdGVneSIpOwogICAgICB0aGlzLl9zdHJhdGVneSA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICJmdW5jdGlvbiIgPyBuZXcgV2ViQW5pbWF0aW9uRnJhbWVTdHJhdGVneSgpIDogbmV3IE5vZGVBbmltYXRpb25GcmFtZVN0cmF0ZWd5KCk7CiAgICB9CiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spIHsKICAgICAgcmV0dXJuIHRoaXMuX3N0cmF0ZWd5LnJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjayk7CiAgICB9CiAgICBjYW5jZWxBbmltYXRpb25GcmFtZShpZCkgewogICAgICB0aGlzLl9zdHJhdGVneS5jYW5jZWxBbmltYXRpb25GcmFtZShpZCk7CiAgICB9CiAgfTsKCiAgLy8gc3JjL2NvbnN0YW50cy50cwogIHZhciBJU19CUk9XU0VSID0gdHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gInVuZGVmaW5lZCI7CiAgdmFyIFpJUF9TSUdOQVRVUkUgPSBuZXcgVWludDhBcnJheShbODAsIDc1LCAzLCA0XSk7CiAgdmFyIExPVFRJRV9KU09OX01BTkRBVE9SWV9GSUVMRFMgPSBbInYiLCAiaXAiLCAib3AiLCAibGF5ZXJzIiwgImZyIiwgInciLCAiaCJdOwogIHZhciBQQUNLQUdFX1ZFUlNJT04gPSAiMC4zMC4zIjsKICB2YXIgUEFDS0FHRV9OQU1FID0gIkBsb3R0aWVmaWxlcy9kb3Rsb3R0aWUtd2ViIjsKCiAgLy8gc3JjL2NvcmUvZG90bG90dGllLXBsYXllci5qcwogIHZhciBjcmVhdGVEb3RMb3R0aWVQbGF5ZXJNb2R1bGUgPSAoKCkgPT4gewogICAgdmFyIF9zY3JpcHREaXIgPSB0eXBlb2YgZG9jdW1lbnQgIT0gInVuZGVmaW5lZCIgPyBkb2N1bWVudC5jdXJyZW50U2NyaXB0Py5zcmMgOiB2b2lkIDA7CiAgICByZXR1cm4gZnVuY3Rpb24obW9kdWxlQXJnID0ge30pIHsKICAgICAgdmFyIGsgPSBtb2R1bGVBcmcsIGFhLCBiYSwgcmVhZHlQcm9taXNlID0gbmV3IFByb21pc2UoKGEsIGIpID0+IHsKICAgICAgICBhYSA9IGE7CiAgICAgICAgYmEgPSBiOwogICAgICB9KSwgY2EgPSBPYmplY3QuYXNzaWduKHt9LCBrKSwgZGEgPSAiLi90aGlzLnByb2dyYW0iLCB0ID0gIiI7CiAgICAgICJ1bmRlZmluZWQiICE9IHR5cGVvZiBkb2N1bWVudCAmJiBkb2N1bWVudC5jdXJyZW50U2NyaXB0ICYmICh0ID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMpOwogICAgICBfc2NyaXB0RGlyICYmICh0ID0gX3NjcmlwdERpcik7CiAgICAgIHQuc3RhcnRzV2l0aCgiYmxvYjoiKSA/IHQgPSAiIiA6IHQgPSB0LnN1YnN0cigwLCB0LnJlcGxhY2UoL1s/I10uKi8sICIiKS5sYXN0SW5kZXhPZigiLyIpICsgMSk7CiAgICAgIHZhciBlYSA9IGsucHJpbnQgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKSwgdyA9IGsucHJpbnRFcnIgfHwgY29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpOwogICAgICBPYmplY3QuYXNzaWduKGssIGNhKTsKICAgICAgY2EgPSBudWxsOwogICAgICBrLnRoaXNQcm9ncmFtICYmIChkYSA9IGsudGhpc1Byb2dyYW0pOwogICAgICB2YXIgeDsKICAgICAgay53YXNtQmluYXJ5ICYmICh4ID0gay53YXNtQmluYXJ5KTsKICAgICAgdmFyIGZhLCBoYSA9IGZhbHNlLCB5LCBBLCBCLCBDLCBFLCBGLCBqYSwga2E7CiAgICAgIGZ1bmN0aW9uIGxhKCkgewogICAgICAgIHZhciBhID0gZmEuYnVmZmVyOwogICAgICAgIGsuSEVBUDggPSB5ID0gbmV3IEludDhBcnJheShhKTsKICAgICAgICBrLkhFQVAxNiA9IEIgPSBuZXcgSW50MTZBcnJheShhKTsKICAgICAgICBrLkhFQVBVOCA9IEEgPSBuZXcgVWludDhBcnJheShhKTsKICAgICAgICBrLkhFQVBVMTYgPSBDID0gbmV3IFVpbnQxNkFycmF5KGEpOwogICAgICAgIGsuSEVBUDMyID0gRSA9IG5ldyBJbnQzMkFycmF5KGEpOwogICAgICAgIGsuSEVBUFUzMiA9IEYgPSBuZXcgVWludDMyQXJyYXkoYSk7CiAgICAgICAgay5IRUFQRjMyID0gamEgPSBuZXcgRmxvYXQzMkFycmF5KGEpOwogICAgICAgIGsuSEVBUEY2NCA9IGthID0gbmV3IEZsb2F0NjRBcnJheShhKTsKICAgICAgfQogICAgICB2YXIgbWEgPSBbXSwgbmEgPSBbXSwgb2EgPSBbXTsKICAgICAgZnVuY3Rpb24gcGEoKSB7CiAgICAgICAgdmFyIGEgPSBrLnByZVJ1bi5zaGlmdCgpOwogICAgICAgIG1hLnVuc2hpZnQoYSk7CiAgICAgIH0KICAgICAgdmFyIEcgPSAwLCBxYSA9IG51bGwsIEggPSBudWxsOwogICAgICBmdW5jdGlvbiByYShhKSB7CiAgICAgICAgay5vbkFib3J0Py4oYSk7CiAgICAgICAgYSA9ICJBYm9ydGVkKCIgKyBhICsgIikiOwogICAgICAgIHcoYSk7CiAgICAgICAgaGEgPSB0cnVlOwogICAgICAgIGEgPSBuZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKGEgKyAiLiBCdWlsZCB3aXRoIC1zQVNTRVJUSU9OUyBmb3IgbW9yZSBpbmZvLiIpOwogICAgICAgIGJhKGEpOwogICAgICAgIHRocm93IGE7CiAgICAgIH0KICAgICAgdmFyIHNhID0gKGEpID0+IGEuc3RhcnRzV2l0aCgiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LCIpLCBJOwogICAgICBJID0gIkRvdExvdHRpZVBsYXllci53YXNtIjsKICAgICAgaWYgKCFzYShJKSkgewogICAgICAgIHZhciB0YSA9IEk7CiAgICAgICAgSSA9IGsubG9jYXRlRmlsZSA/IGsubG9jYXRlRmlsZSh0YSwgdCkgOiB0ICsgdGE7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdWEoYSkgewogICAgICAgIGlmIChhID09IEkgJiYgeCkgcmV0dXJuIG5ldyBVaW50OEFycmF5KHgpOwogICAgICAgIHRocm93ICJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZCI7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gdmEoYSkgewogICAgICAgIHJldHVybiB4IHx8ICJmdW5jdGlvbiIgIT0gdHlwZW9mIGZldGNoID8gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB1YShhKSkgOiBmZXRjaChhLCB7IGNyZWRlbnRpYWxzOiAic2FtZS1vcmlnaW4iIH0pLnRoZW4oKGIpID0+IHsKICAgICAgICAgIGlmICghYi5vaykgdGhyb3cgYGZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJyR7YX0nYDsKICAgICAgICAgIHJldHVybiBiLmFycmF5QnVmZmVyKCk7CiAgICAgICAgfSkuY2F0Y2goKCkgPT4gdWEoYSkpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHdhKGEsIGIsIGMpIHsKICAgICAgICByZXR1cm4gdmEoYSkudGhlbigoZCkgPT4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoZCwgYikpLnRoZW4oYywgKGQpID0+IHsKICAgICAgICAgIHcoYGZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206ICR7ZH1gKTsKICAgICAgICAgIHJhKGQpOwogICAgICAgIH0pOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHhhKGEsIGIpIHsKICAgICAgICB2YXIgYyA9IEk7CiAgICAgICAgcmV0dXJuIHggfHwgImZ1bmN0aW9uIiAhPSB0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcgfHwgc2EoYykgfHwgImZ1bmN0aW9uIiAhPSB0eXBlb2YgZmV0Y2ggPyB3YShjLCBhLCBiKSA6IGZldGNoKGMsIHsgY3JlZGVudGlhbHM6ICJzYW1lLW9yaWdpbiIgfSkudGhlbigKICAgICAgICAgIChkKSA9PiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhkLCBhKS50aGVuKGIsIGZ1bmN0aW9uKGUpIHsKICAgICAgICAgICAgdyhgd2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6ICR7ZX1gKTsKICAgICAgICAgICAgdygiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb24iKTsKICAgICAgICAgICAgcmV0dXJuIHdhKGMsIGEsIGIpOwogICAgICAgICAgfSkKICAgICAgICApOwogICAgICB9CiAgICAgIHZhciB5YSA9IChhKSA9PiB7CiAgICAgICAgZm9yICg7IDAgPCBhLmxlbmd0aDsgKSBhLnNoaWZ0KCkoayk7CiAgICAgIH0sIHphID0gInVuZGVmaW5lZCIgIT0gdHlwZW9mIFRleHREZWNvZGVyID8gbmV3IFRleHREZWNvZGVyKCJ1dGY4IikgOiB2b2lkIDAsIEogPSAoYSwgYiwgYykgPT4gewogICAgICAgIHZhciBkID0gYiArIGM7CiAgICAgICAgZm9yIChjID0gYjsgYVtjXSAmJiAhKGMgPj0gZCk7ICkgKytjOwogICAgICAgIGlmICgxNiA8IGMgLSBiICYmIGEuYnVmZmVyICYmIHphKSByZXR1cm4gemEuZGVjb2RlKGEuc3ViYXJyYXkoYiwgYykpOwogICAgICAgIGZvciAoZCA9ICIiOyBiIDwgYzsgKSB7CiAgICAgICAgICB2YXIgZSA9IGFbYisrXTsKICAgICAgICAgIGlmIChlICYgMTI4KSB7CiAgICAgICAgICAgIHZhciBmID0gYVtiKytdICYgNjM7CiAgICAgICAgICAgIGlmICgxOTIgPT0gKGUgJiAyMjQpKSBkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGUgJiAzMSkgPDwgNiB8IGYpOwogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICB2YXIgbCA9IGFbYisrXSAmIDYzOwogICAgICAgICAgICAgIGUgPSAyMjQgPT0gKGUgJiAyNDApID8gKGUgJiAxNSkgPDwgMTIgfCBmIDw8IDYgfCBsIDogKGUgJiA3KSA8PCAxOCB8IGYgPDwgMTIgfCBsIDw8IDYgfCBhW2IrK10gJiA2MzsKICAgICAgICAgICAgICA2NTUzNiA+IGUgPyBkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZSkgOiAoZSAtPSA2NTUzNiwgZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2IHwgZSA+PiAxMCwgNTYzMjAgfCBlICYgMTAyMykpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZDsKICAgICAgfTsKICAgICAgY2xhc3MgQWEgewogICAgICAgIGNvbnN0cnVjdG9yKGEpIHsKICAgICAgICAgIHRoaXMueWEgPSBhIC0gMjQ7CiAgICAgICAgfQogICAgICB9CiAgICAgIHZhciBCYSA9IDAsIENhID0gMCwgRGEgPSAoYSkgPT4gewogICAgICAgIGZvciAodmFyIGIgPSAwLCBjID0gMDsgYyA8IGEubGVuZ3RoOyArK2MpIHsKICAgICAgICAgIHZhciBkID0gYS5jaGFyQ29kZUF0KGMpOwogICAgICAgICAgMTI3ID49IGQgPyBiKysgOiAyMDQ3ID49IGQgPyBiICs9IDIgOiA1NTI5NiA8PSBkICYmIDU3MzQzID49IGQgPyAoYiArPSA0LCArK2MpIDogYiArPSAzOwogICAgICAgIH0KICAgICAgICByZXR1cm4gYjsKICAgICAgfSwgRWEgPSAoYSwgYiwgYywgZCkgPT4gewogICAgICAgIGlmICgwIDwgZCkgewogICAgICAgICAgZCA9IGMgKyBkIC0gMTsKICAgICAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgYS5sZW5ndGg7ICsrZSkgewogICAgICAgICAgICB2YXIgZiA9IGEuY2hhckNvZGVBdChlKTsKICAgICAgICAgICAgaWYgKDU1Mjk2IDw9IGYgJiYgNTczNDMgPj0gZikgewogICAgICAgICAgICAgIHZhciBsID0gYS5jaGFyQ29kZUF0KCsrZSk7CiAgICAgICAgICAgICAgZiA9IDY1NTM2ICsgKChmICYgMTAyMykgPDwgMTApIHwgbCAmIDEwMjM7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKDEyNyA+PSBmKSB7CiAgICAgICAgICAgICAgaWYgKGMgPj0gZCkgYnJlYWs7CiAgICAgICAgICAgICAgYltjKytdID0gZjsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBpZiAoMjA0NyA+PSBmKSB7CiAgICAgICAgICAgICAgICBpZiAoYyArIDEgPj0gZCkgYnJlYWs7CiAgICAgICAgICAgICAgICBiW2MrK10gPSAxOTIgfCBmID4+IDY7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGlmICg2NTUzNSA+PSBmKSB7CiAgICAgICAgICAgICAgICAgIGlmIChjICsgMiA+PSBkKSBicmVhazsKICAgICAgICAgICAgICAgICAgYltjKytdID0gMjI0IHwgZiA+PiAxMjsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIGlmIChjICsgMyA+PSBkKSBicmVhazsKICAgICAgICAgICAgICAgICAgYltjKytdID0gMjQwIHwgZiA+PiAxODsKICAgICAgICAgICAgICAgICAgYltjKytdID0gMTI4IHwgZiA+PiAxMiAmIDYzOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgYltjKytdID0gMTI4IHwgZiA+PiA2ICYgNjM7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGJbYysrXSA9IDEyOCB8IGYgJiA2MzsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgYltjXSA9IDA7CiAgICAgICAgfQogICAgICB9LCBGYSA9IHt9LCBHYSA9IChhKSA9PiB7CiAgICAgICAgZm9yICg7IGEubGVuZ3RoOyApIHsKICAgICAgICAgIHZhciBiID0gYS5wb3AoKTsKICAgICAgICAgIGEucG9wKCkoYik7CiAgICAgICAgfQogICAgICB9OwogICAgICBmdW5jdGlvbiBLKGEpIHsKICAgICAgICByZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoRlthID4+IDJdKTsKICAgICAgfQogICAgICB2YXIgTCA9IHt9LCBNID0ge30sIEhhID0ge30sIElhLCBQID0gKGEsIGIsIGMpID0+IHsKICAgICAgICBmdW5jdGlvbiBkKGgpIHsKICAgICAgICAgIGggPSBjKGgpOwogICAgICAgICAgaWYgKGgubGVuZ3RoICE9PSBhLmxlbmd0aCkgdGhyb3cgbmV3IElhKCJNaXNtYXRjaGVkIHR5cGUgY29udmVydGVyIGNvdW50Iik7CiAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGEubGVuZ3RoOyArK24pIE8oYVtuXSwgaFtuXSk7CiAgICAgICAgfQogICAgICAgIGEuZm9yRWFjaChmdW5jdGlvbihoKSB7CiAgICAgICAgICBIYVtoXSA9IGI7CiAgICAgICAgfSk7CiAgICAgICAgdmFyIGUgPSBBcnJheShiLmxlbmd0aCksIGYgPSBbXSwgbCA9IDA7CiAgICAgICAgYi5mb3JFYWNoKChoLCBuKSA9PiB7CiAgICAgICAgICBNLmhhc093blByb3BlcnR5KGgpID8gZVtuXSA9IE1baF0gOiAoZi5wdXNoKGgpLCBMLmhhc093blByb3BlcnR5KGgpIHx8IChMW2hdID0gW10pLCBMW2hdLnB1c2goKCkgPT4gewogICAgICAgICAgICBlW25dID0gTVtoXTsKICAgICAgICAgICAgKytsOwogICAgICAgICAgICBsID09PSBmLmxlbmd0aCAmJiBkKGUpOwogICAgICAgICAgfSkpOwogICAgICAgIH0pOwogICAgICAgIDAgPT09IGYubGVuZ3RoICYmIGQoZSk7CiAgICAgIH0sIEphLCBRID0gKGEpID0+IHsKICAgICAgICBmb3IgKHZhciBiID0gIiI7IEFbYV07ICkgYiArPSBKYVtBW2ErK11dOwogICAgICAgIHJldHVybiBiOwogICAgICB9LCBSOwogICAgICBmdW5jdGlvbiBLYShhLCBiLCBjID0ge30pIHsKICAgICAgICB2YXIgZCA9IGIubmFtZTsKICAgICAgICBpZiAoIWEpIHRocm93IG5ldyBSKGB0eXBlICIke2R9IiBtdXN0IGhhdmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIHR5cGVpZCBwb2ludGVyYCk7CiAgICAgICAgaWYgKE0uaGFzT3duUHJvcGVydHkoYSkpIHsKICAgICAgICAgIGlmIChjLmliKSByZXR1cm47CiAgICAgICAgICB0aHJvdyBuZXcgUihgQ2Fubm90IHJlZ2lzdGVyIHR5cGUgJyR7ZH0nIHR3aWNlYCk7CiAgICAgICAgfQogICAgICAgIE1bYV0gPSBiOwogICAgICAgIGRlbGV0ZSBIYVthXTsKICAgICAgICBMLmhhc093blByb3BlcnR5KGEpICYmIChiID0gTFthXSwgZGVsZXRlIExbYV0sIGIuZm9yRWFjaCgoZSkgPT4gZSgpKSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gTyhhLCBiLCBjID0ge30pIHsKICAgICAgICBpZiAoISgiYXJnUGFja0FkdmFuY2UiIGluIGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCJyZWdpc3RlclR5cGUgcmVnaXN0ZXJlZEluc3RhbmNlIHJlcXVpcmVzIGFyZ1BhY2tBZHZhbmNlIik7CiAgICAgICAgcmV0dXJuIEthKGEsIGIsIGMpOwogICAgICB9CiAgICAgIHZhciBMYSA9IChhKSA9PiB7CiAgICAgICAgdGhyb3cgbmV3IFIoYS5tYS56YS54YS5uYW1lICsgIiBpbnN0YW5jZSBhbHJlYWR5IGRlbGV0ZWQiKTsKICAgICAgfSwgTWEgPSBmYWxzZSwgT2EgPSAoKSA9PiB7CiAgICAgIH0sIFBhID0gKGEsIGIsIGMpID0+IHsKICAgICAgICBpZiAoYiA9PT0gYykgcmV0dXJuIGE7CiAgICAgICAgaWYgKHZvaWQgMCA9PT0gYy5DYSkgcmV0dXJuIG51bGw7CiAgICAgICAgYSA9IFBhKGEsIGIsIGMuQ2EpOwogICAgICAgIHJldHVybiBudWxsID09PSBhID8gbnVsbCA6IGMuYWIoYSk7CiAgICAgIH0sIFFhID0ge30sIFJhID0gW10sIFNhID0gKCkgPT4gewogICAgICAgIGZvciAoOyBSYS5sZW5ndGg7ICkgewogICAgICAgICAgdmFyIGEgPSBSYS5wb3AoKTsKICAgICAgICAgIGEubWEuS2EgPSBmYWxzZTsKICAgICAgICAgIGFbImRlbGV0ZSJdKCk7CiAgICAgICAgfQogICAgICB9LCBUYSwgVWEgPSB7fSwgVmEgPSAoYSwgYikgPT4gewogICAgICAgIGlmICh2b2lkIDAgPT09IGIpIHRocm93IG5ldyBSKCJwdHIgc2hvdWxkIG5vdCBiZSB1bmRlZmluZWQiKTsKICAgICAgICBmb3IgKDsgYS5DYTsgKSBiID0gYS5OYShiKSwgYSA9IGEuQ2E7CiAgICAgICAgcmV0dXJuIFVhW2JdOwogICAgICB9LCBYYSA9IChhLCBiKSA9PiB7CiAgICAgICAgaWYgKCFiLnphIHx8ICFiLnlhKSB0aHJvdyBuZXcgSWEoIm1ha2VDbGFzc0hhbmRsZSByZXF1aXJlcyBwdHIgYW5kIHB0clR5cGUiKTsKICAgICAgICBpZiAoISFiLkRhICE9PSAhIWIuQWEpIHRocm93IG5ldyBJYSgiQm90aCBzbWFydFB0clR5cGUgYW5kIHNtYXJ0UHRyIG11c3QgYmUgc3BlY2lmaWVkIik7CiAgICAgICAgYi5jb3VudCA9IHsgdmFsdWU6IDEgfTsKICAgICAgICByZXR1cm4gV2EoT2JqZWN0LmNyZWF0ZShhLCB7IG1hOiB7IHZhbHVlOiBiLCB3cml0YWJsZTogdHJ1ZSB9IH0pKTsKICAgICAgfSwgV2EgPSAoYSkgPT4gewogICAgICAgIGlmICgidW5kZWZpbmVkIiA9PT0gdHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5KSByZXR1cm4gV2EgPSAoYikgPT4gYiwgYTsKICAgICAgICBNYSA9IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgoYikgPT4gewogICAgICAgICAgYiA9IGIubWE7CiAgICAgICAgICAtLWIuY291bnQudmFsdWU7CiAgICAgICAgICAwID09PSBiLmNvdW50LnZhbHVlICYmIChiLkFhID8gYi5EYS5GYShiLkFhKSA6IGIuemEueGEuRmEoYi55YSkpOwogICAgICAgIH0pOwogICAgICAgIFdhID0gKGIpID0+IHsKICAgICAgICAgIHZhciBjID0gYi5tYTsKICAgICAgICAgIGMuQWEgJiYgTWEucmVnaXN0ZXIoYiwgeyBtYTogYyB9LCBiKTsKICAgICAgICAgIHJldHVybiBiOwogICAgICAgIH07CiAgICAgICAgT2EgPSAoYikgPT4gewogICAgICAgICAgTWEudW5yZWdpc3RlcihiKTsKICAgICAgICB9OwogICAgICAgIHJldHVybiBXYShhKTsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gWWEoKSB7CiAgICAgIH0KICAgICAgdmFyIFphID0gKGEsIGIpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLCAibmFtZSIsIHsgdmFsdWU6IGEgfSksICRhID0gKGEsIGIsIGMpID0+IHsKICAgICAgICBpZiAodm9pZCAwID09PSBhW2JdLkJhKSB7CiAgICAgICAgICB2YXIgZCA9IGFbYl07CiAgICAgICAgICBhW2JdID0gZnVuY3Rpb24oLi4uZSkgewogICAgICAgICAgICBpZiAoIWFbYl0uQmEuaGFzT3duUHJvcGVydHkoZS5sZW5ndGgpKQogICAgICAgICAgICAgIHRocm93IG5ldyBSKAogICAgICAgICAgICAgICAgYEZ1bmN0aW9uICcke2N9JyBjYWxsZWQgd2l0aCBhbiBpbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMgKCR7ZS5sZW5ndGh9KSAtIGV4cGVjdHMgb25lIG9mICgke2FbYl0uQmF9KSFgCiAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgcmV0dXJuIGFbYl0uQmFbZS5sZW5ndGhdLmFwcGx5KHRoaXMsIGUpOwogICAgICAgICAgfTsKICAgICAgICAgIGFbYl0uQmEgPSBbXTsKICAgICAgICAgIGFbYl0uQmFbZC5PYV0gPSBkOwogICAgICAgIH0KICAgICAgfSwgYWIgPSAoYSwgYiwgYykgPT4gewogICAgICAgIGlmIChrLmhhc093blByb3BlcnR5KGEpKSB7CiAgICAgICAgICBpZiAodm9pZCAwID09PSBjIHx8IHZvaWQgMCAhPT0ga1thXS5CYSAmJiB2b2lkIDAgIT09IGtbYV0uQmFbY10pCiAgICAgICAgICAgIHRocm93IG5ldyBSKGBDYW5ub3QgcmVnaXN0ZXIgcHVibGljIG5hbWUgJyR7YX0nIHR3aWNlYCk7CiAgICAgICAgICAkYShrLCBhLCBhKTsKICAgICAgICAgIGlmIChrLmhhc093blByb3BlcnR5KGMpKQogICAgICAgICAgICB0aHJvdyBuZXcgUihgQ2Fubm90IHJlZ2lzdGVyIG11bHRpcGxlIG92ZXJsb2FkcyBvZiBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cyAoJHtjfSkhYCk7CiAgICAgICAgICBrW2FdLkJhW2NdID0gYjsKICAgICAgICB9IGVsc2Uga1thXSA9IGIsIHZvaWQgMCAhPT0gYyAmJiAoa1thXS52YiA9IGMpOwogICAgICB9LCBiYiA9IChhKSA9PiB7CiAgICAgICAgaWYgKHZvaWQgMCA9PT0gYSkgcmV0dXJuICJfdW5rbm93biI7CiAgICAgICAgYSA9IGEucmVwbGFjZSgvW15hLXpBLVowLTlfXS9nLCAiJCIpOwogICAgICAgIHZhciBiID0gYS5jaGFyQ29kZUF0KDApOwogICAgICAgIHJldHVybiA0OCA8PSBiICYmIDU3ID49IGIgPyBgXyR7YX1gIDogYTsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gY2IoYSwgYiwgYywgZCwgZSwgZiwgbCwgaCkgewogICAgICAgIHRoaXMubmFtZSA9IGE7CiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGI7CiAgICAgICAgdGhpcy5MYSA9IGM7CiAgICAgICAgdGhpcy5GYSA9IGQ7CiAgICAgICAgdGhpcy5DYSA9IGU7CiAgICAgICAgdGhpcy5jYiA9IGY7CiAgICAgICAgdGhpcy5OYSA9IGw7CiAgICAgICAgdGhpcy5hYiA9IGg7CiAgICAgICAgdGhpcy5rYiA9IFtdOwogICAgICB9CiAgICAgIHZhciBkYiA9IChhLCBiLCBjKSA9PiB7CiAgICAgICAgZm9yICg7IGIgIT09IGM7ICkgewogICAgICAgICAgaWYgKCFiLk5hKSB0aHJvdyBuZXcgUihgRXhwZWN0ZWQgbnVsbCBvciBpbnN0YW5jZSBvZiAke2MubmFtZX0sIGdvdCBhbiBpbnN0YW5jZSBvZiAke2IubmFtZX1gKTsKICAgICAgICAgIGEgPSBiLk5hKGEpOwogICAgICAgICAgYiA9IGIuQ2E7CiAgICAgICAgfQogICAgICAgIHJldHVybiBhOwogICAgICB9OwogICAgICBmdW5jdGlvbiBlYihhLCBiKSB7CiAgICAgICAgaWYgKG51bGwgPT09IGIpIHsKICAgICAgICAgIGlmICh0aGlzLlRhKSB0aHJvdyBuZXcgUihgbnVsbCBpcyBub3QgYSB2YWxpZCAke3RoaXMubmFtZX1gKTsKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0KICAgICAgICBpZiAoIWIubWEpIHRocm93IG5ldyBSKGBDYW5ub3QgcGFzcyAiJHtmYihiKX0iIGFzIGEgJHt0aGlzLm5hbWV9YCk7CiAgICAgICAgaWYgKCFiLm1hLnlhKSB0aHJvdyBuZXcgUihgQ2Fubm90IHBhc3MgZGVsZXRlZCBvYmplY3QgYXMgYSBwb2ludGVyIG9mIHR5cGUgJHt0aGlzLm5hbWV9YCk7CiAgICAgICAgcmV0dXJuIGRiKGIubWEueWEsIGIubWEuemEueGEsIHRoaXMueGEpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGdiKGEsIGIpIHsKICAgICAgICBpZiAobnVsbCA9PT0gYikgewogICAgICAgICAgaWYgKHRoaXMuVGEpIHRocm93IG5ldyBSKGBudWxsIGlzIG5vdCBhIHZhbGlkICR7dGhpcy5uYW1lfWApOwogICAgICAgICAgaWYgKHRoaXMuUWEpIHsKICAgICAgICAgICAgdmFyIGMgPSB0aGlzLlVhKCk7CiAgICAgICAgICAgIG51bGwgIT09IGEgJiYgYS5wdXNoKHRoaXMuRmEsIGMpOwogICAgICAgICAgICByZXR1cm4gYzsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0KICAgICAgICBpZiAoIWIgfHwgIWIubWEpIHRocm93IG5ldyBSKGBDYW5ub3QgcGFzcyAiJHtmYihiKX0iIGFzIGEgJHt0aGlzLm5hbWV9YCk7CiAgICAgICAgaWYgKCFiLm1hLnlhKSB0aHJvdyBuZXcgUihgQ2Fubm90IHBhc3MgZGVsZXRlZCBvYmplY3QgYXMgYSBwb2ludGVyIG9mIHR5cGUgJHt0aGlzLm5hbWV9YCk7CiAgICAgICAgaWYgKCF0aGlzLlBhICYmIGIubWEuemEuUGEpCiAgICAgICAgICB0aHJvdyBuZXcgUigKICAgICAgICAgICAgYENhbm5vdCBjb252ZXJ0IGFyZ3VtZW50IG9mIHR5cGUgJHtiLm1hLkRhID8gYi5tYS5EYS5uYW1lIDogYi5tYS56YS5uYW1lfSB0byBwYXJhbWV0ZXIgdHlwZSAke3RoaXMubmFtZX1gCiAgICAgICAgICApOwogICAgICAgIGMgPSBkYihiLm1hLnlhLCBiLm1hLnphLnhhLCB0aGlzLnhhKTsKICAgICAgICBpZiAodGhpcy5RYSkgewogICAgICAgICAgaWYgKHZvaWQgMCA9PT0gYi5tYS5BYSkgdGhyb3cgbmV3IFIoIlBhc3NpbmcgcmF3IHBvaW50ZXIgdG8gc21hcnQgcG9pbnRlciBpcyBpbGxlZ2FsIik7CiAgICAgICAgICBzd2l0Y2ggKHRoaXMucGIpIHsKICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgIGlmIChiLm1hLkRhID09PSB0aGlzKSBjID0gYi5tYS5BYTsKICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUigKICAgICAgICAgICAgICAgICAgYENhbm5vdCBjb252ZXJ0IGFyZ3VtZW50IG9mIHR5cGUgJHtiLm1hLkRhID8gYi5tYS5EYS5uYW1lIDogYi5tYS56YS5uYW1lfSB0byBwYXJhbWV0ZXIgdHlwZSAke3RoaXMubmFtZX1gCiAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlIDE6CiAgICAgICAgICAgICAgYyA9IGIubWEuQWE7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgICBpZiAoYi5tYS5EYSA9PT0gdGhpcykgYyA9IGIubWEuQWE7CiAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICB2YXIgZCA9IGIuY2xvbmUoKTsKICAgICAgICAgICAgICAgIGMgPSB0aGlzLmxiKAogICAgICAgICAgICAgICAgICBjLAogICAgICAgICAgICAgICAgICBoYigoKSA9PiBkWyJkZWxldGUiXSgpKQogICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICAgIG51bGwgIT09IGEgJiYgYS5wdXNoKHRoaXMuRmEsIGMpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICB0aHJvdyBuZXcgUigiVW5zdXBwb3J0aW5nIHNoYXJpbmcgcG9saWN5Iik7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBjOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGliKGEsIGIpIHsKICAgICAgICBpZiAobnVsbCA9PT0gYikgewogICAgICAgICAgaWYgKHRoaXMuVGEpIHRocm93IG5ldyBSKGBudWxsIGlzIG5vdCBhIHZhbGlkICR7dGhpcy5uYW1lfWApOwogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgfQogICAgICAgIGlmICghYi5tYSkgdGhyb3cgbmV3IFIoYENhbm5vdCBwYXNzICIke2ZiKGIpfSIgYXMgYSAke3RoaXMubmFtZX1gKTsKICAgICAgICBpZiAoIWIubWEueWEpIHRocm93IG5ldyBSKGBDYW5ub3QgcGFzcyBkZWxldGVkIG9iamVjdCBhcyBhIHBvaW50ZXIgb2YgdHlwZSAke3RoaXMubmFtZX1gKTsKICAgICAgICBpZiAoYi5tYS56YS5QYSkgdGhyb3cgbmV3IFIoYENhbm5vdCBjb252ZXJ0IGFyZ3VtZW50IG9mIHR5cGUgJHtiLm1hLnphLm5hbWV9IHRvIHBhcmFtZXRlciB0eXBlICR7dGhpcy5uYW1lfWApOwogICAgICAgIHJldHVybiBkYihiLm1hLnlhLCBiLm1hLnphLnhhLCB0aGlzLnhhKTsKICAgICAgfQogICAgICBmdW5jdGlvbiBqYihhLCBiLCBjLCBkLCBlLCBmLCBsLCBoLCBuLCBtLCBwKSB7CiAgICAgICAgdGhpcy5uYW1lID0gYTsKICAgICAgICB0aGlzLnhhID0gYjsKICAgICAgICB0aGlzLlRhID0gYzsKICAgICAgICB0aGlzLlBhID0gZDsKICAgICAgICB0aGlzLlFhID0gZTsKICAgICAgICB0aGlzLmpiID0gZjsKICAgICAgICB0aGlzLnBiID0gbDsKICAgICAgICB0aGlzLlphID0gaDsKICAgICAgICB0aGlzLlVhID0gbjsKICAgICAgICB0aGlzLmxiID0gbTsKICAgICAgICB0aGlzLkZhID0gcDsKICAgICAgICBlIHx8IHZvaWQgMCAhPT0gYi5DYSA/IHRoaXMudG9XaXJlVHlwZSA9IGdiIDogKHRoaXMudG9XaXJlVHlwZSA9IGQgPyBlYiA6IGliLCB0aGlzLkVhID0gbnVsbCk7CiAgICAgIH0KICAgICAgdmFyIGtiID0gKGEsIGIsIGMpID0+IHsKICAgICAgICBpZiAoIWsuaGFzT3duUHJvcGVydHkoYSkpIHRocm93IG5ldyBJYSgiUmVwbGFjaW5nIG5vbmV4aXN0ZW50IHB1YmxpYyBzeW1ib2wiKTsKICAgICAgICB2b2lkIDAgIT09IGtbYV0uQmEgJiYgdm9pZCAwICE9PSBjID8ga1thXS5CYVtjXSA9IGIgOiAoa1thXSA9IGIsIGtbYV0uT2EgPSBjKTsKICAgICAgfSwgUywgbGIgPSAoYSwgYiwgYyA9IFtdKSA9PiB7CiAgICAgICAgYS5pbmNsdWRlcygiaiIpID8gKGEgPSBhLnJlcGxhY2UoL3AvZywgImkiKSwgYiA9ICgwLCBrWyJkeW5DYWxsXyIgKyBhXSkoYiwgLi4uYykpIDogYiA9IFMuZ2V0KGIpKC4uLmMpOwogICAgICAgIHJldHVybiBiOwogICAgICB9LCBtYiA9IChhLCBiKSA9PiAoLi4uYykgPT4gbGIoYSwgYiwgYyksIFQgPSAoYSwgYikgPT4gewogICAgICAgIGEgPSBRKGEpOwogICAgICAgIHZhciBjID0gYS5pbmNsdWRlcygiaiIpID8gbWIoYSwgYikgOiBTLmdldChiKTsKICAgICAgICBpZiAoImZ1bmN0aW9uIiAhPSB0eXBlb2YgYykgdGhyb3cgbmV3IFIoYHVua25vd24gZnVuY3Rpb24gcG9pbnRlciB3aXRoIHNpZ25hdHVyZSAke2F9OiAke2J9YCk7CiAgICAgICAgcmV0dXJuIGM7CiAgICAgIH0sIG5iLCBwYiA9IChhKSA9PiB7CiAgICAgICAgYSA9IG9iKGEpOwogICAgICAgIHZhciBiID0gUShhKTsKICAgICAgICBVKGEpOwogICAgICAgIHJldHVybiBiOwogICAgICB9LCBxYiA9IChhLCBiKSA9PiB7CiAgICAgICAgZnVuY3Rpb24gYyhmKSB7CiAgICAgICAgICBlW2ZdIHx8IE1bZl0gfHwgKEhhW2ZdID8gSGFbZl0uZm9yRWFjaChjKSA6IChkLnB1c2goZiksIGVbZl0gPSB0cnVlKSk7CiAgICAgICAgfQogICAgICAgIHZhciBkID0gW10sIGUgPSB7fTsKICAgICAgICBiLmZvckVhY2goYyk7CiAgICAgICAgdGhyb3cgbmV3IG5iKGAke2F9OiBgICsgZC5tYXAocGIpLmpvaW4oWyIsICJdKSk7CiAgICAgIH0sIHJiID0gKGEsIGIpID0+IHsKICAgICAgICBmb3IgKHZhciBjID0gW10sIGQgPSAwOyBkIDwgYTsgZCsrKSBjLnB1c2goRltiICsgNCAqIGQgPj4gMl0pOwogICAgICAgIHJldHVybiBjOwogICAgICB9OwogICAgICBmdW5jdGlvbiBzYihhKSB7CiAgICAgICAgZm9yICh2YXIgYiA9IDE7IGIgPCBhLmxlbmd0aDsgKytiKSBpZiAobnVsbCAhPT0gYVtiXSAmJiB2b2lkIDAgPT09IGFbYl0uRWEpIHJldHVybiB0cnVlOwogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQogICAgICBmdW5jdGlvbiB0YihhLCBiLCBjLCBkLCBlKSB7CiAgICAgICAgdmFyIGYgPSBiLmxlbmd0aDsKICAgICAgICBpZiAoMiA+IGYpIHRocm93IG5ldyBSKCJhcmdUeXBlcyBhcnJheSBzaXplIG1pc21hdGNoISBNdXN0IGF0IGxlYXN0IGdldCByZXR1cm4gdmFsdWUgYW5kICd0aGlzJyB0eXBlcyEiKTsKICAgICAgICB2YXIgbCA9IG51bGwgIT09IGJbMV0gJiYgbnVsbCAhPT0gYywgaCA9IHNiKGIpLCBuID0gInZvaWQiICE9PSBiWzBdLm5hbWUsIG0gPSBmIC0gMiwgcCA9IEFycmF5KG0pLCB1ID0gW10sIHYgPSBbXTsKICAgICAgICByZXR1cm4gWmEoYSwgZnVuY3Rpb24oLi4uZykgewogICAgICAgICAgaWYgKGcubGVuZ3RoICE9PSBtKSB0aHJvdyBuZXcgUihgZnVuY3Rpb24gJHthfSBjYWxsZWQgd2l0aCAke2cubGVuZ3RofSBhcmd1bWVudHMsIGV4cGVjdGVkICR7bX1gKTsKICAgICAgICAgIHYubGVuZ3RoID0gMDsKICAgICAgICAgIHUubGVuZ3RoID0gbCA/IDIgOiAxOwogICAgICAgICAgdVswXSA9IGU7CiAgICAgICAgICBpZiAobCkgewogICAgICAgICAgICB2YXIgcSA9IGJbMV0udG9XaXJlVHlwZSh2LCB0aGlzKTsKICAgICAgICAgICAgdVsxXSA9IHE7CiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IG07ICsrcikgcFtyXSA9IGJbciArIDJdLnRvV2lyZVR5cGUodiwgZ1tyXSksIHUucHVzaChwW3JdKTsKICAgICAgICAgIGcgPSBkKC4uLnUpOwogICAgICAgICAgaWYgKGgpIEdhKHYpOwogICAgICAgICAgZWxzZQogICAgICAgICAgICBmb3IgKHIgPSBsID8gMSA6IDI7IHIgPCBiLmxlbmd0aDsgcisrKSB7CiAgICAgICAgICAgICAgdmFyIHogPSAxID09PSByID8gcSA6IHBbciAtIDJdOwogICAgICAgICAgICAgIG51bGwgIT09IGJbcl0uRWEgJiYgYltyXS5FYSh6KTsKICAgICAgICAgICAgfQogICAgICAgICAgcSA9IG4gPyBiWzBdLmZyb21XaXJlVHlwZShnKSA6IHZvaWQgMDsKICAgICAgICAgIHJldHVybiBxOwogICAgICAgIH0pOwogICAgICB9CiAgICAgIHZhciB1YiA9IChhKSA9PiB7CiAgICAgICAgYSA9IGEudHJpbSgpOwogICAgICAgIGNvbnN0IGIgPSBhLmluZGV4T2YoIigiKTsKICAgICAgICByZXR1cm4gLTEgIT09IGIgPyBhLnN1YnN0cigwLCBiKSA6IGE7CiAgICAgIH0sIHZiID0gW10sIFYgPSBbXSwgd2IgPSAoYSkgPT4gewogICAgICAgIDkgPCBhICYmIDAgPT09IC0tVlthICsgMV0gJiYgKFZbYV0gPSB2b2lkIDAsIHZiLnB1c2goYSkpOwogICAgICB9LCB5YiA9IChhKSA9PiB7CiAgICAgICAgaWYgKCFhKSB0aHJvdyBuZXcgUigiQ2Fubm90IHVzZSBkZWxldGVkIHZhbC4gaGFuZGxlID0gIiArIGEpOwogICAgICAgIHJldHVybiBWW2FdOwogICAgICB9LCBoYiA9IChhKSA9PiB7CiAgICAgICAgc3dpdGNoIChhKSB7CiAgICAgICAgICBjYXNlIHZvaWQgMDoKICAgICAgICAgICAgcmV0dXJuIDI7CiAgICAgICAgICBjYXNlIG51bGw6CiAgICAgICAgICAgIHJldHVybiA0OwogICAgICAgICAgY2FzZSB0cnVlOgogICAgICAgICAgICByZXR1cm4gNjsKICAgICAgICAgIGNhc2UgZmFsc2U6CiAgICAgICAgICAgIHJldHVybiA4OwogICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgY29uc3QgYiA9IHZiLnBvcCgpIHx8IFYubGVuZ3RoOwogICAgICAgICAgICBWW2JdID0gYTsKICAgICAgICAgICAgVltiICsgMV0gPSAxOwogICAgICAgICAgICByZXR1cm4gYjsKICAgICAgICB9CiAgICAgIH0sIHpiID0gewogICAgICAgIG5hbWU6ICJlbXNjcmlwdGVuOjp2YWwiLAogICAgICAgIGZyb21XaXJlVHlwZTogKGEpID0+IHsKICAgICAgICAgIHZhciBiID0geWIoYSk7CiAgICAgICAgICB3YihhKTsKICAgICAgICAgIHJldHVybiBiOwogICAgICAgIH0sCiAgICAgICAgdG9XaXJlVHlwZTogKGEsIGIpID0+IGhiKGIpLAogICAgICAgIGFyZ1BhY2tBZHZhbmNlOiA4LAogICAgICAgIHJlYWRWYWx1ZUZyb21Qb2ludGVyOiBLLAogICAgICAgIEVhOiBudWxsCiAgICAgIH0sIEFiID0gKGEsIGIsIGMpID0+IHsKICAgICAgICBzd2l0Y2ggKGIpIHsKICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgcmV0dXJuIGMgPyBmdW5jdGlvbihkKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKHlbZF0pOwogICAgICAgICAgICB9IDogZnVuY3Rpb24oZCkgewogICAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21XaXJlVHlwZShBW2RdKTsKICAgICAgICAgICAgfTsKICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgcmV0dXJuIGMgPyBmdW5jdGlvbihkKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKEJbZCA+PiAxXSk7CiAgICAgICAgICAgIH0gOiBmdW5jdGlvbihkKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKENbZCA+PiAxXSk7CiAgICAgICAgICAgIH07CiAgICAgICAgICBjYXNlIDQ6CiAgICAgICAgICAgIHJldHVybiBjID8gZnVuY3Rpb24oZCkgewogICAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21XaXJlVHlwZShFW2QgPj4gMl0pOwogICAgICAgICAgICB9IDogZnVuY3Rpb24oZCkgewogICAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21XaXJlVHlwZShGW2QgPj4gMl0pOwogICAgICAgICAgICB9OwogICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBpbnRlZ2VyIHdpZHRoICgke2J9KTogJHthfWApOwogICAgICAgIH0KICAgICAgfSwgQmIgPSAoYSwgYikgPT4gewogICAgICAgIHZhciBjID0gTVthXTsKICAgICAgICBpZiAodm9pZCAwID09PSBjKSB0aHJvdyBhID0gYCR7Yn0gaGFzIHVua25vd24gdHlwZSAke3BiKGEpfWAsIG5ldyBSKGEpOwogICAgICAgIHJldHVybiBjOwogICAgICB9LCBmYiA9IChhKSA9PiB7CiAgICAgICAgaWYgKG51bGwgPT09IGEpIHJldHVybiAibnVsbCI7CiAgICAgICAgdmFyIGIgPSB0eXBlb2YgYTsKICAgICAgICByZXR1cm4gIm9iamVjdCIgPT09IGIgfHwgImFycmF5IiA9PT0gYiB8fCAiZnVuY3Rpb24iID09PSBiID8gYS50b1N0cmluZygpIDogIiIgKyBhOwogICAgICB9LCBDYiA9IChhLCBiKSA9PiB7CiAgICAgICAgc3dpdGNoIChiKSB7CiAgICAgICAgICBjYXNlIDQ6CiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKGphW2MgPj4gMl0pOwogICAgICAgICAgICB9OwogICAgICAgICAgY2FzZSA4OgogICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oYykgewogICAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21XaXJlVHlwZShrYVtjID4+IDNdKTsKICAgICAgICAgICAgfTsKICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgZmxvYXQgd2lkdGggKCR7Yn0pOiAke2F9YCk7CiAgICAgICAgfQogICAgICB9LCBEYiA9IChhLCBiLCBjKSA9PiB7CiAgICAgICAgc3dpdGNoIChiKSB7CiAgICAgICAgICBjYXNlIDE6CiAgICAgICAgICAgIHJldHVybiBjID8gKGQpID0+IHlbZF0gOiAoZCkgPT4gQVtkXTsKICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgcmV0dXJuIGMgPyAoZCkgPT4gQltkID4+IDFdIDogKGQpID0+IENbZCA+PiAxXTsKICAgICAgICAgIGNhc2UgNDoKICAgICAgICAgICAgcmV0dXJuIGMgPyAoZCkgPT4gRVtkID4+IDJdIDogKGQpID0+IEZbZCA+PiAyXTsKICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgaW50ZWdlciB3aWR0aCAoJHtifSk6ICR7YX1gKTsKICAgICAgICB9CiAgICAgIH0sIEViID0gInVuZGVmaW5lZCIgIT0gdHlwZW9mIFRleHREZWNvZGVyID8gbmV3IFRleHREZWNvZGVyKCJ1dGYtMTZsZSIpIDogdm9pZCAwLCBGYiA9IChhLCBiKSA9PiB7CiAgICAgICAgdmFyIGMgPSBhID4+IDE7CiAgICAgICAgZm9yICh2YXIgZCA9IGMgKyBiIC8gMjsgIShjID49IGQpICYmIENbY107ICkgKytjOwogICAgICAgIGMgPDw9IDE7CiAgICAgICAgaWYgKDMyIDwgYyAtIGEgJiYgRWIpIHJldHVybiBFYi5kZWNvZGUoQS5zdWJhcnJheShhLCBjKSk7CiAgICAgICAgYyA9ICIiOwogICAgICAgIGZvciAoZCA9IDA7ICEoZCA+PSBiIC8gMik7ICsrZCkgewogICAgICAgICAgdmFyIGUgPSBCW2EgKyAyICogZCA+PiAxXTsKICAgICAgICAgIGlmICgwID09IGUpIGJyZWFrOwogICAgICAgICAgYyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gYzsKICAgICAgfSwgR2IgPSAoYSwgYiwgYykgPT4gewogICAgICAgIGMgPz8gKGMgPSAyMTQ3NDgzNjQ3KTsKICAgICAgICBpZiAoMiA+IGMpIHJldHVybiAwOwogICAgICAgIGMgLT0gMjsKICAgICAgICB2YXIgZCA9IGI7CiAgICAgICAgYyA9IGMgPCAyICogYS5sZW5ndGggPyBjIC8gMiA6IGEubGVuZ3RoOwogICAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgYzsgKytlKSBCW2IgPj4gMV0gPSBhLmNoYXJDb2RlQXQoZSksIGIgKz0gMjsKICAgICAgICBCW2IgPj4gMV0gPSAwOwogICAgICAgIHJldHVybiBiIC0gZDsKICAgICAgfSwgSGIgPSAoYSkgPT4gMiAqIGEubGVuZ3RoLCBJYiA9IChhLCBiKSA9PiB7CiAgICAgICAgZm9yICh2YXIgYyA9IDAsIGQgPSAiIjsgIShjID49IGIgLyA0KTsgKSB7CiAgICAgICAgICB2YXIgZSA9IEVbYSArIDQgKiBjID4+IDJdOwogICAgICAgICAgaWYgKDAgPT0gZSkgYnJlYWs7CiAgICAgICAgICArK2M7CiAgICAgICAgICA2NTUzNiA8PSBlID8gKGUgLT0gNjU1MzYsIGQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NiB8IGUgPj4gMTAsIDU2MzIwIHwgZSAmIDEwMjMpKSA6IGQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShlKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGQ7CiAgICAgIH0sIEpiID0gKGEsIGIsIGMpID0+IHsKICAgICAgICBjID8/IChjID0gMjE0NzQ4MzY0Nyk7CiAgICAgICAgaWYgKDQgPiBjKSByZXR1cm4gMDsKICAgICAgICB2YXIgZCA9IGI7CiAgICAgICAgYyA9IGQgKyBjIC0gNDsKICAgICAgICBmb3IgKHZhciBlID0gMDsgZSA8IGEubGVuZ3RoOyArK2UpIHsKICAgICAgICAgIHZhciBmID0gYS5jaGFyQ29kZUF0KGUpOwogICAgICAgICAgaWYgKDU1Mjk2IDw9IGYgJiYgNTczNDMgPj0gZikgewogICAgICAgICAgICB2YXIgbCA9IGEuY2hhckNvZGVBdCgrK2UpOwogICAgICAgICAgICBmID0gNjU1MzYgKyAoKGYgJiAxMDIzKSA8PCAxMCkgfCBsICYgMTAyMzsKICAgICAgICAgIH0KICAgICAgICAgIEVbYiA+PiAyXSA9IGY7CiAgICAgICAgICBiICs9IDQ7CiAgICAgICAgICBpZiAoYiArIDQgPiBjKSBicmVhazsKICAgICAgICB9CiAgICAgICAgRVtiID4+IDJdID0gMDsKICAgICAgICByZXR1cm4gYiAtIGQ7CiAgICAgIH0sIEtiID0gKGEpID0+IHsKICAgICAgICBmb3IgKHZhciBiID0gMCwgYyA9IDA7IGMgPCBhLmxlbmd0aDsgKytjKSB7CiAgICAgICAgICB2YXIgZCA9IGEuY2hhckNvZGVBdChjKTsKICAgICAgICAgIDU1Mjk2IDw9IGQgJiYgNTczNDMgPj0gZCAmJiArK2M7CiAgICAgICAgICBiICs9IDQ7CiAgICAgICAgfQogICAgICAgIHJldHVybiBiOwogICAgICB9LCBMYiA9IFtdLCBNYiA9IChhKSA9PiB7CiAgICAgICAgdmFyIGIgPSBMYi5sZW5ndGg7CiAgICAgICAgTGIucHVzaChhKTsKICAgICAgICByZXR1cm4gYjsKICAgICAgfSwgTmIgPSAoYSwgYikgPT4gewogICAgICAgIGZvciAodmFyIGMgPSBBcnJheShhKSwgZCA9IDA7IGQgPCBhOyArK2QpIGNbZF0gPSBCYihGW2IgKyA0ICogZCA+PiAyXSwgInBhcmFtZXRlciAiICsgZCk7CiAgICAgICAgcmV0dXJuIGM7CiAgICAgIH0sIE9iID0gUmVmbGVjdC5jb25zdHJ1Y3QsIFBiID0ge30sIFJiID0gKCkgPT4gewogICAgICAgIGlmICghUWIpIHsKICAgICAgICAgIHZhciBhID0gewogICAgICAgICAgICBVU0VSOiAid2ViX3VzZXIiLAogICAgICAgICAgICBMT0dOQU1FOiAid2ViX3VzZXIiLAogICAgICAgICAgICBQQVRIOiAiLyIsCiAgICAgICAgICAgIFBXRDogIi8iLAogICAgICAgICAgICBIT01FOiAiL2hvbWUvd2ViX3VzZXIiLAogICAgICAgICAgICBMQU5HOiAoIm9iamVjdCIgPT0gdHlwZW9mIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IubGFuZ3VhZ2VzICYmIG5hdmlnYXRvci5sYW5ndWFnZXNbMF0gfHwgIkMiKS5yZXBsYWNlKAogICAgICAgICAgICAgICItIiwKICAgICAgICAgICAgICAiXyIKICAgICAgICAgICAgKSArICIuVVRGLTgiLAogICAgICAgICAgICBfOiBkYSB8fCAiLi90aGlzLnByb2dyYW0iCiAgICAgICAgICB9LCBiOwogICAgICAgICAgZm9yIChiIGluIFBiKSB2b2lkIDAgPT09IFBiW2JdID8gZGVsZXRlIGFbYl0gOiBhW2JdID0gUGJbYl07CiAgICAgICAgICB2YXIgYyA9IFtdOwogICAgICAgICAgZm9yIChiIGluIGEpIGMucHVzaChgJHtifT0ke2FbYl19YCk7CiAgICAgICAgICBRYiA9IGM7CiAgICAgICAgfQogICAgICAgIHJldHVybiBRYjsKICAgICAgfSwgUWIsIFNiID0gW251bGwsIFtdLCBbXV0sIFRiID0gKCkgPT4gewogICAgICAgIGlmICgib2JqZWN0IiA9PSB0eXBlb2YgY3J5cHRvICYmICJmdW5jdGlvbiIgPT0gdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpCiAgICAgICAgICByZXR1cm4gKGEpID0+IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYSk7CiAgICAgICAgcmEoImluaXRSYW5kb21EZXZpY2UiKTsKICAgICAgfSwgVWIgPSAoYSkgPT4gKFViID0gVGIoKSkoYSksIFZiID0gKGEpID0+IDAgPT09IGEgJSA0ICYmICgwICE9PSBhICUgMTAwIHx8IDAgPT09IGEgJSA0MDApLCBXYiA9IFszMSwgMjksIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXSwgWGIgPSBbMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07CiAgICAgIGZ1bmN0aW9uIFliKGEpIHsKICAgICAgICB2YXIgYiA9IEFycmF5KERhKGEpICsgMSk7CiAgICAgICAgRWEoYSwgYiwgMCwgYi5sZW5ndGgpOwogICAgICAgIHJldHVybiBiOwogICAgICB9CiAgICAgIHZhciBaYiA9IChhLCBiLCBjLCBkKSA9PiB7CiAgICAgICAgZnVuY3Rpb24gZShnLCBxLCByKSB7CiAgICAgICAgICBmb3IgKGcgPSAibnVtYmVyIiA9PSB0eXBlb2YgZyA/IGcudG9TdHJpbmcoKSA6IGcgfHwgIiI7IGcubGVuZ3RoIDwgcTsgKSBnID0gclswXSArIGc7CiAgICAgICAgICByZXR1cm4gZzsKICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZihnLCBxKSB7CiAgICAgICAgICByZXR1cm4gZShnLCBxLCAiMCIpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBsKGcsIHEpIHsKICAgICAgICAgIGZ1bmN0aW9uIHIoTikgewogICAgICAgICAgICByZXR1cm4gMCA+IE4gPyAtMSA6IDAgPCBOID8gMSA6IDA7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgejsKICAgICAgICAgIDAgPT09ICh6ID0gcihnLmdldEZ1bGxZZWFyKCkgLSBxLmdldEZ1bGxZZWFyKCkpKSAmJiAwID09PSAoeiA9IHIoZy5nZXRNb250aCgpIC0gcS5nZXRNb250aCgpKSkgJiYgKHogPSByKGcuZ2V0RGF0ZSgpIC0gcS5nZXREYXRlKCkpKTsKICAgICAgICAgIHJldHVybiB6OwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBoKGcpIHsKICAgICAgICAgIHN3aXRjaCAoZy5nZXREYXkoKSkgewogICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGcuZ2V0RnVsbFllYXIoKSAtIDEsIDExLCAyOSk7CiAgICAgICAgICAgIGNhc2UgMToKICAgICAgICAgICAgICByZXR1cm4gZzsKICAgICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShnLmdldEZ1bGxZZWFyKCksIDAsIDMpOwogICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGcuZ2V0RnVsbFllYXIoKSwgMCwgMik7CiAgICAgICAgICAgIGNhc2UgNDoKICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoZy5nZXRGdWxsWWVhcigpLCAwLCAxKTsKICAgICAgICAgICAgY2FzZSA1OgogICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShnLmdldEZ1bGxZZWFyKCkgLSAxLCAxMSwgMzEpOwogICAgICAgICAgICBjYXNlIDY6CiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGcuZ2V0RnVsbFllYXIoKSAtIDEsIDExLCAzMCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIG4oZykgewogICAgICAgICAgdmFyIHEgPSBnLklhOwogICAgICAgICAgZm9yIChnID0gbmV3IERhdGUobmV3IERhdGUoZy5KYSArIDE5MDAsIDAsIDEpLmdldFRpbWUoKSk7IDAgPCBxOyApIHsKICAgICAgICAgICAgdmFyIHIgPSBnLmdldE1vbnRoKCksIHogPSAoVmIoZy5nZXRGdWxsWWVhcigpKSA/IFdiIDogWGIpW3JdOwogICAgICAgICAgICBpZiAocSA+IHogLSBnLmdldERhdGUoKSkKICAgICAgICAgICAgICBxIC09IHogLSBnLmdldERhdGUoKSArIDEsIGcuc2V0RGF0ZSgxKSwgMTEgPiByID8gZy5zZXRNb250aChyICsgMSkgOiAoZy5zZXRNb250aCgwKSwgZy5zZXRGdWxsWWVhcihnLmdldEZ1bGxZZWFyKCkgKyAxKSk7CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgIGcuc2V0RGF0ZShnLmdldERhdGUoKSArIHEpOwogICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICByID0gbmV3IERhdGUoZy5nZXRGdWxsWWVhcigpICsgMSwgMCwgNCk7CiAgICAgICAgICBxID0gaChuZXcgRGF0ZShnLmdldEZ1bGxZZWFyKCksIDAsIDQpKTsKICAgICAgICAgIHIgPSBoKHIpOwogICAgICAgICAgcmV0dXJuIDAgPj0gbChxLCBnKSA/IDAgPj0gbChyLCBnKSA/IGcuZ2V0RnVsbFllYXIoKSArIDEgOiBnLmdldEZ1bGxZZWFyKCkgOiBnLmdldEZ1bGxZZWFyKCkgLSAxOwogICAgICAgIH0KICAgICAgICB2YXIgbSA9IEZbZCArIDQwID4+IDJdOwogICAgICAgIGQgPSB7CiAgICAgICAgICBzYjogRVtkID4+IDJdLAogICAgICAgICAgcmI6IEVbZCArIDQgPj4gMl0sCiAgICAgICAgICBSYTogRVtkICsgOCA+PiAyXSwKICAgICAgICAgIFZhOiBFW2QgKyAxMiA+PiAyXSwKICAgICAgICAgIFNhOiBFW2QgKyAxNiA+PiAyXSwKICAgICAgICAgIEphOiBFW2QgKyAyMCA+PiAyXSwKICAgICAgICAgIEdhOiBFW2QgKyAyNCA+PiAyXSwKICAgICAgICAgIElhOiBFW2QgKyAyOCA+PiAyXSwKICAgICAgICAgIHdiOiBFW2QgKyAzMiA+PiAyXSwKICAgICAgICAgIHFiOiBFW2QgKyAzNiA+PiAyXSwKICAgICAgICAgIHRiOiBtID8gbSA/IEooQSwgbSkgOiAiIiA6ICIiCiAgICAgICAgfTsKICAgICAgICBjID0gYyA/IEooQSwgYykgOiAiIjsKICAgICAgICBtID0gewogICAgICAgICAgIiVjIjogIiVhICViICVkICVIOiVNOiVTICVZIiwKICAgICAgICAgICIlRCI6ICIlbS8lZC8leSIsCiAgICAgICAgICAiJUYiOiAiJVktJW0tJWQiLAogICAgICAgICAgIiVoIjogIiViIiwKICAgICAgICAgICIlciI6ICIlSTolTTolUyAlcCIsCiAgICAgICAgICAiJVIiOiAiJUg6JU0iLAogICAgICAgICAgIiVUIjogIiVIOiVNOiVTIiwKICAgICAgICAgICIleCI6ICIlbS8lZC8leSIsCiAgICAgICAgICAiJVgiOiAiJUg6JU06JVMiLAogICAgICAgICAgIiVFYyI6ICIlYyIsCiAgICAgICAgICAiJUVDIjogIiVDIiwKICAgICAgICAgICIlRXgiOiAiJW0vJWQvJXkiLAogICAgICAgICAgIiVFWCI6ICIlSDolTTolUyIsCiAgICAgICAgICAiJUV5IjogIiV5IiwKICAgICAgICAgICIlRVkiOiAiJVkiLAogICAgICAgICAgIiVPZCI6ICIlZCIsCiAgICAgICAgICAiJU9lIjogIiVlIiwKICAgICAgICAgICIlT0giOiAiJUgiLAogICAgICAgICAgIiVPSSI6ICIlSSIsCiAgICAgICAgICAiJU9tIjogIiVtIiwKICAgICAgICAgICIlT00iOiAiJU0iLAogICAgICAgICAgIiVPUyI6ICIlUyIsCiAgICAgICAgICAiJU91IjogIiV1IiwKICAgICAgICAgICIlT1UiOiAiJVUiLAogICAgICAgICAgIiVPViI6ICIlViIsCiAgICAgICAgICAiJU93IjogIiV3IiwKICAgICAgICAgICIlT1ciOiAiJVciLAogICAgICAgICAgIiVPeSI6ICIleSIKICAgICAgICB9OwogICAgICAgIGZvciAodmFyIHAgaW4gbSkgYyA9IGMucmVwbGFjZShuZXcgUmVnRXhwKHAsICJnIiksIG1bcF0pOwogICAgICAgIHZhciB1ID0gIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5Ii5zcGxpdCgiICIpLCB2ID0gIkphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXIiLnNwbGl0KCIgIik7CiAgICAgICAgbSA9IHsKICAgICAgICAgICIlYSI6IChnKSA9PiB1W2cuR2FdLnN1YnN0cmluZygwLCAzKSwKICAgICAgICAgICIlQSI6IChnKSA9PiB1W2cuR2FdLAogICAgICAgICAgIiViIjogKGcpID0+IHZbZy5TYV0uc3Vic3RyaW5nKDAsIDMpLAogICAgICAgICAgIiVCIjogKGcpID0+IHZbZy5TYV0sCiAgICAgICAgICAiJUMiOiAoZykgPT4gZigoZy5KYSArIDE5MDApIC8gMTAwIHwgMCwgMiksCiAgICAgICAgICAiJWQiOiAoZykgPT4gZihnLlZhLCAyKSwKICAgICAgICAgICIlZSI6IChnKSA9PiBlKGcuVmEsIDIsICIgIiksCiAgICAgICAgICAiJWciOiAoZykgPT4gbihnKS50b1N0cmluZygpLnN1YnN0cmluZygyKSwKICAgICAgICAgICIlRyI6IG4sCiAgICAgICAgICAiJUgiOiAoZykgPT4gZihnLlJhLCAyKSwKICAgICAgICAgICIlSSI6IChnKSA9PiB7CiAgICAgICAgICAgIGcgPSBnLlJhOwogICAgICAgICAgICAwID09IGcgPyBnID0gMTIgOiAxMiA8IGcgJiYgKGcgLT0gMTIpOwogICAgICAgICAgICByZXR1cm4gZihnLCAyKTsKICAgICAgICAgIH0sCiAgICAgICAgICAiJWoiOiAoZykgPT4gewogICAgICAgICAgICBmb3IgKHZhciBxID0gMCwgciA9IDA7IHIgPD0gZy5TYSAtIDE7IHEgKz0gKFZiKGcuSmEgKyAxOTAwKSA/IFdiIDogWGIpW3IrK10pIDsKICAgICAgICAgICAgcmV0dXJuIGYoZy5WYSArIHEsIDMpOwogICAgICAgICAgfSwKICAgICAgICAgICIlbSI6IChnKSA9PiBmKGcuU2EgKyAxLCAyKSwKICAgICAgICAgICIlTSI6IChnKSA9PiBmKGcucmIsIDIpLAogICAgICAgICAgIiVuIjogKCkgPT4gIlxuIiwKICAgICAgICAgICIlcCI6IChnKSA9PiAwIDw9IGcuUmEgJiYgMTIgPiBnLlJhID8gIkFNIiA6ICJQTSIsCiAgICAgICAgICAiJVMiOiAoZykgPT4gZihnLnNiLCAyKSwKICAgICAgICAgICIldCI6ICgpID0+ICIJIiwKICAgICAgICAgICIldSI6IChnKSA9PiBnLkdhIHx8IDcsCiAgICAgICAgICAiJVUiOiAoZykgPT4gZihNYXRoLmZsb29yKChnLklhICsgNyAtIGcuR2EpIC8gNyksIDIpLAogICAgICAgICAgIiVWIjogKGcpID0+IHsKICAgICAgICAgICAgdmFyIHEgPSBNYXRoLmZsb29yKChnLklhICsgNyAtIChnLkdhICsgNikgJSA3KSAvIDcpOwogICAgICAgICAgICAyID49IChnLkdhICsgMzcxIC0gZy5JYSAtIDIpICUgNyAmJiBxKys7CiAgICAgICAgICAgIGlmIChxKSA1MyA9PSBxICYmIChyID0gKGcuR2EgKyAzNzEgLSBnLklhKSAlIDcsIDQgPT0gciB8fCAzID09IHIgJiYgVmIoZy5KYSkgfHwgKHEgPSAxKSk7CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgIHEgPSA1MjsKICAgICAgICAgICAgICB2YXIgciA9IChnLkdhICsgNyAtIGcuSWEgLSAxKSAlIDc7CiAgICAgICAgICAgICAgKDQgPT0gciB8fCA1ID09IHIgJiYgVmIoZy5KYSAlIDQwMCAtIDEpKSAmJiBxKys7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGYocSwgMik7CiAgICAgICAgICB9LAogICAgICAgICAgIiV3IjogKGcpID0+IGcuR2EsCiAgICAgICAgICAiJVciOiAoZykgPT4gZihNYXRoLmZsb29yKChnLklhICsgNyAtIChnLkdhICsgNikgJSA3KSAvIDcpLCAyKSwKICAgICAgICAgICIleSI6IChnKSA9PiAoZy5KYSArIDE5MDApLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLAogICAgICAgICAgIiVZIjogKGcpID0+IGcuSmEgKyAxOTAwLAogICAgICAgICAgIiV6IjogKGcpID0+IHsKICAgICAgICAgICAgZyA9IGcucWI7CiAgICAgICAgICAgIHZhciBxID0gMCA8PSBnOwogICAgICAgICAgICBnID0gTWF0aC5hYnMoZykgLyA2MDsKICAgICAgICAgICAgcmV0dXJuIChxID8gIisiIDogIi0iKSArIFN0cmluZygiMDAwMCIgKyAoZyAvIDYwICogMTAwICsgZyAlIDYwKSkuc2xpY2UoLTQpOwogICAgICAgICAgfSwKICAgICAgICAgICIlWiI6IChnKSA9PiBnLnRiLAogICAgICAgICAgIiUlIjogKCkgPT4gIiUiCiAgICAgICAgfTsKICAgICAgICBjID0gYy5yZXBsYWNlKC8lJS9nLCAiXDBcMCIpOwogICAgICAgIGZvciAocCBpbiBtKSBjLmluY2x1ZGVzKHApICYmIChjID0gYy5yZXBsYWNlKG5ldyBSZWdFeHAocCwgImciKSwgbVtwXShkKSkpOwogICAgICAgIGMgPSBjLnJlcGxhY2UoL1wwXDAvZywgIiUiKTsKICAgICAgICBwID0gWWIoYyk7CiAgICAgICAgaWYgKHAubGVuZ3RoID4gYikgcmV0dXJuIDA7CiAgICAgICAgeS5zZXQocCwgYSk7CiAgICAgICAgcmV0dXJuIHAubGVuZ3RoIC0gMTsKICAgICAgfTsKICAgICAgSWEgPSBrLkludGVybmFsRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHsKICAgICAgICBjb25zdHJ1Y3RvcihhKSB7CiAgICAgICAgICBzdXBlcihhKTsKICAgICAgICAgIHRoaXMubmFtZSA9ICJJbnRlcm5hbEVycm9yIjsKICAgICAgICB9CiAgICAgIH07CiAgICAgIGZvciAodmFyICRiID0gQXJyYXkoMjU2KSwgYWMgPSAwOyAyNTYgPiBhYzsgKythYykgJGJbYWNdID0gU3RyaW5nLmZyb21DaGFyQ29kZShhYyk7CiAgICAgIEphID0gJGI7CiAgICAgIFIgPSBrLkJpbmRpbmdFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3IgewogICAgICAgIGNvbnN0cnVjdG9yKGEpIHsKICAgICAgICAgIHN1cGVyKGEpOwogICAgICAgICAgdGhpcy5uYW1lID0gIkJpbmRpbmdFcnJvciI7CiAgICAgICAgfQogICAgICB9OwogICAgICBPYmplY3QuYXNzaWduKFlhLnByb3RvdHlwZSwgewogICAgICAgIGlzQWxpYXNPZjogZnVuY3Rpb24oYSkgewogICAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFlhICYmIGEgaW5zdGFuY2VvZiBZYSkpIHJldHVybiBmYWxzZTsKICAgICAgICAgIHZhciBiID0gdGhpcy5tYS56YS54YSwgYyA9IHRoaXMubWEueWE7CiAgICAgICAgICBhLm1hID0gYS5tYTsKICAgICAgICAgIHZhciBkID0gYS5tYS56YS54YTsKICAgICAgICAgIGZvciAoYSA9IGEubWEueWE7IGIuQ2E7ICkgYyA9IGIuTmEoYyksIGIgPSBiLkNhOwogICAgICAgICAgZm9yICg7IGQuQ2E7ICkgYSA9IGQuTmEoYSksIGQgPSBkLkNhOwogICAgICAgICAgcmV0dXJuIGIgPT09IGQgJiYgYyA9PT0gYTsKICAgICAgICB9LAogICAgICAgIGNsb25lOiBmdW5jdGlvbigpIHsKICAgICAgICAgIHRoaXMubWEueWEgfHwgTGEodGhpcyk7CiAgICAgICAgICBpZiAodGhpcy5tYS5NYSkgcmV0dXJuIHRoaXMubWEuY291bnQudmFsdWUgKz0gMSwgdGhpczsKICAgICAgICAgIHZhciBhID0gV2EsIGIgPSBPYmplY3QsIGMgPSBiLmNyZWF0ZSwgZCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwgZSA9IHRoaXMubWE7CiAgICAgICAgICBhID0gYSgKICAgICAgICAgICAgYy5jYWxsKGIsIGQsIHsKICAgICAgICAgICAgICBtYTogeyB2YWx1ZTogeyBjb3VudDogZS5jb3VudCwgS2E6IGUuS2EsIE1hOiBlLk1hLCB5YTogZS55YSwgemE6IGUuemEsIEFhOiBlLkFhLCBEYTogZS5EYSB9IH0KICAgICAgICAgICAgfSkKICAgICAgICAgICk7CiAgICAgICAgICBhLm1hLmNvdW50LnZhbHVlICs9IDE7CiAgICAgICAgICBhLm1hLkthID0gZmFsc2U7CiAgICAgICAgICByZXR1cm4gYTsKICAgICAgICB9LAogICAgICAgIFsiZGVsZXRlIl0oKSB7CiAgICAgICAgICB0aGlzLm1hLnlhIHx8IExhKHRoaXMpOwogICAgICAgICAgaWYgKHRoaXMubWEuS2EgJiYgIXRoaXMubWEuTWEpIHRocm93IG5ldyBSKCJPYmplY3QgYWxyZWFkeSBzY2hlZHVsZWQgZm9yIGRlbGV0aW9uIik7CiAgICAgICAgICBPYSh0aGlzKTsKICAgICAgICAgIHZhciBhID0gdGhpcy5tYTsKICAgICAgICAgIC0tYS5jb3VudC52YWx1ZTsKICAgICAgICAgIDAgPT09IGEuY291bnQudmFsdWUgJiYgKGEuQWEgPyBhLkRhLkZhKGEuQWEpIDogYS56YS54YS5GYShhLnlhKSk7CiAgICAgICAgICB0aGlzLm1hLk1hIHx8ICh0aGlzLm1hLkFhID0gdm9pZCAwLCB0aGlzLm1hLnlhID0gdm9pZCAwKTsKICAgICAgICB9LAogICAgICAgIGlzRGVsZXRlZDogZnVuY3Rpb24oKSB7CiAgICAgICAgICByZXR1cm4gIXRoaXMubWEueWE7CiAgICAgICAgfSwKICAgICAgICBkZWxldGVMYXRlcjogZnVuY3Rpb24oKSB7CiAgICAgICAgICB0aGlzLm1hLnlhIHx8IExhKHRoaXMpOwogICAgICAgICAgaWYgKHRoaXMubWEuS2EgJiYgIXRoaXMubWEuTWEpIHRocm93IG5ldyBSKCJPYmplY3QgYWxyZWFkeSBzY2hlZHVsZWQgZm9yIGRlbGV0aW9uIik7CiAgICAgICAgICBSYS5wdXNoKHRoaXMpOwogICAgICAgICAgMSA9PT0gUmEubGVuZ3RoICYmIFRhICYmIFRhKFNhKTsKICAgICAgICAgIHRoaXMubWEuS2EgPSB0cnVlOwogICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgay5nZXRJbmhlcml0ZWRJbnN0YW5jZUNvdW50ID0gKCkgPT4gT2JqZWN0LmtleXMoVWEpLmxlbmd0aDsKICAgICAgay5nZXRMaXZlSW5oZXJpdGVkSW5zdGFuY2VzID0gKCkgPT4gewogICAgICAgIHZhciBhID0gW10sIGI7CiAgICAgICAgZm9yIChiIGluIFVhKSBVYS5oYXNPd25Qcm9wZXJ0eShiKSAmJiBhLnB1c2goVWFbYl0pOwogICAgICAgIHJldHVybiBhOwogICAgICB9OwogICAgICBrLmZsdXNoUGVuZGluZ0RlbGV0ZXMgPSBTYTsKICAgICAgay5zZXREZWxheUZ1bmN0aW9uID0gKGEpID0+IHsKICAgICAgICBUYSA9IGE7CiAgICAgICAgUmEubGVuZ3RoICYmIFRhICYmIFRhKFNhKTsKICAgICAgfTsKICAgICAgT2JqZWN0LmFzc2lnbihqYi5wcm90b3R5cGUsIHsKICAgICAgICBlYihhKSB7CiAgICAgICAgICB0aGlzLlphICYmIChhID0gdGhpcy5aYShhKSk7CiAgICAgICAgICByZXR1cm4gYTsKICAgICAgICB9LAogICAgICAgIFhhKGEpIHsKICAgICAgICAgIHRoaXMuRmE/LihhKTsKICAgICAgICB9LAogICAgICAgIGFyZ1BhY2tBZHZhbmNlOiA4LAogICAgICAgIHJlYWRWYWx1ZUZyb21Qb2ludGVyOiBLLAogICAgICAgIGZyb21XaXJlVHlwZTogZnVuY3Rpb24oYSkgewogICAgICAgICAgZnVuY3Rpb24gYigpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuUWEgPyBYYSh0aGlzLnhhLkxhLCB7IHphOiB0aGlzLmpiLCB5YTogYywgRGE6IHRoaXMsIEFhOiBhIH0pIDogWGEodGhpcy54YS5MYSwgeyB6YTogdGhpcywgeWE6IGEgfSk7CiAgICAgICAgICB9CiAgICAgICAgICB2YXIgYyA9IHRoaXMuZWIoYSk7CiAgICAgICAgICBpZiAoIWMpIHJldHVybiB0aGlzLlhhKGEpLCBudWxsOwogICAgICAgICAgdmFyIGQgPSBWYSh0aGlzLnhhLCBjKTsKICAgICAgICAgIGlmICh2b2lkIDAgIT09IGQpIHsKICAgICAgICAgICAgaWYgKDAgPT09IGQubWEuY291bnQudmFsdWUpIHJldHVybiBkLm1hLnlhID0gYywgZC5tYS5BYSA9IGEsIGQuY2xvbmUoKTsKICAgICAgICAgICAgZCA9IGQuY2xvbmUoKTsKICAgICAgICAgICAgdGhpcy5YYShhKTsKICAgICAgICAgICAgcmV0dXJuIGQ7CiAgICAgICAgICB9CiAgICAgICAgICBkID0gdGhpcy54YS5jYihjKTsKICAgICAgICAgIGQgPSBRYVtkXTsKICAgICAgICAgIGlmICghZCkgcmV0dXJuIGIuY2FsbCh0aGlzKTsKICAgICAgICAgIGQgPSB0aGlzLlBhID8gZC4kYSA6IGQucG9pbnRlclR5cGU7CiAgICAgICAgICB2YXIgZSA9IFBhKGMsIHRoaXMueGEsIGQueGEpOwogICAgICAgICAgcmV0dXJuIG51bGwgPT09IGUgPyBiLmNhbGwodGhpcykgOiB0aGlzLlFhID8gWGEoZC54YS5MYSwgeyB6YTogZCwgeWE6IGUsIERhOiB0aGlzLCBBYTogYSB9KSA6IFhhKGQueGEuTGEsIHsgemE6IGQsIHlhOiBlIH0pOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIG5iID0gay5VbmJvdW5kVHlwZUVycm9yID0gKChhLCBiKSA9PiB7CiAgICAgICAgdmFyIGMgPSBaYShiLCBmdW5jdGlvbihkKSB7CiAgICAgICAgICB0aGlzLm5hbWUgPSBiOwogICAgICAgICAgdGhpcy5tZXNzYWdlID0gZDsKICAgICAgICAgIGQgPSBFcnJvcihkKS5zdGFjazsKICAgICAgICAgIHZvaWQgMCAhPT0gZCAmJiAodGhpcy5zdGFjayA9IHRoaXMudG9TdHJpbmcoKSArICJcbiIgKyBkLnJlcGxhY2UoL15FcnJvcig6W15cbl0qKT9cbi8sICIiKSk7CiAgICAgICAgfSk7CiAgICAgICAgYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGEucHJvdG90eXBlKTsKICAgICAgICBjLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGM7CiAgICAgICAgYy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsKICAgICAgICAgIHJldHVybiB2b2lkIDAgPT09IHRoaXMubWVzc2FnZSA/IHRoaXMubmFtZSA6IGAke3RoaXMubmFtZX06ICR7dGhpcy5tZXNzYWdlfWA7CiAgICAgICAgfTsKICAgICAgICByZXR1cm4gYzsKICAgICAgfSkoRXJyb3IsICJVbmJvdW5kVHlwZUVycm9yIik7CiAgICAgIFYucHVzaCgwLCAxLCB2b2lkIDAsIDEsIG51bGwsIDEsIHRydWUsIDEsIGZhbHNlLCAxKTsKICAgICAgay5jb3VudF9lbXZhbF9oYW5kbGVzID0gKCkgPT4gVi5sZW5ndGggLyAyIC0gNSAtIHZiLmxlbmd0aDsKICAgICAgdmFyIG1jID0gewogICAgICAgIGM6IChhLCBiLCBjLCBkKSA9PiB7CiAgICAgICAgICByYSgKICAgICAgICAgICAgYEFzc2VydGlvbiBmYWlsZWQ6ICR7YSA/IEooQSwgYSkgOiAiIn0sIGF0OiBgICsgW2IgPyBiID8gSihBLCBiKSA6ICIiIDogInVua25vd24gZmlsZW5hbWUiLCBjLCBkID8gZCA/IEooQSwgZCkgOiAiIiA6ICJ1bmtub3duIGZ1bmN0aW9uIl0KICAgICAgICAgICk7CiAgICAgICAgfSwKICAgICAgICBtOiAoYSwgYiwgYykgPT4gewogICAgICAgICAgdmFyIGQgPSBuZXcgQWEoYSk7CiAgICAgICAgICBGW2QueWEgKyAxNiA+PiAyXSA9IDA7CiAgICAgICAgICBGW2QueWEgKyA0ID4+IDJdID0gYjsKICAgICAgICAgIEZbZC55YSArIDggPj4gMl0gPSBjOwogICAgICAgICAgQmEgPSBhOwogICAgICAgICAgQ2ErKzsKICAgICAgICAgIHRocm93IEJhOwogICAgICAgIH0sCiAgICAgICAgQjogZnVuY3Rpb24oKSB7CiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB9LAogICAgICAgIFA6ICgpID0+IHsKICAgICAgICB9LAogICAgICAgIE06ICgpID0+IHsKICAgICAgICB9LAogICAgICAgIFI6IGZ1bmN0aW9uKCkgewogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgfSwKICAgICAgICBOOiAoKSA9PiB7CiAgICAgICAgfSwKICAgICAgICBBOiBmdW5jdGlvbigpIHsKICAgICAgICB9LAogICAgICAgIE86ICgpID0+IHsKICAgICAgICB9LAogICAgICAgIHY6IChhKSA9PiB7CiAgICAgICAgICB2YXIgYiA9IEZhW2FdOwogICAgICAgICAgZGVsZXRlIEZhW2FdOwogICAgICAgICAgdmFyIGMgPSBiLlVhLCBkID0gYi5GYSwgZSA9IGIuWWEsIGYgPSBlLm1hcCgobCkgPT4gbC5oYikuY29uY2F0KGUubWFwKChsKSA9PiBsLm5iKSk7CiAgICAgICAgICBQKFthXSwgZiwgKGwpID0+IHsKICAgICAgICAgICAgdmFyIGggPSB7fTsKICAgICAgICAgICAgZS5mb3JFYWNoKChuLCBtKSA9PiB7CiAgICAgICAgICAgICAgdmFyIHAgPSBsW21dLCB1ID0gbi5mYiwgdiA9IG4uZ2IsIGcgPSBsW20gKyBlLmxlbmd0aF0sIHEgPSBuLm1iLCByID0gbi5vYjsKICAgICAgICAgICAgICBoW24uYmJdID0gewogICAgICAgICAgICAgICAgcmVhZDogKHopID0+IHAuZnJvbVdpcmVUeXBlKHUodiwgeikpLAogICAgICAgICAgICAgICAgd3JpdGU6ICh6LCBOKSA9PiB7CiAgICAgICAgICAgICAgICAgIHZhciBEID0gW107CiAgICAgICAgICAgICAgICAgIHEociwgeiwgZy50b1dpcmVUeXBlKEQsIE4pKTsKICAgICAgICAgICAgICAgICAgR2EoRCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIHJldHVybiBbCiAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgbmFtZTogYi5uYW1lLAogICAgICAgICAgICAgICAgZnJvbVdpcmVUeXBlOiAobikgPT4gewogICAgICAgICAgICAgICAgICB2YXIgbSA9IHt9LCBwOwogICAgICAgICAgICAgICAgICBmb3IgKHAgaW4gaCkgbVtwXSA9IGhbcF0ucmVhZChuKTsKICAgICAgICAgICAgICAgICAgZChuKTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIG07CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgdG9XaXJlVHlwZTogKG4sIG0pID0+IHsKICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBoKSBpZiAoIShwIGluIG0pKSB0aHJvdyBuZXcgVHlwZUVycm9yKGBNaXNzaW5nIGZpZWxkOiAiJHtwfSJgKTsKICAgICAgICAgICAgICAgICAgdmFyIHUgPSBjKCk7CiAgICAgICAgICAgICAgICAgIGZvciAocCBpbiBoKSBoW3BdLndyaXRlKHUsIG1bcF0pOwogICAgICAgICAgICAgICAgICBudWxsICE9PSBuICYmIG4ucHVzaChkLCB1KTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHU7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgYXJnUGFja0FkdmFuY2U6IDgsCiAgICAgICAgICAgICAgICByZWFkVmFsdWVGcm9tUG9pbnRlcjogSywKICAgICAgICAgICAgICAgIEVhOiBkCiAgICAgICAgICAgICAgfQogICAgICAgICAgICBdOwogICAgICAgICAgfSk7CiAgICAgICAgfSwKICAgICAgICBJOiAoKSA9PiB7CiAgICAgICAgfSwKICAgICAgICBZOiAoYSwgYiwgYywgZCkgPT4gewogICAgICAgICAgYiA9IFEoYik7CiAgICAgICAgICBPKGEsIHsKICAgICAgICAgICAgbmFtZTogYiwKICAgICAgICAgICAgZnJvbVdpcmVUeXBlOiBmdW5jdGlvbihlKSB7CiAgICAgICAgICAgICAgcmV0dXJuICEhZTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgdG9XaXJlVHlwZTogZnVuY3Rpb24oZSwgZikgewogICAgICAgICAgICAgIHJldHVybiBmID8gYyA6IGQ7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGFyZ1BhY2tBZHZhbmNlOiA4LAogICAgICAgICAgICByZWFkVmFsdWVGcm9tUG9pbnRlcjogZnVuY3Rpb24oZSkgewogICAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21XaXJlVHlwZShBW2VdKTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgRWE6IG51bGwKICAgICAgICAgIH0pOwogICAgICAgIH0sCiAgICAgICAgcjogKGEsIGIsIGMsIGQsIGUsIGYsIGwsIGgsIG4sIG0sIHAsIHUsIHYpID0+IHsKICAgICAgICAgIHAgPSBRKHApOwogICAgICAgICAgZiA9IFQoZSwgZik7CiAgICAgICAgICBoICYmIChoID0gVChsLCBoKSk7CiAgICAgICAgICBtICYmIChtID0gVChuLCBtKSk7CiAgICAgICAgICB2ID0gVCh1LCB2KTsKICAgICAgICAgIHZhciBnID0gYmIocCk7CiAgICAgICAgICBhYihnLCBmdW5jdGlvbigpIHsKICAgICAgICAgICAgcWIoYENhbm5vdCBjb25zdHJ1Y3QgJHtwfSBkdWUgdG8gdW5ib3VuZCB0eXBlc2AsIFtkXSk7CiAgICAgICAgICB9KTsKICAgICAgICAgIFAoW2EsIGIsIGNdLCBkID8gW2RdIDogW10sIChxKSA9PiB7CiAgICAgICAgICAgIHEgPSBxWzBdOwogICAgICAgICAgICBpZiAoZCkgewogICAgICAgICAgICAgIHZhciByID0gcS54YTsKICAgICAgICAgICAgICB2YXIgeiA9IHIuTGE7CiAgICAgICAgICAgIH0gZWxzZSB6ID0gWWEucHJvdG90eXBlOwogICAgICAgICAgICBxID0gWmEocCwgZnVuY3Rpb24oLi4uTmEpIHsKICAgICAgICAgICAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpICE9PSBOKSB0aHJvdyBuZXcgUigiVXNlICduZXcnIHRvIGNvbnN0cnVjdCAiICsgcCk7CiAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gRC5IYSkgdGhyb3cgbmV3IFIocCArICIgaGFzIG5vIGFjY2Vzc2libGUgY29uc3RydWN0b3IiKTsKICAgICAgICAgICAgICB2YXIgeGIgPSBELkhhW05hLmxlbmd0aF07CiAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0geGIpCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUigKICAgICAgICAgICAgICAgICAgYFRyaWVkIHRvIGludm9rZSBjdG9yIG9mICR7cH0gd2l0aCBpbnZhbGlkIG51bWJlciBvZiBwYXJhbWV0ZXJzICgke05hLmxlbmd0aH0pIC0gZXhwZWN0ZWQgKCR7T2JqZWN0LmtleXMoRC5IYSkudG9TdHJpbmcoKX0pIHBhcmFtZXRlcnMgaW5zdGVhZCFgCiAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgIHJldHVybiB4Yi5hcHBseSh0aGlzLCBOYSk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICB2YXIgTiA9IE9iamVjdC5jcmVhdGUoeiwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogcSB9IH0pOwogICAgICAgICAgICBxLnByb3RvdHlwZSA9IE47CiAgICAgICAgICAgIHZhciBEID0gbmV3IGNiKHAsIHEsIE4sIHYsIHIsIGYsIGgsIG0pOwogICAgICAgICAgICBpZiAoRC5DYSkgewogICAgICAgICAgICAgIHZhciBpYTsKICAgICAgICAgICAgICAoaWEgPSBELkNhKS5XYSA/PyAoaWEuV2EgPSBbXSk7CiAgICAgICAgICAgICAgRC5DYS5XYS5wdXNoKEQpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHIgPSBuZXcgamIocCwgRCwgdHJ1ZSwgZmFsc2UsIGZhbHNlKTsKICAgICAgICAgICAgaWEgPSBuZXcgamIocCArICIqIiwgRCwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7CiAgICAgICAgICAgIHogPSBuZXcgamIocCArICIgY29uc3QqIiwgRCwgZmFsc2UsIHRydWUsIGZhbHNlKTsKICAgICAgICAgICAgUWFbYV0gPSB7IHBvaW50ZXJUeXBlOiBpYSwgJGE6IHogfTsKICAgICAgICAgICAga2IoZywgcSk7CiAgICAgICAgICAgIHJldHVybiBbciwgaWEsIHpdOwogICAgICAgICAgfSk7CiAgICAgICAgfSwKICAgICAgICBxOiAoYSwgYiwgYywgZCwgZSwgZikgPT4gewogICAgICAgICAgdmFyIGwgPSByYihiLCBjKTsKICAgICAgICAgIGUgPSBUKGQsIGUpOwogICAgICAgICAgUChbXSwgW2FdLCAoaCkgPT4gewogICAgICAgICAgICBoID0gaFswXTsKICAgICAgICAgICAgdmFyIG4gPSBgY29uc3RydWN0b3IgJHtoLm5hbWV9YDsKICAgICAgICAgICAgdm9pZCAwID09PSBoLnhhLkhhICYmIChoLnhhLkhhID0gW10pOwogICAgICAgICAgICBpZiAodm9pZCAwICE9PSBoLnhhLkhhW2IgLSAxXSkKICAgICAgICAgICAgICB0aHJvdyBuZXcgUigKICAgICAgICAgICAgICAgIGBDYW5ub3QgcmVnaXN0ZXIgbXVsdGlwbGUgY29uc3RydWN0b3JzIHdpdGggaWRlbnRpY2FsIG51bWJlciBvZiBwYXJhbWV0ZXJzICgke2IgLSAxfSkgZm9yIGNsYXNzICcke2gubmFtZX0nISBPdmVybG9hZCByZXNvbHV0aW9uIGlzIGN1cnJlbnRseSBvbmx5IHBlcmZvcm1lZCB1c2luZyB0aGUgcGFyYW1ldGVyIGNvdW50LCBub3QgYWN0dWFsIHR5cGUgaW5mbyFgCiAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgaC54YS5IYVtiIC0gMV0gPSAoKSA9PiB7CiAgICAgICAgICAgICAgcWIoYENhbm5vdCBjb25zdHJ1Y3QgJHtoLm5hbWV9IGR1ZSB0byB1bmJvdW5kIHR5cGVzYCwgbCk7CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIFAoW10sIGwsIChtKSA9PiB7CiAgICAgICAgICAgICAgbS5zcGxpY2UoMSwgMCwgbnVsbCk7CiAgICAgICAgICAgICAgaC54YS5IYVtiIC0gMV0gPSB0YihuLCBtLCBudWxsLCBlLCBmKTsKICAgICAgICAgICAgICByZXR1cm4gW107CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICByZXR1cm4gW107CiAgICAgICAgICB9KTsKICAgICAgICB9LAogICAgICAgIGY6IChhLCBiLCBjLCBkLCBlLCBmLCBsLCBoKSA9PiB7CiAgICAgICAgICB2YXIgbiA9IHJiKGMsIGQpOwogICAgICAgICAgYiA9IFEoYik7CiAgICAgICAgICBiID0gdWIoYik7CiAgICAgICAgICBmID0gVChlLCBmKTsKICAgICAgICAgIFAoW10sIFthXSwgKG0pID0+IHsKICAgICAgICAgICAgZnVuY3Rpb24gcCgpIHsKICAgICAgICAgICAgICBxYihgQ2Fubm90IGNhbGwgJHt1fSBkdWUgdG8gdW5ib3VuZCB0eXBlc2AsIG4pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIG0gPSBtWzBdOwogICAgICAgICAgICB2YXIgdSA9IGAke20ubmFtZX0uJHtifWA7CiAgICAgICAgICAgIGIuc3RhcnRzV2l0aCgiQEAiKSAmJiAoYiA9IFN5bWJvbFtiLnN1YnN0cmluZygyKV0pOwogICAgICAgICAgICBoICYmIG0ueGEua2IucHVzaChiKTsKICAgICAgICAgICAgdmFyIHYgPSBtLnhhLkxhLCBnID0gdltiXTsKICAgICAgICAgICAgdm9pZCAwID09PSBnIHx8IHZvaWQgMCA9PT0gZy5CYSAmJiBnLmNsYXNzTmFtZSAhPT0gbS5uYW1lICYmIGcuT2EgPT09IGMgLSAyID8gKHAuT2EgPSBjIC0gMiwgcC5jbGFzc05hbWUgPSBtLm5hbWUsIHZbYl0gPSBwKSA6ICgkYSh2LCBiLCB1KSwgdltiXS5CYVtjIC0gMl0gPSBwKTsKICAgICAgICAgICAgUChbXSwgbiwgKHEpID0+IHsKICAgICAgICAgICAgICBxID0gdGIodSwgcSwgbSwgZiwgbCk7CiAgICAgICAgICAgICAgdm9pZCAwID09PSB2W2JdLkJhID8gKHEuT2EgPSBjIC0gMiwgdltiXSA9IHEpIDogdltiXS5CYVtjIC0gMl0gPSBxOwogICAgICAgICAgICAgIHJldHVybiBbXTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIHJldHVybiBbXTsKICAgICAgICAgIH0pOwogICAgICAgIH0sCiAgICAgICAgWDogKGEpID0+IE8oYSwgemIpLAogICAgICAgIHg6IChhLCBiLCBjLCBkKSA9PiB7CiAgICAgICAgICBmdW5jdGlvbiBlKCkgewogICAgICAgICAgfQogICAgICAgICAgYiA9IFEoYik7CiAgICAgICAgICBlLnZhbHVlcyA9IHt9OwogICAgICAgICAgTyhhLCB7CiAgICAgICAgICAgIG5hbWU6IGIsCiAgICAgICAgICAgIGNvbnN0cnVjdG9yOiBlLAogICAgICAgICAgICBmcm9tV2lyZVR5cGU6IGZ1bmN0aW9uKGYpIHsKICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci52YWx1ZXNbZl07CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHRvV2lyZVR5cGU6IChmLCBsKSA9PiBsLnZhbHVlLAogICAgICAgICAgICBhcmdQYWNrQWR2YW5jZTogOCwKICAgICAgICAgICAgcmVhZFZhbHVlRnJvbVBvaW50ZXI6IEFiKGIsIGMsIGQpLAogICAgICAgICAgICBFYTogbnVsbAogICAgICAgICAgfSk7CiAgICAgICAgICBhYihiLCBlKTsKICAgICAgICB9LAogICAgICAgIGs6IChhLCBiLCBjKSA9PiB7CiAgICAgICAgICB2YXIgZCA9IEJiKGEsICJlbnVtIik7CiAgICAgICAgICBiID0gUShiKTsKICAgICAgICAgIGEgPSBkLmNvbnN0cnVjdG9yOwogICAgICAgICAgZCA9IE9iamVjdC5jcmVhdGUoZC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHsKICAgICAgICAgICAgdmFsdWU6IHsgdmFsdWU6IGMgfSwKICAgICAgICAgICAgY29uc3RydWN0b3I6IHsgdmFsdWU6IFphKGAke2QubmFtZX1fJHtifWAsIGZ1bmN0aW9uKCkgewogICAgICAgICAgICB9KSB9CiAgICAgICAgICB9KTsKICAgICAgICAgIGEudmFsdWVzW2NdID0gZDsKICAgICAgICAgIGFbYl0gPSBkOwogICAgICAgIH0sCiAgICAgICAgQzogKGEsIGIsIGMpID0+IHsKICAgICAgICAgIGIgPSBRKGIpOwogICAgICAgICAgTyhhLCB7CiAgICAgICAgICAgIG5hbWU6IGIsCiAgICAgICAgICAgIGZyb21XaXJlVHlwZTogKGQpID0+IGQsCiAgICAgICAgICAgIHRvV2lyZVR5cGU6IChkLCBlKSA9PiBlLAogICAgICAgICAgICBhcmdQYWNrQWR2YW5jZTogOCwKICAgICAgICAgICAgcmVhZFZhbHVlRnJvbVBvaW50ZXI6IENiKGIsIGMpLAogICAgICAgICAgICBFYTogbnVsbAogICAgICAgICAgfSk7CiAgICAgICAgfSwKICAgICAgICBFOiAoYSwgYiwgYywgZCwgZSwgZikgPT4gewogICAgICAgICAgdmFyIGwgPSByYihiLCBjKTsKICAgICAgICAgIGEgPSBRKGEpOwogICAgICAgICAgYSA9IHViKGEpOwogICAgICAgICAgZSA9IFQoZCwgZSk7CiAgICAgICAgICBhYigKICAgICAgICAgICAgYSwKICAgICAgICAgICAgZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgcWIoYENhbm5vdCBjYWxsICR7YX0gZHVlIHRvIHVuYm91bmQgdHlwZXNgLCBsKTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgYiAtIDEKICAgICAgICAgICk7CiAgICAgICAgICBQKFtdLCBsLCAoaCkgPT4gewogICAgICAgICAgICBrYihhLCB0YihhLCBbaFswXSwgbnVsbF0uY29uY2F0KGguc2xpY2UoMSkpLCBudWxsLCBlLCBmKSwgYiAtIDEpOwogICAgICAgICAgICByZXR1cm4gW107CiAgICAgICAgICB9KTsKICAgICAgICB9LAogICAgICAgIGw6IChhLCBiLCBjLCBkLCBlKSA9PiB7CiAgICAgICAgICBiID0gUShiKTsKICAgICAgICAgIC0xID09PSBlICYmIChlID0gNDI5NDk2NzI5NSk7CiAgICAgICAgICBlID0gKGgpID0+IGg7CiAgICAgICAgICBpZiAoMCA9PT0gZCkgewogICAgICAgICAgICB2YXIgZiA9IDMyIC0gOCAqIGM7CiAgICAgICAgICAgIGUgPSAoaCkgPT4gaCA8PCBmID4+PiBmOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGwgPSBiLmluY2x1ZGVzKCJ1bnNpZ25lZCIpID8gZnVuY3Rpb24oaCwgbikgewogICAgICAgICAgICByZXR1cm4gbiA+Pj4gMDsKICAgICAgICAgIH0gOiBmdW5jdGlvbihoLCBuKSB7CiAgICAgICAgICAgIHJldHVybiBuOwogICAgICAgICAgfTsKICAgICAgICAgIE8oYSwgewogICAgICAgICAgICBuYW1lOiBiLAogICAgICAgICAgICBmcm9tV2lyZVR5cGU6IGUsCiAgICAgICAgICAgIHRvV2lyZVR5cGU6IGwsCiAgICAgICAgICAgIGFyZ1BhY2tBZHZhbmNlOiA4LAogICAgICAgICAgICByZWFkVmFsdWVGcm9tUG9pbnRlcjogRGIoYiwgYywgMCAhPT0gZCksCiAgICAgICAgICAgIEVhOiBudWxsCiAgICAgICAgICB9KTsKICAgICAgICB9LAogICAgICAgIGc6IChhLCBiLCBjKSA9PiB7CiAgICAgICAgICBmdW5jdGlvbiBkKGYpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBlKHkuYnVmZmVyLCBGW2YgKyA0ID4+IDJdLCBGW2YgPj4gMl0pOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGUgPSBbSW50OEFycmF5LCBVaW50OEFycmF5LCBJbnQxNkFycmF5LCBVaW50MTZBcnJheSwgSW50MzJBcnJheSwgVWludDMyQXJyYXksIEZsb2F0MzJBcnJheSwgRmxvYXQ2NEFycmF5XVtiXTsKICAgICAgICAgIGMgPSBRKGMpOwogICAgICAgICAgTyhhLCB7IG5hbWU6IGMsIGZyb21XaXJlVHlwZTogZCwgYXJnUGFja0FkdmFuY2U6IDgsIHJlYWRWYWx1ZUZyb21Qb2ludGVyOiBkIH0sIHsgaWI6IHRydWUgfSk7CiAgICAgICAgfSwKICAgICAgICB3OiAoYSkgPT4gewogICAgICAgICAgTyhhLCB6Yik7CiAgICAgICAgfSwKICAgICAgICBjYTogKGEsIGIsIGMsIGQsIGUsIGYsIGwsIGgsIG4sIG0sIHAsIHUpID0+IHsKICAgICAgICAgIGMgPSBRKGMpOwogICAgICAgICAgZiA9IFQoZSwgZik7CiAgICAgICAgICBoID0gVChsLCBoKTsKICAgICAgICAgIG0gPSBUKG4sIG0pOwogICAgICAgICAgdSA9IFQocCwgdSk7CiAgICAgICAgICBQKFthXSwgW2JdLCAodikgPT4gewogICAgICAgICAgICB2ID0gdlswXTsKICAgICAgICAgICAgcmV0dXJuIFtuZXcgamIoYywgdi54YSwgZmFsc2UsIGZhbHNlLCB0cnVlLCB2LCBkLCBmLCBoLCBtLCB1KV07CiAgICAgICAgICB9KTsKICAgICAgICB9LAogICAgICAgIEQ6IChhLCBiKSA9PiB7CiAgICAgICAgICBiID0gUShiKTsKICAgICAgICAgIHZhciBjID0gInN0ZDo6c3RyaW5nIiA9PT0gYjsKICAgICAgICAgIE8oYSwgewogICAgICAgICAgICBuYW1lOiBiLAogICAgICAgICAgICBmcm9tV2lyZVR5cGU6IGZ1bmN0aW9uKGQpIHsKICAgICAgICAgICAgICB2YXIgZSA9IEZbZCA+PiAyXSwgZiA9IGQgKyA0OwogICAgICAgICAgICAgIGlmIChjKQogICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IGYsIGggPSAwOyBoIDw9IGU7ICsraCkgewogICAgICAgICAgICAgICAgICB2YXIgbiA9IGYgKyBoOwogICAgICAgICAgICAgICAgICBpZiAoaCA9PSBlIHx8IDAgPT0gQVtuXSkgewogICAgICAgICAgICAgICAgICAgIGwgPSBsID8gSihBLCBsLCBuIC0gbCkgOiAiIjsKICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBtKSB2YXIgbSA9IGw7CiAgICAgICAgICAgICAgICAgICAgZWxzZSBtICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMCksIG0gKz0gbDsKICAgICAgICAgICAgICAgICAgICBsID0gbiArIDE7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIG0gPSBBcnJheShlKTsKICAgICAgICAgICAgICAgIGZvciAoaCA9IDA7IGggPCBlOyArK2gpIG1baF0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKEFbZiArIGhdKTsKICAgICAgICAgICAgICAgIG0gPSBtLmpvaW4oIiIpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBVKGQpOwogICAgICAgICAgICAgIHJldHVybiBtOwogICAgICAgICAgICB9LAogICAgICAgICAgICB0b1dpcmVUeXBlOiBmdW5jdGlvbihkLCBlKSB7CiAgICAgICAgICAgICAgZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyICYmIChlID0gbmV3IFVpbnQ4QXJyYXkoZSkpOwogICAgICAgICAgICAgIHZhciBmID0gInN0cmluZyIgPT0gdHlwZW9mIGU7CiAgICAgICAgICAgICAgaWYgKCEoZiB8fCBlIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBlIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkgfHwgZSBpbnN0YW5jZW9mIEludDhBcnJheSkpCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUigiQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBzdGQ6OnN0cmluZyIpOwogICAgICAgICAgICAgIHZhciBsID0gYyAmJiBmID8gRGEoZSkgOiBlLmxlbmd0aDsKICAgICAgICAgICAgICB2YXIgaCA9IGJjKDQgKyBsICsgMSksIG4gPSBoICsgNDsKICAgICAgICAgICAgICBGW2ggPj4gMl0gPSBsOwogICAgICAgICAgICAgIGlmIChjICYmIGYpIEVhKGUsIEEsIG4sIGwgKyAxKTsKICAgICAgICAgICAgICBlbHNlIGlmIChmKQogICAgICAgICAgICAgICAgZm9yIChmID0gMDsgZiA8IGw7ICsrZikgewogICAgICAgICAgICAgICAgICB2YXIgbSA9IGUuY2hhckNvZGVBdChmKTsKICAgICAgICAgICAgICAgICAgaWYgKDI1NSA8IG0pIHRocm93IFUobiksIG5ldyBSKCJTdHJpbmcgaGFzIFVURi0xNiBjb2RlIHVuaXRzIHRoYXQgZG8gbm90IGZpdCBpbiA4IGJpdHMiKTsKICAgICAgICAgICAgICAgICAgQVtuICsgZl0gPSBtOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGVsc2UgZm9yIChmID0gMDsgZiA8IGw7ICsrZikgQVtuICsgZl0gPSBlW2ZdOwogICAgICAgICAgICAgIG51bGwgIT09IGQgJiYgZC5wdXNoKFUsIGgpOwogICAgICAgICAgICAgIHJldHVybiBoOwogICAgICAgICAgICB9LAogICAgICAgICAgICBhcmdQYWNrQWR2YW5jZTogOCwKICAgICAgICAgICAgcmVhZFZhbHVlRnJvbVBvaW50ZXI6IEssCiAgICAgICAgICAgIEVhKGQpIHsKICAgICAgICAgICAgICBVKGQpOwogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICB9LAogICAgICAgIHU6IChhLCBiLCBjKSA9PiB7CiAgICAgICAgICBjID0gUShjKTsKICAgICAgICAgIGlmICgyID09PSBiKSB7CiAgICAgICAgICAgIHZhciBkID0gRmI7CiAgICAgICAgICAgIHZhciBlID0gR2I7CiAgICAgICAgICAgIHZhciBmID0gSGI7CiAgICAgICAgICAgIHZhciBsID0gKGgpID0+IENbaCA+PiAxXTsKICAgICAgICAgIH0gZWxzZSA0ID09PSBiICYmIChkID0gSWIsIGUgPSBKYiwgZiA9IEtiLCBsID0gKGgpID0+IEZbaCA+PiAyXSk7CiAgICAgICAgICBPKGEsIHsKICAgICAgICAgICAgbmFtZTogYywKICAgICAgICAgICAgZnJvbVdpcmVUeXBlOiAoaCkgPT4gewogICAgICAgICAgICAgIGZvciAodmFyIG4gPSBGW2ggPj4gMl0sIG0sIHAgPSBoICsgNCwgdSA9IDA7IHUgPD0gbjsgKyt1KSB7CiAgICAgICAgICAgICAgICB2YXIgdiA9IGggKyA0ICsgdSAqIGI7CiAgICAgICAgICAgICAgICBpZiAodSA9PSBuIHx8IDAgPT0gbCh2KSkKICAgICAgICAgICAgICAgICAgcCA9IGQocCwgdiAtIHApLCB2b2lkIDAgPT09IG0gPyBtID0gcCA6IChtICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMCksIG0gKz0gcCksIHAgPSB2ICsgYjsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgVShoKTsKICAgICAgICAgICAgICByZXR1cm4gbTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgdG9XaXJlVHlwZTogKGgsIG4pID0+IHsKICAgICAgICAgICAgICBpZiAoInN0cmluZyIgIT0gdHlwZW9mIG4pIHRocm93IG5ldyBSKGBDYW5ub3QgcGFzcyBub24tc3RyaW5nIHRvIEMrKyBzdHJpbmcgdHlwZSAke2N9YCk7CiAgICAgICAgICAgICAgdmFyIG0gPSBmKG4pLCBwID0gYmMoNCArIG0gKyBiKTsKICAgICAgICAgICAgICBGW3AgPj4gMl0gPSBtIC8gYjsKICAgICAgICAgICAgICBlKG4sIHAgKyA0LCBtICsgYik7CiAgICAgICAgICAgICAgbnVsbCAhPT0gaCAmJiBoLnB1c2goVSwgcCk7CiAgICAgICAgICAgICAgcmV0dXJuIHA7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGFyZ1BhY2tBZHZhbmNlOiA4LAogICAgICAgICAgICByZWFkVmFsdWVGcm9tUG9pbnRlcjogSywKICAgICAgICAgICAgRWEoaCkgewogICAgICAgICAgICAgIFUoaCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwogICAgICAgIH0sCiAgICAgICAgczogKGEsIGIsIGMsIGQsIGUsIGYpID0+IHsKICAgICAgICAgIEZhW2FdID0geyBuYW1lOiBRKGIpLCBVYTogVChjLCBkKSwgRmE6IFQoZSwgZiksIFlhOiBbXSB9OwogICAgICAgIH0sCiAgICAgICAgajogKGEsIGIsIGMsIGQsIGUsIGYsIGwsIGgsIG4sIG0pID0+IHsKICAgICAgICAgIEZhW2FdLllhLnB1c2goeyBiYjogUShiKSwgaGI6IGMsIGZiOiBUKGQsIGUpLCBnYjogZiwgbmI6IGwsIG1iOiBUKGgsIG4pLCBvYjogbSB9KTsKICAgICAgICB9LAogICAgICAgIFo6IChhLCBiKSA9PiB7CiAgICAgICAgICBiID0gUShiKTsKICAgICAgICAgIE8oYSwgeyB1YjogdHJ1ZSwgbmFtZTogYiwgYXJnUGFja0FkdmFuY2U6IDAsIGZyb21XaXJlVHlwZTogKCkgPT4gewogICAgICAgICAgfSwgdG9XaXJlVHlwZTogKCkgPT4gewogICAgICAgICAgfSB9KTsKICAgICAgICB9LAogICAgICAgIEo6ICgpID0+IHsKICAgICAgICAgIHRocm93IEluZmluaXR5OwogICAgICAgIH0sCiAgICAgICAgYWE6IChhLCBiLCBjLCBkKSA9PiB7CiAgICAgICAgICBhID0gTGJbYV07CiAgICAgICAgICBiID0geWIoYik7CiAgICAgICAgICByZXR1cm4gYShudWxsLCBiLCBjLCBkKTsKICAgICAgICB9LAogICAgICAgIEY6IHdiLAogICAgICAgICQ6IChhLCBiLCBjKSA9PiB7CiAgICAgICAgICB2YXIgZCA9IE5iKGEsIGIpLCBlID0gZC5zaGlmdCgpOwogICAgICAgICAgYS0tOwogICAgICAgICAgdmFyIGYgPSBBcnJheShhKTsKICAgICAgICAgIGIgPSBgbWV0aG9kQ2FsbGVyPCgke2QubWFwKChsKSA9PiBsLm5hbWUpLmpvaW4oIiwgIil9KSA9PiAke2UubmFtZX0+YDsKICAgICAgICAgIHJldHVybiBNYigKICAgICAgICAgICAgWmEoYiwgKGwsIGgsIG4sIG0pID0+IHsKICAgICAgICAgICAgICBmb3IgKHZhciBwID0gMCwgdSA9IDA7IHUgPCBhOyArK3UpIGZbdV0gPSBkW3VdLnJlYWRWYWx1ZUZyb21Qb2ludGVyKG0gKyBwKSwgcCArPSBkW3VdLmFyZ1BhY2tBZHZhbmNlOwogICAgICAgICAgICAgIGggPSAxID09PSBjID8gT2IoaCwgZikgOiBoLmFwcGx5KGwsIGYpOwogICAgICAgICAgICAgIGwgPSBbXTsKICAgICAgICAgICAgICBoID0gZS50b1dpcmVUeXBlKGwsIGgpOwogICAgICAgICAgICAgIGwubGVuZ3RoICYmIChGW24gPj4gMl0gPSBoYihsKSk7CiAgICAgICAgICAgICAgcmV0dXJuIGg7CiAgICAgICAgICAgIH0pCiAgICAgICAgICApOwogICAgICAgIH0sCiAgICAgICAgYmE6IChhKSA9PiB7CiAgICAgICAgICA5IDwgYSAmJiAoVlthICsgMV0gKz0gMSk7CiAgICAgICAgfSwKICAgICAgICBfOiAoYSkgPT4gewogICAgICAgICAgdmFyIGIgPSB5YihhKTsKICAgICAgICAgIEdhKGIpOwogICAgICAgICAgd2IoYSk7CiAgICAgICAgfSwKICAgICAgICBvOiAoYSwgYikgPT4gewogICAgICAgICAgYSA9IEJiKGEsICJfZW12YWxfdGFrZV92YWx1ZSIpOwogICAgICAgICAgYSA9IGEucmVhZFZhbHVlRnJvbVBvaW50ZXIoYik7CiAgICAgICAgICByZXR1cm4gaGIoYSk7CiAgICAgICAgfSwKICAgICAgICBXOiAoKSA9PiB7CiAgICAgICAgICByYSgiIik7CiAgICAgICAgfSwKICAgICAgICBWOiAoKSA9PiBwZXJmb3JtYW5jZS5ub3coKSwKICAgICAgICBMOiAoYSkgPT4gewogICAgICAgICAgdmFyIGIgPSBBLmxlbmd0aDsKICAgICAgICAgIGEgPj4+PSAwOwogICAgICAgICAgaWYgKDIxNDc0ODM2NDggPCBhKSByZXR1cm4gZmFsc2U7CiAgICAgICAgICBmb3IgKHZhciBjID0gMTsgNCA+PSBjOyBjICo9IDIpIHsKICAgICAgICAgICAgdmFyIGQgPSBiICogKDEgKyAwLjIgLyBjKTsKICAgICAgICAgICAgZCA9IE1hdGgubWluKGQsIGEgKyAxMDA2NjMyOTYpOwogICAgICAgICAgICB2YXIgZSA9IE1hdGg7CiAgICAgICAgICAgIGQgPSBNYXRoLm1heChhLCBkKTsKICAgICAgICAgICAgYTogewogICAgICAgICAgICAgIGUgPSAoZS5taW4uY2FsbChlLCAyMTQ3NDgzNjQ4LCBkICsgKDY1NTM2IC0gZCAlIDY1NTM2KSAlIDY1NTM2KSAtIGZhLmJ1ZmZlci5ieXRlTGVuZ3RoICsgNjU1MzUpIC8gNjU1MzY7CiAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgIGZhLmdyb3coZSk7CiAgICAgICAgICAgICAgICBsYSgpOwogICAgICAgICAgICAgICAgdmFyIGYgPSAxOwogICAgICAgICAgICAgICAgYnJlYWsgYTsKICAgICAgICAgICAgICB9IGNhdGNoIChsKSB7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGYgPSB2b2lkIDA7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGYpIHJldHVybiB0cnVlOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgIH0sCiAgICAgICAgUzogKGEsIGIpID0+IHsKICAgICAgICAgIHZhciBjID0gMDsKICAgICAgICAgIFJiKCkuZm9yRWFjaCgoZCwgZSkgPT4gewogICAgICAgICAgICB2YXIgZiA9IGIgKyBjOwogICAgICAgICAgICBlID0gRlthICsgNCAqIGUgPj4gMl0gPSBmOwogICAgICAgICAgICBmb3IgKGYgPSAwOyBmIDwgZC5sZW5ndGg7ICsrZikgeVtlKytdID0gZC5jaGFyQ29kZUF0KGYpOwogICAgICAgICAgICB5W2VdID0gMDsKICAgICAgICAgICAgYyArPSBkLmxlbmd0aCArIDE7CiAgICAgICAgICB9KTsKICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0sCiAgICAgICAgVDogKGEsIGIpID0+IHsKICAgICAgICAgIHZhciBjID0gUmIoKTsKICAgICAgICAgIEZbYSA+PiAyXSA9IGMubGVuZ3RoOwogICAgICAgICAgdmFyIGQgPSAwOwogICAgICAgICAgYy5mb3JFYWNoKChlKSA9PiBkICs9IGUubGVuZ3RoICsgMSk7CiAgICAgICAgICBGW2IgPj4gMl0gPSBkOwogICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgfSwKICAgICAgICB0OiAoKSA9PiA1MiwKICAgICAgICB6OiAoKSA9PiA1MiwKICAgICAgICBIOiBmdW5jdGlvbigpIHsKICAgICAgICAgIHJldHVybiA3MDsKICAgICAgICB9LAogICAgICAgIFE6IChhLCBiLCBjLCBkKSA9PiB7CiAgICAgICAgICBmb3IgKHZhciBlID0gMCwgZiA9IDA7IGYgPCBjOyBmKyspIHsKICAgICAgICAgICAgdmFyIGwgPSBGW2IgPj4gMl0sIGggPSBGW2IgKyA0ID4+IDJdOwogICAgICAgICAgICBiICs9IDg7CiAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgaDsgbisrKSB7CiAgICAgICAgICAgICAgdmFyIG0gPSBBW2wgKyBuXSwgcCA9IFNiW2FdOwogICAgICAgICAgICAgIDAgPT09IG0gfHwgMTAgPT09IG0gPyAoKDEgPT09IGEgPyBlYSA6IHcpKEoocCwgMCkpLCBwLmxlbmd0aCA9IDApIDogcC5wdXNoKG0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGUgKz0gaDsKICAgICAgICAgIH0KICAgICAgICAgIEZbZCA+PiAyXSA9IGU7CiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB9LAogICAgICAgIFU6IChhLCBiKSA9PiB7CiAgICAgICAgICBVYihBLnN1YmFycmF5KGEsIGEgKyBiKSk7CiAgICAgICAgICByZXR1cm4gMDsKICAgICAgICB9LAogICAgICAgIGk6IGNjLAogICAgICAgIGQ6IGRjLAogICAgICAgIGU6IGVjLAogICAgICAgIHA6IGZjLAogICAgICAgIHk6IGdjLAogICAgICAgIGI6IGhjLAogICAgICAgIGE6IGljLAogICAgICAgIGg6IGpjLAogICAgICAgIG46IGtjLAogICAgICAgIEc6IGxjLAogICAgICAgIEs6IChhLCBiLCBjLCBkKSA9PiBaYihhLCBiLCBjLCBkKQogICAgICB9LCBXID0gZnVuY3Rpb24oKSB7CiAgICAgICAgZnVuY3Rpb24gYShjKSB7CiAgICAgICAgICBXID0gYy5leHBvcnRzOwogICAgICAgICAgZmEgPSBXLmRhOwogICAgICAgICAgbGEoKTsKICAgICAgICAgIFMgPSBXLmhhOwogICAgICAgICAgbmEudW5zaGlmdChXLmVhKTsKICAgICAgICAgIEctLTsKICAgICAgICAgIGsubW9uaXRvclJ1bkRlcGVuZGVuY2llcz8uKEcpOwogICAgICAgICAgMCA9PSBHICYmIChudWxsICE9PSBxYSAmJiAoY2xlYXJJbnRlcnZhbChxYSksIHFhID0gbnVsbCksIEggJiYgKGMgPSBILCBIID0gbnVsbCwgYygpKSk7CiAgICAgICAgICByZXR1cm4gVzsKICAgICAgICB9CiAgICAgICAgdmFyIGIgPSB7IGE6IG1jIH07CiAgICAgICAgRysrOwogICAgICAgIGsubW9uaXRvclJ1bkRlcGVuZGVuY2llcz8uKEcpOwogICAgICAgIGlmIChrLmluc3RhbnRpYXRlV2FzbSkKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHJldHVybiBrLmluc3RhbnRpYXRlV2FzbShiLCBhKTsKICAgICAgICAgIH0gY2F0Y2ggKGMpIHsKICAgICAgICAgICAgdyhgTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogJHtjfWApLCBiYShjKTsKICAgICAgICAgIH0KICAgICAgICB4YShiLCBmdW5jdGlvbihjKSB7CiAgICAgICAgICBhKGMuaW5zdGFuY2UpOwogICAgICAgIH0pLmNhdGNoKGJhKTsKICAgICAgICByZXR1cm4ge307CiAgICAgIH0oKSwgYmMgPSAoYSkgPT4gKGJjID0gVy5mYSkoYSksIG9iID0gKGEpID0+IChvYiA9IFcuZ2EpKGEpLCBVID0gKGEpID0+IChVID0gVy5pYSkoYSksIFggPSAoYSwgYikgPT4gKFggPSBXLmphKShhLCBiKSwgWSA9IChhKSA9PiAoWSA9IFcua2EpKGEpLCBaID0gKCkgPT4gKFogPSBXLmxhKSgpOwogICAgICBrLmR5bkNhbGxfaWlqaiA9IChhLCBiLCBjLCBkLCBlLCBmKSA9PiAoay5keW5DYWxsX2lpamogPSBXLm5hKShhLCBiLCBjLCBkLCBlLCBmKTsKICAgICAgay5keW5DYWxsX3ZpamogPSAoYSwgYiwgYywgZCwgZSwgZikgPT4gKGsuZHluQ2FsbF92aWpqID0gVy5vYSkoYSwgYiwgYywgZCwgZSwgZik7CiAgICAgIGsuZHluQ2FsbF9qaWlpID0gKGEsIGIsIGMsIGQpID0+IChrLmR5bkNhbGxfamlpaSA9IFcucGEpKGEsIGIsIGMsIGQpOwogICAgICBrLmR5bkNhbGxfamlpID0gKGEsIGIsIGMpID0+IChrLmR5bkNhbGxfamlpID0gVy5xYSkoYSwgYiwgYyk7CiAgICAgIHZhciBuYyA9IGsuZHluQ2FsbF92aWlpaiA9IChhLCBiLCBjLCBkLCBlLCBmKSA9PiAobmMgPSBrLmR5bkNhbGxfdmlpaWogPSBXLnJhKShhLCBiLCBjLCBkLCBlLCBmKTsKICAgICAgay5keW5DYWxsX2ppamkgPSAoYSwgYiwgYywgZCwgZSkgPT4gKGsuZHluQ2FsbF9qaWppID0gVy5zYSkoYSwgYiwgYywgZCwgZSk7CiAgICAgIGsuZHluQ2FsbF92aWlqaWkgPSAoYSwgYiwgYywgZCwgZSwgZiwgbCkgPT4gKGsuZHluQ2FsbF92aWlqaWkgPSBXLnRhKShhLCBiLCBjLCBkLCBlLCBmLCBsKTsKICAgICAgay5keW5DYWxsX2lpaWlpaiA9IChhLCBiLCBjLCBkLCBlLCBmLCBsKSA9PiAoay5keW5DYWxsX2lpaWlpaiA9IFcudWEpKGEsIGIsIGMsIGQsIGUsIGYsIGwpOwogICAgICBrLmR5bkNhbGxfaWlpaWlqaiA9IChhLCBiLCBjLCBkLCBlLCBmLCBsLCBoLCBuKSA9PiAoay5keW5DYWxsX2lpaWlpamogPSBXLnZhKShhLCBiLCBjLCBkLCBlLCBmLCBsLCBoLCBuKTsKICAgICAgay5keW5DYWxsX2lpaWlpaWpqID0gKGEsIGIsIGMsIGQsIGUsIGYsIGwsIGgsIG4sIG0pID0+IChrLmR5bkNhbGxfaWlpaWlpamogPSBXLndhKShhLCBiLCBjLCBkLCBlLCBmLCBsLCBoLCBuLCBtKTsKICAgICAgZnVuY3Rpb24gaGMoYSwgYikgewogICAgICAgIHZhciBjID0gWigpOwogICAgICAgIHRyeSB7CiAgICAgICAgICBTLmdldChhKShiKTsKICAgICAgICB9IGNhdGNoIChkKSB7CiAgICAgICAgICBZKGMpOwogICAgICAgICAgaWYgKGQgIT09IGQgKyAwKSB0aHJvdyBkOwogICAgICAgICAgWCgxLCAwKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaWMoYSwgYiwgYykgewogICAgICAgIHZhciBkID0gWigpOwogICAgICAgIHRyeSB7CiAgICAgICAgICBTLmdldChhKShiLCBjKTsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICBZKGQpOwogICAgICAgICAgaWYgKGUgIT09IGUgKyAwKSB0aHJvdyBlOwogICAgICAgICAgWCgxLCAwKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZWMoYSwgYiwgYywgZCkgewogICAgICAgIHZhciBlID0gWigpOwogICAgICAgIHRyeSB7CiAgICAgICAgICByZXR1cm4gUy5nZXQoYSkoYiwgYywgZCk7CiAgICAgICAgfSBjYXRjaCAoZikgewogICAgICAgICAgWShlKTsKICAgICAgICAgIGlmIChmICE9PSBmICsgMCkgdGhyb3cgZjsKICAgICAgICAgIFgoMSwgMCk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRjKGEsIGIsIGMpIHsKICAgICAgICB2YXIgZCA9IFooKTsKICAgICAgICB0cnkgewogICAgICAgICAgcmV0dXJuIFMuZ2V0KGEpKGIsIGMpOwogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIFkoZCk7CiAgICAgICAgICBpZiAoZSAhPT0gZSArIDApIHRocm93IGU7CiAgICAgICAgICBYKDEsIDApOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBjYyhhLCBiKSB7CiAgICAgICAgdmFyIGMgPSBaKCk7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIHJldHVybiBTLmdldChhKShiKTsKICAgICAgICB9IGNhdGNoIChkKSB7CiAgICAgICAgICBZKGMpOwogICAgICAgICAgaWYgKGQgIT09IGQgKyAwKSB0aHJvdyBkOwogICAgICAgICAgWCgxLCAwKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZmMoYSwgYiwgYywgZCwgZSwgZikgewogICAgICAgIHZhciBsID0gWigpOwogICAgICAgIHRyeSB7CiAgICAgICAgICByZXR1cm4gUy5nZXQoYSkoYiwgYywgZCwgZSwgZik7CiAgICAgICAgfSBjYXRjaCAoaCkgewogICAgICAgICAgWShsKTsKICAgICAgICAgIGlmIChoICE9PSBoICsgMCkgdGhyb3cgaDsKICAgICAgICAgIFgoMSwgMCk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGtjKGEsIGIsIGMsIGQsIGUpIHsKICAgICAgICB2YXIgZiA9IFooKTsKICAgICAgICB0cnkgewogICAgICAgICAgUy5nZXQoYSkoYiwgYywgZCwgZSk7CiAgICAgICAgfSBjYXRjaCAobCkgewogICAgICAgICAgWShmKTsKICAgICAgICAgIGlmIChsICE9PSBsICsgMCkgdGhyb3cgbDsKICAgICAgICAgIFgoMSwgMCk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGpjKGEsIGIsIGMsIGQpIHsKICAgICAgICB2YXIgZSA9IFooKTsKICAgICAgICB0cnkgewogICAgICAgICAgUy5nZXQoYSkoYiwgYywgZCk7CiAgICAgICAgfSBjYXRjaCAoZikgewogICAgICAgICAgWShlKTsKICAgICAgICAgIGlmIChmICE9PSBmICsgMCkgdGhyb3cgZjsKICAgICAgICAgIFgoMSwgMCk7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGdjKGEpIHsKICAgICAgICB2YXIgYiA9IFooKTsKICAgICAgICB0cnkgewogICAgICAgICAgUy5nZXQoYSkoKTsKICAgICAgICB9IGNhdGNoIChjKSB7CiAgICAgICAgICBZKGIpOwogICAgICAgICAgaWYgKGMgIT09IGMgKyAwKSB0aHJvdyBjOwogICAgICAgICAgWCgxLCAwKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbGMoYSwgYiwgYywgZCwgZSwgZikgewogICAgICAgIHZhciBsID0gWigpOwogICAgICAgIHRyeSB7CiAgICAgICAgICBuYyhhLCBiLCBjLCBkLCBlLCBmKTsKICAgICAgICB9IGNhdGNoIChoKSB7CiAgICAgICAgICBZKGwpOwogICAgICAgICAgaWYgKGggIT09IGggKyAwKSB0aHJvdyBoOwogICAgICAgICAgWCgxLCAwKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgdmFyIG9jOwogICAgICBIID0gZnVuY3Rpb24gcGMoKSB7CiAgICAgICAgb2MgfHwgcWMoKTsKICAgICAgICBvYyB8fCAoSCA9IHBjKTsKICAgICAgfTsKICAgICAgZnVuY3Rpb24gcWMoKSB7CiAgICAgICAgZnVuY3Rpb24gYSgpIHsKICAgICAgICAgIGlmICghb2MgJiYgKG9jID0gdHJ1ZSwgay5jYWxsZWRSdW4gPSB0cnVlLCAhaGEpKSB7CiAgICAgICAgICAgIHlhKG5hKTsKICAgICAgICAgICAgYWEoayk7CiAgICAgICAgICAgIGlmIChrLm9uUnVudGltZUluaXRpYWxpemVkKSBrLm9uUnVudGltZUluaXRpYWxpemVkKCk7CiAgICAgICAgICAgIGlmIChrLnBvc3RSdW4pCiAgICAgICAgICAgICAgZm9yICgiZnVuY3Rpb24iID09IHR5cGVvZiBrLnBvc3RSdW4gJiYgKGsucG9zdFJ1biA9IFtrLnBvc3RSdW5dKTsgay5wb3N0UnVuLmxlbmd0aDsgKSB7CiAgICAgICAgICAgICAgICB2YXIgYiA9IGsucG9zdFJ1bi5zaGlmdCgpOwogICAgICAgICAgICAgICAgb2EudW5zaGlmdChiKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIHlhKG9hKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKCEoMCA8IEcpKSB7CiAgICAgICAgICBpZiAoay5wcmVSdW4pIGZvciAoImZ1bmN0aW9uIiA9PSB0eXBlb2Ygay5wcmVSdW4gJiYgKGsucHJlUnVuID0gW2sucHJlUnVuXSk7IGsucHJlUnVuLmxlbmd0aDsgKSBwYSgpOwogICAgICAgICAgeWEobWEpOwogICAgICAgICAgMCA8IEcgfHwgKGsuc2V0U3RhdHVzID8gKGsuc2V0U3RhdHVzKCJSdW5uaW5nLi4uIiksIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgay5zZXRTdGF0dXMoIiIpOwogICAgICAgICAgICB9LCAxKTsKICAgICAgICAgICAgYSgpOwogICAgICAgICAgfSwgMSkpIDogYSgpKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgaWYgKGsucHJlSW5pdCkKICAgICAgICBmb3IgKCJmdW5jdGlvbiIgPT0gdHlwZW9mIGsucHJlSW5pdCAmJiAoay5wcmVJbml0ID0gW2sucHJlSW5pdF0pOyAwIDwgay5wcmVJbml0Lmxlbmd0aDsgKSBrLnByZUluaXQucG9wKCkoKTsKICAgICAgcWMoKTsKICAgICAgcmV0dXJuIHJlYWR5UHJvbWlzZTsKICAgIH07CiAgfSkoKTsKICB2YXIgZG90bG90dGllX3BsYXllcl9kZWZhdWx0ID0gY3JlYXRlRG90TG90dGllUGxheWVyTW9kdWxlOwoKICAvLyBzcmMvY29yZS9kb3Rsb3R0aWUtd2FzbS1sb2FkZXIudHMKICB2YXIgRG90TG90dGllV2FzbUxvYWRlciA9IGNsYXNzIHsKICAgIGNvbnN0cnVjdG9yKCkgewogICAgICB0aHJvdyBuZXcgRXJyb3IoIlJlbmRlcmVyTG9hZGVyIGlzIGEgc3RhdGljIGNsYXNzIGFuZCBjYW5ub3QgYmUgaW5zdGFudGlhdGVkLiIpOwogICAgfQogICAgc3RhdGljIGFzeW5jIF90cnlMb2FkKHVybCkgewogICAgICBjb25zdCBtb2R1bGUgPSBhd2FpdCBkb3Rsb3R0aWVfcGxheWVyX2RlZmF1bHQoeyBsb2NhdGVGaWxlOiAoKSA9PiB1cmwgfSk7CiAgICAgIHJldHVybiBtb2R1bGU7CiAgICB9CiAgICAvKioKICAgICAqIFRyaWVzIHRvIGxvYWQgdGhlIFdBU00gbW9kdWxlIGZyb20gdGhlIHByaW1hcnkgVVJMLCBmYWxsaW5nIGJhY2sgdG8gYSBiYWNrdXAgVVJMIGlmIG5lY2Vzc2FyeS4KICAgICAqIFRocm93cyBhbiBlcnJvciBpZiBib3RoIFVSTHMgZmFpbCB0byBsb2FkIHRoZSBtb2R1bGUuCiAgICAgKiBAcmV0dXJucyBQcm9taXNlPE1vZHVsZT4gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgbG9hZGVkIG1vZHVsZS4KICAgICAqLwogICAgc3RhdGljIGFzeW5jIF9sb2FkV2l0aEJhY2t1cCgpIHsKICAgICAgaWYgKCF0aGlzLl9Nb2R1bGVQcm9taXNlKSB7CiAgICAgICAgdGhpcy5fTW9kdWxlUHJvbWlzZSA9IHRoaXMuX3RyeUxvYWQodGhpcy5fd2FzbVVSTCkuY2F0Y2goYXN5bmMgKGluaXRpYWxFcnJvcikgPT4gewogICAgICAgICAgY29uc3QgYmFja3VwVXJsID0gYGh0dHBzOi8vdW5wa2cuY29tLyR7UEFDS0FHRV9OQU1FfUAke1BBQ0tBR0VfVkVSU0lPTn0vZGlzdC9kb3Rsb3R0aWUtcGxheWVyLndhc21gOwogICAgICAgICAgY29uc29sZS53YXJuKGBQcmltYXJ5IFdBU00gbG9hZCBmYWlsZWQgZnJvbSAke3RoaXMuX3dhc21VUkx9LiBFcnJvcjogJHtpbml0aWFsRXJyb3IubWVzc2FnZX1gKTsKICAgICAgICAgIGNvbnNvbGUud2FybihgQXR0ZW1wdGluZyB0byBsb2FkIFdBU00gZnJvbSBiYWNrdXAgVVJMOiAke2JhY2t1cFVybH1gKTsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl90cnlMb2FkKGJhY2t1cFVybCk7CiAgICAgICAgICB9IGNhdGNoIChiYWNrdXBFcnJvcikgewogICAgICAgICAgICBjb25zb2xlLmVycm9yKGBQcmltYXJ5IFdBU00gVVJMIGZhaWxlZDogJHtpbml0aWFsRXJyb3IubWVzc2FnZX1gKTsKICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQmFja3VwIFdBU00gVVJMIGZhaWxlZDogJHtiYWNrdXBFcnJvci5tZXNzYWdlfWApOwogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIldBU00gbG9hZGluZyBmYWlsZWQgZnJvbSBhbGwgc291cmNlcy4iKTsKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgfQogICAgICByZXR1cm4gdGhpcy5fTW9kdWxlUHJvbWlzZTsKICAgIH0KICAgIC8qKgogICAgICogUHVibGljIG1ldGhvZCB0byBsb2FkIHRoZSBXZWJBc3NlbWJseSBtb2R1bGUuCiAgICAgKiBVdGlsaXplcyBhIHByaW1hcnkgYW5kIGJhY2t1cCBVUkwgZm9yIHJvYnVzdG5lc3MuCiAgICAgKiBAcmV0dXJucyBQcm9taXNlPE1vZHVsZT4gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgbG9hZGVkIG1vZHVsZS4KICAgICAqLwogICAgc3RhdGljIGFzeW5jIGxvYWQoKSB7CiAgICAgIHJldHVybiB0aGlzLl9sb2FkV2l0aEJhY2t1cCgpOwogICAgfQogICAgLyoqCiAgICAgKiBTZXRzIGEgbmV3IFVSTCBmb3IgdGhlIFdBU00gZmlsZSBhbmQgaW52YWxpZGF0ZXMgdGhlIGN1cnJlbnQgbW9kdWxlIHByb21pc2UuCiAgICAgKgogICAgICogQHBhcmFtIHN0cmluZyAtICBUaGUgbmV3IFVSTCBmb3IgdGhlIFdBU00gZmlsZS4KICAgICAqLwogICAgc3RhdGljIHNldFdhc21VcmwodXJsKSB7CiAgICAgIHRoaXMuX3dhc21VUkwgPSB1cmw7CiAgICAgIHRoaXMuX01vZHVsZVByb21pc2UgPSBudWxsOwogICAgfQogIH07CiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbgogIF9fcHVibGljRmllbGQoRG90TG90dGllV2FzbUxvYWRlciwgIl9Nb2R1bGVQcm9taXNlIiwgbnVsbCk7CiAgLy8gVVJMIGZvciB0aGUgV0FTTSBmaWxlLCBjb25zdHJ1Y3RlZCB1c2luZyBwYWNrYWdlIGluZm9ybWF0aW9uCiAgX19wdWJsaWNGaWVsZChEb3RMb3R0aWVXYXNtTG9hZGVyLCAiX3dhc21VUkwiLCBgaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS8ke1BBQ0tBR0VfTkFNRX1AJHtQQUNLQUdFX1ZFUlNJT059L2Rpc3QvZG90bG90dGllLXBsYXllci53YXNtYCk7CgogIC8vIHNyYy9ldmVudC1tYW5hZ2VyLnRzCiAgdmFyIEV2ZW50TWFuYWdlciA9IGNsYXNzIHsKICAgIGNvbnN0cnVjdG9yKCkgewogICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsICJfZXZlbnRMaXN0ZW5lcnMiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTsKICAgIH0KICAgIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHsKICAgICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzLmdldCh0eXBlKTsKICAgICAgaWYgKCFsaXN0ZW5lcnMpIHsKICAgICAgICBsaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpOwogICAgICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzLnNldCh0eXBlLCBsaXN0ZW5lcnMpOwogICAgICB9CiAgICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpOwogICAgfQogICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikgewogICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudExpc3RlbmVycy5nZXQodHlwZSk7CiAgICAgIGlmICghbGlzdGVuZXJzKSByZXR1cm47CiAgICAgIGlmIChsaXN0ZW5lcikgewogICAgICAgIGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpOwogICAgICAgIGlmIChsaXN0ZW5lcnMuc2l6ZSA9PT0gMCkgewogICAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMuZGVsZXRlKHR5cGUpOwogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLl9ldmVudExpc3RlbmVycy5kZWxldGUodHlwZSk7CiAgICAgIH0KICAgIH0KICAgIGRpc3BhdGNoKGV2ZW50KSB7CiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50TGlzdGVuZXJzLmdldChldmVudC50eXBlKTsKICAgICAgbGlzdGVuZXJzPy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoZXZlbnQpKTsKICAgIH0KICAgIHJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzKCkgewogICAgICB0aGlzLl9ldmVudExpc3RlbmVycy5jbGVhcigpOwogICAgfQogIH07CgogIC8vIHNyYy91dGlscy50cwogIGZ1bmN0aW9uIGlzSGV4Q29sb3IoY29sb3IpIHsKICAgIHJldHVybiAvXiMoW1xkYS1mXXs2fXxbXGRhLWZdezh9KSQvaXUudGVzdChjb2xvcik7CiAgfQogIGZ1bmN0aW9uIGhleFN0cmluZ1RvUkdCQUludChjb2xvckhleCkgewogICAgaWYgKCFpc0hleENvbG9yKGNvbG9ySGV4KSkgewogICAgICByZXR1cm4gMDsKICAgIH0KICAgIGxldCBoZXggPSBjb2xvckhleC5yZXBsYWNlKCIjIiwgIiIpOwogICAgaGV4ID0gaGV4Lmxlbmd0aCA9PT0gNiA/IGAke2hleH1mZmAgOiBoZXg7CiAgICByZXR1cm4gcGFyc2VJbnQoaGV4LCAxNik7CiAgfQogIGZ1bmN0aW9uIGlzRG90TG90dGllKGZpbGVEYXRhKSB7CiAgICBpZiAoZmlsZURhdGEuYnl0ZUxlbmd0aCA8IDQpIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogICAgY29uc3QgZmlsZVNpZ25hdHVyZSA9IG5ldyBVaW50OEFycmF5KGZpbGVEYXRhLnNsaWNlKDAsIFpJUF9TSUdOQVRVUkUuYnl0ZUxlbmd0aCkpOwogICAgZm9yIChsZXQgaSA9IDA7IGkgPCBaSVBfU0lHTkFUVVJFLmxlbmd0aDsgaSArPSAxKSB7CiAgICAgIGlmIChaSVBfU0lHTkFUVVJFW2ldICE9PSBmaWxlU2lnbmF0dXJlW2ldKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CiAgICB9CiAgICByZXR1cm4gdHJ1ZTsKICB9CiAgZnVuY3Rpb24gaXNMb3R0aWVKU09OKGpzb24pIHsKICAgIHJldHVybiBMT1RUSUVfSlNPTl9NQU5EQVRPUllfRklFTERTLmV2ZXJ5KChmaWVsZCkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGpzb24sIGZpZWxkKSk7CiAgfQogIGZ1bmN0aW9uIGlzTG90dGllKGZpbGVEYXRhKSB7CiAgICBpZiAodHlwZW9mIGZpbGVEYXRhID09PSAic3RyaW5nIikgewogICAgICB0cnkgewogICAgICAgIHJldHVybiBpc0xvdHRpZUpTT04oSlNPTi5wYXJzZShmaWxlRGF0YSkpOwogICAgICB9IGNhdGNoIChfZSkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuIGlzTG90dGllSlNPTihmaWxlRGF0YSk7CiAgICB9CiAgfQoKICAvLyBzcmMvZG90bG90dGllLnRzCiAgdmFyIGNyZWF0ZUNvcmVNb2RlID0gKG1vZGUsIG1vZHVsZSkgPT4gewogICAgaWYgKG1vZGUgPT09ICJyZXZlcnNlIikgewogICAgICByZXR1cm4gbW9kdWxlLk1vZGUuUmV2ZXJzZTsKICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gImJvdW5jZSIpIHsKICAgICAgcmV0dXJuIG1vZHVsZS5Nb2RlLkJvdW5jZTsKICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gInJldmVyc2UtYm91bmNlIikgewogICAgICByZXR1cm4gbW9kdWxlLk1vZGUuUmV2ZXJzZUJvdW5jZTsKICAgIH0gZWxzZSB7CiAgICAgIHJldHVybiBtb2R1bGUuTW9kZS5Gb3J3YXJkOwogICAgfQogIH07CiAgdmFyIGNyZWF0ZUNvcmVGaXQgPSAoZml0LCBtb2R1bGUpID0+IHsKICAgIGlmIChmaXQgPT09ICJjb250YWluIikgewogICAgICByZXR1cm4gbW9kdWxlLkZpdC5Db250YWluOwogICAgfSBlbHNlIGlmIChmaXQgPT09ICJjb3ZlciIpIHsKICAgICAgcmV0dXJuIG1vZHVsZS5GaXQuQ292ZXI7CiAgICB9IGVsc2UgaWYgKGZpdCA9PT0gImZpbGwiKSB7CiAgICAgIHJldHVybiBtb2R1bGUuRml0LkZpbGw7CiAgICB9IGVsc2UgaWYgKGZpdCA9PT0gImZpdC1oZWlnaHQiKSB7CiAgICAgIHJldHVybiBtb2R1bGUuRml0LkZpdEhlaWdodDsKICAgIH0gZWxzZSBpZiAoZml0ID09PSAiZml0LXdpZHRoIikgewogICAgICByZXR1cm4gbW9kdWxlLkZpdC5GaXRXaWR0aDsKICAgIH0gZWxzZSB7CiAgICAgIHJldHVybiBtb2R1bGUuRml0Lk5vbmU7CiAgICB9CiAgfTsKICB2YXIgY3JlYXRlQ29yZUFsaWduID0gKGFsaWduLCBtb2R1bGUpID0+IHsKICAgIGNvbnN0IGNvcmVBbGlnbiA9IG5ldyBtb2R1bGUuVmVjdG9yRmxvYXQoKTsKICAgIGNvcmVBbGlnbi5wdXNoX2JhY2soYWxpZ25bMF0pOwogICAgY29yZUFsaWduLnB1c2hfYmFjayhhbGlnblsxXSk7CiAgICByZXR1cm4gY29yZUFsaWduOwogIH07CiAgdmFyIGNyZWF0ZUNvcmVTZWdtZW50ID0gKHNlZ21lbnQsIG1vZHVsZSkgPT4gewogICAgY29uc3QgY29yZXNlZ21lbnQgPSBuZXcgbW9kdWxlLlZlY3RvckZsb2F0KCk7CiAgICBpZiAoc2VnbWVudC5sZW5ndGggIT09IDIpIHJldHVybiBjb3Jlc2VnbWVudDsKICAgIGNvcmVzZWdtZW50LnB1c2hfYmFjayhzZWdtZW50WzBdKTsKICAgIGNvcmVzZWdtZW50LnB1c2hfYmFjayhzZWdtZW50WzFdKTsKICAgIHJldHVybiBjb3Jlc2VnbWVudDsKICB9OwogIHZhciBfRG90TG90dGllID0gY2xhc3MgX0RvdExvdHRpZSB7CiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHsKICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCAiX2NhbnZhcyIpOwogICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsICJfY29udGV4dCIsIG51bGwpOwogICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsICJfZXZlbnRNYW5hZ2VyIik7CiAgICAgIF9fcHVibGljRmllbGQodGhpcywgIl9hbmltYXRpb25GcmFtZUlkIiwgbnVsbCk7CiAgICAgIF9fcHVibGljRmllbGQodGhpcywgIl9mcmFtZU1hbmFnZXIiKTsKICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCAiX2RvdExvdHRpZUNvcmUiLCBudWxsKTsKICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCAiX3JlbmRlckNvbmZpZyIsIHt9KTsKICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCAiX2lzRnJvemVuIiwgZmFsc2UpOwogICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsICJfYmFja2dyb3VuZENvbG9yIiwgbnVsbCk7CiAgICAgIF9fcHVibGljRmllbGQodGhpcywgIl9wb2ludGVyVXBNZXRob2QiKTsKICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCAiX3BvaW50ZXJEb3duTWV0aG9kIik7CiAgICAgIF9fcHVibGljRmllbGQodGhpcywgIl9wb2ludGVyTW92ZU1ldGhvZCIpOwogICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsICJfcG9pbnRlckVudGVyTWV0aG9kIik7CiAgICAgIF9fcHVibGljRmllbGQodGhpcywgIl9wb2ludGVyRXhpdE1ldGhvZCIpOwogICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsICJfb25Db21wbGV0ZU1ldGhvZCIpOwogICAgICB0aGlzLl9jYW52YXMgPSBjb25maWcuY2FudmFzOwogICAgICB0aGlzLl9jb250ZXh0ID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQoIjJkIik7CiAgICAgIHRoaXMuX2V2ZW50TWFuYWdlciA9IG5ldyBFdmVudE1hbmFnZXIoKTsKICAgICAgdGhpcy5fZnJhbWVNYW5hZ2VyID0gbmV3IEFuaW1hdGlvbkZyYW1lTWFuYWdlcigpOwogICAgICB0aGlzLl9yZW5kZXJDb25maWcgPSBjb25maWcucmVuZGVyQ29uZmlnID8/IHt9OwogICAgICBEb3RMb3R0aWVXYXNtTG9hZGVyLmxvYWQoKS50aGVuKChtb2R1bGUpID0+IHsKICAgICAgICBfRG90TG90dGllLl93YXNtTW9kdWxlID0gbW9kdWxlOwogICAgICAgIHRoaXMuX2RvdExvdHRpZUNvcmUgPSBuZXcgbW9kdWxlLkRvdExvdHRpZVBsYXllcih7CiAgICAgICAgICBhdXRvcGxheTogY29uZmlnLmF1dG9wbGF5ID8/IGZhbHNlLAogICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAwLAogICAgICAgICAgbG9vcEFuaW1hdGlvbjogY29uZmlnLmxvb3AgPz8gZmFsc2UsCiAgICAgICAgICBtb2RlOiBjcmVhdGVDb3JlTW9kZShjb25maWcubW9kZSA/PyAiZm9yd2FyZCIsIG1vZHVsZSksCiAgICAgICAgICBzZWdtZW50OiBjcmVhdGVDb3JlU2VnbWVudChjb25maWcuc2VnbWVudCA/PyBbXSwgbW9kdWxlKSwKICAgICAgICAgIHNwZWVkOiBjb25maWcuc3BlZWQgPz8gMSwKICAgICAgICAgIHVzZUZyYW1lSW50ZXJwb2xhdGlvbjogY29uZmlnLnVzZUZyYW1lSW50ZXJwb2xhdGlvbiA/PyB0cnVlLAogICAgICAgICAgbWFya2VyOiBjb25maWcubWFya2VyID8/ICIiLAogICAgICAgICAgbGF5b3V0OiBjb25maWcubGF5b3V0ID8gewogICAgICAgICAgICBhbGlnbjogY3JlYXRlQ29yZUFsaWduKGNvbmZpZy5sYXlvdXQuYWxpZ24sIG1vZHVsZSksCiAgICAgICAgICAgIGZpdDogY3JlYXRlQ29yZUZpdChjb25maWcubGF5b3V0LmZpdCwgbW9kdWxlKQogICAgICAgICAgfSA6IG1vZHVsZS5jcmVhdGVEZWZhdWx0TGF5b3V0KCkKICAgICAgICB9KTsKICAgICAgICB0aGlzLl9ldmVudE1hbmFnZXIuZGlzcGF0Y2goeyB0eXBlOiAicmVhZHkiIH0pOwogICAgICAgIGlmIChjb25maWcuZGF0YSkgewogICAgICAgICAgdGhpcy5fbG9hZEZyb21EYXRhKGNvbmZpZy5kYXRhKTsKICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5zcmMpIHsKICAgICAgICAgIHRoaXMuX2xvYWRGcm9tU3JjKGNvbmZpZy5zcmMpOwogICAgICAgIH0KICAgICAgICBpZiAoY29uZmlnLmJhY2tncm91bmRDb2xvcikgewogICAgICAgICAgdGhpcy5zZXRCYWNrZ3JvdW5kQ29sb3IoY29uZmlnLmJhY2tncm91bmRDb2xvcik7CiAgICAgICAgfQogICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHsKICAgICAgICB0aGlzLl9ldmVudE1hbmFnZXIuZGlzcGF0Y2goewogICAgICAgICAgdHlwZTogImxvYWRFcnJvciIsCiAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCB3YXNtIG1vZHVsZTogJHtlcnJvcn1gKQogICAgICAgIH0pOwogICAgICB9KTsKICAgICAgdGhpcy5fcG9pbnRlclVwTWV0aG9kID0gdGhpcy5fb25Qb2ludGVyVXAuYmluZCh0aGlzKTsKICAgICAgdGhpcy5fcG9pbnRlckRvd25NZXRob2QgPSB0aGlzLl9vblBvaW50ZXJEb3duLmJpbmQodGhpcyk7CiAgICAgIHRoaXMuX3BvaW50ZXJNb3ZlTWV0aG9kID0gdGhpcy5fb25Qb2ludGVyTW92ZS5iaW5kKHRoaXMpOwogICAgICB0aGlzLl9wb2ludGVyRW50ZXJNZXRob2QgPSB0aGlzLl9vblBvaW50ZXJFbnRlci5iaW5kKHRoaXMpOwogICAgICB0aGlzLl9wb2ludGVyRXhpdE1ldGhvZCA9IHRoaXMuX29uUG9pbnRlckxlYXZlLmJpbmQodGhpcyk7CiAgICAgIHRoaXMuX29uQ29tcGxldGVNZXRob2QgPSB0aGlzLl9vbkNvbXBsZXRlLmJpbmQodGhpcyk7CiAgICB9CiAgICBfZGlzcGF0Y2hFcnJvcihtZXNzYWdlKSB7CiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7CiAgICAgIHRoaXMuX2V2ZW50TWFuYWdlci5kaXNwYXRjaCh7IHR5cGU6ICJsb2FkRXJyb3IiLCBlcnJvcjogbmV3IEVycm9yKG1lc3NhZ2UpIH0pOwogICAgfQogICAgYXN5bmMgX2ZldGNoRGF0YShzcmMpIHsKICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChzcmMpOwogICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggYW5pbWF0aW9uIGRhdGEgZnJvbSBVUkw6ICR7c3JjfS4gJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7CiAgICAgIH0KICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7CiAgICAgIGlmIChpc0RvdExvdHRpZShkYXRhKSkgewogICAgICAgIHJldHVybiBkYXRhOwogICAgICB9CiAgICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZGF0YSk7CiAgICB9CiAgICBfbG9hZEZyb21EYXRhKGRhdGEpIHsKICAgICAgaWYgKHRoaXMuX2RvdExvdHRpZUNvcmUgPT09IG51bGwpIHJldHVybjsKICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLl9jYW52YXMud2lkdGg7CiAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuX2NhbnZhcy5oZWlnaHQ7CiAgICAgIGxldCBsb2FkZWQgPSBmYWxzZTsKICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAic3RyaW5nIikgewogICAgICAgIGlmICghaXNMb3R0aWUoZGF0YSkpIHsKICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoRXJyb3IoCiAgICAgICAgICAgICJJbnZhbGlkIExvdHRpZSBKU09OIHN0cmluZzogVGhlIHByb3ZpZGVkIHN0cmluZyBkb2VzIG5vdCBjb25mb3JtIHRvIHRoZSBMb3R0aWUgSlNPTiBmb3JtYXQuIgogICAgICAgICAgKTsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgbG9hZGVkID0gdGhpcy5fZG90TG90dGllQ29yZS5sb2FkQW5pbWF0aW9uRGF0YShkYXRhLCB3aWR0aCwgaGVpZ2h0KTsKICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHsKICAgICAgICBpZiAoIWlzRG90TG90dGllKGRhdGEpKSB7CiAgICAgICAgICB0aGlzLl9kaXNwYXRjaEVycm9yKAogICAgICAgICAgICAiSW52YWxpZCBkb3RMb3R0aWUgQXJyYXlCdWZmZXI6IFRoZSBwcm92aWRlZCBBcnJheUJ1ZmZlciBkb2VzIG5vdCBjb25mb3JtIHRvIHRoZSBkb3RMb3R0aWUgZm9ybWF0LiIKICAgICAgICAgICk7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGxvYWRlZCA9IHRoaXMuX2RvdExvdHRpZUNvcmUubG9hZERvdExvdHRpZURhdGEoZGF0YSwgd2lkdGgsIGhlaWdodCk7CiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICJvYmplY3QiKSB7CiAgICAgICAgaWYgKCFpc0xvdHRpZShkYXRhKSkgewogICAgICAgICAgdGhpcy5fZGlzcGF0Y2hFcnJvcigKICAgICAgICAgICAgIkludmFsaWQgTG90dGllIEpTT04gb2JqZWN0OiBUaGUgcHJvdmlkZWQgb2JqZWN0IGRvZXMgbm90IGNvbmZvcm0gdG8gdGhlIExvdHRpZSBKU09OIGZvcm1hdC4iCiAgICAgICAgICApOwogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICBsb2FkZWQgPSB0aGlzLl9kb3RMb3R0aWVDb3JlLmxvYWRBbmltYXRpb25EYXRhKEpTT04uc3RyaW5naWZ5KGRhdGEpLCB3aWR0aCwgaGVpZ2h0KTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLl9kaXNwYXRjaEVycm9yKAogICAgICAgICAgYFVuc3VwcG9ydGVkIGRhdGEgdHlwZSBmb3IgYW5pbWF0aW9uIGRhdGEuIEV4cGVjdGVkOiAKICAgICAgICAgIC0gc3RyaW5nIChMb3R0aWUgSlNPTiksCiAgICAgICAgICAtIEFycmF5QnVmZmVyIChkb3RMb3R0aWUpLAogICAgICAgICAgLSBvYmplY3QgKExvdHRpZSBKU09OKS4gCiAgICAgICAgICBSZWNlaXZlZDogJHt0eXBlb2YgZGF0YX1gCiAgICAgICAgKTsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgaWYgKGxvYWRlZCkgewogICAgICAgIHRoaXMuX2V2ZW50TWFuYWdlci5kaXNwYXRjaCh7IHR5cGU6ICJsb2FkIiB9KTsKICAgICAgICBpZiAoSVNfQlJPV1NFUikgewogICAgICAgICAgdGhpcy5yZXNpemUoKTsKICAgICAgICB9CiAgICAgICAgdGhpcy5fZXZlbnRNYW5hZ2VyLmRpc3BhdGNoKHsKICAgICAgICAgIHR5cGU6ICJmcmFtZSIsCiAgICAgICAgICBjdXJyZW50RnJhbWU6IHRoaXMuX2RvdExvdHRpZUNvcmUuY3VycmVudEZyYW1lKCkKICAgICAgICB9KTsKICAgICAgICB0aGlzLl9yZW5kZXIoKTsKICAgICAgICBpZiAodGhpcy5fZG90TG90dGllQ29yZS5jb25maWcoKS5hdXRvcGxheSkgewogICAgICAgICAgdGhpcy5fZG90TG90dGllQ29yZS5wbGF5KCk7CiAgICAgICAgICBpZiAodGhpcy5fZG90TG90dGllQ29yZS5pc1BsYXlpbmcoKSkgewogICAgICAgICAgICB0aGlzLl9ldmVudE1hbmFnZXIuZGlzcGF0Y2goeyB0eXBlOiAicGxheSIgfSk7CiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbkZyYW1lSWQgPSB0aGlzLl9mcmFtZU1hbmFnZXIucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2RyYXcuYmluZCh0aGlzKSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjb25zb2xlLmVycm9yKCJzb21ldGhpbmcgd2VudCB3cm9uZywgdGhlIGFuaW1hdGlvbiB3YXMgc3VwcG9zZSB0byBhdXRvcGxheSIpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICB0aGlzLl9kaXNwYXRjaEVycm9yKCJGYWlsZWQgdG8gbG9hZCBhbmltYXRpb24gZGF0YSIpOwogICAgICB9CiAgICB9CiAgICBfbG9hZEZyb21TcmMoc3JjKSB7CiAgICAgIHRoaXMuX2ZldGNoRGF0YShzcmMpLnRoZW4oKGRhdGEpID0+IHRoaXMuX2xvYWRGcm9tRGF0YShkYXRhKSkuY2F0Y2goKGVycm9yKSA9PiB0aGlzLl9kaXNwYXRjaEVycm9yKGBGYWlsZWQgdG8gbG9hZCBhbmltYXRpb24gZGF0YSBmcm9tIFVSTDogJHtzcmN9LiAke2Vycm9yfWApKTsKICAgIH0KICAgIGdldCBhY3RpdmVBbmltYXRpb25JZCgpIHsKICAgICAgcmV0dXJuIHRoaXMuX2RvdExvdHRpZUNvcmU/LmFjdGl2ZUFuaW1hdGlvbklkKCk7CiAgICB9CiAgICBnZXQgYWN0aXZlVGhlbWVJZCgpIHsKICAgICAgcmV0dXJuIHRoaXMuX2RvdExvdHRpZUNvcmU/LmFjdGl2ZVRoZW1lSWQoKTsKICAgIH0KICAgIGdldCBsYXlvdXQoKSB7CiAgICAgIGNvbnN0IGxheW91dCA9IHRoaXMuX2RvdExvdHRpZUNvcmU/LmNvbmZpZygpLmxheW91dDsKICAgICAgaWYgKGxheW91dCkgewogICAgICAgIHJldHVybiB7CiAgICAgICAgICBhbGlnbjogW2xheW91dC5hbGlnbi5nZXQoMCksIGxheW91dC5hbGlnbi5nZXQoMSldLAogICAgICAgICAgZml0OiAoKCkgPT4gewogICAgICAgICAgICBzd2l0Y2ggKGxheW91dC5maXQpIHsKICAgICAgICAgICAgICBjYXNlIF9Eb3RMb3R0aWUuX3dhc21Nb2R1bGU/LkZpdC5Db250YWluOgogICAgICAgICAgICAgICAgcmV0dXJuICJjb250YWluIjsKICAgICAgICAgICAgICBjYXNlIF9Eb3RMb3R0aWUuX3dhc21Nb2R1bGU/LkZpdC5Db3ZlcjoKICAgICAgICAgICAgICAgIHJldHVybiAiY292ZXIiOwogICAgICAgICAgICAgIGNhc2UgX0RvdExvdHRpZS5fd2FzbU1vZHVsZT8uRml0LkZpbGw6CiAgICAgICAgICAgICAgICByZXR1cm4gImZpbGwiOwogICAgICAgICAgICAgIGNhc2UgX0RvdExvdHRpZS5fd2FzbU1vZHVsZT8uRml0LkZpdEhlaWdodDoKICAgICAgICAgICAgICAgIHJldHVybiAiZml0LWhlaWdodCI7CiAgICAgICAgICAgICAgY2FzZSBfRG90TG90dGllLl93YXNtTW9kdWxlPy5GaXQuRml0V2lkdGg6CiAgICAgICAgICAgICAgICByZXR1cm4gImZpdC13aWR0aCI7CiAgICAgICAgICAgICAgY2FzZSBfRG90TG90dGllLl93YXNtTW9kdWxlPy5GaXQuTm9uZToKICAgICAgICAgICAgICAgIHJldHVybiAibm9uZSI7CiAgICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICAgIHJldHVybiAiY29udGFpbiI7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0pKCkKICAgICAgICB9OwogICAgICB9CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICBnZXQgbWFya2VyKCkgewogICAgICBjb25zdCBtYXJrZXIgPSB0aGlzLl9kb3RMb3R0aWVDb3JlPy5jb25maWcoKS5tYXJrZXI7CiAgICAgIHJldHVybiBtYXJrZXI7CiAgICB9CiAgICBnZXQgbWFuaWZlc3QoKSB7CiAgICAgIHRyeSB7CiAgICAgICAgY29uc3QgbWFuaWZlc3QgPSB0aGlzLl9kb3RMb3R0aWVDb3JlPy5tYW5pZmVzdFN0cmluZygpOwogICAgICAgIGlmICh0aGlzLl9kb3RMb3R0aWVDb3JlID09PSBudWxsIHx8ICFtYW5pZmVzdCkgcmV0dXJuIG51bGw7CiAgICAgICAgY29uc3QgbWFuaWZlc3RKc29uID0gSlNPTi5wYXJzZShtYW5pZmVzdCk7CiAgICAgICAgaWYgKE9iamVjdC5rZXlzKG1hbmlmZXN0SnNvbikubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDsKICAgICAgICByZXR1cm4gbWFuaWZlc3RKc29uOwogICAgICB9IGNhdGNoIChfZXJyKSB7CiAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgIH0KICAgIH0KICAgIGdldCByZW5kZXJDb25maWcoKSB7CiAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJDb25maWc7CiAgICB9CiAgICBnZXQgc2VnbWVudCgpIHsKICAgICAgY29uc3Qgc2VnbWVudCA9IHRoaXMuX2RvdExvdHRpZUNvcmU/LmNvbmZpZygpLnNlZ21lbnQ7CiAgICAgIGlmIChzZWdtZW50ICYmIHNlZ21lbnQuc2l6ZSgpID09PSAyKSB7CiAgICAgICAgcmV0dXJuIFtzZWdtZW50LmdldCgwKSwgc2VnbWVudC5nZXQoMSldOwogICAgICB9CiAgICAgIHJldHVybiB2b2lkIDA7CiAgICB9CiAgICBnZXQgbG9vcCgpIHsKICAgICAgcmV0dXJuIHRoaXMuX2RvdExvdHRpZUNvcmU/LmNvbmZpZygpLmxvb3BBbmltYXRpb24gPz8gZmFsc2U7CiAgICB9CiAgICBnZXQgbW9kZSgpIHsKICAgICAgY29uc3QgbW9kZSA9IHRoaXMuX2RvdExvdHRpZUNvcmU/LmNvbmZpZygpLm1vZGU7CiAgICAgIGlmIChtb2RlID09PSBfRG90TG90dGllLl93YXNtTW9kdWxlPy5Nb2RlLlJldmVyc2UpIHsKICAgICAgICByZXR1cm4gInJldmVyc2UiOwogICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IF9Eb3RMb3R0aWUuX3dhc21Nb2R1bGU/Lk1vZGUuQm91bmNlKSB7CiAgICAgICAgcmV0dXJuICJib3VuY2UiOwogICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IF9Eb3RMb3R0aWUuX3dhc21Nb2R1bGU/Lk1vZGUuUmV2ZXJzZUJvdW5jZSkgewogICAgICAgIHJldHVybiAicmV2ZXJzZS1ib3VuY2UiOwogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiAiZm9yd2FyZCI7CiAgICAgIH0KICAgIH0KICAgIGdldCBpc0Zyb3plbigpIHsKICAgICAgcmV0dXJuIHRoaXMuX2lzRnJvemVuOwogICAgfQogICAgZ2V0IGJhY2tncm91bmRDb2xvcigpIHsKICAgICAgcmV0dXJuIHRoaXMuX2JhY2tncm91bmRDb2xvciA/PyAiIjsKICAgIH0KICAgIGdldCBhdXRvcGxheSgpIHsKICAgICAgcmV0dXJuIHRoaXMuX2RvdExvdHRpZUNvcmU/LmNvbmZpZygpLmF1dG9wbGF5ID8/IGZhbHNlOwogICAgfQogICAgZ2V0IHVzZUZyYW1lSW50ZXJwb2xhdGlvbigpIHsKICAgICAgcmV0dXJuIHRoaXMuX2RvdExvdHRpZUNvcmU/LmNvbmZpZygpLnVzZUZyYW1lSW50ZXJwb2xhdGlvbiA/PyBmYWxzZTsKICAgIH0KICAgIGdldCBzcGVlZCgpIHsKICAgICAgcmV0dXJuIHRoaXMuX2RvdExvdHRpZUNvcmU/LmNvbmZpZygpLnNwZWVkID8/IDA7CiAgICB9CiAgICBnZXQgaXNSZWFkeSgpIHsKICAgICAgcmV0dXJuIHRoaXMuX2RvdExvdHRpZUNvcmUgIT09IG51bGw7CiAgICB9CiAgICBnZXQgaXNMb2FkZWQoKSB7CiAgICAgIHJldHVybiB0aGlzLl9kb3RMb3R0aWVDb3JlPy5pc0xvYWRlZCgpID8/IGZhbHNlOwogICAgfQogICAgZ2V0IGlzUGxheWluZygpIHsKICAgICAgcmV0dXJuIHRoaXMuX2RvdExvdHRpZUNvcmU/LmlzUGxheWluZygpID8/IGZhbHNlOwogICAgfQogICAgZ2V0IGlzUGF1c2VkKCkgewogICAgICByZXR1cm4gdGhpcy5fZG90TG90dGllQ29yZT8uaXNQYXVzZWQoKSA/PyBmYWxzZTsKICAgIH0KICAgIGdldCBpc1N0b3BwZWQoKSB7CiAgICAgIHJldHVybiB0aGlzLl9kb3RMb3R0aWVDb3JlPy5pc1N0b3BwZWQoKSA/PyBmYWxzZTsKICAgIH0KICAgIGdldCBjdXJyZW50RnJhbWUoKSB7CiAgICAgIHJldHVybiB0aGlzLl9kb3RMb3R0aWVDb3JlPy5jdXJyZW50RnJhbWUoKSA/PyAwOwogICAgfQogICAgZ2V0IGxvb3BDb3VudCgpIHsKICAgICAgcmV0dXJuIHRoaXMuX2RvdExvdHRpZUNvcmU/Lmxvb3BDb3VudCgpID8/IDA7CiAgICB9CiAgICBnZXQgdG90YWxGcmFtZXMoKSB7CiAgICAgIHJldHVybiB0aGlzLl9kb3RMb3R0aWVDb3JlPy50b3RhbEZyYW1lcygpID8/IDA7CiAgICB9CiAgICBnZXQgZHVyYXRpb24oKSB7CiAgICAgIHJldHVybiB0aGlzLl9kb3RMb3R0aWVDb3JlPy5kdXJhdGlvbigpID8/IDA7CiAgICB9CiAgICBnZXQgc2VnbWVudER1cmF0aW9uKCkgewogICAgICByZXR1cm4gdGhpcy5fZG90TG90dGllQ29yZT8uc2VnbWVudER1cmF0aW9uKCkgPz8gMDsKICAgIH0KICAgIGdldCBjYW52YXMoKSB7CiAgICAgIHJldHVybiB0aGlzLl9jYW52YXM7CiAgICB9CiAgICBsb2FkKGNvbmZpZykgewogICAgICBpZiAodGhpcy5fZG90TG90dGllQ29yZSA9PT0gbnVsbCB8fCBfRG90TG90dGllLl93YXNtTW9kdWxlID09PSBudWxsKSByZXR1cm47CiAgICAgIHRoaXMuX2RvdExvdHRpZUNvcmUuc2V0Q29uZmlnKHsKICAgICAgICBhdXRvcGxheTogY29uZmlnLmF1dG9wbGF5ID8/IGZhbHNlLAogICAgICAgIGJhY2tncm91bmRDb2xvcjogMCwKICAgICAgICBsb29wQW5pbWF0aW9uOiBjb25maWcubG9vcCA/PyBmYWxzZSwKICAgICAgICBtb2RlOiBjcmVhdGVDb3JlTW9kZShjb25maWcubW9kZSA/PyAiZm9yd2FyZCIsIF9Eb3RMb3R0aWUuX3dhc21Nb2R1bGUpLAogICAgICAgIHNlZ21lbnQ6IGNyZWF0ZUNvcmVTZWdtZW50KGNvbmZpZy5zZWdtZW50ID8/IFtdLCBfRG90TG90dGllLl93YXNtTW9kdWxlKSwKICAgICAgICBzcGVlZDogY29uZmlnLnNwZWVkID8/IDEsCiAgICAgICAgdXNlRnJhbWVJbnRlcnBvbGF0aW9uOiBjb25maWcudXNlRnJhbWVJbnRlcnBvbGF0aW9uID8/IHRydWUsCiAgICAgICAgbWFya2VyOiBjb25maWcubWFya2VyID8/ICIiLAogICAgICAgIGxheW91dDogY29uZmlnLmxheW91dCA/IHsKICAgICAgICAgIGFsaWduOiBjcmVhdGVDb3JlQWxpZ24oY29uZmlnLmxheW91dC5hbGlnbiwgX0RvdExvdHRpZS5fd2FzbU1vZHVsZSksCiAgICAgICAgICBmaXQ6IGNyZWF0ZUNvcmVGaXQoY29uZmlnLmxheW91dC5maXQsIF9Eb3RMb3R0aWUuX3dhc21Nb2R1bGUpCiAgICAgICAgfSA6IF9Eb3RMb3R0aWUuX3dhc21Nb2R1bGUuY3JlYXRlRGVmYXVsdExheW91dCgpCiAgICAgIH0pOwogICAgICBpZiAoY29uZmlnLmRhdGEpIHsKICAgICAgICB0aGlzLl9sb2FkRnJvbURhdGEoY29uZmlnLmRhdGEpOwogICAgICB9IGVsc2UgaWYgKGNvbmZpZy5zcmMpIHsKICAgICAgICB0aGlzLl9sb2FkRnJvbVNyYyhjb25maWcuc3JjKTsKICAgICAgfQogICAgICB0aGlzLnNldEJhY2tncm91bmRDb2xvcihjb25maWcuYmFja2dyb3VuZENvbG9yID8/ICIiKTsKICAgIH0KICAgIF9yZW5kZXIoKSB7CiAgICAgIGlmICh0aGlzLl9kb3RMb3R0aWVDb3JlID09PSBudWxsIHx8IHRoaXMuX2NvbnRleHQgPT09IG51bGwpIHJldHVybiBmYWxzZTsKICAgICAgY29uc3QgcmVuZGVyZWQgPSB0aGlzLl9kb3RMb3R0aWVDb3JlLnJlbmRlcigpOwogICAgICBpZiAocmVuZGVyZWQpIHsKICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9kb3RMb3R0aWVDb3JlLmJ1ZmZlcigpOwogICAgICAgIGNvbnN0IGNsYW1wZWRCdWZmZXIgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoYnVmZmVyLCAwLCB0aGlzLl9jYW52YXMud2lkdGggKiB0aGlzLl9jYW52YXMuaGVpZ2h0ICogNCk7CiAgICAgICAgbGV0IGltYWdlRGF0YSA9IG51bGw7CiAgICAgICAgaWYgKHR5cGVvZiBJbWFnZURhdGEgPT09ICJ1bmRlZmluZWQiKSB7CiAgICAgICAgICBpbWFnZURhdGEgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQpOwogICAgICAgICAgaW1hZ2VEYXRhLmRhdGEuc2V0KGNsYW1wZWRCdWZmZXIpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpbWFnZURhdGEgPSBuZXcgSW1hZ2VEYXRhKGNsYW1wZWRCdWZmZXIsIHRoaXMuX2NhbnZhcy53aWR0aCwgdGhpcy5fY2FudmFzLmhlaWdodCk7CiAgICAgICAgfQogICAgICAgIHRoaXMuX2NvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7CiAgICAgICAgdGhpcy5fZXZlbnRNYW5hZ2VyLmRpc3BhdGNoKHsKICAgICAgICAgIHR5cGU6ICJyZW5kZXIiLAogICAgICAgICAgY3VycmVudEZyYW1lOiB0aGlzLl9kb3RMb3R0aWVDb3JlLmN1cnJlbnRGcmFtZSgpCiAgICAgICAgfSk7CiAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgIH0KICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogICAgX2RyYXcoKSB7CiAgICAgIGlmICh0aGlzLl9kb3RMb3R0aWVDb3JlID09PSBudWxsIHx8IHRoaXMuX2NvbnRleHQgPT09IG51bGwgfHwgIXRoaXMuX2RvdExvdHRpZUNvcmUuaXNQbGF5aW5nKCkpIHJldHVybjsKICAgICAgY29uc3QgbmV4dEZyYW1lID0gdGhpcy5fZG90TG90dGllQ29yZS5yZXF1ZXN0RnJhbWUoKTsKICAgICAgY29uc3QgdXBkYXRlZCA9IHRoaXMuX2RvdExvdHRpZUNvcmUuc2V0RnJhbWUobmV4dEZyYW1lKTsKICAgICAgaWYgKHVwZGF0ZWQpIHsKICAgICAgICB0aGlzLl9ldmVudE1hbmFnZXIuZGlzcGF0Y2goewogICAgICAgICAgdHlwZTogImZyYW1lIiwKICAgICAgICAgIGN1cnJlbnRGcmFtZTogdGhpcy5fZG90TG90dGllQ29yZS5jdXJyZW50RnJhbWUoKQogICAgICAgIH0pOwogICAgICAgIGNvbnN0IHJlbmRlcmVkID0gdGhpcy5fcmVuZGVyKCk7CiAgICAgICAgaWYgKHJlbmRlcmVkKSB7CiAgICAgICAgICBpZiAodGhpcy5fZG90TG90dGllQ29yZS5pc0NvbXBsZXRlKCkpIHsKICAgICAgICAgICAgaWYgKHRoaXMuX2RvdExvdHRpZUNvcmUuY29uZmlnKCkubG9vcEFuaW1hdGlvbikgewogICAgICAgICAgICAgIHRoaXMuX2V2ZW50TWFuYWdlci5kaXNwYXRjaCh7CiAgICAgICAgICAgICAgICB0eXBlOiAibG9vcCIsCiAgICAgICAgICAgICAgICBsb29wQ291bnQ6IHRoaXMuX2RvdExvdHRpZUNvcmUubG9vcENvdW50KCkKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB0aGlzLl9ldmVudE1hbmFnZXIuZGlzcGF0Y2goeyB0eXBlOiAiY29tcGxldGUiIH0pOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIHRoaXMuX2FuaW1hdGlvbkZyYW1lSWQgPSB0aGlzLl9mcmFtZU1hbmFnZXIucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2RyYXcuYmluZCh0aGlzKSk7CiAgICB9CiAgICBwbGF5KCkgewogICAgICBpZiAodGhpcy5fZG90TG90dGllQ29yZSA9PT0gbnVsbCkgcmV0dXJuOwogICAgICBjb25zdCBvayA9IHRoaXMuX2RvdExvdHRpZUNvcmUucGxheSgpOwogICAgICBpZiAob2sgfHwgdGhpcy5fZG90TG90dGllQ29yZS5pc1BsYXlpbmcoKSkgewogICAgICAgIHRoaXMuX2lzRnJvemVuID0gZmFsc2U7CiAgICAgICAgdGhpcy5fZXZlbnRNYW5hZ2VyLmRpc3BhdGNoKHsgdHlwZTogInBsYXkiIH0pOwogICAgICAgIHRoaXMuX2FuaW1hdGlvbkZyYW1lSWQgPSB0aGlzLl9mcmFtZU1hbmFnZXIucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2RyYXcuYmluZCh0aGlzKSk7CiAgICAgIH0KICAgIH0KICAgIHBhdXNlKCkgewogICAgICBpZiAodGhpcy5fZG90TG90dGllQ29yZSA9PT0gbnVsbCkgcmV0dXJuOwogICAgICBjb25zdCBvayA9IHRoaXMuX2RvdExvdHRpZUNvcmUucGF1c2UoKTsKICAgICAgaWYgKG9rIHx8IHRoaXMuX2RvdExvdHRpZUNvcmUuaXNQYXVzZWQoKSkgewogICAgICAgIHRoaXMuX2V2ZW50TWFuYWdlci5kaXNwYXRjaCh7IHR5cGU6ICJwYXVzZSIgfSk7CiAgICAgIH0KICAgIH0KICAgIHN0b3AoKSB7CiAgICAgIGlmICh0aGlzLl9kb3RMb3R0aWVDb3JlID09PSBudWxsKSByZXR1cm47CiAgICAgIGNvbnN0IG9rID0gdGhpcy5fZG90TG90dGllQ29yZS5zdG9wKCk7CiAgICAgIGlmIChvaykgewogICAgICAgIHRoaXMuX2V2ZW50TWFuYWdlci5kaXNwYXRjaCh7IHR5cGU6ICJmcmFtZSIsIGN1cnJlbnRGcmFtZTogdGhpcy5fZG90TG90dGllQ29yZS5jdXJyZW50RnJhbWUoKSB9KTsKICAgICAgICB0aGlzLl9yZW5kZXIoKTsKICAgICAgICB0aGlzLl9ldmVudE1hbmFnZXIuZGlzcGF0Y2goeyB0eXBlOiAic3RvcCIgfSk7CiAgICAgIH0KICAgIH0KICAgIHNldEZyYW1lKGZyYW1lKSB7CiAgICAgIGlmICh0aGlzLl9kb3RMb3R0aWVDb3JlID09PSBudWxsKSByZXR1cm47CiAgICAgIGlmIChmcmFtZSA8IDAgfHwgZnJhbWUgPiB0aGlzLl9kb3RMb3R0aWVDb3JlLnRvdGFsRnJhbWVzKCkpIHJldHVybjsKICAgICAgY29uc3Qgb2sgPSB0aGlzLl9kb3RMb3R0aWVDb3JlLnNlZWsoZnJhbWUpOwogICAgICBpZiAob2spIHsKICAgICAgICB0aGlzLl9ldmVudE1hbmFnZXIuZGlzcGF0Y2goeyB0eXBlOiAiZnJhbWUiLCBjdXJyZW50RnJhbWU6IHRoaXMuX2RvdExvdHRpZUNvcmUuY3VycmVudEZyYW1lKCkgfSk7CiAgICAgICAgdGhpcy5fcmVuZGVyKCk7CiAgICAgIH0KICAgIH0KICAgIHNldFNwZWVkKHNwZWVkKSB7CiAgICAgIGlmICh0aGlzLl9kb3RMb3R0aWVDb3JlID09PSBudWxsKSByZXR1cm47CiAgICAgIHRoaXMuX2RvdExvdHRpZUNvcmUuc2V0Q29uZmlnKHsKICAgICAgICAuLi50aGlzLl9kb3RMb3R0aWVDb3JlLmNvbmZpZygpLAogICAgICAgIHNwZWVkCiAgICAgIH0pOwogICAgfQogICAgc2V0QmFja2dyb3VuZENvbG9yKGNvbG9yKSB7CiAgICAgIGlmICh0aGlzLl9kb3RMb3R0aWVDb3JlID09PSBudWxsKSByZXR1cm47CiAgICAgIGlmIChJU19CUk9XU0VSICYmIHRoaXMuX2NhbnZhcyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7CiAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuX2RvdExvdHRpZUNvcmUuc2V0Q29uZmlnKHsKICAgICAgICAgIC4uLnRoaXMuX2RvdExvdHRpZUNvcmUuY29uZmlnKCksCiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGhleFN0cmluZ1RvUkdCQUludChjb2xvcikKICAgICAgICB9KTsKICAgICAgfQogICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjsKICAgIH0KICAgIHNldExvb3AobG9vcCkgewogICAgICBpZiAodGhpcy5fZG90TG90dGllQ29yZSA9PT0gbnVsbCkgcmV0dXJuOwogICAgICB0aGlzLl9kb3RMb3R0aWVDb3JlLnNldENvbmZpZyh7CiAgICAgICAgLi4udGhpcy5fZG90TG90dGllQ29yZS5jb25maWcoKSwKICAgICAgICBsb29wQW5pbWF0aW9uOiBsb29wCiAgICAgIH0pOwogICAgfQogICAgc2V0VXNlRnJhbWVJbnRlcnBvbGF0aW9uKHVzZUZyYW1lSW50ZXJwb2xhdGlvbikgewogICAgICBpZiAodGhpcy5fZG90TG90dGllQ29yZSA9PT0gbnVsbCkgcmV0dXJuOwogICAgICB0aGlzLl9kb3RMb3R0aWVDb3JlLnNldENvbmZpZyh7CiAgICAgICAgLi4udGhpcy5fZG90TG90dGllQ29yZS5jb25maWcoKSwKICAgICAgICB1c2VGcmFtZUludGVycG9sYXRpb24KICAgICAgfSk7CiAgICB9CiAgICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7CiAgICAgIHRoaXMuX2V2ZW50TWFuYWdlci5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTsKICAgIH0KICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHsKICAgICAgdGhpcy5fZXZlbnRNYW5hZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpOwogICAgfQogICAgZGVzdHJveSgpIHsKICAgICAgdGhpcy5fZG90TG90dGllQ29yZT8uZGVsZXRlKCk7CiAgICAgIHRoaXMuX2RvdExvdHRpZUNvcmUgPSBudWxsOwogICAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDsKICAgICAgdGhpcy5fZXZlbnRNYW5hZ2VyLmRpc3BhdGNoKHsKICAgICAgICB0eXBlOiAiZGVzdHJveSIKICAgICAgfSk7CiAgICAgIHRoaXMuX2V2ZW50TWFuYWdlci5yZW1vdmVBbGxFdmVudExpc3RlbmVycygpOwogICAgICB0aGlzLl9jbGVhbnVwU3RhdGVNYWNoaW5lTGlzdGVuZXJzKCk7CiAgICB9CiAgICBmcmVlemUoKSB7CiAgICAgIGlmICh0aGlzLl9hbmltYXRpb25GcmFtZUlkID09PSBudWxsKSByZXR1cm47CiAgICAgIHRoaXMuX2ZyYW1lTWFuYWdlci5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9hbmltYXRpb25GcmFtZUlkKTsKICAgICAgdGhpcy5fYW5pbWF0aW9uRnJhbWVJZCA9IG51bGw7CiAgICAgIHRoaXMuX2lzRnJvemVuID0gdHJ1ZTsKICAgICAgdGhpcy5fZXZlbnRNYW5hZ2VyLmRpc3BhdGNoKHsgdHlwZTogImZyZWV6ZSIgfSk7CiAgICB9CiAgICB1bmZyZWV6ZSgpIHsKICAgICAgaWYgKHRoaXMuX2FuaW1hdGlvbkZyYW1lSWQgIT09IG51bGwpIHJldHVybjsKICAgICAgdGhpcy5fYW5pbWF0aW9uRnJhbWVJZCA9IHRoaXMuX2ZyYW1lTWFuYWdlci5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fZHJhdy5iaW5kKHRoaXMpKTsKICAgICAgdGhpcy5faXNGcm96ZW4gPSBmYWxzZTsKICAgICAgdGhpcy5fZXZlbnRNYW5hZ2VyLmRpc3BhdGNoKHsgdHlwZTogInVuZnJlZXplIiB9KTsKICAgIH0KICAgIHJlc2l6ZSgpIHsKICAgICAgaWYgKElTX0JST1dTRVIgJiYgdGhpcy5fY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHsKICAgICAgICBjb25zdCBkcHIgPSB0aGlzLl9yZW5kZXJDb25maWcuZGV2aWNlUGl4ZWxSYXRpbyB8fCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxOwogICAgICAgIGNvbnN0IHsgaGVpZ2h0OiBjbGllbnRIZWlnaHQsIHdpZHRoOiBjbGllbnRXaWR0aCB9ID0gdGhpcy5fY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOwogICAgICAgIHRoaXMuX2NhbnZhcy53aWR0aCA9IGNsaWVudFdpZHRoICogZHByOwogICAgICAgIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSBjbGllbnRIZWlnaHQgKiBkcHI7CiAgICAgIH0KICAgICAgY29uc3Qgb2sgPSB0aGlzLl9kb3RMb3R0aWVDb3JlPy5yZXNpemUodGhpcy5fY2FudmFzLndpZHRoLCB0aGlzLl9jYW52YXMuaGVpZ2h0KTsKICAgICAgaWYgKG9rKSB7CiAgICAgICAgdGhpcy5fcmVuZGVyKCk7CiAgICAgIH0KICAgIH0KICAgIHNldFNlZ21lbnQoc3RhcnRGcmFtZSwgZW5kRnJhbWUpIHsKICAgICAgaWYgKHRoaXMuX2RvdExvdHRpZUNvcmUgPT09IG51bGwgfHwgX0RvdExvdHRpZS5fd2FzbU1vZHVsZSA9PT0gbnVsbCkgcmV0dXJuOwogICAgICB0aGlzLl9kb3RMb3R0aWVDb3JlLnNldENvbmZpZyh7CiAgICAgICAgLi4udGhpcy5fZG90TG90dGllQ29yZS5jb25maWcoKSwKICAgICAgICBzZWdtZW50OiBjcmVhdGVDb3JlU2VnbWVudChbc3RhcnRGcmFtZSwgZW5kRnJhbWVdLCBfRG90TG90dGllLl93YXNtTW9kdWxlKQogICAgICB9KTsKICAgIH0KICAgIHNldE1vZGUobW9kZSkgewogICAgICBpZiAodGhpcy5fZG90TG90dGllQ29yZSA9PT0gbnVsbCB8fCBfRG90TG90dGllLl93YXNtTW9kdWxlID09PSBudWxsKSByZXR1cm47CiAgICAgIHRoaXMuX2RvdExvdHRpZUNvcmUuc2V0Q29uZmlnKHsKICAgICAgICAuLi50aGlzLl9kb3RMb3R0aWVDb3JlLmNvbmZpZygpLAogICAgICAgIG1vZGU6IGNyZWF0ZUNvcmVNb2RlKG1vZGUsIF9Eb3RMb3R0aWUuX3dhc21Nb2R1bGUpCiAgICAgIH0pOwogICAgfQogICAgc2V0UmVuZGVyQ29uZmlnKGNvbmZpZykgewogICAgICB0aGlzLl9yZW5kZXJDb25maWcgPSBjb25maWc7CiAgICB9CiAgICBsb2FkQW5pbWF0aW9uKGFuaW1hdGlvbklkKSB7CiAgICAgIGlmICh0aGlzLl9kb3RMb3R0aWVDb3JlID09PSBudWxsIHx8IHRoaXMuX2RvdExvdHRpZUNvcmUuYWN0aXZlQW5pbWF0aW9uSWQoKSA9PT0gYW5pbWF0aW9uSWQpIHJldHVybjsKICAgICAgY29uc3QgbG9hZGVkID0gdGhpcy5fZG90TG90dGllQ29yZS5sb2FkQW5pbWF0aW9uKGFuaW1hdGlvbklkLCB0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQpOwogICAgICBpZiAobG9hZGVkKSB7CiAgICAgICAgdGhpcy5fZXZlbnRNYW5hZ2VyLmRpc3BhdGNoKHsgdHlwZTogImxvYWQiIH0pOwogICAgICAgIHRoaXMucmVzaXplKCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5fZXZlbnRNYW5hZ2VyLmRpc3BhdGNoKHsKICAgICAgICAgIHR5cGU6ICJsb2FkRXJyb3IiLAogICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgRmFpbGVkIHRvIGFuaW1hdGlvbiA6JHthbmltYXRpb25JZH1gKQogICAgICAgIH0pOwogICAgICB9CiAgICB9CiAgICBzZXRNYXJrZXIobWFya2VyKSB7CiAgICAgIGlmICh0aGlzLl9kb3RMb3R0aWVDb3JlID09PSBudWxsKSByZXR1cm47CiAgICAgIHRoaXMuX2RvdExvdHRpZUNvcmUuc2V0Q29uZmlnKHsKICAgICAgICAuLi50aGlzLl9kb3RMb3R0aWVDb3JlLmNvbmZpZygpLAogICAgICAgIG1hcmtlcgogICAgICB9KTsKICAgIH0KICAgIG1hcmtlcnMoKSB7CiAgICAgIGNvbnN0IG1hcmtlcnMgPSB0aGlzLl9kb3RMb3R0aWVDb3JlPy5tYXJrZXJzKCk7CiAgICAgIGlmIChtYXJrZXJzKSB7CiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrZXJzLnNpemUoKTsgaSArPSAxKSB7CiAgICAgICAgICBjb25zdCBtYXJrZXIgPSBtYXJrZXJzLmdldChpKTsKICAgICAgICAgIHJlc3VsdC5wdXNoKHsKICAgICAgICAgICAgbmFtZTogbWFya2VyLm5hbWUsCiAgICAgICAgICAgIHRpbWU6IG1hcmtlci50aW1lLAogICAgICAgICAgICBkdXJhdGlvbjogbWFya2VyLmR1cmF0aW9uCiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgfQogICAgICByZXR1cm4gW107CiAgICB9CiAgICBsb2FkVGhlbWUodGhlbWVJZCkgewogICAgICBpZiAodGhpcy5fZG90TG90dGllQ29yZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlOwogICAgICBjb25zdCBsb2FkZWQgPSB0aGlzLl9kb3RMb3R0aWVDb3JlLmxvYWRUaGVtZSh0aGVtZUlkKTsKICAgICAgdGhpcy5fcmVuZGVyKCk7CiAgICAgIHJldHVybiBsb2FkZWQ7CiAgICB9CiAgICBsb2FkVGhlbWVEYXRhKHRoZW1lRGF0YSkgewogICAgICBpZiAodGhpcy5fZG90TG90dGllQ29yZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlOwogICAgICBjb25zdCBsb2FkZWQgPSB0aGlzLl9kb3RMb3R0aWVDb3JlLmxvYWRUaGVtZURhdGEodGhlbWVEYXRhKTsKICAgICAgdGhpcy5fcmVuZGVyKCk7CiAgICAgIHJldHVybiBsb2FkZWQ7CiAgICB9CiAgICBzZXRMYXlvdXQobGF5b3V0KSB7CiAgICAgIGlmICh0aGlzLl9kb3RMb3R0aWVDb3JlID09PSBudWxsIHx8IF9Eb3RMb3R0aWUuX3dhc21Nb2R1bGUgPT09IG51bGwpIHJldHVybjsKICAgICAgdGhpcy5fZG90TG90dGllQ29yZS5zZXRDb25maWcoewogICAgICAgIC4uLnRoaXMuX2RvdExvdHRpZUNvcmUuY29uZmlnKCksCiAgICAgICAgbGF5b3V0OiB7CiAgICAgICAgICBhbGlnbjogY3JlYXRlQ29yZUFsaWduKGxheW91dC5hbGlnbiwgX0RvdExvdHRpZS5fd2FzbU1vZHVsZSksCiAgICAgICAgICBmaXQ6IGNyZWF0ZUNvcmVGaXQobGF5b3V0LmZpdCwgX0RvdExvdHRpZS5fd2FzbU1vZHVsZSkKICAgICAgICB9CiAgICAgIH0pOwogICAgfQogICAgc2V0Vmlld3BvcnQoeCwgeSwgd2lkdGgsIGhlaWdodCkgewogICAgICBpZiAodGhpcy5fZG90TG90dGllQ29yZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlOwogICAgICByZXR1cm4gdGhpcy5fZG90TG90dGllQ29yZS5zZXRWaWV3cG9ydCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTsKICAgIH0KICAgIHN0YXRpYyBzZXRXYXNtVXJsKHVybCkgewogICAgICBEb3RMb3R0aWVXYXNtTG9hZGVyLnNldFdhc21VcmwodXJsKTsKICAgIH0KICAgIGxvYWRTdGF0ZU1hY2hpbmUoc3RhdGVNYWNoaW5lSWQpIHsKICAgICAgcmV0dXJuIHRoaXMuX2RvdExvdHRpZUNvcmU/LmxvYWRTdGF0ZU1hY2hpbmUoc3RhdGVNYWNoaW5lSWQpID8/IGZhbHNlOwogICAgfQogICAgc3RhcnRTdGF0ZU1hY2hpbmUoKSB7CiAgICAgIGNvbnN0IHN0YXJ0ZWQgPSB0aGlzLl9kb3RMb3R0aWVDb3JlPy5zdGFydFN0YXRlTWFjaGluZSgpID8/IGZhbHNlOwogICAgICBpZiAoc3RhcnRlZCkgewogICAgICAgIHRoaXMuX3NldHVwU3RhdGVNYWNoaW5lTGlzdGVuZXJzKCk7CiAgICAgIH0KICAgICAgcmV0dXJuIHN0YXJ0ZWQ7CiAgICB9CiAgICBzdG9wU3RhdGVNYWNoaW5lKCkgewogICAgICBjb25zdCBzdG9wcGVkID0gdGhpcy5fZG90TG90dGllQ29yZT8uc3RvcFN0YXRlTWFjaGluZSgpID8/IGZhbHNlOwogICAgICBpZiAoc3RvcHBlZCkgewogICAgICAgIHRoaXMuX2NsZWFudXBTdGF0ZU1hY2hpbmVMaXN0ZW5lcnMoKTsKICAgICAgfQogICAgICByZXR1cm4gc3RvcHBlZDsKICAgIH0KICAgIF9nZXRQb2ludGVyUG9zaXRpb24oZXZlbnQpIHsKICAgICAgY29uc3QgcmVjdCA9IHRoaXMuX2NhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsKICAgICAgY29uc3Qgc2NhbGVYID0gdGhpcy5fY2FudmFzLndpZHRoIC8gcmVjdC53aWR0aDsKICAgICAgY29uc3Qgc2NhbGVZID0gdGhpcy5fY2FudmFzLmhlaWdodCAvIHJlY3QuaGVpZ2h0OwogICAgICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gdGhpcy5fcmVuZGVyQ29uZmlnLmRldmljZVBpeGVsUmF0aW8gfHwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTsKICAgICAgY29uc3QgeCA9IChldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0KSAqIHNjYWxlWCAvIGRldmljZVBpeGVsUmF0aW87CiAgICAgIGNvbnN0IHkgPSAoZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wKSAqIHNjYWxlWSAvIGRldmljZVBpeGVsUmF0aW87CiAgICAgIHJldHVybiB7CiAgICAgICAgeCwKICAgICAgICB5CiAgICAgIH07CiAgICB9CiAgICBfb25Qb2ludGVyVXAoZXZlbnQpIHsKICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLl9nZXRQb2ludGVyUG9zaXRpb24oZXZlbnQpOwogICAgICB0aGlzLnBvc3RTdGF0ZU1hY2hpbmVFdmVudChgT25Qb2ludGVyVXA6ICR7eH0gJHt5fWApOwogICAgfQogICAgX29uUG9pbnRlckRvd24oZXZlbnQpIHsKICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLl9nZXRQb2ludGVyUG9zaXRpb24oZXZlbnQpOwogICAgICB0aGlzLnBvc3RTdGF0ZU1hY2hpbmVFdmVudChgT25Qb2ludGVyRG93bjogJHt4fSAke3l9YCk7CiAgICB9CiAgICBfb25Qb2ludGVyTW92ZShldmVudCkgewogICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMuX2dldFBvaW50ZXJQb3NpdGlvbihldmVudCk7CiAgICAgIHRoaXMucG9zdFN0YXRlTWFjaGluZUV2ZW50KGBPblBvaW50ZXJNb3ZlOiAke3h9ICR7eX1gKTsKICAgIH0KICAgIF9vblBvaW50ZXJFbnRlcihldmVudCkgewogICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMuX2dldFBvaW50ZXJQb3NpdGlvbihldmVudCk7CiAgICAgIHRoaXMucG9zdFN0YXRlTWFjaGluZUV2ZW50KGBPblBvaW50ZXJFbnRlcjogJHt4fSAke3l9YCk7CiAgICB9CiAgICBfb25Qb2ludGVyTGVhdmUoZXZlbnQpIHsKICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLl9nZXRQb2ludGVyUG9zaXRpb24oZXZlbnQpOwogICAgICB0aGlzLnBvc3RTdGF0ZU1hY2hpbmVFdmVudChgT25Qb2ludGVyRXhpdDogJHt4fSAke3l9YCk7CiAgICB9CiAgICBfb25Db21wbGV0ZSgpIHsKICAgICAgdGhpcy5wb3N0U3RhdGVNYWNoaW5lRXZlbnQoIk9uQ29tcGxldGUiKTsKICAgIH0KICAgIC8qKgogICAgICogQGV4cGVyaW1lbnRhbAogICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIGV2ZW50IHRvIGJlIHBvc3RlZCB0byB0aGUgc3RhdGUgbWFjaGluZQogICAgICogQHJldHVybnMgYm9vbGVhbiAtIHRydWUgaWYgdGhlIGV2ZW50IHdhcyBwb3N0ZWQgc3VjY2Vzc2Z1bGx5LCBmYWxzZSBvdGhlcndpc2UKICAgICAqLwogICAgcG9zdFN0YXRlTWFjaGluZUV2ZW50KGV2ZW50KSB7CiAgICAgIGNvbnN0IHJ0ID0gdGhpcy5fZG90TG90dGllQ29yZT8ucG9zdEV2ZW50UGF5bG9hZChldmVudCkgPz8gMTsKICAgICAgaWYgKHJ0ID09PSAyKSB7CiAgICAgICAgdGhpcy5wbGF5KCk7CiAgICAgIH0gZWxzZSBpZiAocnQgPT09IDMpIHsKICAgICAgICB0aGlzLnBhdXNlKCk7CiAgICAgIH0gZWxzZSBpZiAocnQgPT09IDQpIHsKICAgICAgICB0aGlzLl9yZW5kZXIoKTsKICAgICAgfQogICAgICByZXR1cm4gcnQ7CiAgICB9CiAgICBnZXRTdGF0ZU1hY2hpbmVMaXN0ZW5lcnMoKSB7CiAgICAgIGlmICghdGhpcy5fZG90TG90dGllQ29yZSkgcmV0dXJuIFtdOwogICAgICBjb25zdCBsaXN0ZW5lcnNWZWN0b3IgPSB0aGlzLl9kb3RMb3R0aWVDb3JlLnN0YXRlTWFjaGluZUZyYW1ld29ya1NldHVwKCk7CiAgICAgIGNvbnN0IGxpc3RlbmVycyA9IFtdOwogICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVyc1ZlY3Rvci5zaXplKCk7IGkgKz0gMSkgewogICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyc1ZlY3Rvci5nZXQoaSkpOwogICAgICB9CiAgICAgIHJldHVybiBsaXN0ZW5lcnM7CiAgICB9CiAgICBfc2V0dXBTdGF0ZU1hY2hpbmVMaXN0ZW5lcnMoKSB7CiAgICAgIGlmIChJU19CUk9XU0VSICYmIHRoaXMuX2NhbnZhcyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50ICYmIHRoaXMuX2RvdExvdHRpZUNvcmUgIT09IG51bGwgJiYgdGhpcy5pc0xvYWRlZCkgewogICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuZ2V0U3RhdGVNYWNoaW5lTGlzdGVuZXJzKCk7CiAgICAgICAgaWYgKGxpc3RlbmVycy5pbmNsdWRlcygiUG9pbnRlclVwIikpIHsKICAgICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCJwb2ludGVydXAiLCB0aGlzLl9wb2ludGVyVXBNZXRob2QpOwogICAgICAgIH0KICAgICAgICBpZiAobGlzdGVuZXJzLmluY2x1ZGVzKCJQb2ludGVyRG93biIpKSB7CiAgICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigicG9pbnRlcmRvd24iLCB0aGlzLl9wb2ludGVyRG93bk1ldGhvZCk7CiAgICAgICAgfQogICAgICAgIGlmIChsaXN0ZW5lcnMuaW5jbHVkZXMoIlBvaW50ZXJNb3ZlIikpIHsKICAgICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCJwb2ludGVybW92ZSIsIHRoaXMuX3BvaW50ZXJNb3ZlTWV0aG9kKTsKICAgICAgICB9CiAgICAgICAgaWYgKGxpc3RlbmVycy5pbmNsdWRlcygiUG9pbnRlckVudGVyIikpIHsKICAgICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCJwb2ludGVyZW50ZXIiLCB0aGlzLl9wb2ludGVyRW50ZXJNZXRob2QpOwogICAgICAgIH0KICAgICAgICBpZiAobGlzdGVuZXJzLmluY2x1ZGVzKCJQb2ludGVyRXhpdCIpKSB7CiAgICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigicG9pbnRlcmxlYXZlIiwgdGhpcy5fcG9pbnRlckV4aXRNZXRob2QpOwogICAgICAgIH0KICAgICAgICBpZiAobGlzdGVuZXJzLmluY2x1ZGVzKCJDb21wbGV0ZSIpKSB7CiAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoImNvbXBsZXRlIiwgdGhpcy5fb25Db21wbGV0ZU1ldGhvZCk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBfY2xlYW51cFN0YXRlTWFjaGluZUxpc3RlbmVycygpIHsKICAgICAgaWYgKElTX0JST1dTRVIgJiYgdGhpcy5fY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHsKICAgICAgICB0aGlzLl9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigicG9pbnRlcnVwIiwgdGhpcy5fcG9pbnRlclVwTWV0aG9kKTsKICAgICAgICB0aGlzLl9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigicG9pbnRlcmRvd24iLCB0aGlzLl9wb2ludGVyRG93bk1ldGhvZCk7CiAgICAgICAgdGhpcy5fY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoInBvaW50ZXJtb3ZlIiwgdGhpcy5fcG9pbnRlck1vdmVNZXRob2QpOwogICAgICAgIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCJwb2ludGVyZW50ZXIiLCB0aGlzLl9wb2ludGVyRW50ZXJNZXRob2QpOwogICAgICAgIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCJwb2ludGVybGVhdmUiLCB0aGlzLl9wb2ludGVyRXhpdE1ldGhvZCk7CiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCJjb21wbGV0ZSIsIHRoaXMuX29uQ29tcGxldGVNZXRob2QpOwogICAgICB9CiAgICB9CiAgICBsb2FkU3RhdGVNYWNoaW5lRGF0YShzdGF0ZU1hY2hpbmVEYXRhKSB7CiAgICAgIHJldHVybiB0aGlzLl9kb3RMb3R0aWVDb3JlPy5sb2FkU3RhdGVNYWNoaW5lRGF0YShzdGF0ZU1hY2hpbmVEYXRhKSA/PyBmYWxzZTsKICAgIH0KICAgIGFuaW1hdGlvblNpemUoKSB7CiAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5fZG90TG90dGllQ29yZT8uYW5pbWF0aW9uU2l6ZSgpLmdldCgwKSA/PyAwOwogICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLl9kb3RMb3R0aWVDb3JlPy5hbmltYXRpb25TaXplKCkuZ2V0KDEpID8/IDA7CiAgICAgIHJldHVybiB7CiAgICAgICAgd2lkdGgsCiAgICAgICAgaGVpZ2h0CiAgICAgIH07CiAgICB9CiAgICBzZXRTdGF0ZU1hY2hpbmVCb29sZWFuQ29udGV4dChuYW1lLCB2YWx1ZSkgewogICAgICByZXR1cm4gdGhpcy5fZG90TG90dGllQ29yZT8uc2V0U3RhdGVNYWNoaW5lQm9vbGVhbkNvbnRleHQobmFtZSwgdmFsdWUpID8/IGZhbHNlOwogICAgfQogICAgc2V0U3RhdGVNYWNoaW5lTnVtZXJpY0NvbnRleHQobmFtZSwgdmFsdWUpIHsKICAgICAgcmV0dXJuIHRoaXMuX2RvdExvdHRpZUNvcmU/LnNldFN0YXRlTWFjaGluZU51bWVyaWNDb250ZXh0KG5hbWUsIHZhbHVlKSA/PyBmYWxzZTsKICAgIH0KICAgIHNldFN0YXRlTWFjaGluZVN0cmluZ0NvbnRleHQobmFtZSwgdmFsdWUpIHsKICAgICAgcmV0dXJuIHRoaXMuX2RvdExvdHRpZUNvcmU/LnNldFN0YXRlTWFjaGluZVN0cmluZ0NvbnRleHQobmFtZSwgdmFsdWUpID8/IGZhbHNlOwogICAgfQogIH07CiAgX19wdWJsaWNGaWVsZChfRG90TG90dGllLCAiX3dhc21Nb2R1bGUiLCBudWxsKTsKICB2YXIgRG90TG90dGllID0gX0RvdExvdHRpZTsKCiAgLy8gc3JjL3dvcmtlci9kb3Rsb3R0aWUud29ya2VyLnRzCiAgdmFyIGluc3RhbmNlc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7CiAgdmFyIGV2ZW50SGFuZGxlck1hcCA9IHsKICAgIHJlYWR5OiAoaW5zdGFuY2VJZCkgPT4gKGV2ZW50KSA9PiB7CiAgICAgIGNvbnN0IHJlc3BvbnNlID0gewogICAgICAgIGlkOiAiIiwKICAgICAgICBtZXRob2Q6ICJvblJlYWR5IiwKICAgICAgICByZXN1bHQ6IHsKICAgICAgICAgIGluc3RhbmNlSWQsCiAgICAgICAgICBldmVudAogICAgICAgIH0KICAgICAgfTsKICAgICAgc2VsZi5wb3N0TWVzc2FnZShyZXNwb25zZSk7CiAgICB9LAogICAgY29tcGxldGU6IChpbnN0YW5jZUlkKSA9PiAoZXZlbnQpID0+IHsKICAgICAgY29uc3QgcmVzcG9uc2UgPSB7CiAgICAgICAgaWQ6ICIiLAogICAgICAgIG1ldGhvZDogIm9uQ29tcGxldGUiLAogICAgICAgIHJlc3VsdDogewogICAgICAgICAgaW5zdGFuY2VJZCwKICAgICAgICAgIGV2ZW50CiAgICAgICAgfQogICAgICB9OwogICAgICBzZWxmLnBvc3RNZXNzYWdlKHJlc3BvbnNlKTsKICAgIH0sCiAgICBsb2FkOiAoaW5zdGFuY2VJZCkgPT4gKGV2ZW50KSA9PiB7CiAgICAgIGNvbnN0IGxvYWRFdmVudCA9IGV2ZW50OwogICAgICBjb25zdCByZXNwb25zZSA9IHsKICAgICAgICBpZDogIiIsCiAgICAgICAgbWV0aG9kOiAib25Mb2FkIiwKICAgICAgICByZXN1bHQ6IHsKICAgICAgICAgIGluc3RhbmNlSWQsCiAgICAgICAgICBldmVudDogbG9hZEV2ZW50CiAgICAgICAgfQogICAgICB9OwogICAgICBzZWxmLnBvc3RNZXNzYWdlKHJlc3BvbnNlKTsKICAgIH0sCiAgICBsb2FkRXJyb3I6IChpbnN0YW5jZUlkKSA9PiAoZXZlbnQpID0+IHsKICAgICAgY29uc3QgbG9hZEVycm9yRXZlbnQgPSBldmVudDsKICAgICAgY29uc3QgcmVzcG9uc2UgPSB7CiAgICAgICAgaWQ6ICIiLAogICAgICAgIG1ldGhvZDogIm9uTG9hZEVycm9yIiwKICAgICAgICByZXN1bHQ6IHsKICAgICAgICAgIGluc3RhbmNlSWQsCiAgICAgICAgICBldmVudDogbG9hZEVycm9yRXZlbnQKICAgICAgICB9CiAgICAgIH07CiAgICAgIHNlbGYucG9zdE1lc3NhZ2UocmVzcG9uc2UpOwogICAgfSwKICAgIGxvb3A6IChpbnN0YW5jZUlkKSA9PiAoZXZlbnQpID0+IHsKICAgICAgY29uc3QgbG9vcEV2ZW50ID0gZXZlbnQ7CiAgICAgIGNvbnN0IHJlc3BvbnNlID0gewogICAgICAgIGlkOiAiIiwKICAgICAgICBtZXRob2Q6ICJvbkxvb3AiLAogICAgICAgIHJlc3VsdDogewogICAgICAgICAgaW5zdGFuY2VJZCwKICAgICAgICAgIGV2ZW50OiBsb29wRXZlbnQKICAgICAgICB9CiAgICAgIH07CiAgICAgIHNlbGYucG9zdE1lc3NhZ2UocmVzcG9uc2UpOwogICAgfSwKICAgIHBsYXk6IChpbnN0YW5jZUlkKSA9PiAoZXZlbnQpID0+IHsKICAgICAgY29uc3QgcGxheUV2ZW50ID0gZXZlbnQ7CiAgICAgIGNvbnN0IHJlc3BvbnNlID0gewogICAgICAgIGlkOiAiIiwKICAgICAgICBtZXRob2Q6ICJvblBsYXkiLAogICAgICAgIHJlc3VsdDogewogICAgICAgICAgaW5zdGFuY2VJZCwKICAgICAgICAgIGV2ZW50OiBwbGF5RXZlbnQKICAgICAgICB9CiAgICAgIH07CiAgICAgIHNlbGYucG9zdE1lc3NhZ2UocmVzcG9uc2UpOwogICAgfSwKICAgIHBhdXNlOiAoaW5zdGFuY2VJZCkgPT4gKGV2ZW50KSA9PiB7CiAgICAgIGNvbnN0IHBhdXNlRXZlbnQgPSBldmVudDsKICAgICAgY29uc3QgcmVzcG9uc2UgPSB7CiAgICAgICAgaWQ6ICIiLAogICAgICAgIG1ldGhvZDogIm9uUGF1c2UiLAogICAgICAgIHJlc3VsdDogewogICAgICAgICAgaW5zdGFuY2VJZCwKICAgICAgICAgIGV2ZW50OiBwYXVzZUV2ZW50CiAgICAgICAgfQogICAgICB9OwogICAgICBzZWxmLnBvc3RNZXNzYWdlKHJlc3BvbnNlKTsKICAgIH0sCiAgICBzdG9wOiAoaW5zdGFuY2VJZCkgPT4gKGV2ZW50KSA9PiB7CiAgICAgIGNvbnN0IHN0b3BFdmVudCA9IGV2ZW50OwogICAgICBjb25zdCByZXNwb25zZSA9IHsKICAgICAgICBpZDogIiIsCiAgICAgICAgbWV0aG9kOiAib25TdG9wIiwKICAgICAgICByZXN1bHQ6IHsKICAgICAgICAgIGluc3RhbmNlSWQsCiAgICAgICAgICBldmVudDogc3RvcEV2ZW50CiAgICAgICAgfQogICAgICB9OwogICAgICBzZWxmLnBvc3RNZXNzYWdlKHJlc3BvbnNlKTsKICAgIH0sCiAgICBmcmFtZTogKGluc3RhbmNlSWQpID0+IChldmVudCkgPT4gewogICAgICBjb25zdCBmcmFtZUV2ZW50ID0gZXZlbnQ7CiAgICAgIGNvbnN0IHJlc3BvbnNlID0gewogICAgICAgIGlkOiAiIiwKICAgICAgICBtZXRob2Q6ICJvbkZyYW1lIiwKICAgICAgICByZXN1bHQ6IHsKICAgICAgICAgIGluc3RhbmNlSWQsCiAgICAgICAgICBldmVudDogZnJhbWVFdmVudAogICAgICAgIH0KICAgICAgfTsKICAgICAgc2VsZi5wb3N0TWVzc2FnZShyZXNwb25zZSk7CiAgICB9LAogICAgcmVuZGVyOiAoaW5zdGFuY2VJZCkgPT4gKGV2ZW50KSA9PiB7CiAgICAgIGNvbnN0IHJlbmRlckV2ZW50ID0gZXZlbnQ7CiAgICAgIGNvbnN0IHJlc3BvbnNlID0gewogICAgICAgIGlkOiAiIiwKICAgICAgICBtZXRob2Q6ICJvblJlbmRlciIsCiAgICAgICAgcmVzdWx0OiB7CiAgICAgICAgICBpbnN0YW5jZUlkLAogICAgICAgICAgZXZlbnQ6IHJlbmRlckV2ZW50CiAgICAgICAgfQogICAgICB9OwogICAgICBzZWxmLnBvc3RNZXNzYWdlKHJlc3BvbnNlKTsKICAgIH0sCiAgICBmcmVlemU6IChpbnN0YW5jZUlkKSA9PiAoZXZlbnQpID0+IHsKICAgICAgY29uc3QgZnJlZXplRXZlbnQgPSBldmVudDsKICAgICAgY29uc3QgcmVzcG9uc2UgPSB7CiAgICAgICAgaWQ6ICIiLAogICAgICAgIG1ldGhvZDogIm9uRnJlZXplIiwKICAgICAgICByZXN1bHQ6IHsKICAgICAgICAgIGluc3RhbmNlSWQsCiAgICAgICAgICBldmVudDogZnJlZXplRXZlbnQKICAgICAgICB9CiAgICAgIH07CiAgICAgIHNlbGYucG9zdE1lc3NhZ2UocmVzcG9uc2UpOwogICAgfSwKICAgIHVuZnJlZXplOiAoaW5zdGFuY2VJZCkgPT4gKGV2ZW50KSA9PiB7CiAgICAgIGNvbnN0IHVuZnJlZXplRXZlbnQgPSBldmVudDsKICAgICAgY29uc3QgcmVzcG9uc2UgPSB7CiAgICAgICAgaWQ6ICIiLAogICAgICAgIG1ldGhvZDogIm9uVW5mcmVlemUiLAogICAgICAgIHJlc3VsdDogewogICAgICAgICAgaW5zdGFuY2VJZCwKICAgICAgICAgIGV2ZW50OiB1bmZyZWV6ZUV2ZW50CiAgICAgICAgfQogICAgICB9OwogICAgICBzZWxmLnBvc3RNZXNzYWdlKHJlc3BvbnNlKTsKICAgIH0sCiAgICBkZXN0cm95OiAoaW5zdGFuY2VJZCkgPT4gKGV2ZW50KSA9PiB7CiAgICAgIGNvbnN0IGRlc3Ryb3lFdmVudCA9IGV2ZW50OwogICAgICBjb25zdCByZXNwb25zZSA9IHsKICAgICAgICBpZDogIiIsCiAgICAgICAgbWV0aG9kOiAib25EZXN0cm95IiwKICAgICAgICByZXN1bHQ6IHsKICAgICAgICAgIGluc3RhbmNlSWQsCiAgICAgICAgICBldmVudDogZGVzdHJveUV2ZW50CiAgICAgICAgfQogICAgICB9OwogICAgICBzZWxmLnBvc3RNZXNzYWdlKHJlc3BvbnNlKTsKICAgIH0KICB9OwogIHZhciBjb21tYW5kcyA9IHsKICAgIGdldERvdExvdHRpZUluc3RhbmNlU3RhdGUocmVxdWVzdCkgewogICAgICBjb25zdCBpbnN0YW5jZUlkID0gcmVxdWVzdC5wYXJhbXMuaW5zdGFuY2VJZDsKICAgICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXNNYXAuZ2V0KGluc3RhbmNlSWQpOwogICAgICBpZiAoIWluc3RhbmNlKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN0YW5jZSB3aXRoIGlkICR7aW5zdGFuY2VJZH0gZG9lcyBub3QgZXhpc3QuYCk7CiAgICAgIH0KICAgICAgY29uc3Qgc3RhdGUgPSB7CiAgICAgICAgaXNMb2FkZWQ6IGluc3RhbmNlLmlzTG9hZGVkLAogICAgICAgIGlzUGF1c2VkOiBpbnN0YW5jZS5pc1BhdXNlZCwKICAgICAgICBpc1BsYXlpbmc6IGluc3RhbmNlLmlzUGxheWluZywKICAgICAgICBpc1N0b3BwZWQ6IGluc3RhbmNlLmlzU3RvcHBlZCwKICAgICAgICBpc0Zyb3plbjogaW5zdGFuY2UuaXNGcm96ZW4sCiAgICAgICAgbG9vcDogaW5zdGFuY2UubG9vcCwKICAgICAgICBtb2RlOiBpbnN0YW5jZS5tb2RlLAogICAgICAgIHNwZWVkOiBpbnN0YW5jZS5zcGVlZCwKICAgICAgICBjdXJyZW50RnJhbWU6IGluc3RhbmNlLmN1cnJlbnRGcmFtZSwKICAgICAgICB0b3RhbEZyYW1lczogaW5zdGFuY2UudG90YWxGcmFtZXMsCiAgICAgICAgZHVyYXRpb246IGluc3RhbmNlLmR1cmF0aW9uLAogICAgICAgIHVzZUZyYW1lSW50ZXJwb2xhdGlvbjogaW5zdGFuY2UudXNlRnJhbWVJbnRlcnBvbGF0aW9uLAogICAgICAgIHJlbmRlckNvbmZpZzogaW5zdGFuY2UucmVuZGVyQ29uZmlnLAogICAgICAgIG1hcmtlcjogaW5zdGFuY2UubWFya2VyLAogICAgICAgIGJhY2tncm91bmRDb2xvcjogaW5zdGFuY2UuYmFja2dyb3VuZENvbG9yLAogICAgICAgIG1hcmtlcnM6IGluc3RhbmNlLm1hcmtlcnMoKSwKICAgICAgICBhY3RpdmVBbmltYXRpb25JZDogaW5zdGFuY2UuYWN0aXZlQW5pbWF0aW9uSWQsCiAgICAgICAgYWN0aXZlVGhlbWVJZDogaW5zdGFuY2UuYWN0aXZlVGhlbWVJZCwKICAgICAgICBhdXRvcGxheTogaW5zdGFuY2UuYXV0b3BsYXksCiAgICAgICAgc2VnbWVudDogaW5zdGFuY2Uuc2VnbWVudCwKICAgICAgICBsYXlvdXQ6IGluc3RhbmNlLmxheW91dCwKICAgICAgICBzZWdtZW50RHVyYXRpb246IGluc3RhbmNlLnNlZ21lbnREdXJhdGlvbiwKICAgICAgICBpc1JlYWR5OiBpbnN0YW5jZS5pc1JlYWR5LAogICAgICAgIG1hbmlmZXN0OiBpbnN0YW5jZS5tYW5pZmVzdAogICAgICB9OwogICAgICByZXR1cm4gewogICAgICAgIHN0YXRlCiAgICAgIH07CiAgICB9LAogICAgc2V0TGF5b3V0KHJlcXVlc3QpIHsKICAgICAgY29uc3QgaW5zdGFuY2VJZCA9IHJlcXVlc3QucGFyYW1zLmluc3RhbmNlSWQ7CiAgICAgIGNvbnN0IGxheW91dCA9IHJlcXVlc3QucGFyYW1zLmxheW91dDsKICAgICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXNNYXAuZ2V0KGluc3RhbmNlSWQpOwogICAgICBpZiAoIWluc3RhbmNlKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN0YW5jZSB3aXRoIGlkICR7aW5zdGFuY2VJZH0gZG9lcyBub3QgZXhpc3QuYCk7CiAgICAgIH0KICAgICAgaW5zdGFuY2Uuc2V0TGF5b3V0KGxheW91dCk7CiAgICAgIHJldHVybiB7CiAgICAgICAgc3VjY2VzczogdHJ1ZQogICAgICB9OwogICAgfSwKICAgIGdldFN0YXRlTWFjaGluZUxpc3RlbmVycyhyZXF1ZXN0KSB7CiAgICAgIGNvbnN0IGluc3RhbmNlSWQgPSByZXF1ZXN0LnBhcmFtcy5pbnN0YW5jZUlkOwogICAgICBjb25zdCBpbnN0YW5jZSA9IGluc3RhbmNlc01hcC5nZXQoaW5zdGFuY2VJZCk7CiAgICAgIGlmICghaW5zdGFuY2UpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3RhbmNlIHdpdGggaWQgJHtpbnN0YW5jZUlkfSBkb2VzIG5vdCBleGlzdC5gKTsKICAgICAgfQogICAgICByZXR1cm4gaW5zdGFuY2UuZ2V0U3RhdGVNYWNoaW5lTGlzdGVuZXJzKCk7CiAgICB9LAogICAgcG9zdFN0YXRlTWFjaGluZUV2ZW50KHJlcXVlc3QpIHsKICAgICAgY29uc3QgaW5zdGFuY2VJZCA9IHJlcXVlc3QucGFyYW1zLmluc3RhbmNlSWQ7CiAgICAgIGNvbnN0IGV2ZW50ID0gcmVxdWVzdC5wYXJhbXMuZXZlbnQ7CiAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzTWFwLmdldChpbnN0YW5jZUlkKTsKICAgICAgaWYgKCFpbnN0YW5jZSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdGFuY2Ugd2l0aCBpZCAke2luc3RhbmNlSWR9IGRvZXMgbm90IGV4aXN0LmApOwogICAgICB9CiAgICAgIHJldHVybiBpbnN0YW5jZS5wb3N0U3RhdGVNYWNoaW5lRXZlbnQoZXZlbnQpOwogICAgfSwKICAgIHN0YXJ0U3RhdGVNYWNoaW5lKHJlcXVlc3QpIHsKICAgICAgY29uc3QgaW5zdGFuY2VJZCA9IHJlcXVlc3QucGFyYW1zLmluc3RhbmNlSWQ7CiAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzTWFwLmdldChpbnN0YW5jZUlkKTsKICAgICAgaWYgKCFpbnN0YW5jZSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdGFuY2Ugd2l0aCBpZCAke2luc3RhbmNlSWR9IGRvZXMgbm90IGV4aXN0LmApOwogICAgICB9CiAgICAgIHJldHVybiBpbnN0YW5jZS5zdGFydFN0YXRlTWFjaGluZSgpOwogICAgfSwKICAgIHN0b3BTdGF0ZU1hY2hpbmUocmVxdWVzdCkgewogICAgICBjb25zdCBpbnN0YW5jZUlkID0gcmVxdWVzdC5wYXJhbXMuaW5zdGFuY2VJZDsKICAgICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXNNYXAuZ2V0KGluc3RhbmNlSWQpOwogICAgICBpZiAoIWluc3RhbmNlKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN0YW5jZSB3aXRoIGlkICR7aW5zdGFuY2VJZH0gZG9lcyBub3QgZXhpc3QuYCk7CiAgICAgIH0KICAgICAgcmV0dXJuIGluc3RhbmNlLnN0b3BTdGF0ZU1hY2hpbmUoKTsKICAgIH0sCiAgICBsb2FkU3RhdGVNYWNoaW5lKHJlcXVlc3QpIHsKICAgICAgY29uc3QgaW5zdGFuY2VJZCA9IHJlcXVlc3QucGFyYW1zLmluc3RhbmNlSWQ7CiAgICAgIGNvbnN0IHN0YXRlTWFjaGluZUlkID0gcmVxdWVzdC5wYXJhbXMuc3RhdGVNYWNoaW5lSWQ7CiAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzTWFwLmdldChpbnN0YW5jZUlkKTsKICAgICAgaWYgKCFpbnN0YW5jZSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdGFuY2Ugd2l0aCBpZCAke2luc3RhbmNlSWR9IGRvZXMgbm90IGV4aXN0LmApOwogICAgICB9CiAgICAgIHJldHVybiBpbnN0YW5jZS5sb2FkU3RhdGVNYWNoaW5lKHN0YXRlTWFjaGluZUlkKTsKICAgIH0sCiAgICBsb2FkU3RhdGVNYWNoaW5lRGF0YShyZXF1ZXN0KSB7CiAgICAgIGNvbnN0IGluc3RhbmNlSWQgPSByZXF1ZXN0LnBhcmFtcy5pbnN0YW5jZUlkOwogICAgICBjb25zdCBzdGF0ZU1hY2hpbmVEYXRhID0gcmVxdWVzdC5wYXJhbXMuc3RhdGVNYWNoaW5lRGF0YTsKICAgICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXNNYXAuZ2V0KGluc3RhbmNlSWQpOwogICAgICBpZiAoIWluc3RhbmNlKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN0YW5jZSB3aXRoIGlkICR7aW5zdGFuY2VJZH0gZG9lcyBub3QgZXhpc3QuYCk7CiAgICAgIH0KICAgICAgcmV0dXJuIGluc3RhbmNlLmxvYWRTdGF0ZU1hY2hpbmVEYXRhKHN0YXRlTWFjaGluZURhdGEpOwogICAgfSwKICAgIGNyZWF0ZTogKHJlcXVlc3QpID0+IHsKICAgICAgY29uc3QgaW5zdGFuY2VJZCA9IHJlcXVlc3QucGFyYW1zLmluc3RhbmNlSWQ7CiAgICAgIGNvbnN0IGNvbmZpZyA9IHJlcXVlc3QucGFyYW1zLmNvbmZpZzsKICAgICAgY29uc3Qgd2lkdGggPSByZXF1ZXN0LnBhcmFtcy53aWR0aDsKICAgICAgY29uc3QgaGVpZ2h0ID0gcmVxdWVzdC5wYXJhbXMuaGVpZ2h0OwogICAgICBpZiAoaW5zdGFuY2VzTWFwLmhhcyhpbnN0YW5jZUlkKSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdGFuY2Ugd2l0aCBpZCAke2luc3RhbmNlSWR9IGFscmVhZHkgZXhpc3RzLmApOwogICAgICB9CiAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IERvdExvdHRpZShjb25maWcpOwogICAgICBpbnN0YW5jZS5jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0OwogICAgICBpbnN0YW5jZS5jYW52YXMud2lkdGggPSB3aWR0aDsKICAgICAgaW5zdGFuY2VzTWFwLnNldChpbnN0YW5jZUlkLCBpbnN0YW5jZSk7CiAgICAgIGNvbnN0IGV2ZW50cyA9IFsKICAgICAgICAiY29tcGxldGUiLAogICAgICAgICJmcmFtZSIsCiAgICAgICAgImxvYWQiLAogICAgICAgICJsb2FkRXJyb3IiLAogICAgICAgICJsb29wIiwKICAgICAgICAicGF1c2UiLAogICAgICAgICJwbGF5IiwKICAgICAgICAic3RvcCIsCiAgICAgICAgImRlc3Ryb3kiLAogICAgICAgICJmcmVlemUiLAogICAgICAgICJ1bmZyZWV6ZSIsCiAgICAgICAgInJlbmRlciIsCiAgICAgICAgInJlYWR5IgogICAgICBdOwogICAgICBldmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHsKICAgICAgICBpbnN0YW5jZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBldmVudEhhbmRsZXJNYXBbZXZlbnRdKGluc3RhbmNlSWQpKTsKICAgICAgfSk7CiAgICAgIHJldHVybiB7CiAgICAgICAgaW5zdGFuY2VJZAogICAgICB9OwogICAgfSwKICAgIGRlc3Ryb3k6IChyZXF1ZXN0KSA9PiB7CiAgICAgIGNvbnN0IGluc3RhbmNlSWQgPSByZXF1ZXN0LnBhcmFtcy5pbnN0YW5jZUlkOwogICAgICBjb25zdCBpbnN0YW5jZSA9IGluc3RhbmNlc01hcC5nZXQoaW5zdGFuY2VJZCk7CiAgICAgIGlmICghaW5zdGFuY2UpIHJldHVybjsKICAgICAgaW5zdGFuY2UuZGVzdHJveSgpOwogICAgICBpbnN0YW5jZXNNYXAuZGVsZXRlKGluc3RhbmNlSWQpOwogICAgfSwKICAgIGZyZWV6ZTogKHJlcXVlc3QpID0+IHsKICAgICAgY29uc3QgaW5zdGFuY2VJZCA9IHJlcXVlc3QucGFyYW1zLmluc3RhbmNlSWQ7CiAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzTWFwLmdldChpbnN0YW5jZUlkKTsKICAgICAgaWYgKCFpbnN0YW5jZSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdGFuY2Ugd2l0aCBpZCAke2luc3RhbmNlSWR9IGRvZXMgbm90IGV4aXN0LmApOwogICAgICB9CiAgICAgIGluc3RhbmNlLmZyZWV6ZSgpOwogICAgfSwKICAgIGxvYWQ6IChyZXF1ZXN0KSA9PiB7CiAgICAgIGNvbnN0IGluc3RhbmNlSWQgPSByZXF1ZXN0LnBhcmFtcy5pbnN0YW5jZUlkOwogICAgICBjb25zdCBjb25maWcgPSByZXF1ZXN0LnBhcmFtcy5jb25maWc7CiAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzTWFwLmdldChpbnN0YW5jZUlkKTsKICAgICAgaWYgKCFpbnN0YW5jZSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdGFuY2Ugd2l0aCBpZCAke2luc3RhbmNlSWR9IGRvZXMgbm90IGV4aXN0LmApOwogICAgICB9CiAgICAgIGluc3RhbmNlLmxvYWQoY29uZmlnKTsKICAgIH0sCiAgICBsb2FkQW5pbWF0aW9uOiAocmVxdWVzdCkgPT4gewogICAgICBjb25zdCBpbnN0YW5jZUlkID0gcmVxdWVzdC5wYXJhbXMuaW5zdGFuY2VJZDsKICAgICAgY29uc3QgYW5pbWF0aW9uSWQgPSByZXF1ZXN0LnBhcmFtcy5hbmltYXRpb25JZDsKICAgICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXNNYXAuZ2V0KGluc3RhbmNlSWQpOwogICAgICBpZiAoIWluc3RhbmNlKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN0YW5jZSB3aXRoIGlkICR7aW5zdGFuY2VJZH0gZG9lcyBub3QgZXhpc3QuYCk7CiAgICAgIH0KICAgICAgaW5zdGFuY2UubG9hZEFuaW1hdGlvbihhbmltYXRpb25JZCk7CiAgICB9LAogICAgbG9hZFRoZW1lOiAocmVxdWVzdCkgPT4gewogICAgICBjb25zdCBpbnN0YW5jZUlkID0gcmVxdWVzdC5wYXJhbXMuaW5zdGFuY2VJZDsKICAgICAgY29uc3QgdGhlbWVJZCA9IHJlcXVlc3QucGFyYW1zLnRoZW1lSWQ7CiAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzTWFwLmdldChpbnN0YW5jZUlkKTsKICAgICAgaWYgKCFpbnN0YW5jZSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdGFuY2Ugd2l0aCBpZCAke2luc3RhbmNlSWR9IGRvZXMgbm90IGV4aXN0LmApOwogICAgICB9CiAgICAgIHJldHVybiBpbnN0YW5jZS5sb2FkVGhlbWUodGhlbWVJZCk7CiAgICB9LAogICAgbG9hZFRoZW1lRGF0YTogKHJlcXVlc3QpID0+IHsKICAgICAgY29uc3QgaW5zdGFuY2VJZCA9IHJlcXVlc3QucGFyYW1zLmluc3RhbmNlSWQ7CiAgICAgIGNvbnN0IHRoZW1lRGF0YSA9IHJlcXVlc3QucGFyYW1zLnRoZW1lRGF0YTsKICAgICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXNNYXAuZ2V0KGluc3RhbmNlSWQpOwogICAgICBpZiAoIWluc3RhbmNlKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN0YW5jZSB3aXRoIGlkICR7aW5zdGFuY2VJZH0gZG9lcyBub3QgZXhpc3QuYCk7CiAgICAgIH0KICAgICAgcmV0dXJuIGluc3RhbmNlLmxvYWRUaGVtZURhdGEodGhlbWVEYXRhKTsKICAgIH0sCiAgICBwYXVzZTogKHJlcXVlc3QpID0+IHsKICAgICAgY29uc3QgaW5zdGFuY2VJZCA9IHJlcXVlc3QucGFyYW1zLmluc3RhbmNlSWQ7CiAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzTWFwLmdldChpbnN0YW5jZUlkKTsKICAgICAgaWYgKCFpbnN0YW5jZSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdGFuY2Ugd2l0aCBpZCAke2luc3RhbmNlSWR9IGRvZXMgbm90IGV4aXN0LmApOwogICAgICB9CiAgICAgIHJldHVybiBpbnN0YW5jZS5wYXVzZSgpOwogICAgfSwKICAgIHBsYXk6IChyZXF1ZXN0KSA9PiB7CiAgICAgIGNvbnN0IGluc3RhbmNlSWQgPSByZXF1ZXN0LnBhcmFtcy5pbnN0YW5jZUlkOwogICAgICBjb25zdCBpbnN0YW5jZSA9IGluc3RhbmNlc01hcC5nZXQoaW5zdGFuY2VJZCk7CiAgICAgIGlmICghaW5zdGFuY2UpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3RhbmNlIHdpdGggaWQgJHtpbnN0YW5jZUlkfSBkb2VzIG5vdCBleGlzdC5gKTsKICAgICAgfQogICAgICByZXR1cm4gaW5zdGFuY2UucGxheSgpOwogICAgfSwKICAgIHJlc2l6ZTogKHJlcXVlc3QpID0+IHsKICAgICAgY29uc3QgaW5zdGFuY2VJZCA9IHJlcXVlc3QucGFyYW1zLmluc3RhbmNlSWQ7CiAgICAgIGNvbnN0IHdpZHRoID0gcmVxdWVzdC5wYXJhbXMud2lkdGg7CiAgICAgIGNvbnN0IGhlaWdodCA9IHJlcXVlc3QucGFyYW1zLmhlaWdodDsKICAgICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXNNYXAuZ2V0KGluc3RhbmNlSWQpOwogICAgICBpZiAoIWluc3RhbmNlKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN0YW5jZSB3aXRoIGlkICR7aW5zdGFuY2VJZH0gZG9lcyBub3QgZXhpc3QuYCk7CiAgICAgIH0KICAgICAgaW5zdGFuY2UuY2FudmFzLmhlaWdodCA9IGhlaWdodDsKICAgICAgaW5zdGFuY2UuY2FudmFzLndpZHRoID0gd2lkdGg7CiAgICAgIGluc3RhbmNlLnJlc2l6ZSgpOwogICAgICByZXR1cm4gewogICAgICAgIHN1Y2Nlc3M6IHRydWUKICAgICAgfTsKICAgIH0sCiAgICBzZXRCYWNrZ3JvdW5kQ29sb3I6IChyZXF1ZXN0KSA9PiB7CiAgICAgIGNvbnN0IGluc3RhbmNlSWQgPSByZXF1ZXN0LnBhcmFtcy5pbnN0YW5jZUlkOwogICAgICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSByZXF1ZXN0LnBhcmFtcy5iYWNrZ3JvdW5kQ29sb3I7CiAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzTWFwLmdldChpbnN0YW5jZUlkKTsKICAgICAgaWYgKCFpbnN0YW5jZSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdGFuY2Ugd2l0aCBpZCAke2luc3RhbmNlSWR9IGRvZXMgbm90IGV4aXN0LmApOwogICAgICB9CiAgICAgIGluc3RhbmNlLnNldEJhY2tncm91bmRDb2xvcihiYWNrZ3JvdW5kQ29sb3IpOwogICAgfSwKICAgIHNldEZyYW1lOiAocmVxdWVzdCkgPT4gewogICAgICBjb25zdCBpbnN0YW5jZUlkID0gcmVxdWVzdC5wYXJhbXMuaW5zdGFuY2VJZDsKICAgICAgY29uc3QgZnJhbWUgPSByZXF1ZXN0LnBhcmFtcy5mcmFtZTsKICAgICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXNNYXAuZ2V0KGluc3RhbmNlSWQpOwogICAgICBpZiAoIWluc3RhbmNlKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN0YW5jZSB3aXRoIGlkICR7aW5zdGFuY2VJZH0gZG9lcyBub3QgZXhpc3QuYCk7CiAgICAgIH0KICAgICAgaW5zdGFuY2Uuc2V0RnJhbWUoZnJhbWUpOwogICAgfSwKICAgIHNldE1vZGU6IChyZXF1ZXN0KSA9PiB7CiAgICAgIGNvbnN0IGluc3RhbmNlSWQgPSByZXF1ZXN0LnBhcmFtcy5pbnN0YW5jZUlkOwogICAgICBjb25zdCBtb2RlID0gcmVxdWVzdC5wYXJhbXMubW9kZTsKICAgICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXNNYXAuZ2V0KGluc3RhbmNlSWQpOwogICAgICBpZiAoIWluc3RhbmNlKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN0YW5jZSB3aXRoIGlkICR7aW5zdGFuY2VJZH0gZG9lcyBub3QgZXhpc3QuYCk7CiAgICAgIH0KICAgICAgaW5zdGFuY2Uuc2V0TW9kZShtb2RlKTsKICAgIH0sCiAgICBzZXRSZW5kZXJDb25maWc6IChyZXF1ZXN0KSA9PiB7CiAgICAgIGNvbnN0IGluc3RhbmNlSWQgPSByZXF1ZXN0LnBhcmFtcy5pbnN0YW5jZUlkOwogICAgICBjb25zdCByZW5kZXJDb25maWcgPSByZXF1ZXN0LnBhcmFtcy5yZW5kZXJDb25maWc7CiAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzTWFwLmdldChpbnN0YW5jZUlkKTsKICAgICAgaWYgKCFpbnN0YW5jZSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdGFuY2Ugd2l0aCBpZCAke2luc3RhbmNlSWR9IGRvZXMgbm90IGV4aXN0LmApOwogICAgICB9CiAgICAgIGluc3RhbmNlLnNldFJlbmRlckNvbmZpZyhyZW5kZXJDb25maWcpOwogICAgfSwKICAgIHNldFNlZ21lbnQ6IChyZXF1ZXN0KSA9PiB7CiAgICAgIGNvbnN0IGluc3RhbmNlSWQgPSByZXF1ZXN0LnBhcmFtcy5pbnN0YW5jZUlkOwogICAgICBjb25zdCBzZWdtZW50ID0gcmVxdWVzdC5wYXJhbXMuc2VnbWVudDsKICAgICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXNNYXAuZ2V0KGluc3RhbmNlSWQpOwogICAgICBpZiAoIWluc3RhbmNlKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN0YW5jZSB3aXRoIGlkICR7aW5zdGFuY2VJZH0gZG9lcyBub3QgZXhpc3QuYCk7CiAgICAgIH0KICAgICAgaW5zdGFuY2Uuc2V0U2VnbWVudChzZWdtZW50WzBdLCBzZWdtZW50WzFdKTsKICAgIH0sCiAgICBzZXRTcGVlZDogKHJlcXVlc3QpID0+IHsKICAgICAgY29uc3QgaW5zdGFuY2VJZCA9IHJlcXVlc3QucGFyYW1zLmluc3RhbmNlSWQ7CiAgICAgIGNvbnN0IHNwZWVkID0gcmVxdWVzdC5wYXJhbXMuc3BlZWQ7CiAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzTWFwLmdldChpbnN0YW5jZUlkKTsKICAgICAgaWYgKCFpbnN0YW5jZSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdGFuY2Ugd2l0aCBpZCAke2luc3RhbmNlSWR9IGRvZXMgbm90IGV4aXN0LmApOwogICAgICB9CiAgICAgIGluc3RhbmNlLnNldFNwZWVkKHNwZWVkKTsKICAgIH0sCiAgICBzZXRVc2VGcmFtZUludGVycG9sYXRpb246IChyZXF1ZXN0KSA9PiB7CiAgICAgIGNvbnN0IGluc3RhbmNlSWQgPSByZXF1ZXN0LnBhcmFtcy5pbnN0YW5jZUlkOwogICAgICBjb25zdCB1c2VGcmFtZUludGVycG9sYXRpb24gPSByZXF1ZXN0LnBhcmFtcy51c2VGcmFtZUludGVycG9sYXRpb247CiAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzTWFwLmdldChpbnN0YW5jZUlkKTsKICAgICAgaWYgKCFpbnN0YW5jZSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdGFuY2Ugd2l0aCBpZCAke2luc3RhbmNlSWR9IGRvZXMgbm90IGV4aXN0LmApOwogICAgICB9CiAgICAgIGluc3RhbmNlLnNldFVzZUZyYW1lSW50ZXJwb2xhdGlvbih1c2VGcmFtZUludGVycG9sYXRpb24pOwogICAgfSwKICAgIHNldFdhc21Vcmw6IChyZXF1ZXN0KSA9PiB7CiAgICAgIERvdExvdHRpZS5zZXRXYXNtVXJsKHJlcXVlc3QucGFyYW1zLnVybCk7CiAgICB9LAogICAgc3RvcDogKHJlcXVlc3QpID0+IHsKICAgICAgY29uc3QgaW5zdGFuY2VJZCA9IHJlcXVlc3QucGFyYW1zLmluc3RhbmNlSWQ7CiAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzTWFwLmdldChpbnN0YW5jZUlkKTsKICAgICAgaWYgKCFpbnN0YW5jZSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdGFuY2Ugd2l0aCBpZCAke2luc3RhbmNlSWR9IGRvZXMgbm90IGV4aXN0LmApOwogICAgICB9CiAgICAgIGluc3RhbmNlLnN0b3AoKTsKICAgIH0sCiAgICB1bmZyZWV6ZTogKHJlcXVlc3QpID0+IHsKICAgICAgY29uc3QgaW5zdGFuY2VJZCA9IHJlcXVlc3QucGFyYW1zLmluc3RhbmNlSWQ7CiAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzTWFwLmdldChpbnN0YW5jZUlkKTsKICAgICAgaWYgKCFpbnN0YW5jZSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdGFuY2Ugd2l0aCBpZCAke2luc3RhbmNlSWR9IGRvZXMgbm90IGV4aXN0LmApOwogICAgICB9CiAgICAgIGluc3RhbmNlLnVuZnJlZXplKCk7CiAgICB9LAogICAgc2V0Vmlld3BvcnQocmVxdWVzdCkgewogICAgICBjb25zdCBpbnN0YW5jZUlkID0gcmVxdWVzdC5wYXJhbXMuaW5zdGFuY2VJZDsKICAgICAgY29uc3QgeCA9IHJlcXVlc3QucGFyYW1zLng7CiAgICAgIGNvbnN0IHkgPSByZXF1ZXN0LnBhcmFtcy55OwogICAgICBjb25zdCB3aWR0aCA9IHJlcXVlc3QucGFyYW1zLndpZHRoOwogICAgICBjb25zdCBoZWlnaHQgPSByZXF1ZXN0LnBhcmFtcy5oZWlnaHQ7CiAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzTWFwLmdldChpbnN0YW5jZUlkKTsKICAgICAgaWYgKCFpbnN0YW5jZSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdGFuY2Ugd2l0aCBpZCAke2luc3RhbmNlSWR9IGRvZXMgbm90IGV4aXN0LmApOwogICAgICB9CiAgICAgIHJldHVybiBpbnN0YW5jZS5zZXRWaWV3cG9ydCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTsKICAgIH0sCiAgICBzZXRNYXJrZXIocmVxdWVzdCkgewogICAgICBjb25zdCBpbnN0YW5jZUlkID0gcmVxdWVzdC5wYXJhbXMuaW5zdGFuY2VJZDsKICAgICAgY29uc3QgbWFya2VyID0gcmVxdWVzdC5wYXJhbXMubWFya2VyOwogICAgICBjb25zdCBpbnN0YW5jZSA9IGluc3RhbmNlc01hcC5nZXQoaW5zdGFuY2VJZCk7CiAgICAgIGlmICghaW5zdGFuY2UpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3RhbmNlIHdpdGggaWQgJHtpbnN0YW5jZUlkfSBkb2VzIG5vdCBleGlzdC5gKTsKICAgICAgfQogICAgICBpbnN0YW5jZS5zZXRNYXJrZXIobWFya2VyKTsKICAgICAgcmV0dXJuIHsKICAgICAgICBzdWNjZXNzOiB0cnVlCiAgICAgIH07CiAgICB9LAogICAgc2V0TG9vcChyZXF1ZXN0KSB7CiAgICAgIGNvbnN0IGluc3RhbmNlSWQgPSByZXF1ZXN0LnBhcmFtcy5pbnN0YW5jZUlkOwogICAgICBjb25zdCBsb29wID0gcmVxdWVzdC5wYXJhbXMubG9vcDsKICAgICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXNNYXAuZ2V0KGluc3RhbmNlSWQpOwogICAgICBpZiAoIWluc3RhbmNlKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN0YW5jZSB3aXRoIGlkICR7aW5zdGFuY2VJZH0gZG9lcyBub3QgZXhpc3QuYCk7CiAgICAgIH0KICAgICAgaW5zdGFuY2Uuc2V0TG9vcChsb29wKTsKICAgICAgcmV0dXJuIHsKICAgICAgICBzdWNjZXNzOiB0cnVlCiAgICAgIH07CiAgICB9CiAgfTsKICBmdW5jdGlvbiBleGVjdXRlQ29tbWFuZChycGNSZXF1ZXN0KSB7CiAgICBjb25zdCBtZXRob2QgPSBycGNSZXF1ZXN0Lm1ldGhvZDsKICAgIGlmICh0eXBlb2YgY29tbWFuZHNbbWV0aG9kXSA9PT0gImZ1bmN0aW9uIikgewogICAgICByZXR1cm4gY29tbWFuZHNbbWV0aG9kXShycGNSZXF1ZXN0KTsKICAgIH0gZWxzZSB7CiAgICAgIHRocm93IG5ldyBFcnJvcihgTWV0aG9kICR7bWV0aG9kfSBpcyBub3QgaW1wbGVtZW50ZWQgaW4gY29tbWFuZHMuYCk7CiAgICB9CiAgfQogIHNlbGYub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7CiAgICB0cnkgewogICAgICBjb25zdCByZXN1bHQgPSBleGVjdXRlQ29tbWFuZChldmVudC5kYXRhKTsKICAgICAgY29uc3QgcmVzcG9uc2UgPSB7CiAgICAgICAgaWQ6IGV2ZW50LmRhdGEuaWQsCiAgICAgICAgbWV0aG9kOiBldmVudC5kYXRhLm1ldGhvZCwKICAgICAgICByZXN1bHQKICAgICAgfTsKICAgICAgc2VsZi5wb3N0TWVzc2FnZShyZXNwb25zZSk7CiAgICB9IGNhdGNoIChlcnJvcikgewogICAgICBjb25zdCBlcnJvclJlc3BvbnNlID0gewogICAgICAgIGlkOiBldmVudC5kYXRhLmlkLAogICAgICAgIG1ldGhvZDogZXZlbnQuZGF0YS5tZXRob2QsCiAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UKICAgICAgfTsKICAgICAgc2VsZi5wb3N0TWVzc2FnZShlcnJvclJlc3BvbnNlKTsKICAgIH0KICB9OwogIHZhciBkdW1teSA9ICIiOwogIHZhciBkb3Rsb3R0aWVfd29ya2VyX2RlZmF1bHQgPSBkdW1teTsKfSkoKTsK",
        { type: "classic" },
      );
    }
  },
  Iq = class {
    constructor() {
      (kt(this, "_workers", new Map()),
        kt(this, "_animationWorkerMap", new Map()));
    }
    getWorker(n) {
      return (
        this._workers.has(n) || this._workers.set(n, new Cq()),
        this._workers.get(n)
      );
    }
    assignAnimationToWorker(n, e) {
      this._animationWorkerMap.set(n, e);
    }
    unassignAnimationFromWorker(n) {
      this._animationWorkerMap.delete(n);
    }
    sendMessage(n, e, t) {
      this.getWorker(n).postMessage(e, t || []);
    }
    terminateWorker(n) {
      let e = this._workers.get(n);
      e && (e.terminate(), this._workers.delete(n));
    }
  };
function Bx(n) {
  if (n instanceof OffscreenCanvas) return { width: n.width, height: n.height };
  let { height: e, width: t } = n.getBoundingClientRect();
  return {
    width: t * window.devicePixelRatio,
    height: e * window.devicePixelRatio,
  };
}
function Px() {
  return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
}
var Nx = class wc {
  constructor(e) {
    (kt(this, "_eventManager", new DL()),
      kt(this, "_id"),
      kt(this, "_worker"),
      kt(this, "_canvas"),
      kt(this, "_dotLottieInstanceState", {
        markers: [],
        autoplay: !1,
        backgroundColor: "",
        currentFrame: 0,
        duration: 0,
        loop: !1,
        mode: "forward",
        segment: [0, 0],
        segmentDuration: 0,
        speed: 1,
        totalFrames: 0,
        isLoaded: !1,
        isPlaying: !1,
        isPaused: !1,
        isStopped: !0,
        isFrozen: !1,
        useFrameInterpolation: !1,
        renderConfig: { devicePixelRatio: window.devicePixelRatio },
        activeAnimationId: "",
        activeThemeId: "",
        layout: void 0,
        marker: void 0,
        isReady: !1,
        manifest: null,
      }),
      kt(this, "_created", !1),
      kt(this, "_pointerUpMethod"),
      kt(this, "_pointerDownMethod"),
      kt(this, "_pointerMoveMethod"),
      kt(this, "_pointerEnterMethod"),
      kt(this, "_pointerExitMethod"),
      kt(this, "_onCompleteMethod"),
      (this._canvas = e.canvas),
      (this._id = `dotlottie-${Px()}`));
    let t = e.workerId || "defaultWorker";
    ((this._worker = wc._workerManager.getWorker(t)),
      wc._workerManager.assignAnimationToWorker(this._id, t),
      wc._wasmUrl && this._sendMessage("setWasmUrl", { url: wc._wasmUrl }),
      this._create(e),
      this._worker.addEventListener(
        "message",
        this._handleWorkerEvent.bind(this),
      ),
      (this._pointerUpMethod = this._onPointerUp.bind(this)),
      (this._pointerDownMethod = this._onPointerDown.bind(this)),
      (this._pointerMoveMethod = this._onPointerMove.bind(this)),
      (this._pointerEnterMethod = this._onPointerEnter.bind(this)),
      (this._pointerExitMethod = this._onPointerLeave.bind(this)),
      (this._onCompleteMethod = this._onComplete.bind(this)));
  }
  async _handleWorkerEvent(e) {
    let t = e.data;
    t.id ||
      (t.method === "onLoad" &&
        t.result.instanceId === this._id &&
        (await this._updateDotLottieInstanceState(),
        this._eventManager.dispatch(t.result.event)),
      t.method === "onComplete" &&
        t.result.instanceId === this._id &&
        (await this._updateDotLottieInstanceState(),
        this._eventManager.dispatch(t.result.event)),
      t.method === "onDestroy" &&
        t.result.instanceId === this._id &&
        this._eventManager.dispatch(t.result.event),
      t.method === "onUnfreeze" &&
        t.result.instanceId === this._id &&
        (await this._updateDotLottieInstanceState(),
        (this._dotLottieInstanceState.isFrozen = !1),
        this._eventManager.dispatch(t.result.event)),
      t.method === "onFrame" &&
        t.result.instanceId === this._id &&
        ((this._dotLottieInstanceState.currentFrame =
          t.result.event.currentFrame),
        this._eventManager.dispatch(t.result.event)),
      t.method === "onRender" &&
        t.result.instanceId === this._id &&
        this._eventManager.dispatch(t.result.event),
      t.method === "onFreeze" &&
        t.result.instanceId === this._id &&
        (await this._updateDotLottieInstanceState(),
        this._eventManager.dispatch(t.result.event)),
      t.method === "onPause" &&
        t.result.instanceId === this._id &&
        (await this._updateDotLottieInstanceState(),
        this._eventManager.dispatch(t.result.event)),
      t.method === "onPlay" &&
        t.result.instanceId === this._id &&
        (await this._updateDotLottieInstanceState(),
        this._eventManager.dispatch(t.result.event)),
      t.method === "onStop" &&
        t.result.instanceId === this._id &&
        (await this._updateDotLottieInstanceState(),
        this._eventManager.dispatch(t.result.event)),
      t.method === "onLoadError" &&
        t.result.instanceId === this._id &&
        (await this._updateDotLottieInstanceState(),
        this._eventManager.dispatch(t.result.event)),
      t.method === "onReady" &&
        t.result.instanceId === this._id &&
        (await this._updateDotLottieInstanceState(),
        this._eventManager.dispatch(t.result.event)));
  }
  async _create(e) {
    let t;
    this._canvas instanceof HTMLCanvasElement
      ? (t = this._canvas.transferControlToOffscreen())
      : (t = this._canvas);
    let { instanceId: i } = await this._sendMessage(
      "create",
      {
        instanceId: this._id,
        config: { ...e, canvas: t },
        ...Bx(this._canvas),
      },
      [t],
    );
    if (i !== this._id) throw new Error("Instance ID mismatch");
    ((this._created = !0), await this._updateDotLottieInstanceState());
  }
  get isLoaded() {
    return this._dotLottieInstanceState.isLoaded;
  }
  get isPlaying() {
    return this._dotLottieInstanceState.isPlaying;
  }
  get isPaused() {
    return this._dotLottieInstanceState.isPaused;
  }
  get isStopped() {
    return this._dotLottieInstanceState.isStopped;
  }
  get currentFrame() {
    return this._dotLottieInstanceState.currentFrame;
  }
  get isFrozen() {
    return this._dotLottieInstanceState.isFrozen;
  }
  get segmentDuration() {
    return this._dotLottieInstanceState.segmentDuration;
  }
  get totalFrames() {
    return this._dotLottieInstanceState.totalFrames;
  }
  get segment() {
    return this._dotLottieInstanceState.segment;
  }
  get speed() {
    return this._dotLottieInstanceState.speed;
  }
  get duration() {
    return this._dotLottieInstanceState.duration;
  }
  get isReady() {
    return this._dotLottieInstanceState.isReady;
  }
  get mode() {
    return this._dotLottieInstanceState.mode;
  }
  get canvas() {
    return this._canvas;
  }
  get autoplay() {
    return this._dotLottieInstanceState.autoplay;
  }
  get backgroundColor() {
    return this._dotLottieInstanceState.backgroundColor;
  }
  get loop() {
    return this._dotLottieInstanceState.loop;
  }
  get useFrameInterpolation() {
    return this._dotLottieInstanceState.useFrameInterpolation;
  }
  get renderConfig() {
    return this._dotLottieInstanceState.renderConfig;
  }
  get manifest() {
    return this._dotLottieInstanceState.manifest;
  }
  get activeAnimationId() {
    return this._dotLottieInstanceState.activeAnimationId;
  }
  get marker() {
    return this._dotLottieInstanceState.marker;
  }
  get activeThemeId() {
    return this._dotLottieInstanceState.activeThemeId;
  }
  get layout() {
    return this._dotLottieInstanceState.layout;
  }
  async play() {
    this._created &&
      (await this._sendMessage("play", { instanceId: this._id }),
      await this._updateDotLottieInstanceState());
  }
  async pause() {
    this._created &&
      (await this._sendMessage("pause", { instanceId: this._id }),
      await this._updateDotLottieInstanceState());
  }
  async stop() {
    this._created &&
      (await this._sendMessage("stop", { instanceId: this._id }),
      await this._updateDotLottieInstanceState());
  }
  async setSpeed(e) {
    this._created &&
      (await this._sendMessage("setSpeed", { instanceId: this._id, speed: e }),
      await this._updateDotLottieInstanceState());
  }
  async setMode(e) {
    this._created &&
      (await this._sendMessage("setMode", { instanceId: this._id, mode: e }),
      await this._updateDotLottieInstanceState());
  }
  async setFrame(e) {
    this._created &&
      (await this._sendMessage("setFrame", { frame: e, instanceId: this._id }),
      await this._updateDotLottieInstanceState());
  }
  async setSegment(e, t) {
    this._created &&
      (await this._sendMessage("setSegment", {
        instanceId: this._id,
        segment: [e, t],
      }),
      await this._updateDotLottieInstanceState());
  }
  async setRenderConfig(e) {
    this._created &&
      (await this._sendMessage("setRenderConfig", {
        instanceId: this._id,
        renderConfig: e,
      }),
      await this._updateDotLottieInstanceState());
  }
  async setUseFrameInterpolation(e) {
    this._created &&
      (await this._sendMessage("setUseFrameInterpolation", {
        instanceId: this._id,
        useFrameInterpolation: e,
      }),
      await this._updateDotLottieInstanceState());
  }
  async loadTheme(e) {
    if (!this._created) return !1;
    let t = this._sendMessage("loadTheme", {
      instanceId: this._id,
      themeId: e,
    });
    return (await this._updateDotLottieInstanceState(), t);
  }
  async load(e) {
    this._created &&
      (await this._sendMessage("load", { config: e, instanceId: this._id }),
      await this._updateDotLottieInstanceState());
  }
  async setLoop(e) {
    this._created &&
      (await this._sendMessage("setLoop", { instanceId: this._id, loop: e }),
      await this._updateDotLottieInstanceState());
  }
  async resize() {
    if (!this._created) return;
    let { height: e, width: t } = Bx(this._canvas);
    ((this._canvas.width = t),
      (this._canvas.height = e),
      await this._sendMessage("resize", {
        height: e,
        instanceId: this._id,
        width: t,
      }),
      await this._updateDotLottieInstanceState());
  }
  async destroy() {
    this._created &&
      ((this._created = !1),
      await this._sendMessage("destroy", { instanceId: this._id }),
      this._cleanupStateMachineListeners(),
      wc._workerManager.unassignAnimationFromWorker(this._id),
      this._eventManager.removeAllEventListeners());
  }
  async freeze() {
    this._created &&
      (await this._sendMessage("freeze", { instanceId: this._id }),
      await this._updateDotLottieInstanceState());
  }
  async unfreeze() {
    this._created &&
      (await this._sendMessage("unfreeze", { instanceId: this._id }),
      await this._updateDotLottieInstanceState());
  }
  async setBackgroundColor(e) {
    this._created &&
      (await this._sendMessage("setBackgroundColor", {
        instanceId: this._id,
        backgroundColor: e,
      }),
      await this._updateDotLottieInstanceState());
  }
  async loadAnimation(e) {
    this._created &&
      (await this._sendMessage("loadAnimation", {
        animationId: e,
        instanceId: this._id,
      }),
      await this._updateDotLottieInstanceState());
  }
  async setLayout(e) {
    this._created &&
      (await this._sendMessage("setLayout", {
        instanceId: this._id,
        layout: e,
      }),
      await this._updateDotLottieInstanceState());
  }
  async _updateDotLottieInstanceState() {
    if (!this._created) return;
    let e = await this._sendMessage("getDotLottieInstanceState", {
      instanceId: this._id,
    });
    this._dotLottieInstanceState = e.state;
  }
  markers() {
    return this._dotLottieInstanceState.markers;
  }
  async setMarker(e) {
    this._created &&
      (await this._sendMessage("setMarker", {
        instanceId: this._id,
        marker: e,
      }),
      await this._updateDotLottieInstanceState());
  }
  async loadThemeData(e) {
    if (!this._created) return !1;
    let t = await this._sendMessage("loadThemeData", {
      instanceId: this._id,
      themeData: e,
    });
    return (await this._updateDotLottieInstanceState(), t);
  }
  async setViewport(e, t, i, r) {
    return this._created
      ? this._sendMessage("setViewport", {
          x: e,
          y: t,
          width: i,
          height: r,
          instanceId: this._id,
        })
      : !1;
  }
  async _sendMessage(e, t, i) {
    let r = { id: `dotlottie-request-${Px()}`, method: e, params: t };
    return (
      this._worker.postMessage(r, i || []),
      new Promise((s, o) => {
        let a = (l) => {
          let c = l.data;
          c.id === r.id &&
            (this._worker.removeEventListener("message", a),
            c.error
              ? o(new Error(`Failed to execute method ${e}: ${c.error}`))
              : s(c.result));
        };
        this._worker.addEventListener("message", a);
      })
    );
  }
  addEventListener(e, t) {
    this._eventManager.addEventListener(e, t);
  }
  removeEventListener(e, t) {
    this._eventManager.removeEventListener(e, t);
  }
  static setWasmUrl(e) {
    wc._wasmUrl = e;
  }
  async loadStateMachine(e) {
    if (!this._created) return !1;
    let t = await this._sendMessage("loadStateMachine", {
      instanceId: this._id,
      stateMachineId: e,
    });
    return (await this._updateDotLottieInstanceState(), t);
  }
  async loadStateMachineData(e) {
    if (!this._created) return !1;
    let t = await this._sendMessage("loadStateMachineData", {
      instanceId: this._id,
      stateMachineData: e,
    });
    return (await this._updateDotLottieInstanceState(), t);
  }
  async startStateMachine() {
    if (!this._created) return !1;
    this._setupStateMachineListeners();
    let e = await this._sendMessage("startStateMachine", {
      instanceId: this._id,
    });
    return (await this._updateDotLottieInstanceState(), e);
  }
  async stopStateMachine() {
    return this._created
      ? (this._cleanupStateMachineListeners(),
        this._sendMessage("stopStateMachine", { instanceId: this._id }))
      : !1;
  }
  async postStateMachineEvent(e) {
    return this._created
      ? this._sendMessage("postStateMachineEvent", {
          event: e,
          instanceId: this._id,
        })
      : 1;
  }
  async getStateMachineListeners() {
    return this._created
      ? this._sendMessage("getStateMachineListeners", { instanceId: this._id })
      : [];
  }
  _getPointerPosition(e) {
    let t = this._canvas.getBoundingClientRect(),
      i = this._canvas.width / t.width,
      r = this._canvas.height / t.height,
      s =
        this._dotLottieInstanceState.renderConfig.devicePixelRatio ||
        window.devicePixelRatio ||
        1,
      o = ((e.clientX - t.left) * i) / s,
      a = ((e.clientY - t.top) * r) / s;
    return { x: o, y: a };
  }
  _onPointerUp(e) {
    let { x: t, y: i } = this._getPointerPosition(e);
    this.postStateMachineEvent(`OnPointerUp: ${t} ${i}`);
  }
  _onPointerDown(e) {
    let { x: t, y: i } = this._getPointerPosition(e);
    this.postStateMachineEvent(`OnPointerDown: ${t} ${i}`);
  }
  _onPointerMove(e) {
    let { x: t, y: i } = this._getPointerPosition(e);
    this.postStateMachineEvent(`OnPointerMove: ${t} ${i}`);
  }
  _onPointerEnter(e) {
    let { x: t, y: i } = this._getPointerPosition(e);
    this.postStateMachineEvent(`OnPointerEnter: ${t} ${i}`);
  }
  _onPointerLeave(e) {
    let { x: t, y: i } = this._getPointerPosition(e);
    this.postStateMachineEvent(`OnPointerExit: ${t} ${i}`);
  }
  _onComplete() {
    this.postStateMachineEvent("OnComplete");
  }
  async _setupStateMachineListeners() {
    if (Gc && this._canvas instanceof HTMLCanvasElement && this.isLoaded) {
      let e = await this._sendMessage("getStateMachineListeners", {
        instanceId: this._id,
      });
      (e.includes("PointerUp") &&
        this._canvas.addEventListener("pointerup", this._pointerUpMethod),
        e.includes("PointerDown") &&
          this._canvas.addEventListener("pointerdown", this._pointerDownMethod),
        e.includes("PointerMove") &&
          this._canvas.addEventListener("pointermove", this._pointerMoveMethod),
        e.includes("PointerEnter") &&
          this._canvas.addEventListener(
            "pointerenter",
            this._pointerEnterMethod,
          ),
        e.includes("PointerExit") &&
          this._canvas.addEventListener(
            "pointerleave",
            this._pointerExitMethod,
          ),
        e.includes("Complete") &&
          this.addEventListener("complete", this._onCompleteMethod));
    }
  }
  _cleanupStateMachineListeners() {
    Gc &&
      this._canvas instanceof HTMLCanvasElement &&
      (this._canvas.removeEventListener("pointerup", this._pointerUpMethod),
      this._canvas.removeEventListener("pointerdown", this._pointerDownMethod),
      this._canvas.removeEventListener("pointermove", this._pointerMoveMethod),
      this._canvas.removeEventListener(
        "pointerenter",
        this._pointerEnterMethod,
      ),
      this._canvas.removeEventListener("pointerleave", this._pointerExitMethod),
      this.removeEventListener("complete", this._onCompleteMethod));
  }
};
(kt(Nx, "_workerManager", new Iq()), kt(Nx, "_wasmUrl", ""));
const Aq = xt("<br>"),
  yq = (n) => {
    const [e, t] = Dr(n, ["children", "tag", "isTriggered", "ref", "spacing"]),
      i = Dn(!1);
    return (
      Ct(() => {
        e.isTriggered && i(!0);
      }),
      G(
        $.Generic,
        jn(
          {
            get as() {
              return e.tag ?? "div";
            },
            ref(r) {
              const s = e.ref;
              typeof s == "function" ? s(r) : (e.ref = r);
            },
            get css() {
              return {
                "span > span": { display: "inline-block" },
                "> span": {
                  paddingBottom: `${e.spacing ?? 6}rem`,
                  marginBottom: `-${e.spacing ?? 6}rem`,
                },
              };
            },
          },
          t,
          {
            get children() {
              return G(Yn, {
                get each() {
                  return e.children
                    .replace(
                      `
`,
                      `

`,
                    )
                    .split(/[ \n]/);
                },
                children: (r, s) =>
                  r === ""
                    ? ft(Aq)
                    : [
                        G($.Generic, {
                          css: { display: "inline-flex", overflow: "hidden" },
                          as: "span",
                          get children() {
                            return G($.Generic, {
                              css: { willChange: "transform" },
                              as: "span",
                              get style() {
                                return {
                                  transform: i()
                                    ? "skewY(0deg) translateY(0)"
                                    : "skewY(10deg) translateY(115%)",
                                  transition: `transform 1000ms cubic-bezier(0.25, 0, 0.1, 1) ${s() * 0.04}s, opacity 0.3s ease ${s() * 0.04}s`,
                                  opacity: i() ? 1 : 0,
                                };
                              },
                              children: r,
                            });
                          },
                        }),
                        " ",
                      ],
              });
            },
          },
        ),
      )
    );
  },
  Zc = Dn(null),
  iI = (n) => {
    let e = !1;
    dn(() => {
      e && Zc(null);
    });
    function t(i) {
      n.isDisabled ||
        n.exclude?.().includes(i.target) ||
        (Zc({ type: n.type, isDraggable: n.isDraggable ?? !1 }), (e = !0));
    }
    return (
      Ct(() => {
        n.override === !1 && (Zc(null), (e = !1));
      }),
      G(n.children, {
        onMouseEnter: t,
        onMouseMove: t,
        onMouseLeave: () => {
          (Zc(null), (e = !1));
        },
      })
    );
  },
  _q = xt(
    '<svg width="144" height="145" viewBox="0 0 144 145" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M72 144.002C32.2987 144.002 0 111.703 0 72.002C0 32.3007 32.2987 0.00195312 72 0.00195312C111.701 0.00195312 144 32.3007 144 72.002C144 111.703 111.701 144.002 72 144.002ZM72 24.002C45.5325 24.002 24 45.5345 24 72.002C24 98.4695 45.5325 120.002 72 120.002C98.4675 120.002 120 98.4695 120 72.002C120 45.5345 98.4675 24.002 72 24.002Z" fill="white" style="fill:white;fill:white;fill-opacity:1;">',
  ),
  bq = (n = {}) =>
    (() => {
      const e = ft(_q);
      return (fn(e, n, !0, !0), An(), e);
    })(),
  Wd = (n) => (
    Ct(() => {
      for (const [e, t] of Object.entries(n))
        if (e.startsWith("on")) {
          const i = e.slice(2).toLowerCase();
          let r = t,
            s = {};
          (Array.isArray(t) && ([r, s] = t),
            window.addEventListener(i, r, s),
            dn(() => {
              window.removeEventListener(i, r, s);
            }));
        }
    }),
    null
  ),
  vq = xt(
    '<svg width="130" height="130" viewBox="0 0 130 130" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M60.973 0.501709L59.7505 0.527959V0.531709L59.9605 9.68546L68.1317 9.49796L68.1055 8.42546L61.1567 8.58296L60.973 0.501709ZM48.402 2.42938C50.7045 1.80688 52.6732 2.48938 53.7719 4.05313L52.9282 4.83688C52.0094 3.53938 50.5244 2.99188 48.7019 3.48313C46.3994 4.10563 45.1094 5.97688 45.6757 8.05813C46.242 10.1394 48.297 11.0994 50.5994 10.4769C52.422 9.98188 53.4232 8.75938 53.562 7.17688L54.687 7.42813C54.5294 9.33313 53.1757 10.9156 50.8732 11.5419C47.9332 12.3406 45.1994 11.0319 44.4832 8.38438C43.7669 5.73688 45.4657 3.22813 48.4057 2.43313L48.402 2.42938ZM40.085 15.4795L41.1837 14.9395L37.1525 6.71948L36.0537 7.25948L40.085 15.4795ZM32.31 20.2419L27.4668 13.7718L30.9263 11.1819L30.285 10.3231L22.3838 16.2369L23.025 17.0956L26.4863 14.5044L31.3313 20.9769L32.31 20.2419ZM104.513 25.9155L105.308 26.8493V26.8455L108.229 24.3593L110.791 27.3705L109.538 31.818L110.446 32.8868L111.706 28.3493C112.838 29.328 114.154 29.478 115.272 28.5293C116.603 27.3968 116.431 25.7993 115.193 24.3443L111.484 19.983L104.513 25.9155ZM114.499 27.618C113.712 28.2855 112.756 28.0455 111.912 27.0555L109.036 23.6768L111.473 21.603L114.349 24.9818C115.193 25.9718 115.287 26.9468 114.499 27.618ZM123.864 40.7054L124.824 40.2292V40.2254L121.036 32.6279L112.842 36.7117L116.63 44.3092L117.59 43.8329L114.335 37.3079L117.129 35.9129L120.057 41.7892L121.017 41.3129L118.089 35.4367L120.609 34.1804L123.864 40.7054ZM128.269 52.0042L120.334 58.6304L120.06 57.3592L122.262 55.5292L121.062 49.9567L118.302 49.1804L118.028 47.9092L127.992 50.6917L128.273 52.0004L128.269 52.0042ZM122.224 50.2792L123.188 54.7529L126.957 51.6067L122.224 50.2792ZM129.511 67.8479L129.709 63.3254L120.563 62.9279L120.364 67.4504C120.229 70.5179 121.924 72.6366 124.714 72.7566C127.504 72.8766 129.376 70.9191 129.511 67.8479ZM124.771 71.5191C122.644 71.4291 121.321 69.8654 121.426 67.4954H121.422L121.568 64.1691L128.599 64.4766L128.457 67.7878C128.352 70.1691 126.912 71.6129 124.771 71.5191ZM123.443 92.5116L113.119 93.0629L113.663 91.8816L116.52 91.7354L118.898 86.5566L117.15 84.2804L117.694 83.0991L124.005 91.2966L123.447 92.5116H123.443ZM117.728 91.6716L119.636 87.5136L122.629 91.4091L117.728 91.6716ZM110.705 96.6405L109.932 97.593H109.936L112.917 100.008L110.427 103.079L105.822 102.663L104.941 103.754L109.632 104.159C108.878 105.453 108.972 106.777 110.112 107.699C111.47 108.798 113.007 108.337 114.211 106.852L117.815 102.404L110.705 96.6405ZM110.866 106.769C110.063 106.117 110.123 105.131 110.941 104.122V104.126L113.735 100.679L116.221 102.693L113.427 106.139C112.61 107.148 111.668 107.422 110.866 106.769ZM102.72 116.103L97.8525 109.649L98.8313 108.91L103.699 115.364L107.149 112.762L107.794 113.617L99.915 119.56L99.2701 118.705L102.72 116.103ZM90.0911 114.434L88.9961 114.978L93.0536 123.183L94.1486 122.639L90.0911 114.434ZM81.8306 127.507C79.5319 128.14 77.5631 127.465 76.4569 125.905L77.2969 125.118C78.2194 126.412 79.7044 126.955 81.5231 126.453C83.8219 125.819 85.1044 123.948 84.5344 121.87C83.9644 119.793 81.9019 118.84 79.6031 119.47C77.7844 119.969 76.7869 121.199 76.6519 122.782L75.5269 122.534C75.6769 120.629 77.0269 119.043 79.3219 118.409C82.2581 117.599 84.9956 118.897 85.7231 121.54C86.4506 124.184 84.7631 126.697 81.8231 127.507H81.8306ZM69.2596 129.487L70.482 129.453L70.2383 120.307L62.0708 120.524L62.1008 121.593L69.0458 121.409L69.2596 129.487ZM47.2363 127.263L47.4576 126.217L54.5938 127.721L55.1751 124.964L48.7513 123.611L48.9726 122.564L55.3963 123.918L56.0413 120.862L48.9051 119.358L49.1263 118.312L57.4326 120.063L55.5426 129.018L47.2363 127.267V127.263ZM35.6853 114.093C34.7666 113.545 33.6341 113.8 33.0566 114.764C32.4716 115.735 32.7828 116.857 33.7016 117.408C34.6316 117.967 35.7903 117.723 36.3716 116.748C36.9453 115.784 36.6153 114.648 35.6853 114.093ZM24.5554 103.012L25.3467 103.946L18.3529 109.852L14.6592 105.479C13.4254 104.017 13.2604 102.423 14.5954 101.294C15.7167 100.349 17.0329 100.503 18.1617 101.486L19.4367 96.9518L20.3404 98.0243L19.0729 102.468L21.6229 105.487L24.5554 103.012ZM17.9517 102.783C17.1117 101.789 16.1554 101.546 15.3679 102.213C14.5804 102.881 14.6704 103.856 15.5067 104.849L18.3717 108.239L20.8167 106.173L17.9517 102.783ZM6.04691 89.0842L5.08691 89.5567L8.84816 97.1692L17.0569 93.1154L13.2957 85.5029L12.3357 85.9792L15.5644 92.5192L12.7632 93.9029L9.85316 88.0154L8.89316 88.4879L11.8032 94.3754L9.27567 95.6242L6.04691 89.0842ZM1.68115 77.7628L9.6424 71.1665L9.9124 72.4378L7.70365 74.2603L8.88115 79.8365L11.6412 80.6203L11.9112 81.8915L1.95865 79.0715L1.68115 77.7628ZM7.71865 79.5103L6.7699 75.0328L2.9899 78.164L7.71865 79.5103ZM0.492226 61.9267L0.282227 66.4492L9.42848 66.8767L9.63848 62.3542C9.78098 59.283 8.09348 57.1642 5.30348 57.033C2.51348 56.9017 0.634726 58.8555 0.492226 61.9267ZM5.24723 58.2705C7.37348 58.368 8.69348 59.9355 8.58098 62.3055L8.42723 65.6317L1.39598 65.3017L1.54973 61.9905C1.66223 59.6092 3.10598 58.1692 5.24723 58.2705ZM6.65658 37.278L16.9841 36.7643L16.4366 37.9455L13.5753 38.0805L11.1791 43.2518L12.9191 45.5318L12.3716 46.713L6.09033 38.4893L6.65283 37.2743L6.65658 37.278ZM10.4441 42.2955L12.3678 38.1405L7.46283 38.3843L10.4441 42.2955ZM19.4116 33.2017L20.1878 32.253H20.1841L17.2103 29.823L19.7116 26.763L24.3128 27.198L25.2016 26.1105L20.5103 25.6868C21.2678 24.393 21.1816 23.0692 20.0453 22.143C18.6916 21.0367 17.1541 21.4905 15.9428 22.9717L12.3203 27.408L19.4116 33.2017ZM19.2878 23.0692C20.0866 23.7255 20.0228 24.708 19.2016 25.7167L16.3928 29.1555L13.9141 27.1305L16.7228 23.6917C17.5441 22.683 18.4891 22.4167 19.2878 23.0692ZM82.9963 2.80062L82.7713 3.84687L75.6388 2.31687L75.0463 5.07312L81.4663 6.45312L81.2413 7.49937L74.8213 6.11937L74.165 9.17562L81.2975 10.7056L81.0725 11.7519L72.77 9.96688L74.6938 1.01562L82.9963 2.80062ZM94.4867 16.0119C95.4055 16.5669 96.5379 16.3119 97.1192 15.3519C97.7042 14.3807 97.4005 13.2594 96.4817 12.7044C95.5555 12.1457 94.3967 12.3857 93.8117 13.3569C93.2304 14.3169 93.5605 15.4532 94.4867 16.0119Z" fill="black" style="fill:black;fill:black;fill-opacity:1;">',
  ),
  xq = (n = {}) =>
    (() => {
      const e = ft(vq);
      return (fn(e, n, !0, !0), An(), e);
    })(),
  wq = xt(
    '<svg width="130" height="130" viewBox="0 0 130 130" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M56.8818 5.60191L56.6006 0.805659L57.8081 0.73441L58.0856 5.49316C58.2093 7.64566 59.3794 8.83816 61.6556 8.70691C63.9319 8.57566 64.9406 7.25191 64.8168 5.09941L64.5394 0.340659L65.7619 0.269409L66.0431 5.06566C66.2044 7.85191 64.7118 9.62566 61.7231 9.80191C58.7193 9.97816 57.0431 8.38816 56.8818 5.60191ZM48.6432 3.62535L50.7948 11.4144L49.6135 11.7406L47.461 3.94812L43.2948 5.09936L43.0098 4.06812L52.5235 1.44312L52.8085 2.47437L48.6432 3.62535ZM35.123 14.5491C36.6268 15.5204 38.4605 15.2541 39.8855 14.5341C41.5018 13.7204 42.3755 12.5391 41.918 11.6279C41.4193 10.6379 40.5455 10.8891 37.9655 11.8604C35.7267 12.7154 34.088 13.1429 33.2968 11.5716C32.5805 10.1504 33.5142 8.37664 35.678 7.28914C37.5792 6.33289 39.488 6.29914 40.6842 7.05289L40.208 8.09164C39.1805 7.46539 37.7105 7.46539 36.113 8.26789C34.4517 9.10414 33.893 10.1841 34.2793 10.9454C34.7143 11.8116 35.5992 11.5791 37.8267 10.7316C40.5267 9.71539 42.0943 9.31039 42.9305 10.9754C43.7443 12.5916 42.5517 14.3916 40.343 15.5054C38.3292 16.5216 36.0868 16.6079 34.6805 15.6591L35.123 14.5529V14.5491ZM24.5791 15.8165L23.844 15.0402L23.8403 15.0365L17.6753 20.8752L23.9716 27.524L30.1366 21.6852L29.4016 20.909L24.1066 25.9228L21.9578 23.654L26.724 19.139L25.989 18.3627L21.2228 22.8777L19.2841 20.8302L24.5791 15.8165ZM110.874 19.2179L106.966 28.7916H106.959L107.863 29.8641L117.973 27.6554L117.136 26.6616L108.301 28.6004L111.718 20.2229L110.874 19.2179ZM112.106 35.778L112.74 36.8242V36.8205L120.566 32.073L119.933 31.0267L112.106 35.778ZM126.283 44.0957L125.296 44.5119L122.469 37.7882L119.87 38.8794L122.416 44.9319L121.43 45.3482L118.884 39.2957L116.004 40.5069L118.831 47.2307L117.845 47.6469L114.553 39.8207L122.99 36.2694L126.283 44.0957ZM121.5 59.6768L128.937 55.8443L128.933 55.8368L128.73 54.5018L120.484 53.0543L127.891 49.0193L127.699 47.7593L119.157 52.473L119.382 53.9355L127.534 55.3605L120.181 59.1443L120.405 60.6068L129.968 62.5643L129.777 61.3155L121.5 59.6768ZM128.51 77.5003C128.067 79.8441 126.593 81.3141 124.707 81.6178L124.37 80.5153C125.937 80.2528 127.077 79.1616 127.43 77.3053C127.872 74.9616 126.755 72.9853 124.64 72.5841C122.525 72.1828 120.758 73.6116 120.316 75.9553C119.963 77.8078 120.627 79.2441 121.988 80.0616L121.272 80.9653C119.626 79.9903 118.797 78.0816 119.24 75.7416C119.806 72.7491 122.176 70.8628 124.868 71.3728C127.561 71.8828 129.076 74.5078 128.51 77.5003ZM113.923 91.6454L124.228 90.7904L124.749 89.5566L118.198 81.5466L117.692 82.7429L119.507 84.9666L117.283 90.2166L114.429 90.4491L113.923 91.6454ZM118.49 90.1191L120.275 85.9041L123.384 89.7141L118.49 90.1191ZM115.279 95.1633L115.279 95.1633L115.144 93.9821C113.457 93.8133 111.526 94.9533 110.232 96.8021C108.814 98.8271 108.616 100.976 110.101 102.015C111.627 103.083 112.816 101.985 114.709 99.8096C116.266 98.0058 116.933 97.3833 117.728 97.9383C118.429 98.4296 118.448 99.6408 117.383 101.167C116.359 102.63 115.062 103.327 113.862 103.263L113.937 104.403C115.343 104.501 117.012 103.563 118.231 101.82C119.618 99.8358 119.603 97.8333 118.298 96.9183C116.858 95.9096 115.613 97.0646 114.049 98.8796C112.238 100.957 111.589 101.595 110.682 100.957C109.846 100.372 110.056 98.9171 111.094 97.4321C112.005 96.1272 113.498 95.021 115.279 95.1633L115.279 95.1671V95.1633ZM106.243 114.888L106.246 114.892L106.243 114.888L106.243 114.888ZM106.243 114.888L105.508 114.115L110.795 109.09L108.853 107.047L104.094 111.569L103.355 110.793L108.114 106.27L105.961 104.005L100.674 109.03L99.9351 108.254L106.089 102.404L112.396 109.038L106.243 114.888ZM94.9579 115.402C93.4541 114.434 91.6204 114.704 90.1954 115.42C88.5791 116.238 87.7054 117.419 88.1666 118.33C88.6654 119.32 89.5391 119.065 92.1191 118.09C94.3579 117.232 95.9966 116.804 96.7916 118.372C97.5116 119.793 96.5779 121.567 94.4141 122.658C92.5129 123.618 90.6041 123.655 89.4079 122.902L89.8841 121.863C90.9116 122.485 92.3854 122.485 93.9791 121.679C95.6404 120.839 96.1954 119.759 95.8091 118.998C95.3704 118.132 94.4891 118.364 92.2616 119.219C89.5616 120.239 87.9941 120.644 87.1579 118.983C86.3404 117.367 87.5329 115.567 89.7379 114.449C91.7516 113.433 93.9941 113.343 95.4004 114.288L94.9616 115.398L94.9579 115.402ZM81.4495 126.356L79.2829 118.571L80.4604 118.241L82.6279 126.029L86.7942 124.871L87.0792 125.902L77.5692 128.546L77.2842 127.514L81.4495 126.356ZM73.2091 124.387L73.4978 129.183L72.2904 129.254L72.0053 124.496C71.8778 122.347 70.7079 121.151 68.4279 121.286C66.1479 121.421 65.1428 122.748 65.2703 124.897L65.5553 129.656L64.3328 129.73L64.0441 124.934C63.8791 122.148 65.3679 120.371 68.3566 120.194C71.3604 120.014 73.0366 121.601 73.2054 124.387H73.2091ZM54.9915 128.808L59.4652 129.506L60.8752 120.461L56.4015 119.763C53.364 119.291 51.0765 120.738 50.6452 123.498C50.214 126.258 51.954 128.336 54.9915 128.808ZM51.8677 123.689C52.1977 121.586 53.8965 120.446 56.2402 120.809V120.806L59.529 121.319L58.4452 128.276L55.1677 127.766C52.8127 127.398 51.5377 125.804 51.8677 123.689ZM39.0877 124.293L37.6777 123.775L43.9327 120.577L45.309 116.83L46.4452 117.247L45.069 120.993L47.7615 127.484L46.3365 126.959L44.1652 121.679L39.0877 124.293ZM32.1952 111.832C31.3214 111.217 30.1702 111.389 29.5252 112.308H29.5214C28.8727 113.238 29.0977 114.378 29.9752 114.993C30.8639 115.615 32.0339 115.458 32.6864 114.528C33.3314 113.609 33.0839 112.454 32.1952 111.832ZM22.9709 101.141L22.9699 101.143L22.0709 100.068L11.9609 102.258L12.7972 103.256L21.6359 101.332L18.2047 109.702L19.0484 110.707L22.9699 101.143L22.9709 101.144V101.141ZM17.8445 94.1432L17.2107 93.0969L9.37695 97.8294L10.0107 98.8757L17.8445 94.1432ZM3.68393 85.8068L4.67018 85.3943L7.48643 92.1218L10.0852 91.0343L7.54642 84.978L8.53268 84.5655L11.0714 90.6218L13.9514 89.4143L11.1352 82.6868L12.1214 82.2743L15.4027 90.1043L6.96143 93.6405L3.68018 85.8105L3.68393 85.8068ZM8.4875 70.2407L1.04751 74.0657H1.05124L1.25375 75.4007L9.49625 76.8595L2.08624 80.8832L2.2775 82.1432L10.8238 77.4445L10.6025 75.9819L2.45376 74.5495L9.81126 70.7769L9.59 69.3145L0.03125 67.3457L0.21875 68.5945L8.4875 70.2407ZM1.51318 52.3944C1.96318 50.0544 3.43691 48.5844 5.32316 48.2844L5.65692 49.3869C4.08942 49.6457 2.94567 50.7369 2.58942 52.5894C2.13942 54.9294 3.25317 56.9094 5.37192 57.3144C7.48692 57.7194 9.25316 56.2944 9.70316 53.9507C10.0594 52.0982 9.39941 50.6619 8.03816 49.8407L8.75442 48.9407C10.3969 49.9157 11.2257 51.8282 10.7757 54.1682C10.2019 57.1607 7.83192 59.0432 5.13942 58.5257C2.44692 58.0082 0.939425 55.3832 1.51318 52.3944ZM16.1259 38.2755L5.82091 39.1118L5.2959 40.3418L11.8284 48.363L12.3384 47.1668L10.5272 44.9393L12.7622 39.6968L15.6159 39.4718L16.1259 38.2755ZM11.5584 39.7943L9.76591 44.0055L6.66466 40.1918L11.5584 39.7943ZM14.7728 34.7579C16.554 34.9041 18.0465 33.7979 18.9615 32.4966C20.0002 31.0154 20.214 29.5604 19.3778 28.9716C18.4703 28.3341 17.8215 28.9716 16.0065 31.0454C14.439 32.8566 13.194 34.0079 11.754 32.9991C10.449 32.0841 10.4378 30.0816 11.829 28.0979C13.0515 26.3541 14.7202 25.4204 16.1265 25.5216L16.1977 26.6616C14.9977 26.5979 13.7003 27.2916 12.6728 28.7541C11.604 30.2766 11.6228 31.4916 12.324 31.9829C13.119 32.5379 13.7865 31.9191 15.3465 30.1154C17.244 27.9441 18.4365 26.8454 19.959 27.9141C21.4403 28.9529 21.2415 31.1054 19.8203 33.1304C18.5228 34.9791 16.5915 36.1116 14.904 35.9429L14.769 34.7579H14.7728ZM75.1027 1.21053L70.6327 0.509277L69.2114 9.55053L73.6814 10.2518C76.7152 10.728 79.0064 9.28053 79.4414 6.52428C79.8764 3.76803 78.1364 1.68678 75.1027 1.21053ZM78.2227 6.33678C77.8927 8.43678 76.1902 9.57678 73.8464 9.20928L73.8502 9.21303L70.5614 8.69553L71.6527 1.74303L74.9264 2.25678C77.2814 2.62803 78.5564 4.22178 78.2227 6.33678ZM91.0131 5.75194L92.4231 6.27319L86.1606 9.46444L84.7769 13.2069L83.6406 12.7869L85.0244 9.04444L82.3394 2.54944L83.7606 3.07444L85.9281 8.35819L91.0094 5.74819L91.0131 5.75194ZM97.8834 18.2278C98.7609 18.8466 99.9121 18.6741 100.557 17.7553C101.21 16.8291 100.985 15.6853 100.107 15.0703C99.2221 14.4478 98.0484 14.6053 97.3959 15.5316C96.7509 16.4466 96.9984 17.6053 97.8834 18.2278Z" fill="black" style="fill:black;fill:black;fill-opacity:1;">',
  ),
  Sq = (n = {}) =>
    (() => {
      const e = ft(wq);
      return (fn(e, n, !0, !0), An(), e);
    })(),
  Tq = xt(
    '<svg width="130" height="130" viewBox="0 0 130 130" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M68.4094 1.58569L68.0569 9.65944L66.8344 9.60694L67.1869 1.52944L62.8706 1.34194L62.9156 0.273193L72.7744 0.704444L72.7294 1.77319L68.4131 1.58569H68.4094ZM62.0939 3.11197C61.2164 1.41322 59.3601 0.468218 56.9939 0.775718H56.9976C53.9789 1.16947 51.9539 3.42322 52.3064 6.14197C52.6551 8.86072 55.1864 10.5257 58.2089 10.1357C60.5714 9.82822 62.1314 8.44447 62.5439 6.57697L61.4639 6.17572C61.1114 7.72822 59.9526 8.80072 58.0814 9.04447C55.7189 9.34822 53.8101 8.11822 53.5326 5.98072C53.2551 3.84322 54.7851 2.16697 57.1514 1.85947C59.0226 1.61947 60.4176 2.36197 61.1526 3.77197L62.0939 3.11197ZM46.2234 3.19821L53.5546 10.4845L52.3134 10.8745L50.2884 8.85321L44.8546 10.5632L44.3409 13.3832L43.0996 13.7732L44.9484 3.59571L46.2271 3.19446L46.2234 3.19821ZM45.0684 9.37446L49.4334 7.99821L45.9496 4.53696L45.0646 9.37071L45.0684 9.37446ZM40.8237 15.112L37.2162 7.87822L37.2199 7.88197L41.0861 5.95072L40.6061 4.99072L31.7749 9.39697L32.2549 10.357L36.1211 8.42572L39.7286 15.6595L40.8237 15.112ZM35.2319 18.0182L35.2301 18.0196L29.7044 10.7245L28.7707 11.4332L33.2407 17.3357L23.4232 15.4795L22.3882 16.2632L27.9157 23.5607L28.8494 22.852L24.2257 16.7432L34.3694 18.6707L35.2301 18.0196L35.2319 18.022V18.0182ZM23.7798 28.1618C25.8198 25.8818 25.8498 22.8818 23.8061 21.0555V21.0518C21.7623 19.2255 18.7848 19.593 16.7448 21.873C14.7048 24.153 14.6748 27.153 16.7186 28.9793C18.7623 30.8093 21.7398 30.4418 23.7798 28.1618ZM22.9623 27.4343C21.3648 29.2193 19.1485 29.4968 17.5435 28.0605V28.0643C15.9348 26.628 15.9648 24.393 17.5623 22.608C19.1598 20.8193 21.3686 20.553 22.9736 21.9893C24.5786 23.4255 24.5598 25.6455 22.9623 27.4343ZM115.49 29.0806C116.442 27.4231 116.228 25.3531 114.687 23.5306L114.691 23.5269C112.722 21.1981 109.73 20.7219 107.637 22.4919C105.545 24.2619 105.515 27.2919 107.484 29.6206C109.021 31.4431 111.031 31.9981 112.824 31.3344L112.572 30.2094C111.08 30.7569 109.546 30.3631 108.327 28.9231C106.786 27.1044 106.786 24.8319 108.432 23.4406C110.078 22.0494 112.317 22.4244 113.859 24.2469C115.077 25.6869 115.205 27.2619 114.421 28.6456L115.49 29.0806ZM119.533 30.3145L118.918 29.257L111.013 33.8695L115.13 40.927L116.056 40.387L112.554 34.387L119.533 30.3145ZM115.946 43.1395L115.451 42.022L123.821 38.317L124.316 39.4345L115.946 43.1395ZM125.592 51.9857C127.122 50.8419 127.744 48.8544 127.054 46.5744C126.169 43.6607 123.616 42.0369 120.991 42.8319C118.366 43.6269 117.139 46.3982 118.024 49.3119C118.718 51.5957 120.338 52.9007 122.247 53.0019L122.464 51.8694C120.878 51.7757 119.626 50.8082 119.078 49.0044C118.388 46.7207 119.288 44.6357 121.351 44.0132C123.413 43.3907 125.318 44.6244 126.008 46.9044C126.556 48.7082 126.049 50.2082 124.782 51.1644L125.592 51.9857ZM123.958 55.3045L129.519 60.8208L129.718 62.5683L125.24 58.0308L120.662 63.9483L120.474 62.302L124.427 57.2095L122.687 55.4433L119.735 55.777L119.597 54.562L128.694 53.5345L128.833 54.7495L123.954 55.3008L123.958 55.3045ZM127.935 73.5444L119.915 72.5432L120.065 71.3282L128.086 72.3294L128.622 68.0394L129.683 68.1707L128.461 77.9619L127.4 77.8307L127.935 73.5444ZM120.845 87.6184C118.224 86.8197 116.99 84.0822 117.882 81.1572C118.775 78.2322 121.325 76.6497 123.946 77.4484C126.567 78.2472 127.801 80.9809 126.909 83.9097C126.016 86.8347 123.466 88.4172 120.845 87.6184ZM123.586 78.6334C121.524 78.0034 119.634 79.1884 118.932 81.4797C118.235 83.7709 119.15 85.7959 121.209 86.4259C123.271 87.0559 125.157 85.8859 125.859 83.591C126.556 81.2997 125.645 79.2597 123.586 78.6334ZM115.059 101.527C116.934 101.909 118.831 101.051 120.072 99.0144L120.076 99.0069C121.662 96.4081 121.171 93.4194 118.831 91.9906C116.491 90.5656 113.607 91.4919 112.021 94.0944C110.776 96.1269 110.881 98.2081 112.077 99.7006L113.067 99.1081C112.081 97.8631 111.969 96.2844 112.951 94.6756C114.192 92.6431 116.345 91.9269 118.186 93.0481C120.024 94.1731 120.372 96.4156 119.131 98.4519C118.149 100.064 116.694 100.687 115.134 100.376L115.059 101.527ZM105.784 109.323C103.759 107.478 103.819 104.478 105.878 102.217C107.941 99.9556 110.922 99.6181 112.947 101.467C114.972 103.312 114.916 106.312 112.853 108.573C110.791 110.834 107.809 111.172 105.784 109.327V109.323ZM112.114 102.378C110.521 100.927 108.304 101.182 106.688 102.956C105.072 104.729 105.031 106.949 106.624 108.401C108.218 109.852 110.427 109.604 112.039 107.834C113.652 106.064 113.704 103.829 112.111 102.378H112.114ZM95.1982 111.615L94.3281 112.26L99.7881 119.61L100.729 118.908L96.3119 112.961L106.114 114.907L107.157 114.131L101.697 106.781L100.756 107.482L105.327 113.636L95.1982 111.615ZM92.2667 122.377L88.7229 115.109L89.8217 114.573L93.3654 121.841L97.2504 119.947L97.7192 120.911L88.8467 125.238L88.3779 124.274L92.2629 122.381L92.2667 122.377ZM75.9385 119.624L83.2022 126.978H83.206L84.4847 126.588L86.4272 116.429L85.1822 116.808L84.6422 119.624L79.1897 121.286L77.1835 119.246L75.9385 119.624ZM80.041 122.144L84.4172 120.813H84.421L83.491 125.639L80.041 122.144ZM72.4132 129.299C70.0469 129.584 68.1982 128.624 67.3357 126.918L68.2844 126.266C69.0082 127.679 70.3957 128.437 72.2669 128.212C74.6332 127.927 76.1819 126.266 75.9232 124.124C75.6644 121.987 73.7707 120.738 71.4044 121.023C69.5294 121.248 68.3632 122.313 67.9957 123.858L66.9194 123.449C67.3507 121.586 68.9182 120.217 71.2844 119.932C74.3107 119.568 76.8232 121.256 77.1494 123.978C77.4757 126.701 75.4357 128.936 72.4094 129.299H72.4132ZM61.4325 120.315L61.0087 128.388L56.6925 128.16L56.6362 129.228L66.4912 129.746L66.5475 128.677L62.2312 128.448L62.655 120.378L61.4325 120.315ZM52.0554 123.547L50.6642 128.148L49.5055 127.796L50.8854 123.232C51.5079 121.169 50.8254 119.643 48.6392 118.983C46.4529 118.323 45.0504 119.216 44.4279 121.278L43.0479 125.842L41.8779 125.486L43.2692 120.884C44.0792 118.211 46.0892 117.063 48.9579 117.929C51.8379 118.799 52.8654 120.869 52.0554 123.543V123.547ZM39.2787 115.162C40.7 115.882 42.0012 117.206 42.1099 118.991L43.265 118.691C43.1975 116.996 41.7987 115.241 39.7887 114.217C37.5837 113.096 35.4274 113.201 34.6062 114.813C33.7624 116.471 35.0149 117.494 37.4337 119.069C39.4362 120.359 40.145 120.937 39.7062 121.799C39.3162 122.561 38.1162 122.752 36.4587 121.908C34.8687 121.098 33.9987 119.913 33.8937 118.713L32.7725 118.946C32.87 120.356 34.0287 121.874 35.9262 122.842C38.0862 123.941 40.0662 123.648 40.7899 122.227C41.5887 120.656 40.2724 119.587 38.2587 118.289C35.9487 116.786 35.2287 116.235 35.7312 115.244C36.1924 114.337 37.6662 114.341 39.2787 115.162ZM27.1895 110.46C27.8795 109.575 29.0382 109.458 29.882 110.115C30.737 110.782 30.9283 111.948 30.2383 112.833C29.5408 113.73 28.3633 113.831 27.5083 113.163C26.6645 112.503 26.492 111.352 27.1895 110.46ZM14.8475 101.396C13.91 103.061 14.1463 105.131 15.7025 106.938L15.7063 106.942C17.6938 109.252 20.69 109.698 22.7675 107.909C24.845 106.117 24.845 103.091 22.8538 100.781C21.2975 98.9769 19.2838 98.4369 17.4988 99.1194L17.7575 100.241C19.2463 99.6818 20.78 100.057 22.0138 101.486C23.5738 103.289 23.5925 105.562 21.9613 106.968C20.3263 108.378 18.0838 108.022 16.5275 106.214C15.2938 104.786 15.1475 103.211 15.92 101.819L14.8475 101.396ZM11.4128 101.246L10.7866 100.196L17.7316 96.0557L14.1728 90.0857L15.0916 89.5382L19.2766 96.5582L11.4128 101.246ZM14.7571 88.443L14.2508 87.3292L5.91455 91.113L6.42084 92.2267L14.7571 88.443ZM3.11701 83.9996C2.40451 81.7234 3.00826 79.7321 4.53076 78.5734L5.34453 79.3871C4.08453 80.3546 3.59327 81.8584 4.15952 83.6584C4.87202 85.9346 6.78827 87.1496 8.84702 86.5046C10.902 85.8596 11.7832 83.7671 11.0707 81.4946C10.5082 79.6946 9.2445 78.7384 7.65825 78.6634L7.86452 77.5309C9.77327 77.6134 11.4083 78.9071 12.1208 81.1796C13.032 84.0859 11.832 86.8684 9.21826 87.6859C6.60076 88.5034 4.03201 86.9059 3.12076 83.9996H3.11701ZM0.515022 69.7681L6.12878 75.2356H6.13254L1.25754 75.8319L1.40752 77.0469L10.4938 75.9369L10.3438 74.7219L7.39629 75.0819L5.64127 73.3306L9.54878 68.2044L9.34627 66.5581L4.82004 72.5169L0.30127 68.0206L0.515022 69.7681ZM1.98474 57.0294L10.0172 57.9594L9.87473 59.1744L1.84224 58.2444L1.34724 62.5382L0.282227 62.4144L1.41473 52.6082L2.47974 52.7319L1.98474 57.0257V57.0294ZM11.9667 49.3309C12.8292 46.3984 11.5729 43.6759 8.94419 42.8996V42.8959C6.31544 42.1196 3.78419 43.7246 2.91794 46.6609C2.05544 49.5971 3.31169 52.3196 5.94044 53.0959C8.56919 53.8721 11.1004 52.2671 11.9667 49.3309ZM10.9167 49.0196C10.2379 51.3221 8.35541 52.5184 6.28916 51.9109C4.22291 51.2996 3.29294 49.2709 3.97169 46.9721C4.65044 44.6734 6.52917 43.4884 8.59542 44.0959C10.6617 44.7034 11.5954 46.7209 10.9167 49.0196ZM9.62035 31.4993C10.8428 29.4518 12.7366 28.5781 14.6116 28.9418L14.5479 30.0931C12.9879 29.7968 11.5366 30.4306 10.5691 32.0506C9.34661 34.0981 9.71412 36.3368 11.5629 37.4431C13.4116 38.5493 15.5604 37.8143 16.7829 35.7668C17.7504 34.1468 17.6266 32.5718 16.6254 31.3343L17.6079 30.7343C18.8154 32.2156 18.9391 34.2931 17.7166 36.3406C16.1529 38.9543 13.2766 39.9106 10.9254 38.5043C8.57414 37.0981 8.0566 34.1131 9.62035 31.4993ZM78.7509 1.72815L77.4046 6.34065H77.3971C76.6134 9.0219 77.6596 11.0806 80.5471 11.9244C83.4234 12.7644 85.4259 11.5981 86.2096 8.9169L87.5596 4.3044L86.3859 3.9594L85.0471 8.53815C84.4434 10.6081 83.0484 11.5156 80.8584 10.8744C78.6684 10.2369 77.9709 8.71815 78.5746 6.64815L79.9134 2.0694L78.7509 1.72815ZM87.3882 10.8034L87.3883 10.8044L86.2407 11.1147C86.327 12.8097 87.737 14.5497 89.7582 15.5547C91.9707 16.6534 94.1269 16.5297 94.9332 14.9097C95.7619 13.2409 94.502 12.2322 92.0682 10.6797C90.0507 9.40841 89.3382 8.83841 89.7695 7.97216C90.1482 7.20716 91.3482 7.00466 93.0132 7.83341C94.6107 8.62841 95.492 9.80591 95.6082 11.0022L96.7257 10.7584C96.6132 9.35216 95.4395 7.84466 93.5345 6.89591C91.367 5.81591 89.387 6.13092 88.6782 7.55591C87.8945 9.13091 89.222 10.1884 91.247 11.4672C93.5682 12.9522 94.2957 13.4959 93.8007 14.4897C93.347 15.4047 91.8732 15.4122 90.2532 14.6059C88.8247 13.8973 87.5124 12.5889 87.3883 10.8044L87.392 10.8034H87.3882ZM99.7012 19.5633C100.552 20.2158 101.707 20.0883 102.39 19.1958L102.386 19.1921C103.076 18.2921 102.896 17.1408 102.045 16.4921C101.182 15.8358 100.009 15.9483 99.3187 16.8483C98.64 17.7408 98.8387 18.9071 99.7012 19.5633Z" fill="black" style="fill:black;fill:black;fill-opacity:1;">',
  ),
  Eq = (n = {}) =>
    (() => {
      const e = ft(Tq);
      return (fn(e, n, !0, !0), An(), e);
    })(),
  Mq = xt(
    '<svg width="130" height="130" viewBox="0 0 130 130" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M75.2301 1.07577L75.1364 2.14077L67.8726 1.49577L67.6214 4.30077L74.1614 4.88202L74.0676 5.94702L67.5276 5.36577L67.2501 8.47827L74.5139 9.12327L74.4201 10.1883L65.9639 9.43827L66.7739 0.322021L75.2301 1.07202V1.07577ZM55.9361 10.1544L57.1549 10.0494H57.1586L56.8249 6.22443L60.7624 5.87943L63.6611 9.47943L65.0599 9.35568L62.0899 5.69943C63.5449 5.34318 64.4299 4.35693 64.3024 2.89443C64.1486 1.15443 62.7499 0.370677 60.8449 0.535677L55.1411 1.03443L55.9361 10.1544ZM63.1061 2.99943C63.1961 4.03068 62.4461 4.67193 61.1486 4.78443V4.78068L56.7274 5.16693L56.4499 1.97943L60.8711 1.59318C62.1686 1.48068 63.0161 1.97193 63.1061 2.99943ZM46.0775 3.23575L46.0811 3.24073L44.795 3.64825L44.645 12.0183L39.5075 5.32825L38.2925 5.7145L44.2737 13.4208L45.6837 12.9708L45.8225 4.69825L50.7012 11.377L52.1112 10.927L52.5575 1.177L51.3537 1.5595L51.02 9.9895L46.0811 3.24073L46.085 3.2395L46.0775 3.23575ZM37.055 17.2907C39.6913 15.7419 40.6363 12.8957 39.2488 10.5332C37.8613 8.17067 34.9175 7.60817 32.2775 9.15692C29.6413 10.7057 28.6963 13.5519 30.0838 15.9144C31.4713 18.2769 34.4188 18.8394 37.055 17.2907ZM36.5 16.3494C34.4338 17.5607 32.2401 17.1482 31.1488 15.2919V15.2957C30.0576 13.4394 30.7663 11.3244 32.8326 10.1094C34.8988 8.89442 37.0813 9.31442 38.1726 11.1707C39.2638 13.0269 38.5663 15.1344 36.5 16.3494ZM25.5048 13.6907L31.6023 20.5232L30.6985 21.3294L27.9048 18.1982L22.7485 22.7994L25.5423 25.9307L24.6273 26.7444L18.5298 19.9119L19.4448 19.0982L22.036 22.0007L27.1923 17.3994L24.601 14.4969L25.5048 13.6907ZM104.518 25.9307L105.313 26.8607H105.316L108.234 24.3669L111.069 27.6819C112.325 29.1557 113.889 29.5307 115.198 28.4132C116.525 27.2769 116.368 25.7019 115.108 24.2282L111.478 19.9832L104.518 25.9307ZM114.406 27.4944C113.623 28.1657 112.67 27.9369 111.826 26.9469V26.9507L109.033 23.6844L111.466 21.6032L114.26 24.8694C115.104 25.8594 115.19 26.8232 114.406 27.4944ZM119.259 29.8794L118.633 28.8257L110.765 33.5057L114.943 40.5294L115.861 39.9819L112.31 34.0119L119.259 29.8794ZM125.761 43.0794L118.861 50.7782L118.408 49.5594L120.324 47.4294L118.333 42.0894L115.486 41.7219L115.033 40.5032L125.293 41.8232L125.761 43.0794ZM119.533 42.2432L121.13 46.5332L124.408 42.8769L119.533 42.2432ZM129.103 56.2398L129.103 56.2382L129.106 56.2419L129.103 56.2398ZM124.231 53.2644L129.103 56.2398L129.395 57.7157L123.406 54.0369L119.491 54.8094L119.259 53.6207L123.174 52.8482L127.318 47.1707L127.61 48.6594L124.231 53.2644ZM124.58 73.8857C121.842 73.7244 120.005 71.3544 120.185 68.3019C120.365 65.2494 122.469 63.1119 125.206 63.2732C127.944 63.4344 129.781 65.8044 129.601 68.8569C129.421 71.9094 127.317 74.0469 124.58 73.8857ZM125.131 64.5069C122.982 64.3794 121.419 65.9732 121.276 68.3657C121.134 70.7582 122.503 72.5094 124.651 72.6369C126.804 72.7644 128.364 71.1819 128.506 68.7894C128.649 66.3969 127.284 64.6307 125.131 64.5032V64.5069ZM128.69 76.6607L124.036 75.4644H124.04C121.336 74.7707 119.315 75.8844 118.565 78.7982C117.819 81.7007 119.053 83.6619 121.756 84.3557L126.41 85.5519L126.714 84.3669L122.094 83.1819C120.009 82.6457 119.056 81.2807 119.623 79.0719C120.189 76.8632 121.685 76.1132 123.77 76.6494L128.39 77.8344L128.69 76.6607ZM116.525 85.6757L117.042 84.5657L125.341 88.4282L122.926 93.6182C122.12 95.3507 120.74 96.1719 119.157 95.4369C117.83 94.8182 117.417 93.5582 117.834 92.1219L113.184 92.8682L113.776 91.5969L118.34 90.8807L120.009 87.2994L116.529 85.6794L116.525 85.6757ZM119.09 91.7619C118.542 92.9394 118.722 93.9107 119.66 94.3457C120.597 94.7807 121.445 94.2894 121.992 93.1119L123.864 89.0882L120.961 87.7382L119.09 91.7619ZM113.195 98.3764L113.199 98.3769H113.195L113.195 98.3764ZM113.195 98.3764C111.426 98.1196 109.872 99.1278 108.875 100.368C107.742 101.782 107.439 103.222 108.234 103.859C109.1 104.553 109.786 103.961 111.729 102.003C113.409 100.293 114.725 99.2244 116.097 100.323C117.342 101.321 117.226 103.319 115.711 105.209C114.38 106.871 112.659 107.696 111.256 107.508V106.364C112.452 106.503 113.791 105.896 114.905 104.501C116.067 103.046 116.124 101.834 115.46 101.302C114.702 100.694 113.997 101.272 112.325 102.974C110.292 105.022 109.036 106.042 107.581 104.876C106.167 103.743 106.505 101.613 108.05 99.6819C109.46 97.9194 111.462 96.9107 113.135 97.1882L113.195 98.3764ZM103.621 116.966L97.6436 110.036L98.5623 109.245L101.3 112.421L106.531 107.91L103.794 104.733L104.72 103.935L110.697 110.865L109.771 111.663L107.232 108.72L102.001 113.231L104.54 116.175L103.621 116.966ZM92.1316 113.178C89.4691 114.682 88.4753 117.513 89.8216 119.898C91.1716 122.287 94.1078 122.898 96.7703 121.395C99.4328 119.891 100.427 117.06 99.0803 114.675C97.7303 112.286 94.7941 111.675 92.1316 113.178ZM92.6716 114.135C94.7603 112.957 96.9466 113.407 98.0041 115.282V115.286C99.0616 117.161 98.3153 119.265 96.2303 120.442C94.1416 121.62 91.9666 121.162 90.9091 119.287C89.8516 117.408 90.5866 115.312 92.6716 114.135ZM82.8874 127.072L78.0612 120.236L77.5887 128.658L76.3774 129.022L76.9887 119.283L78.4062 118.859L83.1724 125.621L83.4537 117.352L84.8712 116.928L90.7212 124.736L89.4987 125.103L84.4774 118.327L84.1849 126.693L82.8912 127.079L82.8874 127.072ZM73.1376 119.992L71.9151 120.078V120.082L72.1851 123.911L68.2438 124.188L65.4051 120.539L64.0063 120.637L66.9126 124.342C65.4538 124.676 64.5501 125.647 64.6551 127.109C64.7751 128.853 66.1626 129.663 68.0714 129.528L73.7826 129.123L73.1376 119.992ZM65.8513 127.027C65.7763 125.996 66.5376 125.366 67.8351 125.276H67.8389L72.2638 124.964L72.4888 128.156L68.0638 128.467C66.7663 128.561 65.9226 128.058 65.8513 127.027ZM53.6938 128.752L53.8063 127.687L61.0588 128.452L61.3551 125.651L54.8263 124.961L54.9388 123.896L61.4676 124.586L61.7976 121.481L54.5451 120.716L54.6576 119.651L63.1026 120.543L62.1426 129.648L53.6976 128.756L53.6938 128.752ZM43.0139 124.766L42.7176 125.793L42.7139 125.797L50.8701 128.159L53.4164 119.366L45.2601 117.003L44.9639 118.031L51.9689 120.059L51.0989 123.059L44.7914 121.233L44.4951 122.261L50.8026 124.087L50.0189 126.794L43.0139 124.766ZM40.0774 124.713L38.9787 124.177L42.5224 116.909L36.2749 113.864L36.7437 112.901L44.0899 116.486L40.0774 124.713ZM30.4999 110.595C29.6486 109.946 28.4936 110.081 27.8149 110.973H27.8111C27.1286 111.877 27.3124 113.028 28.1674 113.673C29.0336 114.326 30.2074 114.21 30.8936 113.306C31.5686 112.413 31.3624 111.247 30.4999 110.595ZM25.3361 103.814L26.1461 104.729L19.2873 110.793L15.5898 106.612C14.3073 105.161 14.1236 103.586 15.4323 102.431C16.7223 101.291 18.2898 101.639 19.5723 103.091L22.4598 106.357L25.3361 103.814ZM18.8223 103.841C17.9598 102.866 17.0073 102.656 16.2348 103.338C15.4623 104.021 15.5636 104.984 16.4261 105.959L19.2723 109.177L21.6686 107.058L18.8223 103.841ZM11.9797 102.066L11.9824 102.071L11.9787 102.067L11.9797 102.066ZM19.7674 97.2557L11.9797 102.066L11.3374 101.028L18.2149 96.7795L14.5624 90.8657L15.4737 90.3032L19.7674 97.2557ZM4.61768 87.9444L11.3864 80.1294L11.8627 81.3407L9.98393 83.5006L12.0614 88.8069L14.9114 89.1256L15.3877 90.3369L5.10893 89.1894L4.62143 87.9444H4.61768ZM10.8577 88.6756L9.18892 84.4156L5.97518 88.1281L10.8577 88.6794V88.6756ZM0.732422 73.3645L1.04742 74.8345L1.05117 74.8382L5.97867 77.7332L2.67492 82.3945L2.99367 83.8795L7.03992 78.1308L10.9437 77.2908L10.6887 76.1058L6.78492 76.942L0.732422 73.3645ZM5.27738 57.1195C8.01488 57.2358 9.89363 59.572 9.76613 62.6283C9.63863 65.6845 7.56863 67.8558 4.82738 67.7395C2.08988 67.6233 0.211134 65.287 0.338634 62.227C0.466134 59.1708 2.53613 56.9995 5.27738 57.1158V57.1195ZM4.87988 66.5058C7.03238 66.5958 8.56613 64.9758 8.67113 62.5833C8.77238 60.187 7.37738 58.4583 5.22488 58.3683C3.07238 58.2783 1.53863 59.8833 1.43738 62.2795C1.33613 64.6758 2.73113 66.4158 4.88363 66.5095L4.87988 66.5058ZM1.11865 54.4194L5.7949 55.5331C8.5099 56.1819 10.5162 55.0344 11.2137 52.1094C11.9074 49.1956 10.6399 47.2569 7.9249 46.6081L3.24865 45.4944L2.96365 46.6831L7.6024 47.7894C9.69865 48.2881 10.6737 49.6344 10.1449 51.8544C9.61615 54.0744 8.1349 54.8469 6.03865 54.3481L1.3999 53.2419L1.11865 54.4194ZM13.1336 45.1983L12.6348 46.3158L4.26855 42.592L6.5973 37.3608C7.37355 35.6133 8.7423 34.7695 10.3361 35.4783C11.6748 36.0745 12.1098 37.327 11.7161 38.7745L16.3548 37.9495L15.7848 39.232L11.2323 40.0233L9.62356 43.6345L13.1298 45.1945L13.1336 45.1983ZM10.4636 39.1533C10.9923 37.9645 10.7936 36.997 9.8523 36.577C8.9073 36.157 8.07105 36.6633 7.5423 37.852L5.73856 41.9058L8.66356 43.207L10.4673 39.1533H10.4636ZM20.5324 30.3818C19.5574 31.6418 18.0162 32.6731 16.2424 32.4443V32.4556L16.3212 33.6443C17.9974 33.8918 19.9849 32.8493 21.3649 31.0643C22.8799 29.1106 23.1799 26.9731 21.7474 25.8631C20.2737 24.7231 19.0362 25.7618 17.0374 27.8431C15.3912 29.5681 14.6937 30.1568 13.9287 29.5643C13.2499 29.0393 13.2874 27.8243 14.4274 26.3543C15.5224 24.9443 16.8499 24.3106 18.0462 24.4306L18.0274 23.2868C16.6249 23.1181 14.9187 23.9731 13.6137 25.6568C12.1324 27.5693 12.0499 29.5718 13.3099 30.5468C14.7012 31.6231 15.9987 30.5318 17.6487 28.7956C19.5574 26.8081 20.2362 26.2043 21.1137 26.8831C21.9199 27.5056 21.6424 28.9493 20.5324 30.3818ZM85.9774 4.87438L86.2586 3.83938H86.2549L78.0574 1.61938L75.6611 10.4581L83.8586 12.6781L84.1399 11.6431L77.1011 9.73438L77.9186 6.71939L84.2561 8.43688L84.5374 7.40189L78.1999 5.68438L78.9386 2.96563L85.9774 4.87438ZM88.9211 4.88184L90.0311 5.39934L86.6111 12.7231L92.9074 15.6631L92.4536 16.6343L85.0474 13.1768L88.9211 4.88184ZM98.7313 18.8395C99.5976 19.4732 100.749 19.3195 101.413 18.4157L101.409 18.412C102.08 17.497 101.874 16.3532 101.011 15.7195C100.138 15.082 98.9638 15.217 98.2926 16.132C97.6326 17.0395 97.8576 18.1982 98.7313 18.8395Z" fill="black" style="fill:black;fill:black;fill-opacity:1;">',
  ),
  Lq = (n = {}) =>
    (() => {
      const e = ft(Mq);
      return (fn(e, n, !0, !0), An(), e);
    })(),
  Rq = xt(
    '<svg width="130" height="130" viewBox="0 0 130 130" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M73.8274 5.40878C73.6699 8.14628 71.2999 9.98753 68.2436 9.81128C65.1874 9.63503 63.0499 7.53128 63.2074 4.79378C63.3649 2.05628 65.7349 0.215032 68.7911 0.391282C71.8474 0.567532 73.9849 2.67128 73.8274 5.40878ZM64.4449 4.86503C64.3211 7.01753 65.9149 8.57753 68.3074 8.71628C70.6999 8.85503 72.4549 7.48628 72.5786 5.33753C72.7024 3.18503 71.1199 1.62503 68.7274 1.48628C66.3349 1.34753 64.5686 2.71253 64.4449 4.86503ZM53.662 7.47355L53.6602 7.47127H53.664L53.662 7.47355ZM53.662 7.47355C54.7534 8.88916 56.5673 9.25241 58.149 9.05752C59.9452 8.83252 61.1677 8.01127 61.0402 7.00252C60.9015 5.90002 59.9977 5.84752 57.2415 5.89627C54.8452 5.95252 53.1577 5.80252 52.9402 4.05502C52.7415 2.47252 54.219 1.11877 56.6227 0.818771C58.734 0.556271 60.5452 1.16377 61.419 2.27752L60.6202 3.09502C59.8627 2.16127 58.4752 1.66627 56.7052 1.88752C54.8602 2.12002 53.9715 2.94877 54.0802 3.79627C54.2002 4.75627 55.1115 4.83877 57.4927 4.78252C60.3765 4.73002 61.989 4.87627 62.2177 6.72502C62.4427 8.52127 60.714 9.81502 58.2615 10.1225C56.0227 10.4038 53.8815 9.73252 52.8765 8.36752L53.662 7.47355ZM47.2552 5.62999L47.2538 5.6316C46.0046 4.20746 43.956 3.74491 41.7465 4.59874C38.8665 5.71249 37.4415 8.35249 38.4352 10.9212C39.429 13.49 42.234 14.5212 45.099 13.415C46.7715 12.755 47.8102 11.5475 47.9827 10.4412L48.5565 11.9262L49.6252 11.5137L47.9115 7.07749L42.714 9.08374L43.1002 10.0812L47.2852 8.46499C47.8215 9.99124 46.6177 11.6487 44.7015 12.3875C42.489 13.2425 40.3777 12.485 39.5977 10.4637C38.8215 8.45374 39.8902 6.48499 42.1365 5.61499C43.899 4.93249 45.4402 5.32249 46.4902 6.51499L47.2538 5.6316L47.259 5.63749L47.2552 5.62999ZM38.4125 16.2313L39.3275 15.6538H39.3312L34.4412 7.91382L33.4475 8.54007L37.4037 14.8026L27.7775 12.1213L26.6787 12.8151L31.5687 20.5551L32.5587 19.9288L28.4675 13.4488L38.4125 16.2313ZM30.2749 21.7962L29.3299 22.5725L23.5137 15.5075L24.4587 14.7312L30.2749 21.7962ZM15.0948 25.5275L23.7123 28.0212V28.0287L24.3985 27.275L21.121 18.9312L27.0648 24.3537L27.8635 23.4762L21.1023 17.3037L19.8573 18.6687L22.9923 26.6562L14.761 24.2525L13.4785 25.655L20.2398 31.8275L21.0385 30.95L15.0948 25.5275ZM114.688 23.5287C116.229 25.3512 116.443 27.4212 115.49 29.0787L114.421 28.6437C115.205 27.2599 115.078 25.6849 113.859 24.2449C112.318 22.4224 110.079 22.0474 108.433 23.4387C106.786 24.8299 106.786 27.1024 108.328 28.9212C109.546 30.3612 111.08 30.7549 112.573 30.2074L112.824 31.3324C111.031 31.9962 109.021 31.4412 107.484 29.6187C105.515 27.2899 105.545 24.2599 107.638 22.4899C109.73 20.7199 112.723 21.1962 114.691 23.5249L114.688 23.5287ZM119.971 40.3475C117.579 41.6862 114.751 40.685 113.259 38.015C111.766 35.345 112.385 32.4087 114.777 31.07C117.17 29.7312 119.997 30.7325 121.49 33.4025C122.986 36.0725 122.364 39.0087 119.971 40.3475ZM115.377 32.15C113.499 33.2037 113.041 35.3862 114.211 37.4787C115.381 39.5712 117.477 40.31 119.36 39.2562C121.239 38.2025 121.704 36.0275 120.53 33.9387C119.36 31.8462 117.256 31.0962 115.377 32.15ZM124.374 42.0801L117.845 48.2301L118.145 49.2051L126.995 50.6226L119.304 52.9851L119.653 54.1176L128.405 51.4288L127.861 49.6626L119.39 48.3051L125.645 42.4363L125.086 40.6213L116.334 43.3101L116.683 44.4426L124.374 42.0801ZM119.862 57.05L119.675 55.8388L128.72 54.4363L128.907 55.6475L119.862 57.05ZM120.5 66.8787L120.53 67.9624L129.68 67.6999L129.646 66.5262L122.244 66.7399L129.455 59.8249L129.418 58.5237L120.268 58.7862L120.301 59.9599L127.959 59.7387L120.5 66.8787ZM125.15 79.8913L124.775 78.7813C126.335 78.4813 127.452 77.3488 127.76 75.4851C128.15 73.1076 126.995 71.1838 124.869 70.8351C122.731 70.4826 121.006 71.9188 120.624 74.2588C120.29 76.2838 121.104 78.1626 122.694 78.4776L123.421 74.0488L124.479 74.2213L123.575 79.7188L118.88 78.9463L119.067 77.8138L120.639 78.0726C119.772 77.3601 119.259 75.8563 119.54 74.0788C120.039 71.0451 122.352 69.1513 125.071 69.6013C127.79 70.0476 129.342 72.6163 128.844 75.6613C128.457 78.0013 127.017 79.5351 125.15 79.8876V79.8913ZM116.664 87.5413C117.298 86.0788 118.535 84.6951 120.309 84.4776V84.4738L119.938 83.3413C118.25 83.5176 116.589 85.0213 115.693 87.0913C114.71 89.3601 114.95 91.5051 116.611 92.2251C118.318 92.9638 119.263 91.6513 120.68 89.1388C121.846 87.0613 122.375 86.3151 123.264 86.7013C124.048 87.0426 124.314 88.2238 123.575 89.9338C122.866 91.5726 121.738 92.5138 120.549 92.6938L120.849 93.7963C122.248 93.6126 123.691 92.3601 124.535 90.4063C125.495 88.1826 125.079 86.2251 123.616 85.5913C122 84.8938 121.018 86.2738 119.848 88.3663C118.49 90.7626 117.984 91.5163 116.968 91.0776C116.034 90.6726 115.944 89.2026 116.664 87.5413ZM111.83 102.883C109.558 101.353 109.179 98.3751 110.889 95.8363C112.599 93.2976 115.498 92.5326 117.774 94.0626C120.046 95.5926 120.425 98.5701 118.715 101.109C117.005 103.648 114.106 104.413 111.83 102.883ZM117.08 95.0901C115.291 93.8863 113.135 94.4638 111.796 96.4513C110.458 98.4388 110.739 100.644 112.528 101.848C114.316 103.051 116.465 102.485 117.804 100.498C119.143 98.5101 118.869 96.2938 117.08 95.0901ZM103.839 104.341C101.66 106.494 101.442 109.486 103.37 111.436C105.294 113.386 108.29 113.206 110.469 111.058C112.647 108.905 112.865 105.913 110.937 103.963C109.01 102.013 106.017 102.189 103.839 104.341ZM104.607 105.121C106.314 103.438 108.541 103.299 110.056 104.833H110.06C111.575 106.366 111.406 108.594 109.7 110.278C107.994 111.961 105.774 112.093 104.259 110.559C102.744 109.025 102.901 106.805 104.607 105.121ZM91.7787 113.754L92.6824 113.154L102.687 115.711L98.4499 109.325L99.4286 108.676L104.491 116.304L103.407 117.024L93.7212 114.556L97.8162 120.729L96.8374 121.378L91.7749 113.75L91.7787 113.754ZM86.3074 118.07C85.3136 118.467 84.8299 119.525 85.2499 120.567C85.6736 121.617 86.7536 122.049 87.7474 121.651C88.7524 121.25 89.2586 120.181 88.8349 119.127C88.4149 118.089 87.3124 117.665 86.3074 118.07ZM76.385 128.724C74.0412 129.155 72.1325 128.311 71.1687 126.661L72.0762 125.949C72.8862 127.317 74.3187 127.989 76.175 127.647C78.5187 127.216 79.9625 125.461 79.5725 123.342C79.1825 121.224 77.21 120.095 74.8662 120.526C73.01 120.867 71.9075 122.004 71.6412 123.571L70.5425 123.23C70.8575 121.344 72.3387 119.877 74.6825 119.446C77.6787 118.895 80.2962 120.425 80.7912 123.121C81.2862 125.817 79.385 128.176 76.3887 128.727L76.385 128.724ZM64.5538 120.282C61.4938 120.234 59.2063 122.172 59.1613 124.914C59.1163 127.655 61.3401 129.669 64.4001 129.717C67.4601 129.766 69.7476 127.827 69.7926 125.086C69.8376 122.345 67.6138 120.331 64.5538 120.282ZM64.5388 121.381C66.9351 121.419 68.5926 122.911 68.5588 125.067C68.5251 127.224 66.8188 128.66 64.4226 128.622C62.0263 128.585 60.3801 127.092 60.4138 124.936C60.4476 122.78 62.1426 121.344 64.5388 121.381ZM53.3451 119.199L55.4601 127.917L57.2151 120.065L58.3739 120.324L56.3789 129.26L54.5226 128.847L52.5201 120.507L47.1426 127.197L45.3389 126.792L47.3339 117.856L48.4926 118.115L46.7376 125.967L52.3514 118.977L53.3451 119.199ZM45.8415 117.028L44.6977 116.593L41.439 125.146L42.5827 125.581L45.8415 117.028ZM34.8838 111.762L35.84 112.272L38.3375 122.296L41.9488 115.535L42.9838 116.086L38.6713 124.164L37.5238 123.552L35.0975 113.855L31.6063 120.391L30.5713 119.84L34.8838 111.762ZM22.2485 109.828L22.2462 109.827L22.25 109.824L22.2485 109.828ZM24.0762 115.13C22.2402 113.631 21.6247 111.623 22.2485 109.828L23.3937 110.056C22.8762 111.56 23.3037 113.094 24.7662 114.286C26.6337 115.809 28.8762 115.764 30.2375 114.091C31.6062 112.411 31.22 110.202 29.3825 108.706C27.7925 107.409 25.7562 107.18 24.695 108.402L28.175 111.237L27.5 112.066L23.18 108.545L26.1837 104.859L27.0725 105.582L26.0637 106.816C27.11 106.419 28.6737 106.722 30.0762 107.847C32.4575 109.79 32.9487 112.737 31.2087 114.875C29.4687 117.009 26.4687 117.08 24.0762 115.13ZM20.6748 103.366C21.361 101.716 20.7723 99.9575 19.816 98.6825C18.7285 97.235 17.4085 96.5863 16.5948 97.1975C15.7098 97.865 16.111 98.6788 17.5285 101.045C18.7698 103.096 19.4823 104.634 18.076 105.691C16.801 106.651 14.896 106.044 13.4373 104.109C12.1548 102.406 11.7835 100.535 12.3123 99.2263L13.4185 99.5113C12.9873 100.633 13.246 102.08 14.3223 103.509C15.4435 104.994 16.6023 105.35 17.2848 104.836C18.0573 104.255 17.6748 103.426 16.441 101.386C14.9598 98.9113 14.2848 97.4413 15.7698 96.32C17.2173 95.2325 19.1973 96.0838 20.686 98.06C22.0435 99.8638 22.5273 102.054 21.8448 103.603L20.6748 103.366ZM15.4548 89.5588C14.0973 86.8175 11.3223 85.6738 8.86603 86.8925H8.86228C6.40978 88.1151 5.64103 91.0138 7.00228 93.755C8.36353 96.4963 11.1385 97.6401 13.5948 96.4213C16.0473 95.1988 16.8123 92.3 15.4548 89.5588ZM14.4723 90.0463C15.5373 92.1913 14.9748 94.3513 13.0435 95.3113C11.1123 96.2713 9.04978 95.4163 7.98478 93.2675C6.91978 91.1188 7.49353 88.9738 9.42103 88.0138C11.3485 87.0538 13.4073 87.9013 14.4723 90.0463ZM5.64134 75.3012C8.29259 74.5962 10.7826 76.2724 11.5663 79.2312C12.3501 82.1899 11.0188 84.8787 8.37134 85.5837C5.72009 86.2887 3.23009 84.6124 2.44634 81.6537C1.66259 78.6949 2.99384 76.0062 5.64134 75.3049V75.3012ZM8.05259 84.3837C10.1338 83.8324 11.1201 81.8262 10.5051 79.5087C9.89009 77.1912 8.04509 75.9537 5.96009 76.5049C3.87884 77.0562 2.88884 79.0474 3.50384 81.3649C4.11884 83.6824 5.96759 84.9312 8.05259 84.3799V84.3837ZM9.46635 65.1613L9.3951 64.0813V64.085L0.256348 64.6813L0.331347 65.8513L7.72635 65.3675L0.770097 72.5413L0.856348 73.8388L9.9951 73.2425L9.9201 72.0725L2.2701 72.5713L9.46635 65.1613ZM6.71019 55.0326C7.82019 55.1826 8.50269 56.1276 8.36019 57.1889C8.21393 58.2614 7.29893 59.0151 6.18893 58.8614C5.06393 58.7076 4.38519 57.7401 4.53144 56.6676C4.67769 55.6064 5.58519 54.8826 6.71019 55.0326ZM8.38635 39.7737C6.4776 39.7924 4.80135 41.0337 4.01385 43.2837L4.0176 43.2874C3.0126 46.1637 4.1226 48.9837 6.7101 49.8874C9.2976 50.7912 11.9226 49.2762 12.9276 46.3999C13.7114 44.1462 13.1751 42.1362 11.6901 40.9287L10.8464 41.7162C12.0726 42.7249 12.5151 44.2437 11.8926 46.0249C11.1051 48.2749 9.15135 49.4262 7.1151 48.7174C5.07885 48.0049 4.2651 45.8824 5.0526 43.6324C5.6751 41.8512 6.9651 40.9399 8.5551 40.9137L8.38635 39.7737ZM15.8265 30.2039C18.1927 31.5839 18.7627 34.5314 17.2215 37.1714C15.6802 39.8151 12.834 40.7676 10.4677 39.3839C8.10148 38.0039 7.53148 35.0564 9.07273 32.4164C10.614 29.7726 13.4602 28.8201 15.8265 30.2039ZM11.0902 38.3189C12.9502 39.4064 15.0652 38.6901 16.2727 36.6201C17.4802 34.5501 17.0565 32.3676 15.1965 31.2839C13.3365 30.1964 11.229 30.9014 10.0215 32.9714C8.81398 35.0414 9.23023 37.2314 11.0902 38.3189ZM79.1413 11.5401C82.1001 12.3201 84.7888 10.9851 85.4864 8.33385C86.1839 5.6826 84.5038 3.19635 81.5451 2.41635C78.5863 1.63635 75.8976 2.97135 75.2001 5.6226C74.5026 8.27385 76.1826 10.7601 79.1413 11.5401ZM79.4188 10.4788C77.1013 9.8676 75.8488 8.0226 76.3963 5.9376V5.94135C76.9438 3.85635 78.9464 2.86635 81.2638 3.4776C83.5813 4.08885 84.8226 5.9301 84.2751 8.0151C83.7276 10.0963 81.7364 11.0901 79.4188 10.4788ZM93.369 17.1575L92.394 16.6813L89.5252 6.75875L86.169 13.6475L85.1152 13.1337L89.124 4.90625L90.294 5.47625L93.0765 15.0725L96.3202 8.4125L97.374 8.92625L93.3652 17.1538L93.369 17.1575ZM99.864 19.6849C100.711 20.3411 101.866 20.2174 102.553 19.3286C103.246 18.4286 103.07 17.2774 102.223 16.6249C101.364 15.9649 100.186 16.0699 99.4927 16.9699C98.8102 17.8586 99.0052 19.0249 99.864 19.6849Z" fill="black" style="fill:black;fill:black;fill-opacity:1;">',
  ),
  Bq = (n = {}) =>
    (() => {
      const e = ft(Rq);
      return (fn(e, n, !0, !0), An(), e);
    })(),
  Pq = xt(
    '<svg width="130" height="130" viewBox="0 0 130 130" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M67.4112 3.08527C66.6837 1.31902 64.9137 0.220274 62.5325 0.325274L62.5287 0.321524C59.4875 0.456524 57.2787 2.52652 57.3987 5.26777C57.5187 8.00902 59.8962 9.88027 62.9412 9.74902C65.3225 9.64402 66.9912 8.39902 67.5612 6.57277L66.5187 6.08152C66.035 7.59652 64.79 8.56777 62.9037 8.65027C60.5225 8.75152 58.7262 7.36402 58.6325 5.21152C58.5387 3.05902 60.2075 1.52152 62.5887 1.41652C64.475 1.33402 65.8025 2.19652 66.4137 3.66277L67.4112 3.08527ZM52.7486 10.9304L51.5561 11.2117L49.4448 2.30542L50.6373 2.02417L52.7486 10.9304ZM42.9349 14.1366L39.6311 6.75656V6.75281L43.5761 4.98656L43.1374 4.00781L34.1299 8.04281L34.5686 9.02156L38.5136 7.25531L41.8174 14.6353L42.9349 14.1366ZM26.2363 21.0215L26.2425 21.0241L26.015 22.1878C27.5713 22.8553 29.7575 22.3528 31.5463 20.9803C33.5075 19.4765 34.3438 17.4853 33.2413 16.049C32.1088 14.5753 30.6463 15.2615 28.1825 16.7653C26.1538 18.0178 25.3288 18.4078 24.74 17.639C24.2188 16.9603 24.5638 15.7978 26.0413 14.6653C27.4588 13.5778 28.9063 13.3078 30.0313 13.7278L30.305 12.6178C28.9888 12.0965 27.1213 12.4865 25.43 13.784C23.5063 15.2578 22.9175 17.174 23.8888 18.4378C24.9613 19.8328 26.4913 19.109 28.5313 17.849C30.8825 16.4128 31.6925 16.0003 32.3675 16.8815C32.9863 17.6915 32.3488 19.0153 30.9125 20.1178C29.6466 21.0878 27.8982 21.695 26.2425 21.0241L26.2438 21.0178L26.2363 21.0215ZM115.49 29.0765C116.443 27.419 116.229 25.349 114.688 23.5265L114.691 23.5227C112.723 21.194 109.73 20.7177 107.638 22.4877C105.545 24.2577 105.515 27.2877 107.484 29.6165C109.021 31.439 111.031 31.994 112.824 31.3302L112.573 30.2052C111.08 30.7527 109.546 30.359 108.328 28.919C106.786 27.1002 106.786 24.8277 108.433 23.4365C110.079 22.0452 112.318 22.4202 113.859 24.2427C115.078 25.6827 115.205 27.2577 114.421 28.6415L115.49 29.0765ZM121.764 34.0828L121.22 32.9878L113.019 37.0565L116.649 44.3765L117.609 43.9003L114.522 37.6753L121.764 34.0828ZM118.441 50.2453L118.104 49.0678L126.905 46.5403L127.242 47.7178L118.441 50.2453ZM126.954 64.5253C128.686 63.7153 129.702 61.8965 129.489 59.5228L129.485 59.5265C129.211 56.4928 127.04 54.3853 124.31 54.629C121.58 54.8728 119.814 57.3365 120.087 60.3703C120.301 62.744 121.621 64.3528 123.47 64.8403L123.912 63.7753C122.375 63.3628 121.347 62.1628 121.179 60.284C120.969 57.9103 122.274 56.0503 124.419 55.859C126.564 55.664 128.18 57.2615 128.394 59.6353C128.562 61.514 127.764 62.879 126.327 63.5578L126.954 64.5253ZM124.393 71.5002L128.285 78.3027L128.008 80.039L124.903 74.474L118.91 78.959L119.169 77.3202L124.336 73.4652L123.129 71.2977L120.193 70.8327L120.384 69.6252L129.425 71.0577L129.234 72.2652L124.385 71.4965L124.393 71.5002ZM112.347 97.1204C112.621 98.2979 113.214 99.3666 114.076 100.21L114.091 100.214L114.849 99.3441C114.087 98.6054 113.604 97.6754 113.386 96.6966L113.409 96.6816L116.772 95.4141C116.259 96.8616 116.435 98.2754 117.507 98.9204C118.535 99.5354 119.907 99.3029 120.886 97.6754C121.824 96.1116 121.43 94.6566 120.327 93.9929C119.735 93.6366 119.124 93.5691 118.407 93.7191C118.899 92.2304 118.61 90.8804 117.504 90.2166C116.105 89.3766 114.41 90.1154 113.21 92.1179C112.456 93.3741 112.141 94.7166 112.205 96.0216C111.215 96.4566 110.319 97.0341 109.749 98.1329L110.634 98.6654C111.005 97.9941 111.462 97.5554 112.347 97.1204ZM113.255 95.5829C113.255 94.6154 113.514 93.6404 114.05 92.7441V92.7404C114.864 91.3866 116.026 90.7604 116.945 91.3116C117.755 91.7991 117.912 92.7741 117.327 94.0716L113.33 95.5529C113.324 95.5567 113.318 95.5595 113.311 95.5619C113.305 95.5642 113.299 95.566 113.292 95.5679C113.279 95.5716 113.266 95.5754 113.255 95.5829ZM118.055 97.9416C117.181 97.4204 117.275 96.2691 117.886 95.0016V94.9979C118.842 94.6679 119.322 94.7166 119.791 94.9979C120.436 95.3879 120.665 96.2204 120.087 97.1841C119.469 98.2116 118.644 98.2979 118.055 97.9416ZM103.82 108.925L103.813 108.922L104.037 107.755C102.481 107.088 100.295 107.59 98.5061 108.967C96.5449 110.474 95.7124 112.465 96.8149 113.902C97.9474 115.379 99.4136 114.689 101.874 113.182C103.902 111.929 104.724 111.535 105.316 112.304C105.837 112.983 105.496 114.145 104.019 115.282C102.605 116.369 101.161 116.643 100.032 116.223L99.7587 117.333C101.075 117.854 102.946 117.46 104.634 116.163C106.557 114.689 107.142 112.773 106.171 111.509C105.099 110.114 103.569 110.842 101.529 112.102C99.1774 113.542 98.3674 113.954 97.6924 113.073C97.0699 112.263 97.7074 110.935 99.1436 109.833C100.406 108.863 102.157 108.256 103.813 108.922L103.812 108.925H103.82ZM87.1363 115.829L90.4476 123.202L86.5063 124.972L86.9451 125.947L95.9451 121.904L95.5063 120.929L91.5651 122.699L88.2538 115.327L87.1363 115.829ZM77.311 119.054L78.4998 118.769L80.6223 127.672L79.4335 127.957L77.311 119.054ZM62.6599 126.91C63.3874 128.677 65.1612 129.772 67.5424 129.667V129.663C70.5874 129.528 72.7924 127.45 72.6687 124.713C72.5487 121.975 70.1674 120.104 67.1224 120.239C64.7374 120.348 63.0724 121.593 62.5024 123.419L63.5449 123.91C64.0249 122.395 65.2699 121.42 67.1562 121.338C69.5374 121.233 71.3374 122.62 71.4312 124.773C71.5287 126.925 69.8599 128.467 67.4787 128.572C65.5962 128.654 64.2687 127.795 63.6537 126.329L62.6599 126.91ZM55.8048 124.038L48.8336 127.615L47.1123 127.259L52.8123 124.409L48.6086 118.221L50.2323 118.555L53.8436 123.891L56.0636 122.785L56.6636 119.875L57.8636 120.123L56.0186 129.089L54.8186 128.841L55.8086 124.034L55.8048 124.038ZM35.8102 114.164C34.8877 113.616 33.7552 113.879 33.1814 114.843L33.1852 114.839C32.6039 115.814 32.9189 116.935 33.8377 117.483C34.7677 118.038 35.9227 117.79 36.5039 116.815C37.0777 115.851 36.7402 114.719 35.8102 114.164ZM15.2676 106.417C13.7301 104.594 13.5163 102.524 14.4726 100.867L15.5376 101.302C14.7501 102.682 14.8813 104.26 16.0963 105.7C17.6338 107.523 19.8726 107.902 21.5188 106.514C23.1651 105.123 23.1688 102.854 21.6313 101.032C20.4126 99.5879 18.8826 99.1979 17.3901 99.7416L17.1426 98.6166C18.9351 97.9529 20.9413 98.5116 22.4788 100.334C24.4438 102.663 24.4138 105.693 22.3176 107.459C20.2213 109.225 17.2326 108.749 15.2676 106.42V106.417ZM8.73784 96.9314L8.73857 96.9329H8.73482L8.73784 96.9314ZM16.9398 92.8792L8.73784 96.9314L8.19482 95.8379L15.4398 92.2567L12.3611 86.0279L13.3211 85.5554L16.9398 92.8792ZM11.54 79.6865L11.8775 80.864L3.07627 83.384L2.73877 82.2065L11.54 79.6865ZM3.03871 65.3991C1.30621 66.2053 0.289958 68.024 0.499958 70.3978V70.4016C0.769958 73.4391 2.94121 75.5503 5.67121 75.3066C8.40121 75.0666 10.1675 72.6066 9.89746 69.5691C9.68746 67.1916 8.36746 65.5791 6.51871 65.0916L6.07621 66.1566C7.60996 66.5691 8.63746 67.7728 8.80621 69.6516C9.01621 72.0253 7.70746 73.8816 5.56246 74.0728C3.41746 74.2641 1.80121 72.6628 1.59121 70.2891C1.42246 68.4103 2.22496 67.0453 3.66121 66.3666L3.03871 65.3991ZM1.73395 51.6215L5.61284 58.4236L0.770195 57.6478L0.575195 58.8553L9.61269 60.3028L9.80769 59.0953L6.87519 58.6265L5.67144 56.459L10.8427 52.6115L11.1052 50.9765L5.10894 55.454L2.01145 49.8853L1.73395 51.6215ZM17.6938 32.8152C17.42 31.6377 16.8275 30.5652 15.9688 29.7214L15.2075 30.5877C15.965 31.3264 16.4488 32.2564 16.6625 33.2352L16.64 33.2502L13.2763 34.5139C13.79 33.0664 13.6138 31.6527 12.545 31.0077C11.5175 30.3889 10.145 30.6177 9.16627 32.2452C8.22502 33.8089 8.61502 35.2639 9.71752 35.9277C10.3063 36.2839 10.9175 36.3552 11.6338 36.2052C11.1425 37.6939 11.4313 39.0439 12.5338 39.7077C13.9325 40.5514 15.6238 39.8127 16.8275 37.8139C17.585 36.5577 17.9 35.2152 17.8363 33.9139C18.8263 33.4827 19.7225 32.9052 20.2963 31.8064L19.4113 31.2739C19.0363 31.9414 18.5788 32.3802 17.6938 32.8152ZM11.9863 31.9864C12.86 32.5114 12.7663 33.6589 12.1513 34.9264V34.9302C11.1913 35.2602 10.715 35.2114 10.2463 34.9302C9.60127 34.5402 9.37626 33.7039 9.95376 32.7439C10.5725 31.7164 11.3975 31.6302 11.9863 31.9864ZM16.7825 34.3489C16.7825 35.3164 16.5238 36.2914 15.9838 37.1877C15.17 38.5414 14.0075 39.1639 13.0888 38.6127C12.2788 38.1289 12.1213 37.1539 12.71 35.8564L16.7075 34.3789C16.7197 34.3688 16.7341 34.3652 16.7483 34.3617C16.7603 34.3587 16.7722 34.3558 16.7825 34.3489ZM74.2664 5.96906L81.2414 2.40281L82.9627 2.75906L77.2552 5.60156L81.4552 11.7966L79.8315 11.4591L76.2239 6.11531L74.0039 7.21781L73.4002 10.1278L72.2002 9.88031L74.0564 0.914062L75.2564 1.16156L74.2589 5.96906H74.2664ZM94.2575 15.8728C95.1762 16.4203 96.3125 16.1616 96.8862 15.1978C97.4675 14.2228 97.1562 13.1016 96.2375 12.5541C95.3037 11.9991 94.1487 12.2428 93.5675 13.2178C92.9937 14.1816 93.3275 15.3178 94.2575 15.8728Z" fill="black" style="fill:black;fill:black;fill-opacity:1;">',
  ),
  Nq = (n = {}) =>
    (() => {
      const e = ft(Pq);
      return (fn(e, n, !0, !0), An(), e);
    })(),
  Dq = xt(
    '<svg width="130" height="131" viewBox="0 0 130 131" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M106.966 23.8953C106.382 25.5946 107.087 27.3203 108.131 28.5335C109.318 29.9125 110.682 30.4815 111.458 29.8108C112.302 29.0836 111.846 28.2962 110.275 26.0166C108.899 24.0423 108.086 22.5427 109.427 21.3935C110.64 20.3498 112.596 20.8359 114.182 22.6821C115.576 24.306 116.07 26.1598 115.625 27.5049L114.498 27.2939C114.86 26.141 114.502 24.7054 113.334 23.3452C112.113 21.9286 110.93 21.646 110.278 22.2036C109.54 22.8366 109.981 23.6429 111.348 25.6097C112.995 27.9947 113.767 29.4265 112.347 30.6435C110.968 31.8304 108.926 31.1032 107.306 29.2155C105.829 27.4974 105.203 25.3309 105.787 23.7333L106.974 23.8953H106.966Z" fill="black" style="fill:black;fill:black;fill-opacity:1;"></path><path d="M123.374 36.5137C124.448 38.6538 124.169 40.7299 122.847 42.124L121.908 41.4495C123.001 40.2853 123.246 38.7179 122.398 37.0224C121.324 34.8822 119.23 33.9817 117.293 34.9538C115.356 35.9221 114.821 38.1414 115.895 40.2815C116.743 41.977 118.148 42.7193 119.734 42.5422L119.712 43.6989C117.805 43.925 115.974 42.9039 114.904 40.7638C113.533 38.0284 114.275 35.0744 116.739 33.8423C119.203 32.6102 122.01 33.782 123.382 36.5175L123.374 36.5137Z" fill="black" style="fill:black;fill:black;fill-opacity:1;"></path><path d="M118.815 50.4769L118.555 49.275L127.545 47.3232L128.765 52.9448C129.172 54.825 128.566 56.317 126.851 56.69C125.412 57.0028 124.316 56.2454 123.773 54.84L120.503 58.265L120.205 56.886L123.426 53.5364L122.582 49.6555L118.815 50.4731V50.4769ZM124.568 53.7888C124.847 55.0661 125.582 55.733 126.595 55.5107C127.609 55.2922 127.989 54.3804 127.71 53.1031L126.765 48.7437L123.622 49.4257L124.568 53.785V53.7888Z" fill="black" style="fill:black;fill:black;fill-opacity:1;"></path><path d="M125.039 73.0876C122.289 72.9745 120.397 70.6272 120.521 67.5564C120.646 64.4857 122.722 62.3003 125.476 62.4134C128.227 62.5264 130.118 64.8737 129.994 67.9445C129.869 71.0153 127.793 73.2006 125.039 73.0876ZM125.423 63.6567C123.261 63.5701 121.72 65.1978 121.622 67.6054C121.524 70.0093 122.925 71.7462 125.088 71.8367C127.251 71.9233 128.792 70.3069 128.89 67.9031C128.988 65.4992 127.586 63.7472 125.423 63.6605V63.6567Z" fill="black" style="fill:black;fill:black;fill-opacity:1;"></path><path d="M128.305 80.1528L127.955 81.3321L120.17 79.0187L118.181 85.7103L117.148 85.4051L119.488 77.5342L128.305 80.1566V80.1528Z" fill="black" style="fill:black;fill:black;fill-opacity:1;"></path><path d="M123.201 94.2594L122.587 95.3257L115.545 91.2791L112.067 97.3339L111.133 96.7989L115.225 89.6777L123.201 94.2594Z" fill="black" style="fill:black;fill:black;fill-opacity:1;"></path><path d="M109.266 112.932L105.724 115.788C103.32 117.725 100.6 117.616 98.8365 115.434C97.0731 113.253 97.5441 110.566 99.948 108.629L103.49 105.773L109.266 112.936V112.932ZM100.619 109.455C98.7649 110.95 98.4635 112.989 99.8048 114.654C101.157 116.331 103.203 116.459 105.068 114.956L107.661 112.864L103.222 107.36L100.619 109.458V109.455Z" fill="black" style="fill:black;fill:black;fill-opacity:1;"></path><path d="M84.3777 122.612C83.2699 120.091 84.5472 117.359 87.3618 116.12C90.1763 114.884 93.0512 115.788 94.1589 118.309C95.2667 120.83 93.9894 123.561 91.1748 124.797C88.3602 126.033 85.4854 125.129 84.3777 122.608V122.612ZM93.021 118.81C92.1507 116.828 90.0068 116.161 87.8026 117.13C85.5984 118.098 84.6527 120.125 85.5269 122.107C86.401 124.089 88.526 124.763 90.734 123.791C92.9381 122.823 93.8952 120.792 93.021 118.81Z" fill="black" style="fill:black;fill:black;fill-opacity:1;"></path><path d="M72.5714 129.707L68.9129 122.137L67.0553 130.408L65.7969 130.566L68.0086 121.011L69.4818 120.822L73.0914 128.309L74.7341 120.159L76.2073 119.971L80.7174 128.674L79.4477 128.836L75.5857 121.293L73.9165 129.537L72.5676 129.707H72.5714Z" fill="black" style="fill:black;fill:black;fill-opacity:1;"></path><path d="M51.371 119.451L52.4448 119.628L58.0626 128.355L59.3097 120.755L60.474 120.947L58.9819 130.024L57.6933 129.813L52.2489 121.377L51.0432 128.724L49.8789 128.532L51.371 119.455V119.451Z" fill="black" style="fill:black;fill:black;fill-opacity:1;"></path><path d="M34.7566 116.376C35.2992 115.389 36.4296 115.088 37.3715 115.608C38.3248 116.132 38.6978 117.258 38.1552 118.245C37.6051 119.244 36.4522 119.53 35.4989 119.006C34.5569 118.486 34.2028 117.375 34.7529 116.373L34.7566 116.376Z" fill="black" style="fill:black;fill:black;fill-opacity:1;"></path><path d="M24.466 107.959C24.9935 106.241 24.2324 104.542 23.151 103.359C21.9227 102.018 20.5399 101.498 19.7826 102.187C18.9612 102.941 19.4435 103.713 21.09 105.944C22.5293 107.873 23.3922 109.342 22.0885 110.537C20.9092 111.618 18.9424 111.2 17.2958 109.406C15.849 107.831 15.2951 105.993 15.6983 104.633L16.8324 104.81C16.5084 105.974 16.9115 107.398 18.1248 108.717C19.3907 110.096 20.5851 110.337 21.2181 109.757C21.934 109.097 21.4706 108.31 20.0388 106.388C18.3169 104.056 17.4993 102.651 18.8783 101.388C20.2197 100.16 22.2844 100.819 23.9649 102.651C25.4984 104.32 26.1954 106.464 25.6604 108.084L24.4698 107.959H24.466Z" fill="black" style="fill:black;fill:black;fill-opacity:1;"></path><path d="M7.65626 95.8908C6.51462 93.7846 6.72561 91.7048 7.99913 90.2693L8.95993 90.9135C7.90494 92.1117 7.71278 93.6904 8.61705 95.3558C9.7587 97.462 11.8837 98.2909 13.7865 97.2548C15.6892 96.2224 16.1527 93.9881 15.011 91.8819C14.1068 90.2165 12.6788 89.5195 11.1 89.7493L11.085 88.5926C12.984 88.3062 14.8452 89.2633 15.9869 91.3657C17.4488 94.0559 16.8045 97.0287 14.3818 98.3437C11.9629 99.6586 9.11817 98.5773 7.65626 95.8871V95.8908Z" fill="black" style="fill:black;fill:black;fill-opacity:1;"></path><path d="M11.749 81.7766L12.0504 82.971L3.12826 85.2166L1.72286 79.6365C1.25188 77.7714 1.80952 76.2605 3.51257 75.831C4.94057 75.4693 6.05962 76.1927 6.64739 77.5793L9.80105 74.0488L10.1439 75.4165L7.03548 78.8679L8.00381 82.7186L11.7452 81.7766H11.749ZM5.89006 78.6531C5.5698 77.3871 4.81624 76.7428 3.81023 76.999C2.80422 77.2515 2.45382 78.1746 2.77408 79.4406L3.86298 83.7622L6.98273 82.9785L5.89383 78.6531H5.89006Z" fill="black" style="fill:black;fill:black;fill-opacity:1;"></path><path d="M4.82747 59.3845C7.58174 59.4297 9.5297 61.728 9.48072 64.8026C9.43174 67.8771 7.40842 70.1114 4.65415 70.0662C1.89988 70.021 -0.0480783 67.7226 0.000903284 64.6481C0.0498848 61.5736 2.0732 59.3392 4.82747 59.3845ZM4.67299 68.8228C6.83948 68.8567 8.33907 67.1914 8.37675 64.7837C8.41443 62.3761 6.97136 60.6731 4.80486 60.6391C2.63837 60.6052 1.13878 62.2593 1.1011 64.6669C1.06343 67.0746 2.5065 68.7889 4.67299 68.8228Z" fill="black" style="fill:black;fill:black;fill-opacity:1;"></path><path d="M1.29688 52.433L1.6096 51.2424L9.46926 53.2996L11.2364 46.5439L12.2763 46.8152L10.1964 54.7615L1.29688 52.433Z" fill="black" style="fill:black;fill:black;fill-opacity:1;"></path><path d="M5.92188 38.1713L6.49835 37.0862L13.6723 40.8954L16.9465 34.7275L17.896 35.2324L14.0453 42.4855L5.92188 38.1713Z" fill="black" style="fill:black;fill:black;fill-opacity:1;"></path><path d="M19.2422 19.0471L22.686 16.0781C25.0258 14.0623 27.7499 14.0812 29.5811 16.2062C31.4122 18.3313 31.0317 21.029 28.6919 23.0448L25.2481 26.0138L19.2422 19.0471ZM27.9986 22.2385C29.8034 20.6824 30.037 18.6365 28.6391 17.0163C27.2337 15.3848 25.184 15.3245 23.3717 16.8882L20.8473 19.0622L25.4666 24.42L27.9986 22.2385Z" fill="black" style="fill:black;fill:black;fill-opacity:1;"></path><path d="M43.7985 8.55284C44.9892 11.0358 43.8061 13.8089 41.033 15.139C38.2598 16.469 35.3586 15.6589 34.1642 13.1759C32.9736 10.693 34.1567 7.91984 36.9298 6.58981C39.7029 5.25977 42.6041 6.06985 43.7985 8.55284ZM35.287 12.6371C36.2252 14.5889 38.3842 15.1842 40.5582 14.1443C42.7285 13.1006 43.6064 11.0471 42.6682 9.0954C41.73 7.14367 39.5823 6.54082 37.4083 7.58451C35.2381 8.62819 34.3489 10.6854 35.287 12.6371Z" fill="black" style="fill:black;fill:black;fill-opacity:1;"></path><path d="M55.374 1.07759L59.2774 8.52279L60.8637 0.199694L62.1146 0L60.2156 9.61922L58.7499 9.85283L54.8992 2.49052L53.524 10.6893L52.0583 10.9229L47.2656 2.37749L48.5316 2.17403L52.6348 9.58531L54.0326 1.29236L55.374 1.07759Z" fill="black" style="fill:black;fill:black;fill-opacity:1;"></path><path d="M76.8906 10.6366L75.8092 10.4934L69.9126 1.95931L68.9141 9.5929L67.7461 9.43842L68.9405 0.320312L70.2366 0.489864L75.9524 8.74137L76.9169 1.364L78.085 1.51848L76.8906 10.6366Z" fill="black" style="fill:black;fill:black;fill-opacity:1;"></path><path d="M93.6103 13.1607C93.1017 14.1667 91.9826 14.502 91.0218 14.016C90.0497 13.5224 89.639 12.4109 90.1515 11.4049C90.6677 10.3875 91.8093 10.0635 92.7814 10.5571C93.7422 11.0431 94.1303 12.1471 93.6141 13.1644L93.6103 13.1607Z" fill="black" style="fill:black;fill:black;fill-opacity:1;">',
  ),
  Gq = (n = {}) =>
    (() => {
      const e = ft(Dq);
      return (fn(e, n, !0, !0), An(), e);
    })(),
  Fq = xt(
    '<svg width="130" height="130" viewBox="0 0 130 130" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M69.5114 9.49239L64.5501 0.421143H64.5464L63.2076 0.443642L58.5464 9.67989L59.8476 9.65739L61.1414 7.09614L66.8414 6.99864L68.2101 9.51489L69.5114 9.49239ZM66.2676 5.93739L61.6926 6.01614L63.9126 1.62864L66.2676 5.93739ZM53.7724 1.23886L54.0312 2.27761L46.9512 4.02886L47.6262 6.76261L54.0012 5.18761L54.2599 6.22636L47.8849 7.80136L48.6349 10.8351L55.7149 9.08386L55.9737 10.1226L47.7312 12.1626L45.5337 3.27511L53.7762 1.23511L53.7724 1.23886ZM40.7185 15.1588L37.0923 7.93635L37.0885 7.9326L40.951 5.99385L40.471 5.0376L31.6548 9.46635L32.1348 10.4226L35.9973 8.48385L39.6235 15.7063L40.7185 15.1588ZM22.1977 16.4412L22.9589 17.1949L17.8327 22.3812L19.8352 24.3612L24.4514 19.6887L25.2127 20.4424L20.5964 25.1149L22.8202 27.3087L27.9464 22.1224L28.7077 22.8762L22.7414 28.9174L16.2314 22.4824L22.1977 16.4412ZM111.53 21.6051L107.776 29.7501L108.418 30.5414L117.155 28.5464L110.904 33.6126L111.65 34.5351L118.76 28.7714L117.598 27.3351L109.231 29.2439L112.839 21.4626L111.643 19.9851L104.533 25.7489L105.279 26.6714L111.53 21.6051ZM124.497 42.3012L125.469 41.8474H125.465L121.884 34.1487L113.585 38.0112L117.166 45.7099L118.137 45.2562L115.062 38.6449L117.894 37.3287L120.665 43.2799L121.636 42.8299L118.865 36.8787L121.419 35.6899L124.497 42.3012ZM129.042 55.4938L127.996 55.7226L126.436 48.5976L123.684 49.2013L125.09 55.6176L124.044 55.8463L122.637 49.4301L119.585 50.0976L121.145 57.2226L120.099 57.4513L118.28 49.1563L127.224 47.1951L129.042 55.4901V55.4938ZM120.414 65.8063L128.495 65.9375H128.499L128.427 70.2613L129.5 70.28L129.657 60.4138L128.585 60.395L128.514 64.715L120.432 64.5838L120.414 65.8063ZM124.805 86.4275L117.17 83.7762L117.571 82.6212L125.206 85.2725L126.624 81.1887L127.636 81.5412L124.4 90.8637L123.387 90.5112L124.805 86.4275ZM109.269 98.6788L116.99 103.595H116.994L117.646 102.575L114.365 100.486L118.077 94.6588L121.355 96.7476L122.011 95.7163L114.29 90.8L113.634 91.8313L117.17 94.0851L113.457 99.9126L109.921 97.6588L109.269 98.6788ZM107.011 114.249L106.261 113.484L111.47 108.376L109.498 106.366L104.81 110.964L104.06 110.199L108.748 105.601L106.561 103.37L101.353 108.478L100.603 107.713L106.666 101.769L113.075 108.305L107.011 114.249ZM88.4712 115.224L91.9812 122.506H91.9775L88.085 124.381L88.55 125.345L97.4375 121.062L96.9725 120.099L93.08 121.974L89.5737 114.691L88.4712 115.224ZM75.1888 128.934L74.9488 127.891L82.055 126.256L81.4213 123.511L75.0238 124.985L74.7838 123.943L81.1813 122.469L80.48 119.424L73.3738 121.059L73.1338 120.016L81.4063 118.111L83.4613 127.033L75.1888 128.938V128.934ZM59.5215 120.511L64.4752 129.586H64.479L65.8177 129.564L70.4902 120.331L69.189 120.354L67.8915 122.911L62.1915 123.005L60.8227 120.489L59.5215 120.511ZM62.769 124.066L67.344 123.991V123.995L65.1202 128.379L62.769 124.066ZM51.6536 118.809L53.4949 127.588L55.4936 119.795L56.6411 120.091L54.3649 128.956L52.5236 128.484L50.7836 120.088L45.1999 126.605L43.4111 126.144L45.6874 117.279L46.8349 117.575L44.8361 125.368L50.6636 118.558L51.6499 118.813L51.6536 118.809ZM34.4599 113.337C33.5524 112.764 32.4124 112.992 31.8124 113.941V113.937C31.2086 114.897 31.4899 116.026 32.3936 116.6C33.3086 117.181 34.4711 116.967 35.0786 116.007C35.6786 115.059 35.3749 113.919 34.4599 113.337ZM22.8013 100.932L19.175 109.137L25.3475 103.974L26.1088 104.885L19.0888 110.761L17.87 109.306L21.3538 101.469L13.0175 103.505L11.8325 102.087L18.8525 96.2112L19.6138 97.1187L13.4413 102.282L22.1488 100.152L22.805 100.936L22.8013 100.932ZM4.91504 89.1343L4.91357 89.135V89.1313L4.91504 89.1343ZM4.91504 89.1343L5.87732 88.6663L9.06108 95.2288L11.5961 93.9988L8.72732 88.0888L9.69107 87.62L12.5598 93.53L15.3723 92.165L12.1886 85.6025L13.1523 85.1338L16.8611 92.7763L8.62232 96.7738L4.91504 89.1343ZM1.12256 75.545L1.1234 75.5448L3.07256 83.8062L11.9826 81.7025L10.0326 73.4375L8.99006 73.685L10.6663 80.7838L7.62506 81.5L6.11756 75.11L5.07506 75.3575L6.58256 81.7475L3.84131 82.3962L2.16506 75.2975L1.1234 75.5448L1.12256 75.5413V75.545ZM9.56744 65.015L1.48619 65.1463L1.48994 65.1425L1.41869 60.8225L0.346191 60.8413L0.503692 70.7075L1.57619 70.6888L1.50494 66.3688L9.58619 66.2375L9.56744 65.015ZM4.86139 44.5363L12.5376 47.0638L12.1551 48.2263L4.47889 45.6988L3.12514 49.8051L2.10889 49.4713L5.19514 40.1001L6.21139 40.4338L4.85764 44.5401L4.86139 44.5363ZM20.1915 32.045L12.3952 27.2488L11.7615 28.28L15.0727 30.3163L11.454 36.2038L8.14272 34.1675L7.50146 35.21L15.2977 40.0063L15.939 38.9638L12.3652 36.7663L15.984 30.8788L19.5577 33.0763L20.1915 32.045ZM77.4688 10.9812L75.4851 2.2325L73.6101 10.055L72.4551 9.7775L74.5888 0.875L76.4376 1.3175L78.3126 9.6875L83.7876 3.08L85.5838 3.51125L83.4501 12.4137L82.2951 12.1362L84.1701 4.31375L78.4513 11.2175L77.4576 10.9812H77.4688ZM94.7524 16.175C95.6674 16.73 96.8036 16.4825 97.3886 15.5263L97.3849 15.53C97.9774 14.5625 97.6774 13.4375 96.7624 12.8788C95.8399 12.3125 94.6811 12.5488 94.0886 13.5163C93.5074 14.4725 93.8261 15.6088 94.7524 16.175Z" fill="black" style="fill:black;fill:black;fill-opacity:1;">',
  ),
  kq = (n = {}) =>
    (() => {
      const e = ft(Fq);
      return (fn(e, n, !0, !0), An(), e);
    })(),
  Oq = xt(
    '<svg width="134" height="134" viewBox="0 0 134 134" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M72.4318 11.8445L71.0993 11.6964L67.4995 2.491L68.7472 2.62974L71.8988 10.6816L76.7422 3.51871L77.9778 3.65609L72.4318 11.8445Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M84.6349 5.27246L82.1188 13.6541L80.9981 13.3177L83.5142 4.93604L84.6349 5.27246Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M90.9184 7.18172L98.178 10.8137L97.7199 11.7293L91.485 8.60995L90.2798 11.0189L95.8934 13.8274L95.4353 14.743L89.8217 11.9345L88.4856 14.6051L94.7206 17.7244L94.2625 18.64L87.0029 15.0081L90.9184 7.18172Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M108.618 18.0772L109.573 18.9471L106.352 26.2672L113.484 22.509L114.376 23.3215L106.096 27.6165L105.05 26.6645L108.242 19.4321L101.329 23.275L100.284 22.323L103.797 13.6864L104.698 14.5071L101.621 21.9586L108.618 18.0772Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M118.539 37.7494L115.227 39.3263L114.724 38.2699L122.625 34.5083L124.92 39.3284C125.716 41.0011 125.469 42.4956 123.962 43.2133C122.476 43.9206 121.127 43.1858 120.331 41.5131L118.539 37.7494ZM119.453 37.3146L121.218 41.0232C121.753 42.1457 122.573 42.5922 123.464 42.1679C124.355 41.7435 124.515 40.8307 123.98 39.7082L122.215 35.9996L119.453 37.3146Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M123.889 50.4104L120.299 51.1645L120.058 50.0194L128.623 48.2207L129.748 53.5764C130.123 55.3656 129.537 56.784 127.903 57.1272C126.531 57.4153 125.494 56.6866 124.989 55.3481L121.857 58.5838L121.582 57.2717L124.666 54.1081L123.889 50.4104ZM124.879 50.2025L125.751 54.3535C126.007 55.5701 126.701 56.2089 127.667 56.0059C128.634 55.803 129.001 54.9413 128.745 53.7247L127.873 49.5737L124.879 50.2025Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M131.278 67.9416C131.162 70.8645 129.188 72.9451 126.57 72.8411C123.951 72.7371 122.149 70.5065 122.265 67.5836C122.381 64.6608 124.355 62.5801 126.973 62.6841C129.592 62.7881 131.394 65.0187 131.278 67.9416ZM130.23 67.9C130.321 65.6104 128.984 63.9472 126.926 63.8654C124.868 63.7837 123.404 65.3356 123.313 67.6252C123.222 69.9148 124.559 71.5659 126.617 71.6476C128.675 71.7293 130.139 70.1896 130.23 67.9Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M122.957 84.8391C120.963 84.2764 120.048 82.3591 120.683 80.1069C121.22 78.2066 122.699 77.003 124.276 76.9794L124.509 78.1724C123.265 78.1379 122.084 78.9571 121.68 80.3882C121.23 81.9835 121.785 83.2926 123.31 83.7229L128.483 85.1827L128.166 86.3088L122.957 84.8391Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M125.943 92.7167L122.072 99.852L121.172 99.3639L124.497 93.2356L122.129 91.9513L119.136 97.4689L118.236 96.9807L121.229 91.4632L118.604 90.0394L115.28 96.1676L114.38 95.6795L118.25 88.5442L125.943 92.7167Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M115.655 102.063C117.61 103.808 117.559 106.703 115.619 108.876C114.101 110.576 112.169 111.057 110.473 110.376L110.74 109.308C112.153 109.867 113.628 109.533 114.829 108.187C116.347 106.486 116.405 104.316 114.868 102.945C113.331 101.573 111.182 101.876 109.664 103.577C108.463 104.923 108.298 106.425 109.013 107.766L107.981 108.152C107.113 106.544 107.372 104.57 108.89 102.87C110.83 100.697 113.7 100.318 115.655 102.063Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M100.338 120.504L103.733 118.15L99.3313 111.799L100.293 111.132L104.695 117.483L108.091 115.129L108.674 115.971L100.921 121.345L100.338 120.504Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M83.1666 121.537C84.1873 121.261 85.2241 121.858 85.4995 122.878C85.7749 123.899 85.1786 124.936 84.1579 125.211C83.1372 125.487 82.1003 124.891 81.8249 123.87C81.5496 122.849 82.1458 121.812 83.1666 121.537Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M62.9422 122.196L64.2774 122.317L68.0612 131.449L66.8109 131.335L63.4984 123.348L58.7997 130.607L57.5616 130.494L62.9422 122.196Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M50.8863 129.02L53.227 120.588L54.3545 120.901L52.0137 129.333L50.8863 129.02Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M44.5668 127.242L37.2337 123.761L37.6728 122.836L43.9709 125.826L45.126 123.393L39.4555 120.701L39.8946 119.776L45.5651 122.468L46.8456 119.77L40.5475 116.78L40.9866 115.855L48.3197 119.337L44.5668 127.242Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M26.6295 116.701L25.6572 115.85L28.7321 108.468L21.6762 112.367L20.7681 111.573L28.9614 107.113L30.0254 108.044L26.9792 115.339L33.8138 111.359L34.8779 112.29L31.537 120.995L30.6197 120.192L33.5479 112.681L26.6295 116.701Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M16.3209 97.2418L19.6001 95.5968L20.1248 96.6427L12.3026 100.567L9.90891 95.7947C9.07824 94.1388 9.29432 92.6396 10.7869 91.8909C12.2576 91.1531 13.6212 91.8599 14.4519 93.5159L16.3209 97.2418ZM15.4167 97.6953L13.575 94.0239C13.0176 92.9127 12.1885 92.4832 11.306 92.9258C10.4236 93.3685 10.283 94.2844 10.8405 95.3956L12.6822 99.0671L15.4167 97.6953Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M10.7114 84.7039L14.2851 83.8749L14.5495 85.0147L6.02474 86.9923L4.78806 81.6613C4.37492 79.8804 4.93146 78.45 6.55806 78.0727C7.92345 77.7559 8.97576 78.4627 9.50897 79.7904L12.572 76.4899L12.8749 77.7959L9.85754 81.0233L10.7114 84.7039ZM9.72591 84.9325L8.76742 80.8007C8.48648 79.5897 7.77867 78.9656 6.81696 79.1887C5.85525 79.4118 5.50636 80.281 5.78729 81.4921L6.74579 85.6239L9.72591 84.9325Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M2.96583 67.3513C3.02279 64.4267 4.95363 62.3066 7.57361 62.3576C10.1936 62.4086 12.0404 64.6023 11.9834 67.527C11.9265 70.4516 9.99564 72.5717 7.37565 72.5207C4.75567 72.4697 2.90886 70.2759 2.96583 67.3513ZM4.01382 67.3717C3.9692 69.6627 5.33925 71.2985 7.39868 71.3386C9.45811 71.3788 10.8908 69.7975 10.9354 67.5065C10.9801 65.2156 9.60978 63.5919 7.55035 63.5518C5.49092 63.5117 4.05844 65.0808 4.01382 67.3717Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M10.9413 50.2617C12.9467 50.7825 13.9021 52.6802 13.3139 54.9453C12.8176 56.8564 11.3637 58.0907 9.78753 58.1473L9.52932 56.9595C10.7738 56.9678 11.9374 56.1241 12.3111 54.6849C12.7278 53.0805 12.1454 51.7833 10.6118 51.385L5.40929 50.034L5.70339 48.9015L10.9413 50.2617Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M7.80094 42.4313L11.5243 35.2182L12.4341 35.6878L9.23622 41.8829L11.6297 43.1184L14.5089 37.5407L15.4187 38.0103L12.5395 43.588L15.193 44.9577L18.3908 38.7627L19.3006 39.2323L15.5772 46.4454L7.80094 42.4313Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M17.8995 32.8715C15.9101 31.1658 15.9039 28.2707 17.7999 26.0592C19.2834 24.3289 21.2057 23.8096 22.915 24.4562L22.6689 25.5297C21.2452 24.9994 19.7777 25.3627 18.6036 26.7322C17.1201 28.4625 17.1053 30.6332 18.669 31.9739C20.2328 33.3147 22.3758 32.9686 23.8593 31.2382C25.0334 29.8688 25.1685 28.3631 24.427 27.037L25.4503 26.6299C26.3504 28.2204 26.1307 30.1994 24.6472 31.9298C22.7511 34.1412 19.8889 34.5771 17.8995 32.8715Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M32.8345 14.1337L29.487 16.5556L34.0165 22.8163L33.0685 23.5021L28.539 17.2415L25.1914 19.6634L24.5913 18.8339L32.2344 13.3042L32.8345 14.1337Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M48.9769 12.1537C47.9731 12.4847 46.9052 11.9465 46.5741 10.9427C46.2431 9.93891 46.7813 8.87101 47.7851 8.53994C48.7889 8.20887 49.8568 8.74707 50.1878 9.75088C50.5189 10.7547 49.9807 11.8226 48.9769 12.1537Z" fill="black" style="fill:black;fill-opacity:1;">',
  ),
  Uq = (n = {}) =>
    (() => {
      const e = ft(Oq);
      return (fn(e, n, !0, !0), An(), e);
    })(),
  Hq = xt(
    '<svg width="130" height="130" viewBox="0 0 130 130" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M69.8826 9.93133C72.9314 10.1976 75.3501 8.42383 75.5901 5.69383C75.8301 2.96008 73.7526 0.79633 70.7039 0.53008C67.6551 0.26383 65.2364 2.03383 64.9964 4.76758C64.7564 7.50133 66.8339 9.66508 69.8826 9.93133ZM69.9764 8.84008C67.5876 8.63008 66.0389 7.02133 66.2264 4.87633C66.4139 2.73133 68.2176 1.41508 70.6064 1.62508C72.9951 1.83133 74.5326 3.43633 74.3451 5.58508C74.1576 7.73383 72.3651 9.05008 69.9764 8.84008ZM61.561 9.67999L60.3423 9.76624L59.686 0.638741L60.9048 0.55249L61.561 9.67999ZM53.1912 10.8313L51.3874 2.95254L55.6024 1.98879L55.3624 0.946289L45.7437 3.14754L45.9837 4.19004L50.1949 3.22629L51.9987 11.105L53.1912 10.8313ZM38.1389 6.10239C40.3026 5.09739 42.3576 5.43864 43.7039 6.79614L43.0026 7.71114C41.8776 6.58989 40.3214 6.29739 38.6114 7.09239C36.4476 8.09739 35.4951 10.1561 36.3989 12.1099C37.3026 14.0636 39.4964 14.6636 41.6601 13.6586C43.3701 12.8636 44.1539 11.4911 44.0226 9.90489L45.1739 9.96114C45.3426 11.8661 44.2739 13.6549 42.1101 14.6561C39.3464 15.9386 36.4326 15.1136 35.2776 12.6274C34.1226 10.1411 35.3714 7.38114 38.1351 6.09864L38.1389 6.10239ZM26.8308 12.9025L26.8285 12.9014H26.8323L26.8308 12.9025ZM26.8308 12.9025L36.1698 17.3414L35.1273 18.1214L32.5435 16.8876L27.9835 20.3076L28.4335 23.1426L27.3948 23.9226L25.7598 13.7039L26.8308 12.9025ZM31.4523 16.3701L27.7885 19.1151L27.016 14.2589L31.4523 16.3701ZM107.9 28.4562C106.861 27.2487 106.16 25.5312 106.741 23.8399H106.749L105.567 23.6787C104.986 25.2687 105.609 27.4249 107.079 29.1349C108.691 31.0137 110.724 31.7374 112.096 30.5562C113.51 29.3449 112.741 27.9199 111.102 25.5462C109.741 23.5887 109.302 22.7862 110.037 22.1562C110.686 21.6012 111.864 21.8824 113.079 23.2924C114.241 24.6462 114.597 26.0749 114.237 27.2225L115.359 27.4324C115.801 26.0937 115.31 24.2487 113.922 22.6324C112.344 20.7949 110.397 20.3112 109.19 21.3499C107.855 22.4937 108.665 23.9862 110.034 25.9512C111.597 28.2199 112.051 29.0037 111.211 29.7274C110.439 30.3949 109.081 29.8287 107.9 28.4562ZM122.758 38.1912L123.695 37.6737L123.691 37.67L119.581 30.2412L111.575 34.6737L115.685 42.1025L116.623 41.585L113.09 35.2062L115.824 33.695L119.004 39.44L119.941 38.9225L116.761 33.1775L119.225 31.8125L122.758 38.1912ZM128.056 50.2962L127.033 50.6112L124.891 43.6399L122.199 44.4687L124.126 50.7462L123.103 51.0612L121.175 44.7837L118.19 45.7024L120.331 52.6737L119.308 52.9887L116.814 44.8699L125.566 42.1812L128.06 50.2999L128.056 50.2962ZM129.65 60.9387L124.842 60.8599L124.846 60.8562C122.052 60.8112 120.346 62.3674 120.297 65.3749C120.249 68.3712 121.902 69.9912 124.696 70.0362L129.504 70.1149L129.522 68.8924L124.756 68.8137C122.6 68.7799 121.355 67.6737 121.392 65.3937C121.43 63.1137 122.709 62.0374 124.865 62.0712L129.631 62.1499L129.65 60.9387ZM122.99 73.6476C121.288 74.2026 120.339 75.7926 119.998 77.3488C119.608 79.1151 119.975 80.5401 120.973 80.7613C122.056 80.9976 122.409 80.1651 123.283 77.5476C124.033 75.2713 124.734 73.7301 126.455 74.1051C128.011 74.4463 128.795 76.2913 128.274 78.6538C127.816 80.7313 126.639 82.2351 125.3 82.6851L124.794 81.6613C125.926 81.2563 126.856 80.1163 127.239 78.3726C127.636 76.5538 127.153 75.4438 126.316 75.2601C125.371 75.0538 124.993 75.8826 124.246 78.1476C123.331 80.8851 122.656 82.3551 120.838 81.9538C119.071 81.5638 118.426 79.5051 118.955 77.0901C119.439 74.8851 120.785 73.0926 122.409 72.6013L122.99 73.6438V73.6476ZM114.969 89.0188L114.425 90.1138L122.63 94.1788L123.174 93.0801L114.969 89.0188ZM107.506 100.861L108.136 99.98L118.396 98.7875L112.156 94.34L112.839 93.3838L120.294 98.6975L119.54 99.7588L109.614 100.921L115.648 105.219L114.965 106.175L107.51 100.861H107.506ZM93.4326 112.899L102.733 117.417V117.414L103.813 116.619L102.26 106.389L101.214 107.161L101.641 110L97.0514 113.382L94.4789 112.126L93.4326 112.899ZM98.1389 113.911L101.825 111.196V111.192L102.556 116.056L98.1389 113.911ZM91.3662 124.122C89.195 125.109 87.1437 124.752 85.8087 123.384L86.5175 122.476C87.635 123.609 89.1837 123.912 90.905 123.132C93.0762 122.146 94.0475 120.095 93.1587 118.134C92.27 116.172 90.0837 115.554 87.9125 116.54C86.195 117.32 85.4 118.689 85.52 120.275L84.3687 120.207C84.2187 118.302 85.2987 116.521 87.47 115.535C90.245 114.275 93.1512 115.126 94.2837 117.624C95.4162 120.121 94.145 122.866 91.37 124.126L91.3662 124.122ZM76.3588 119.263L78.0913 127.156L78.0951 127.16L73.8726 128.086L74.1013 129.132L83.7388 127.014L83.5101 125.967L79.2876 126.894L77.5551 119L76.3588 119.263ZM67.9849 120.346L69.2074 120.268L69.7924 129.406L68.5699 129.485L67.9849 120.346ZM59.6601 120.031C56.6151 119.739 54.1814 121.49 53.9189 124.22C53.6601 126.95 55.7189 129.129 58.7639 129.421C61.8089 129.714 64.2464 127.963 64.5051 125.233C64.7639 122.503 62.7051 120.324 59.6601 120.031ZM59.5551 121.119C61.9401 121.348 63.4776 122.968 63.2714 125.113L63.2751 125.109C63.0689 127.254 61.2539 128.555 58.8689 128.326C56.4801 128.101 54.9614 126.481 55.1639 124.336C55.3664 122.191 57.1701 120.89 59.5551 121.119ZM42.9727 116.083L44.0002 116.428L48.1214 125.896L50.5627 118.633L51.6727 119.008L48.7552 127.685L47.5214 127.273L43.5239 118.115L41.1652 125.135L40.0552 124.76L42.9727 116.083ZM32.9638 112.359C32.0788 111.759 30.9313 111.95 30.3013 112.88C29.6638 113.821 29.9076 114.958 30.7963 115.558C31.6963 116.165 32.8626 115.985 33.5001 115.048C34.1301 114.118 33.8601 112.966 32.9638 112.359ZM23.5998 106.505L23.601 106.501L24.781 106.655C25.351 105.058 24.7098 102.909 23.2248 101.21C21.601 99.3463 19.561 98.6376 18.196 99.8301C16.7935 101.053 17.5735 102.47 19.231 104.833C20.6073 106.779 21.0535 107.578 20.3223 108.215C19.6773 108.778 18.496 108.508 17.2698 107.105C16.096 105.763 15.7323 104.338 16.081 103.186L14.956 102.984C14.521 104.326 15.0273 106.168 16.4298 107.773C18.0235 109.595 19.9698 110.064 21.1698 109.014C22.4973 107.859 21.676 106.374 20.2885 104.42C18.706 102.163 18.241 101.383 19.0773 100.651C19.846 99.9801 21.2073 100.531 22.3998 101.896C23.449 103.095 24.165 104.808 23.601 106.501L23.5998 106.501V106.505ZM7.46744 92.2849L6.53369 92.8099V92.8174L10.7074 100.209L18.6762 95.7086L14.5024 88.3174L13.5687 88.8424L17.1537 95.1911L14.4349 96.7249L11.2099 91.0061L10.2762 91.5311L13.5049 97.2499L11.0524 98.6336L7.46744 92.2849ZM2.06381 80.2251L3.08381 79.9026L5.28506 86.8588L7.97381 86.0076L5.99381 79.7451L7.01381 79.4226L8.99381 85.6851L11.9713 84.7438L9.77006 77.7876L10.7901 77.4651L13.3513 85.5613L4.62131 88.3213L2.06006 80.2251H2.06381ZM0.496347 69.7175L5.30385 69.6387C8.0976 69.5937 9.7551 67.985 9.70635 64.9775C9.6576 61.9812 7.95135 60.4137 5.1576 60.4587L0.350098 60.5375L0.368847 61.76L5.1351 61.6812C7.29135 61.6475 8.5701 62.7087 8.6076 64.9925C8.64135 67.2762 7.4001 68.3937 5.24385 68.4275L0.477598 68.5062L0.496347 69.7175ZM6.9387 56.8399C8.6337 56.2736 9.5712 54.6724 9.9012 53.1124C10.2762 51.3424 9.89745 49.9211 8.89995 49.7074C7.8162 49.4786 7.46745 50.3186 6.6162 52.9399C5.8887 55.2236 5.19495 56.7686 3.4737 56.4086C1.9137 56.0786 1.11495 54.2449 1.61745 51.8749C2.0562 49.7936 3.22245 48.2786 4.55745 47.8174L5.0712 48.8374C3.94245 49.2499 3.0237 50.3974 2.65245 52.1449C2.2662 53.9674 2.76495 55.0736 3.6012 55.2499C4.54995 55.4486 4.9212 54.6161 5.6487 52.3474C6.5412 49.6024 7.20495 48.1286 9.0237 48.5111C10.7937 48.8861 11.4575 50.9411 10.9437 53.3599C10.4787 55.5686 9.14745 57.3724 7.52745 57.8786L6.9387 56.8436V56.8399ZM14.8325 41.4051L15.365 40.3026L7.12625 36.3088L6.59375 37.4113L14.8325 41.4051ZM22.1973 29.4912L21.5748 30.38L11.326 31.655L17.6035 36.05L16.9323 37.01L9.43604 31.76L10.1823 30.695L20.0973 29.45L14.0298 25.2012L14.701 24.2412L22.1973 29.4912ZM86.5964 13.7337L85.5651 13.3962L81.3651 3.96118L78.9839 11.2437L77.8701 10.8799L80.7126 2.17993L81.9501 2.58493L86.0226 11.7087L88.3214 4.66618L89.4351 5.02993L86.5926 13.7299L86.5964 13.7337ZM96.6316 17.3713C97.5241 17.9638 98.6679 17.7613 99.2904 16.8275L99.2866 16.8313C99.9166 15.8863 99.6616 14.75 98.7691 14.1575C97.8691 13.5575 96.7028 13.745 96.0728 14.69C95.4541 15.6238 95.7279 16.7713 96.6316 17.3713Z" fill="black" style="fill:black;fill:black;fill-opacity:1;">',
  ),
  Wq = (n = {}) =>
    (() => {
      const e = ft(Hq);
      return (fn(e, n, !0, !0), An(), e);
    })(),
  Vq = xt(
    '<svg width="130" height="130" viewBox="0 0 130 130" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M106.742 23.8399C106.16 25.5312 106.862 27.2487 107.9 28.4562C109.082 29.8287 110.439 30.3949 111.212 29.7274C112.052 29.0037 111.598 28.2199 110.034 25.9512C108.665 23.9862 107.855 22.4937 109.19 21.3499C110.398 20.3112 112.344 20.7949 113.923 22.6324C115.31 24.2487 115.802 26.0937 115.359 27.4324L114.238 27.2224C114.598 26.0749 114.242 24.6462 113.079 23.2924C111.864 21.8824 110.687 21.6012 110.038 22.1562C109.303 22.7862 109.742 23.5887 111.103 25.5462C112.742 27.9199 113.51 29.3449 112.097 30.5562C110.724 31.7374 108.692 31.0137 107.079 29.1349C105.609 27.4249 104.987 25.2687 105.568 23.6787L106.749 23.8399H106.742Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M123.073 36.3988C124.141 38.5288 123.864 40.595 122.548 41.9825L121.614 41.3113C122.701 40.1525 122.945 38.5925 122.101 36.905C121.033 34.775 118.948 33.8788 117.02 34.8463C115.093 35.81 114.56 38.0188 115.629 40.1488C116.473 41.8363 117.871 42.575 119.45 42.3988L119.428 43.55C117.53 43.775 115.708 42.7588 114.643 40.6288C113.278 37.9063 114.016 34.9663 116.469 33.74C118.921 32.5138 121.715 33.68 123.08 36.4025L123.073 36.3988Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M118.535 50.2962L118.276 49.1L127.224 47.1575L128.439 52.7525C128.844 54.6237 128.24 56.1087 126.534 56.48C125.101 56.7912 124.01 56.0375 123.47 54.6387L120.215 58.0475L119.919 56.675L123.125 53.3412L122.285 49.4787L118.535 50.2925V50.2962ZM124.261 53.5962C124.539 54.8675 125.27 55.5312 126.279 55.31C127.288 55.0925 127.666 54.185 127.389 52.9137L126.448 48.575L123.32 49.2537L124.261 53.5925V53.5962Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M124.73 72.8C121.993 72.6875 120.11 70.3513 120.234 67.295C120.358 64.2388 122.424 62.0638 125.165 62.1763C127.903 62.2888 129.785 64.625 129.661 67.6813C129.538 70.7375 127.471 72.9125 124.73 72.8ZM125.116 63.41C122.964 63.3238 121.43 64.9438 121.333 67.34C121.235 69.7325 122.63 71.4613 124.783 71.5513C126.935 71.6375 128.469 70.0288 128.566 67.6363C128.664 65.2438 127.269 63.5 125.116 63.4138V63.41Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M127.978 79.8312L127.629 81.005L119.882 78.7025L117.902 85.3625L116.874 85.0587L119.203 77.225L127.978 79.835V79.8312Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M122.9 93.8713L122.289 94.9325L115.28 90.905L111.819 96.9313L110.889 96.3988L114.961 89.3113L122.9 93.8713Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M109.033 112.456L105.508 115.299C103.115 117.226 100.408 117.118 98.6527 114.946C96.8977 112.775 97.3665 110.101 99.759 108.174L103.284 105.331L109.033 112.46V112.456ZM100.423 108.995C98.5777 110.484 98.2777 112.513 99.6127 114.17C100.959 115.839 102.995 115.966 104.851 114.47L107.431 112.389L103.014 106.91L100.423 108.999V108.995Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M84.2601 122.09C83.1576 119.581 84.4288 116.862 87.2301 115.629C90.0313 114.399 92.8926 115.299 93.9951 117.807C95.0976 120.316 93.8263 123.035 91.0251 124.265C88.2238 125.495 85.3626 124.595 84.2601 122.086V122.09ZM92.8663 118.31C92.0001 116.337 89.8663 115.674 87.6726 116.637C85.4788 117.601 84.5376 119.619 85.4076 121.591C86.2776 123.564 88.3926 124.235 90.5901 123.267C92.7838 122.304 93.7363 120.282 92.8663 118.31Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M72.5076 129.151L68.8664 121.618L67.0176 129.849L65.7651 130.006L67.9664 120.496L69.4326 120.309L73.0251 127.76L74.6601 119.649L76.1264 119.461L80.6151 128.124L79.3514 128.285L75.5076 120.778L73.8464 128.983L72.5039 129.151H72.5076Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M51.4103 118.944L52.479 119.12L58.0703 127.805L59.3115 120.241L60.4703 120.432L58.9853 129.466L57.7028 129.256L52.284 120.86L51.084 128.172L49.9253 127.981L51.4103 118.947V118.944Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M31.5354 118.985L35.7316 112.078L36.7779 112.711L32.5816 119.619L36.2754 121.861L35.7204 122.776L27.2866 117.654L27.8416 116.739L31.5354 118.981V118.985Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M18.8602 103.726C20.7952 101.784 23.7915 101.979 25.959 104.142C28.1265 106.302 28.329 109.299 26.3902 111.237C24.4552 113.18 21.459 112.985 19.2915 110.821C17.124 108.661 16.9215 105.665 18.8602 103.726ZM25.5165 110.364C27.039 108.837 26.8815 106.61 25.1865 104.919C23.4877 103.224 21.2715 103.085 19.749 104.611C18.2265 106.137 18.3727 108.354 20.0715 110.049C21.7702 111.744 23.9977 111.894 25.5202 110.367L25.5165 110.364Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M12.9127 91.9288C13.9702 90.485 13.8089 88.6363 13.1752 87.1738C12.4552 85.5125 11.3264 84.5713 10.3889 84.9763C9.37266 85.415 9.57142 86.3 10.3927 88.9325C11.1164 91.2163 11.4464 92.8813 9.83391 93.5788C8.37141 94.2125 6.65767 93.1738 5.69767 90.95C4.85017 88.9963 4.92892 87.0875 5.75017 85.94L6.75891 86.4763C6.07641 87.4663 5.99016 88.9363 6.69891 90.575C7.43766 92.285 8.48392 92.9 9.26767 92.5625C10.1564 92.1763 9.97642 91.2838 9.26017 89.0113C8.40142 86.2588 8.09017 84.6688 9.79642 83.93C11.4577 83.21 13.1864 84.5038 14.1689 86.7763C15.0652 88.8463 15.0202 91.0888 13.9927 92.4388L12.9127 91.9325V91.9288Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M0.590332 71.4838L1.64783 71.3038L2.87033 78.4925L5.64908 78.02L4.55033 71.5475L5.60783 71.3675L6.70658 77.84L9.78533 77.3188L8.56283 70.1263L9.62033 69.9463L11.0416 78.32L2.01533 79.8538L0.594082 71.48L0.590332 71.4838Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M0.893926 55.9625L1.96268 56.0375L1.45268 63.3125L4.26518 63.5113L4.72643 56.96L5.79518 57.035L5.33393 63.5863L8.45018 63.8038L8.96018 56.5288L10.0289 56.6038L9.43643 65.075L0.305176 64.4338L0.897676 55.9625H0.893926Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M13.6326 43.9362L13.1076 45.0425L4.83887 41.12L7.29137 35.9487C8.11262 34.22 9.49637 33.41 11.0751 34.16C12.3989 34.79 12.8039 36.05 12.3764 37.4862L17.0339 36.7737L16.4339 38.0412L11.8626 38.7237L10.1676 42.2937L13.6364 43.94L13.6326 43.9362ZM11.1126 37.8275C11.6714 36.6537 11.4951 35.6825 10.5614 35.24C9.62762 34.7975 8.77637 35.2812 8.22137 36.4587L6.32012 40.4675L9.21137 41.84L11.1126 37.8312V37.8275Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M17.8441 20.6562L18.6729 21.335L14.0529 26.9788L16.2316 28.7638L20.3941 23.6825L21.2229 24.3612L17.0604 29.4425L19.4791 31.4225L24.0991 25.7788L24.9279 26.4575L19.5466 33.0275L12.4629 27.2262L17.8441 20.6562Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M32.1954 12.4438L31.6929 13.4975C30.3654 12.6238 28.7754 12.6613 27.2566 13.7825C25.3179 15.215 24.8116 17.4013 26.0904 19.13C27.3804 20.8738 29.6154 21.0425 31.5204 19.6325C33.1704 18.4138 33.8941 16.4975 32.9716 15.1663L29.3641 17.8363L28.7266 16.9738L33.2041 13.6625L36.0316 17.4838L35.1091 18.1663L34.1604 16.8838C34.2841 17.9975 33.6054 19.4338 32.1691 20.5138C29.6979 22.34 26.7204 22.085 25.0816 19.8725C23.4429 17.66 24.1179 14.735 26.5966 12.8975C28.5016 11.4875 30.6054 11.39 32.1879 12.44L32.1954 12.4438Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M41.8777 14.6112L40.7714 15.1362L36.8564 6.85996L37.9627 6.33496L41.8777 14.6075V14.6112Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M55.5578 5.50253C56.2216 8.16128 54.5116 10.625 51.5416 11.3675C48.5716 12.11 45.9053 10.7375 45.2378 8.07878C44.5703 5.42003 46.2841 2.95253 49.2541 2.21378C52.2241 1.47128 54.8903 2.84378 55.5578 5.50253ZM46.4416 7.77878C46.9628 9.87128 48.9503 10.8838 51.2791 10.3025C53.6078 9.72128 54.8716 7.89503 54.3466 5.80253C53.8216 3.71003 51.8491 2.69378 49.5241 3.27503C47.1991 3.85628 45.9203 5.68628 46.4416 7.77878Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M70.4715 9.65751L69.3878 9.63876L62.589 1.86501L62.4653 9.52626L61.2915 9.50751L61.4378 0.35376L62.739 0.37626L69.324 7.89126L69.444 0.485009L70.6178 0.50376L70.4715 9.65751Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M76.3515 7.47495C76.824 9.19995 78.369 10.2237 79.9065 10.64C81.654 11.1125 83.094 10.8125 83.3602 9.82995C83.649 8.75745 82.8315 8.36745 80.259 7.36995C78.0202 6.51495 76.5127 5.7387 76.9702 4.03995C77.3865 2.50245 79.2615 1.80495 81.6015 2.43495C83.6565 2.98995 85.104 4.2387 85.4902 5.5962L84.444 6.0537C84.0952 4.90245 83.0002 3.91995 81.2752 3.45495C79.479 2.9712 78.3465 3.40245 78.1215 4.22745C77.8702 5.1612 78.6802 5.5812 80.9077 6.43245C83.5965 7.47495 85.0327 8.21745 84.549 10.0137C84.0765 11.7612 81.9915 12.3087 79.6027 11.6637C77.424 11.075 75.699 9.6462 75.2827 8.0037L76.3515 7.4712V7.47495Z" fill="black" style="fill:black;fill-opacity:1;"></path><path d="M99.5116 16.985C98.8853 17.915 97.7378 18.1138 96.8491 17.5175C95.9491 16.9138 95.6791 15.7625 96.3016 14.8325C96.9353 13.8913 98.1016 13.7075 99.0016 14.3113C99.8903 14.9075 100.142 16.0438 99.5078 16.9888L99.5116 16.985Z" fill="black" style="fill:black;fill-opacity:1;">',
  ),
  Zq = (n = {}) =>
    (() => {
      const e = ft(Vq);
      return (fn(e, n, !0, !0), An(), e);
    })();
var o_ = () => {},
  Dx = (n, e) => e();
function zq(n, e) {
  const t = zt(n),
    i = t ? [t] : [],
    { onEnter: r = Dx, onExit: s = Dx } = e,
    [o, a] = Jt(e.appear ? [] : i),
    [l] = I7();
  let c,
    u = !1;
  function h(g, p) {
    if (!g) return p && p();
    ((u = !0),
      s(g, () => {
        qA(() => {
          ((u = !1), a((m) => m.filter((C) => C !== g)), p && p());
        });
      }));
  }
  function d(g) {
    const p = c;
    if (!p) return g && g();
    ((c = void 0), a((m) => [p, ...m]), r(p, g ?? o_));
  }
  const f =
    e.mode === "out-in"
      ? (g) => u || h(g, d)
      : e.mode === "in-out"
        ? (g) => d(() => h(g))
        : (g) => {
            (h(g), d());
          };
  return (
    QA(
      (g) => {
        const p = n();
        return zt(l)
          ? (l(), g)
          : (p !== g && ((c = p), qA(() => zt(() => f(g)))), p);
      },
      e.appear ? void 0 : t,
    ),
    o
  );
}
function Yq(n, e) {
  const t = zt(n),
    { onChange: i } = e;
  let r = new Set(e.appear ? void 0 : t);
  const s = new WeakSet(),
    [o, a] = Jt([], { equals: !1 }),
    [l] = I7(),
    c =
      e.exitMethod === "remove"
        ? o_
        : (h) => {
            a((d) => (d.push.apply(d, h), d));
            for (const d of h) s.delete(d);
          },
    u =
      e.exitMethod === "remove"
        ? o_
        : e.exitMethod === "keep-index"
          ? (h, d, f) => h.splice(f, 0, d)
          : (h, d) => h.push(d);
  return pe(
    (h) => {
      const d = o(),
        f = n();
      if ((f[rm], zt(l))) return (l(), h);
      if (d.length) {
        const g = h.filter((p) => !d.includes(p));
        return (
          (d.length = 0),
          i({
            list: g,
            added: [],
            removed: [],
            unchanged: g,
            finishRemoved: c,
          }),
          g
        );
      }
      return zt(() => {
        const g = new Set(f),
          p = f.slice(),
          m = [],
          C = [],
          A = [];
        for (const y of f) (r.has(y) ? A : m).push(y);
        let I = !m.length;
        for (let y = 0; y < h.length; y++) {
          const x = h[y];
          (g.has(x) || (s.has(x) || (C.push(x), s.add(x)), u(p, x, y)),
            I && x !== p[y] && (I = !1));
        }
        return !C.length && I
          ? h
          : (i({
              list: p,
              added: m,
              removed: C,
              unchanged: A,
              finishRemoved: c,
            }),
            (r = g),
            p);
      });
    },
    e.appear ? [] : t.slice(),
  );
}
function Xq(n) {
  return (...e) => {
    for (const t of n) t && t(...e);
  };
}
function Kq(...n) {
  return Xq(n);
}
var Zm = (n) => n instanceof Element;
function a_(n, e) {
  if (e(n)) return n;
  if (typeof n == "function" && !n.length) return a_(n(), e);
  if (Array.isArray(n)) {
    const t = [];
    for (const i of n) {
      const r = a_(i, e);
      r && (Array.isArray(r) ? t.push.apply(t, r) : t.push(r));
    }
    return t.length ? t : null;
  }
  return null;
}
function jq(n, e = Zm, t = Zm) {
  const i = pe(n),
    r = pe(() => a_(i(), e));
  return (
    (r.toArray = () => {
      const s = r();
      return Array.isArray(s) ? s : s ? [s] : [];
    }),
    r
  );
}
function l_(n, e) {
  if (e(n)) return n;
  if (typeof n == "function" && !n.length) return l_(n(), e);
  if (Array.isArray(n))
    for (const t of n) {
      const i = l_(t, e);
      if (i) return i;
    }
  return null;
}
function $q(n, e = Zm, t = Zm) {
  const i = pe(n);
  return pe(() => l_(i(), e));
}
function FL(n) {
  return pe(() => {
    const e = n.name || "s";
    return {
      enterActive: (n.enterActiveClass || e + "-enter-active").split(" "),
      enter: (n.enterClass || e + "-enter").split(" "),
      enterTo: (n.enterToClass || e + "-enter-to").split(" "),
      exitActive: (n.exitActiveClass || e + "-exit-active").split(" "),
      exit: (n.exitClass || e + "-exit").split(" "),
      exitTo: (n.exitToClass || e + "-exit-to").split(" "),
      move: (n.moveClass || e + "-move").split(" "),
    };
  });
}
function kL(n) {
  requestAnimationFrame(() => requestAnimationFrame(n));
}
function OL(n, e, t, i) {
  const { onBeforeEnter: r, onEnter: s, onAfterEnter: o } = e;
  (r?.(t),
    t.classList.add(...n.enter),
    t.classList.add(...n.enterActive),
    queueMicrotask(() => {
      if (!t.parentNode) return i?.();
      s?.(t, () => a());
    }),
    kL(() => {
      (t.classList.remove(...n.enter),
        t.classList.add(...n.enterTo),
        (!s || s.length < 2) &&
          (t.addEventListener("transitionend", a),
          t.addEventListener("animationend", a)));
    }));
  function a(l) {
    (!l || l.target === t) &&
      (i?.(),
      t.removeEventListener("transitionend", a),
      t.removeEventListener("animationend", a),
      t.classList.remove(...n.enterActive),
      t.classList.remove(...n.enterTo),
      o?.(t));
  }
}
function UL(n, e, t, i) {
  const { onBeforeExit: r, onExit: s, onAfterExit: o } = e;
  if (!t.parentNode) return i?.();
  (r?.(t),
    t.classList.add(...n.exit),
    t.classList.add(...n.exitActive),
    s?.(t, () => a()),
    kL(() => {
      (t.classList.remove(...n.exit),
        t.classList.add(...n.exitTo),
        (!s || s.length < 2) &&
          (t.addEventListener("transitionend", a),
          t.addEventListener("animationend", a)));
    }));
  function a(l) {
    (!l || l.target === t) &&
      (i?.(),
      t.removeEventListener("transitionend", a),
      t.removeEventListener("animationend", a),
      t.classList.remove(...n.exitActive),
      t.classList.remove(...n.exitTo),
      o?.(t));
  }
}
var Jq = { inout: "in-out", outin: "out-in" },
  Qq = (n) => {
    const e = FL(n);
    return zq(
      $q(() => n.children),
      {
        mode: Jq[n.mode],
        appear: n.appear,
        onEnter(t, i) {
          OL(e(), n, t, i);
        },
        onExit(t, i) {
          UL(e(), n, t, i);
        },
      },
    );
  },
  ome = (n) => {
    const e = FL(n);
    return Yq(jq(() => n.children).toArray, {
      appear: n.appear,
      exitMethod: "keep-index",
      onChange({ added: t, removed: i, finishRemoved: r, list: s }) {
        const o = e();
        for (const l of t) OL(o, n, l);
        const a = [];
        for (const l of s)
          l.isConnected &&
            (l instanceof HTMLElement || l instanceof SVGElement) &&
            a.push({ el: l, rect: l.getBoundingClientRect() });
        queueMicrotask(() => {
          const l = [];
          for (const { el: c, rect: u } of a)
            if (c.isConnected) {
              const h = c.getBoundingClientRect(),
                d = u.left - h.left,
                f = u.top - h.top;
              (d || f) &&
                ((c.style.transform = `translate(${d}px, ${f}px)`),
                (c.style.transitionDuration = "0s"),
                l.push(c));
            }
          document.body.offsetHeight;
          for (const c of l) {
            let u = function (h) {
              (h.target === c || /transform$/.test(h.propertyName)) &&
                (c.removeEventListener("transitionend", u),
                c.classList.remove(...o.move));
            };
            (c.classList.add(...o.move),
              (c.style.transform = c.style.transitionDuration = ""),
              c.addEventListener("transitionend", u));
          }
        });
        for (const l of i) UL(o, n, l, () => r([l]));
      },
    });
  };
let xi = (function (n) {
  return (
    (n[(n.Article = 0)] = "Article"),
    (n[(n.CaseStudy = 1)] = "CaseStudy"),
    (n[(n.ContactUs = 2)] = "ContactUs"),
    (n[(n.Showreel = 3)] = "Showreel"),
    (n[(n.ClickAndStick = 4)] = "ClickAndStick"),
    (n[(n.ComingSoon = 5)] = "ComingSoon"),
    (n[(n.MeetTheTeam = 6)] = "MeetTheTeam"),
    (n[(n.SeeUsInAction = 7)] = "SeeUsInAction"),
    (n[(n.ScrollDown = 8)] = "ScrollDown"),
    (n[(n.Project = 9)] = "Project"),
    (n[(n.Regions = 10)] = "Regions"),
    n
  );
})({});
const qq = {
    [xi.Article]: xq,
    [xi.CaseStudy]: Sq,
    [xi.ContactUs]: Eq,
    [xi.Showreel]: Lq,
    [xi.ClickAndStick]: Nq,
    [xi.ComingSoon]: Bq,
    [xi.MeetTheTeam]: kq,
    [xi.SeeUsInAction]: Wq,
    [xi.ScrollDown]: Gq,
    [xi.Project]: Uq,
    [xi.Regions]: Zq,
  },
  eee = () => {
    const n = Dn([0, 0]),
      e = Dn(
        { type: xi.ContactUs, isDraggable: !1 },
        (r, s) => r.type === s.type && r.isDraggable === s.isDraggable,
      ),
      t = pe(() => Zc() != null && n()[0] !== 0 && n()[1] !== 0);
    let i;
    return (
      Ct(() => {
        Zc() == null
          ? dn(() => {
              clearTimeout(i);
            })
          : e(Zc());
      }),
      [
        G(Wd, {
          onMouseMove: (r) => {
            n([r.clientX, r.clientY]);
          },
          onMouseEnter: (r) => {
            n([r.clientX, r.clientY]);
          },
        }),
        G(Qq, {
          name: "fade",
          appear: !0,
          get children() {
            return G(Hl, {
              get when() {
                return t();
              },
              keyed: !0,
              get children() {
                return G($.Generic, {
                  get style() {
                    return {
                      transform: `translate(calc(-50% + ${n()[0]}px), calc(-50% + ${n()[1]}px))`,
                      ...(e().type !== xi.ContactUs && {
                        mixBlendMode: "difference",
                      }),
                    };
                  },
                  css: [
                    {
                      pointerEvents: "none",
                      position: "fixed",
                      zIndex: "50",
                      height: "144rem",
                      width: "144rem",
                    },
                    {
                      "svg:last-child": {
                        position: "absolute",
                        left: "7.5rem",
                        top: "7.5rem",
                        height: "auto",
                        width: "129.44rem",
                        animation: "cursor-spin 10s linear infinite",
                      },
                      "@keyframes cursor-spin": {
                        "0%": { transform: "rotate(0deg)" },
                        "100%": { transform: "rotate(360deg)" },
                      },
                      "&.fade-exit-to, &.fade-enter": { opacity: "0" },
                      "&.fade-exit-active, &.fade-enter-active": {
                        transitionProperty: "opacity",
                        transitionTimingFunction:
                          "cubic-bezier(0.68, 0, 0.1, 1.9)",
                        transitionDuration: "1s",
                      },
                      "&.fade-exit-to .transformer, &.fade-enter .transformer":
                        {
                          "--tw-scale-x": "0",
                          "--tw-scale-y": "0",
                          transform:
                            "translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))",
                        },
                      "&.fade-exit-active .transformer, &.fade-enter-active .transformer":
                        {
                          transitionProperty: "transform",
                          transitionTimingFunction:
                            "cubic-bezier(0.68, 0, 0.1, 1.9)",
                          transitionDuration: "1s",
                        },
                    },
                  ],
                  as: "div",
                  get children() {
                    return G($.Generic, {
                      class: "transformer",
                      css: {
                        display: "flex",
                        alignItems: "center",
                        justifyContent: "center",
                      },
                      as: "div",
                      get children() {
                        return [
                          G($.Generic, {
                            css: { height: "auto", width: "144rem" },
                            as: bq,
                          }),
                          G($.Generic, {
                            get css() {
                              return [
                                {
                                  position: "absolute",
                                  "--tw-text-opacity": "1",
                                  color:
                                    "rgb(255 255 255 / var(--tw-text-opacity))",
                                  opacity: "0",
                                  mixBlendMode: "difference",
                                  transitionProperty: "opacity",
                                  transitionTimingFunction:
                                    "cubic-bezier(0.4, 0, 0.2, 1)",
                                  transitionDuration: "500ms",
                                },
                                nt.sohne.body3,
                                { ...(e().isDraggable && { opacity: "1" }) },
                              ];
                            },
                            as: "div",
                            children: " Drag ",
                          }),
                          pe(() =>
                            pe(() => e() == null)()
                              ? null
                              : (() => {
                                  const r = qq[e().type];
                                  return G(r, {});
                                })(),
                          ),
                        ];
                      },
                    });
                  },
                });
              },
            });
          },
        }),
      ]
    );
  },
  tee = [16, 32, 48, 64, 96, 128, 256, 384, 640, 750, 828, 1080, 1200, 1920],
  nee = (n) => {
    const [e, t] = Dr(n, [
      "src",
      "isEager",
      "width",
      "height",
      "sizes",
      "isHidden",
      "quality",
      "onLoad",
      "ref",
      "shouldDisableAutoplay",
      "shouldOptimizeVercel",
      "isInvisible",
    ]);
    let { src: i } = e,
      r,
      s;
    if (
      (e.sizes &&
        (s = Object.entries(e.sizes)
          .map(([u, h]) => (u === "-1" ? h : `(max-width: ${u}px) ${h}`))
          .join(", ")),
      i == null)
    )
      return (console.error("Image src is null"), null);
    i.startsWith("https://cdn.local/") &&
      (r = tee
        .map((u) => `${B9(i, u, 100, e.shouldOptimizeVercel)} ${u}w`)
        .join(", "));
    const o = pe(() => B9(i, 1080, 100, e.shouldOptimizeVercel)),
      [a, l] = Jt(!1);
    let c = null;
    return (
      Ct(() => {
        c.complete && l(!0);
      }),
      G(
        $.Generic,
        jn(
          {
            onLoad: () => {
              (e.onLoad?.(), l(!0));
            },
            ref: (u) => {
              (e.ref?.(u), (c = u));
            },
            css: {
              transitionProperty: "opacity",
              transitionTimingFunction: "cubic-bezier(0.4, 0, 0.2, 1)",
              transitionDuration: "500ms",
            },
            as: "img",
            get style() {
              return {
                ...(e.isInvisible && { visibility: "hidden" }),
                opacity: a() && !e.isHidden ? 1 : 0,
              };
            },
            get loading() {
              return e.isEager ? "eager" : "lazy";
            },
            crossOrigin: "anonymous",
            get src() {
              return pe(() => !!i.startsWith("/"))() ? i : o();
            },
            get height() {
              return e.height;
            },
            get width() {
              return e.width;
            },
            sizes: s,
            srcSet: r,
          },
          t,
        ),
      )
    );
  };
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const Mv = "176",
  iee = 0,
  Gx = 1,
  ree = 2,
  HL = 1,
  see = 2,
  sa = 3,
  Go = 0,
  er = 1,
  Ao = 2,
  wl = 0,
  Ph = 1,
  c_ = 2,
  Fx = 3,
  kx = 4,
  oee = 5,
  Fc = 100,
  aee = 101,
  lee = 102,
  cee = 103,
  uee = 104,
  hee = 200,
  dee = 201,
  fee = 202,
  gee = 203,
  u_ = 204,
  h_ = 205,
  pee = 206,
  mee = 207,
  Cee = 208,
  Iee = 209,
  Aee = 210,
  yee = 211,
  _ee = 212,
  bee = 213,
  vee = 214,
  d_ = 0,
  f_ = 1,
  g_ = 2,
  rd = 3,
  p_ = 4,
  m_ = 5,
  C_ = 6,
  I_ = 7,
  WL = 0,
  xee = 1,
  wee = 2,
  Sl = 0,
  See = 1,
  Tee = 2,
  Eee = 3,
  Mee = 4,
  Lee = 5,
  Ree = 6,
  Bee = 7,
  Ox = "attached",
  Pee = "detached",
  VL = 300,
  sd = 301,
  od = 302,
  A_ = 303,
  y_ = 304,
  rI = 306,
  ad = 1e3,
  xo = 1001,
  zm = 1002,
  gi = 1003,
  ZL = 1004,
  Ff = 1005,
  Yr = 1006,
  F0 = 1007,
  ga = 1008,
  Fo = 1009,
  zL = 1010,
  YL = 1011,
  Lg = 1012,
  Lv = 1013,
  gu = 1014,
  Xr = 1015,
  wp = 1016,
  Rv = 1017,
  Bv = 1018,
  Rg = 1020,
  XL = 35902,
  KL = 1021,
  jL = 1022,
  Sr = 1023,
  Bg = 1026,
  Pg = 1027,
  Pv = 1028,
  Nv = 1029,
  $L = 1030,
  Dv = 1031,
  Gv = 1033,
  k0 = 33776,
  O0 = 33777,
  U0 = 33778,
  H0 = 33779,
  __ = 35840,
  b_ = 35841,
  v_ = 35842,
  x_ = 35843,
  w_ = 36196,
  S_ = 37492,
  T_ = 37496,
  E_ = 37808,
  M_ = 37809,
  L_ = 37810,
  R_ = 37811,
  B_ = 37812,
  P_ = 37813,
  N_ = 37814,
  D_ = 37815,
  G_ = 37816,
  F_ = 37817,
  k_ = 37818,
  O_ = 37819,
  U_ = 37820,
  H_ = 37821,
  W0 = 36492,
  W_ = 36494,
  V_ = 36495,
  JL = 36283,
  Z_ = 36284,
  z_ = 36285,
  Y_ = 36286,
  X_ = 2200,
  Nee = 2201,
  Dee = 2202,
  Ng = 2300,
  Dg = 2301,
  I2 = 2302,
  Ih = 2400,
  Ah = 2401,
  Ym = 2402,
  Fv = 2500,
  Gee = 2501,
  Fee = 0,
  QL = 1,
  K_ = 2,
  kee = 3200,
  Oee = 3201,
  qL = 0,
  Uee = 1,
  dl = "",
  Gi = "srgb",
  Ir = "srgb-linear",
  Xm = "linear",
  mn = "srgb",
  Gu = 7680,
  Ux = 519,
  Hee = 512,
  Wee = 513,
  Vee = 514,
  eR = 515,
  Zee = 516,
  zee = 517,
  Yee = 518,
  Xee = 519,
  j_ = 35044,
  Hx = "300 es",
  pa = 2e3,
  Km = 2001;
class wu {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    (i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t));
  }
  hasEventListener(e, t) {
    const i = this._listeners;
    return i === void 0 ? !1 : i[e] !== void 0 && i[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    const i = this._listeners;
    if (i === void 0) return;
    const r = i[e];
    if (r !== void 0) {
      const s = r.indexOf(t);
      s !== -1 && r.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    const t = this._listeners;
    if (t === void 0) return;
    const i = t[e.type];
    if (i !== void 0) {
      e.target = this;
      const r = i.slice(0);
      for (let s = 0, o = r.length; s < o; s++) r[s].call(this, e);
      e.target = null;
    }
  }
}
const Hi = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let Wx = 1234567;
const tg = Math.PI / 180,
  ld = 180 / Math.PI;
function Js() {
  const n = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    i = (Math.random() * 4294967295) | 0;
  return (
    Hi[n & 255] +
    Hi[(n >> 8) & 255] +
    Hi[(n >> 16) & 255] +
    Hi[(n >> 24) & 255] +
    "-" +
    Hi[e & 255] +
    Hi[(e >> 8) & 255] +
    "-" +
    Hi[((e >> 16) & 15) | 64] +
    Hi[(e >> 24) & 255] +
    "-" +
    Hi[(t & 63) | 128] +
    Hi[(t >> 8) & 255] +
    "-" +
    Hi[(t >> 16) & 255] +
    Hi[(t >> 24) & 255] +
    Hi[i & 255] +
    Hi[(i >> 8) & 255] +
    Hi[(i >> 16) & 255] +
    Hi[(i >> 24) & 255]
  ).toLowerCase();
}
function Wt(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
function kv(n, e) {
  return ((n % e) + e) % e;
}
function Kee(n, e, t, i, r) {
  return i + ((n - e) * (r - i)) / (t - e);
}
function jee(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0;
}
function ng(n, e, t) {
  return (1 - t) * n + t * e;
}
function $ee(n, e, t, i) {
  return ng(n, e, 1 - Math.exp(-t * i));
}
function Jee(n, e = 1) {
  return e - Math.abs(kv(n, e * 2) - e);
}
function Qee(n, e, t) {
  return n <= e
    ? 0
    : n >= t
      ? 1
      : ((n = (n - e) / (t - e)), n * n * (3 - 2 * n));
}
function qee(n, e, t) {
  return n <= e
    ? 0
    : n >= t
      ? 1
      : ((n = (n - e) / (t - e)), n * n * n * (n * (n * 6 - 15) + 10));
}
function ete(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1));
}
function tte(n, e) {
  return n + Math.random() * (e - n);
}
function nte(n) {
  return n * (0.5 - Math.random());
}
function ite(n) {
  n !== void 0 && (Wx = n);
  let e = (Wx += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function rte(n) {
  return n * tg;
}
function ste(n) {
  return n * ld;
}
function ote(n) {
  return (n & (n - 1)) === 0 && n !== 0;
}
function ate(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function lte(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function cte(n, e, t, i, r) {
  const s = Math.cos,
    o = Math.sin,
    a = s(t / 2),
    l = o(t / 2),
    c = s((e + i) / 2),
    u = o((e + i) / 2),
    h = s((e - i) / 2),
    d = o((e - i) / 2),
    f = s((i - e) / 2),
    g = o((i - e) / 2);
  switch (r) {
    case "XYX":
      n.set(a * u, l * h, l * d, a * c);
      break;
    case "YZY":
      n.set(l * d, a * u, l * h, a * c);
      break;
    case "ZXZ":
      n.set(l * h, l * d, a * u, a * c);
      break;
    case "XZX":
      n.set(a * u, l * g, l * f, a * c);
      break;
    case "YXY":
      n.set(l * f, a * u, l * g, a * c);
      break;
    case "ZYZ":
      n.set(l * g, l * f, a * u, a * c);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          r,
      );
  }
}
function zs(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return n / 4294967295;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int32Array:
      return Math.max(n / 2147483647, -1);
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function gn(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return Math.round(n * 4294967295);
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int32Array:
      return Math.round(n * 2147483647);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const zc = {
  DEG2RAD: tg,
  RAD2DEG: ld,
  generateUUID: Js,
  clamp: Wt,
  euclideanModulo: kv,
  mapLinear: Kee,
  inverseLerp: jee,
  lerp: ng,
  damp: $ee,
  pingpong: Jee,
  smoothstep: Qee,
  smootherstep: qee,
  randInt: ete,
  randFloat: tte,
  randFloatSpread: nte,
  seededRandom: ite,
  degToRad: rte,
  radToDeg: ste,
  isPowerOfTwo: ote,
  ceilPowerOfTwo: ate,
  floorPowerOfTwo: lte,
  setQuaternionFromProperEuler: cte,
  normalize: gn,
  denormalize: zs,
};
class Gt {
  constructor(e = 0, t = 0) {
    ((Gt.prototype.isVector2 = !0), (this.x = e), (this.y = t));
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return ((this.x = e), (this.y = t), this);
  }
  setScalar(e) {
    return ((this.x = e), (this.y = e), this);
  }
  setX(e) {
    return ((this.x = e), this);
  }
  setY(e) {
    return ((this.y = e), this);
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return ((this.x = e.x), (this.y = e.y), this);
  }
  add(e) {
    return ((this.x += e.x), (this.y += e.y), this);
  }
  addScalar(e) {
    return ((this.x += e), (this.y += e), this);
  }
  addVectors(e, t) {
    return ((this.x = e.x + t.x), (this.y = e.y + t.y), this);
  }
  addScaledVector(e, t) {
    return ((this.x += e.x * t), (this.y += e.y * t), this);
  }
  sub(e) {
    return ((this.x -= e.x), (this.y -= e.y), this);
  }
  subScalar(e) {
    return ((this.x -= e), (this.y -= e), this);
  }
  subVectors(e, t) {
    return ((this.x = e.x - t.x), (this.y = e.y - t.y), this);
  }
  multiply(e) {
    return ((this.x *= e.x), (this.y *= e.y), this);
  }
  multiplyScalar(e) {
    return ((this.x *= e), (this.y *= e), this);
  }
  divide(e) {
    return ((this.x /= e.x), (this.y /= e.y), this);
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      r = e.elements;
    return (
      (this.x = r[0] * t + r[3] * i + r[6]),
      (this.y = r[1] * t + r[4] * i + r[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Wt(this.x, e.x, t.x)),
      (this.y = Wt(this.y, e.y, t.y)),
      this
    );
  }
  clampScalar(e, t) {
    return ((this.x = Wt(this.x, e, t)), (this.y = Wt(this.y, e, t)), this);
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Wt(i, e, t));
  }
  floor() {
    return ((this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this);
  }
  ceil() {
    return ((this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this);
  }
  round() {
    return ((this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this);
  }
  roundToZero() {
    return ((this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this);
  }
  negate() {
    return ((this.x = -this.x), (this.y = -this.y), this);
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(Wt(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y;
    return t * t + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return ((this.x = e[t]), (this.y = e[t + 1]), this);
  }
  toArray(e = [], t = 0) {
    return ((e[t] = this.x), (e[t + 1] = this.y), e);
  }
  fromBufferAttribute(e, t) {
    return ((this.x = e.getX(t)), (this.y = e.getY(t)), this);
  }
  rotateAround(e, t) {
    const i = Math.cos(t),
      r = Math.sin(t),
      s = this.x - e.x,
      o = this.y - e.y;
    return (
      (this.x = s * i - o * r + e.x),
      (this.y = s * r + o * i + e.y),
      this
    );
  }
  random() {
    return ((this.x = Math.random()), (this.y = Math.random()), this);
  }
  *[Symbol.iterator]() {
    (yield this.x, yield this.y);
  }
}
class Pt {
  constructor(e, t, i, r, s, o, a, l, c) {
    ((Pt.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, i, r, s, o, a, l, c));
  }
  set(e, t, i, r, s, o, a, l, c) {
    const u = this.elements;
    return (
      (u[0] = e),
      (u[1] = r),
      (u[2] = a),
      (u[3] = t),
      (u[4] = s),
      (u[5] = l),
      (u[6] = i),
      (u[7] = o),
      (u[8] = c),
      this
    );
  }
  identity() {
    return (this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this);
  }
  copy(e) {
    const t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      i.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      r = t.elements,
      s = this.elements,
      o = i[0],
      a = i[3],
      l = i[6],
      c = i[1],
      u = i[4],
      h = i[7],
      d = i[2],
      f = i[5],
      g = i[8],
      p = r[0],
      m = r[3],
      C = r[6],
      A = r[1],
      I = r[4],
      y = r[7],
      x = r[2],
      T = r[5],
      S = r[8];
    return (
      (s[0] = o * p + a * A + l * x),
      (s[3] = o * m + a * I + l * T),
      (s[6] = o * C + a * y + l * S),
      (s[1] = c * p + u * A + h * x),
      (s[4] = c * m + u * I + h * T),
      (s[7] = c * C + u * y + h * S),
      (s[2] = d * p + f * A + g * x),
      (s[5] = d * m + f * I + g * T),
      (s[8] = d * C + f * y + g * S),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      u = e[8];
    return (
      t * o * u - t * a * c - i * s * u + i * a * l + r * s * c - r * o * l
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      u = e[8],
      h = u * o - a * c,
      d = a * l - u * s,
      f = c * s - o * l,
      g = t * h + i * d + r * f;
    if (g === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const p = 1 / g;
    return (
      (e[0] = h * p),
      (e[1] = (r * c - u * i) * p),
      (e[2] = (a * i - r * o) * p),
      (e[3] = d * p),
      (e[4] = (u * t - r * l) * p),
      (e[5] = (r * s - a * t) * p),
      (e[6] = f * p),
      (e[7] = (i * l - c * t) * p),
      (e[8] = (o * t - i * s) * p),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, i, r, s, o, a) {
    const l = Math.cos(s),
      c = Math.sin(s);
    return (
      this.set(
        i * l,
        i * c,
        -i * (l * o + c * a) + o + e,
        -r * c,
        r * l,
        -r * (-c * o + l * a) + a + t,
        0,
        0,
        1,
      ),
      this
    );
  }
  scale(e, t) {
    return (this.premultiply(A2.makeScale(e, t)), this);
  }
  rotate(e) {
    return (this.premultiply(A2.makeRotation(-e)), this);
  }
  translate(e, t) {
    return (this.premultiply(A2.makeTranslation(e, t)), this);
  }
  makeTranslation(e, t) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return (this.set(t, -i, 0, i, t, 0, 0, 0, 1), this);
  }
  makeScale(e, t) {
    return (this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this);
  }
  equals(e) {
    const t = this.elements,
      i = e.elements;
    for (let r = 0; r < 9; r++) if (t[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const A2 = new Pt();
function tR(n) {
  for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return !0;
  return !1;
}
function Gg(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
function ute() {
  const n = Gg("canvas");
  return ((n.style.display = "block"), n);
}
const Vx = {};
function V0(n) {
  n in Vx || ((Vx[n] = !0), console.warn(n));
}
function hte(n, e, t) {
  return new Promise(function (i, r) {
    function s() {
      switch (n.clientWaitSync(e, n.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case n.WAIT_FAILED:
          r();
          break;
        case n.TIMEOUT_EXPIRED:
          setTimeout(s, t);
          break;
        default:
          i();
      }
    }
    setTimeout(s, t);
  });
}
function dte(n) {
  const e = n.elements;
  ((e[2] = 0.5 * e[2] + 0.5 * e[3]),
    (e[6] = 0.5 * e[6] + 0.5 * e[7]),
    (e[10] = 0.5 * e[10] + 0.5 * e[11]),
    (e[14] = 0.5 * e[14] + 0.5 * e[15]));
}
function fte(n) {
  const e = n.elements;
  e[11] === -1
    ? ((e[10] = -e[10] - 1), (e[14] = -e[14]))
    : ((e[10] = -e[10]), (e[14] = -e[14] + 1));
}
const Zx = new Pt().set(
    0.4123908,
    0.3575843,
    0.1804808,
    0.212639,
    0.7151687,
    0.0721923,
    0.0193308,
    0.1191948,
    0.9505322,
  ),
  zx = new Pt().set(
    3.2409699,
    -1.5373832,
    -0.4986108,
    -0.9692436,
    1.8759675,
    0.0415551,
    0.0556301,
    -0.203977,
    1.0569715,
  );
function gte() {
  const n = {
      enabled: !0,
      workingColorSpace: Ir,
      spaces: {},
      convert: function (r, s, o) {
        return (
          this.enabled === !1 ||
            s === o ||
            !s ||
            !o ||
            (this.spaces[s].transfer === mn &&
              ((r.r = Sa(r.r)), (r.g = Sa(r.g)), (r.b = Sa(r.b))),
            this.spaces[s].primaries !== this.spaces[o].primaries &&
              (r.applyMatrix3(this.spaces[s].toXYZ),
              r.applyMatrix3(this.spaces[o].fromXYZ)),
            this.spaces[o].transfer === mn &&
              ((r.r = Nh(r.r)), (r.g = Nh(r.g)), (r.b = Nh(r.b)))),
          r
        );
      },
      fromWorkingColorSpace: function (r, s) {
        return this.convert(r, this.workingColorSpace, s);
      },
      toWorkingColorSpace: function (r, s) {
        return this.convert(r, s, this.workingColorSpace);
      },
      getPrimaries: function (r) {
        return this.spaces[r].primaries;
      },
      getTransfer: function (r) {
        return r === dl ? Xm : this.spaces[r].transfer;
      },
      getLuminanceCoefficients: function (r, s = this.workingColorSpace) {
        return r.fromArray(this.spaces[s].luminanceCoefficients);
      },
      define: function (r) {
        Object.assign(this.spaces, r);
      },
      _getMatrix: function (r, s, o) {
        return r.copy(this.spaces[s].toXYZ).multiply(this.spaces[o].fromXYZ);
      },
      _getDrawingBufferColorSpace: function (r) {
        return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace;
      },
      _getUnpackColorSpace: function (r = this.workingColorSpace) {
        return this.spaces[r].workingColorSpaceConfig.unpackColorSpace;
      },
    },
    e = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06],
    t = [0.2126, 0.7152, 0.0722],
    i = [0.3127, 0.329];
  return (
    n.define({
      [Ir]: {
        primaries: e,
        whitePoint: i,
        transfer: Xm,
        toXYZ: Zx,
        fromXYZ: zx,
        luminanceCoefficients: t,
        workingColorSpaceConfig: { unpackColorSpace: Gi },
        outputColorSpaceConfig: { drawingBufferColorSpace: Gi },
      },
      [Gi]: {
        primaries: e,
        whitePoint: i,
        transfer: mn,
        toXYZ: Zx,
        fromXYZ: zx,
        luminanceCoefficients: t,
        outputColorSpaceConfig: { drawingBufferColorSpace: Gi },
      },
    }),
    n
  );
}
const Kt = gte();
function Sa(n) {
  return n < 0.04045
    ? n * 0.0773993808
    : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
function Nh(n) {
  return n < 0.0031308 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
let Fu;
class pte {
  static getDataURL(e, t = "image/png") {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let i;
    if (e instanceof HTMLCanvasElement) i = e;
    else {
      (Fu === void 0 && (Fu = Gg("canvas")),
        (Fu.width = e.width),
        (Fu.height = e.height));
      const r = Fu.getContext("2d");
      (e instanceof ImageData
        ? r.putImageData(e, 0, 0)
        : r.drawImage(e, 0, 0, e.width, e.height),
        (i = Fu));
    }
    return i.toDataURL(t);
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const t = Gg("canvas");
      ((t.width = e.width), (t.height = e.height));
      const i = t.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const r = i.getImageData(0, 0, e.width, e.height),
        s = r.data;
      for (let o = 0; o < s.length; o++) s[o] = Sa(s[o] / 255) * 255;
      return (i.putImageData(r, 0, 0), t);
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let i = 0; i < t.length; i++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[i] = Math.floor(Sa(t[i] / 255) * 255))
          : (t[i] = Sa(t[i]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.",
        ),
        e
      );
  }
}
let mte = 0;
class Ov {
  constructor(e = null) {
    ((this.isSource = !0),
      Object.defineProperty(this, "id", { value: mte++ }),
      (this.uuid = Js()),
      (this.data = e),
      (this.dataReady = !0),
      (this.version = 0));
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const i = { uuid: this.uuid, url: "" },
      r = this.data;
    if (r !== null) {
      let s;
      if (Array.isArray(r)) {
        s = [];
        for (let o = 0, a = r.length; o < a; o++)
          r[o].isDataTexture ? s.push(y2(r[o].image)) : s.push(y2(r[o]));
      } else s = y2(r);
      i.url = s;
    }
    return (t || (e.images[this.uuid] = i), i);
  }
}
function y2(n) {
  return (typeof HTMLImageElement < "u" && n instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && n instanceof ImageBitmap)
    ? pte.getDataURL(n)
    : n.data
      ? {
          data: Array.from(n.data),
          width: n.width,
          height: n.height,
          type: n.data.constructor.name,
        }
      : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let Cte = 0,
  Oi = class Z0 extends wu {
    constructor(
      e = Z0.DEFAULT_IMAGE,
      t = Z0.DEFAULT_MAPPING,
      i = xo,
      r = xo,
      s = Yr,
      o = ga,
      a = Sr,
      l = Fo,
      c = Z0.DEFAULT_ANISOTROPY,
      u = dl,
    ) {
      (super(),
        (this.isTexture = !0),
        Object.defineProperty(this, "id", { value: Cte++ }),
        (this.uuid = Js()),
        (this.name = ""),
        (this.source = new Ov(e)),
        (this.mipmaps = []),
        (this.mapping = t),
        (this.channel = 0),
        (this.wrapS = i),
        (this.wrapT = r),
        (this.magFilter = s),
        (this.minFilter = o),
        (this.anisotropy = c),
        (this.format = a),
        (this.internalFormat = null),
        (this.type = l),
        (this.offset = new Gt(0, 0)),
        (this.repeat = new Gt(1, 1)),
        (this.center = new Gt(0, 0)),
        (this.rotation = 0),
        (this.matrixAutoUpdate = !0),
        (this.matrix = new Pt()),
        (this.generateMipmaps = !0),
        (this.premultiplyAlpha = !1),
        (this.flipY = !0),
        (this.unpackAlignment = 4),
        (this.colorSpace = u),
        (this.userData = {}),
        (this.version = 0),
        (this.onUpdate = null),
        (this.renderTarget = null),
        (this.isRenderTargetTexture = !1),
        (this.isTextureArray = !1),
        (this.pmremVersion = 0));
    }
    get image() {
      return this.source.data;
    }
    set image(e = null) {
      this.source.data = e;
    }
    updateMatrix() {
      this.matrix.setUvTransform(
        this.offset.x,
        this.offset.y,
        this.repeat.x,
        this.repeat.y,
        this.rotation,
        this.center.x,
        this.center.y,
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return (
        (this.name = e.name),
        (this.source = e.source),
        (this.mipmaps = e.mipmaps.slice(0)),
        (this.mapping = e.mapping),
        (this.channel = e.channel),
        (this.wrapS = e.wrapS),
        (this.wrapT = e.wrapT),
        (this.magFilter = e.magFilter),
        (this.minFilter = e.minFilter),
        (this.anisotropy = e.anisotropy),
        (this.format = e.format),
        (this.internalFormat = e.internalFormat),
        (this.type = e.type),
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        (this.rotation = e.rotation),
        (this.matrixAutoUpdate = e.matrixAutoUpdate),
        this.matrix.copy(e.matrix),
        (this.generateMipmaps = e.generateMipmaps),
        (this.premultiplyAlpha = e.premultiplyAlpha),
        (this.flipY = e.flipY),
        (this.unpackAlignment = e.unpackAlignment),
        (this.colorSpace = e.colorSpace),
        (this.renderTarget = e.renderTarget),
        (this.isRenderTargetTexture = e.isRenderTargetTexture),
        (this.isTextureArray = e.isTextureArray),
        (this.userData = JSON.parse(JSON.stringify(e.userData))),
        (this.needsUpdate = !0),
        this
      );
    }
    toJSON(e) {
      const t = e === void 0 || typeof e == "string";
      if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
      const i = {
        metadata: {
          version: 4.6,
          type: "Texture",
          generator: "Texture.toJSON",
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(e).uuid,
        mapping: this.mapping,
        channel: this.channel,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        internalFormat: this.internalFormat,
        type: this.type,
        colorSpace: this.colorSpace,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        generateMipmaps: this.generateMipmaps,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment,
      };
      return (
        Object.keys(this.userData).length > 0 && (i.userData = this.userData),
        t || (e.textures[this.uuid] = i),
        i
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    transformUv(e) {
      if (this.mapping !== VL) return e;
      if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
        switch (this.wrapS) {
          case ad:
            e.x = e.x - Math.floor(e.x);
            break;
          case xo:
            e.x = e.x < 0 ? 0 : 1;
            break;
          case zm:
            Math.abs(Math.floor(e.x) % 2) === 1
              ? (e.x = Math.ceil(e.x) - e.x)
              : (e.x = e.x - Math.floor(e.x));
            break;
        }
      if (e.y < 0 || e.y > 1)
        switch (this.wrapT) {
          case ad:
            e.y = e.y - Math.floor(e.y);
            break;
          case xo:
            e.y = e.y < 0 ? 0 : 1;
            break;
          case zm:
            Math.abs(Math.floor(e.y) % 2) === 1
              ? (e.y = Math.ceil(e.y) - e.y)
              : (e.y = e.y - Math.floor(e.y));
            break;
        }
      return (this.flipY && (e.y = 1 - e.y), e);
    }
    set needsUpdate(e) {
      e === !0 && (this.version++, (this.source.needsUpdate = !0));
    }
    set needsPMREMUpdate(e) {
      e === !0 && this.pmremVersion++;
    }
  };
Oi.DEFAULT_IMAGE = null;
Oi.DEFAULT_MAPPING = VL;
Oi.DEFAULT_ANISOTROPY = 1;
class ln {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    ((ln.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      (this.w = r));
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, i, r) {
    return ((this.x = e), (this.y = t), (this.z = i), (this.w = r), this);
  }
  setScalar(e) {
    return ((this.x = e), (this.y = e), (this.z = e), (this.w = e), this);
  }
  setX(e) {
    return ((this.x = e), this);
  }
  setY(e) {
    return ((this.y = e), this);
  }
  setZ(e) {
    return ((this.z = e), this);
  }
  setW(e) {
    return ((this.w = e), this);
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x),
      (this.y += e.y),
      (this.z += e.z),
      (this.w += e.w),
      this
    );
  }
  addScalar(e) {
    return ((this.x += e), (this.y += e), (this.z += e), (this.w += e), this);
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x),
      (this.y -= e.y),
      (this.z -= e.z),
      (this.w -= e.w),
      this
    );
  }
  subScalar(e) {
    return ((this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this);
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x),
      (this.y *= e.y),
      (this.z *= e.z),
      (this.w *= e.w),
      this
    );
  }
  multiplyScalar(e) {
    return ((this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this);
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = this.w,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s),
      (this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s),
      (this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s),
      (this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s),
      this
    );
  }
  divide(e) {
    return (
      (this.x /= e.x),
      (this.y /= e.y),
      (this.z /= e.z),
      (this.w /= e.w),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, i, r, s;
    const l = e.elements,
      c = l[0],
      u = l[4],
      h = l[8],
      d = l[1],
      f = l[5],
      g = l[9],
      p = l[2],
      m = l[6],
      C = l[10];
    if (
      Math.abs(u - d) < 0.01 &&
      Math.abs(h - p) < 0.01 &&
      Math.abs(g - m) < 0.01
    ) {
      if (
        Math.abs(u + d) < 0.1 &&
        Math.abs(h + p) < 0.1 &&
        Math.abs(g + m) < 0.1 &&
        Math.abs(c + f + C - 3) < 0.1
      )
        return (this.set(1, 0, 0, 0), this);
      t = Math.PI;
      const I = (c + 1) / 2,
        y = (f + 1) / 2,
        x = (C + 1) / 2,
        T = (u + d) / 4,
        S = (h + p) / 4,
        E = (g + m) / 4;
      return (
        I > y && I > x
          ? I < 0.01
            ? ((i = 0), (r = 0.707106781), (s = 0.707106781))
            : ((i = Math.sqrt(I)), (r = T / i), (s = S / i))
          : y > x
            ? y < 0.01
              ? ((i = 0.707106781), (r = 0), (s = 0.707106781))
              : ((r = Math.sqrt(y)), (i = T / r), (s = E / r))
            : x < 0.01
              ? ((i = 0.707106781), (r = 0.707106781), (s = 0))
              : ((s = Math.sqrt(x)), (i = S / s), (r = E / s)),
        this.set(i, r, s, t),
        this
      );
    }
    let A = Math.sqrt(
      (m - g) * (m - g) + (h - p) * (h - p) + (d - u) * (d - u),
    );
    return (
      Math.abs(A) < 0.001 && (A = 1),
      (this.x = (m - g) / A),
      (this.y = (h - p) / A),
      (this.z = (d - u) / A),
      (this.w = Math.acos((c + f + C - 1) / 2)),
      this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (
      (this.x = t[12]),
      (this.y = t[13]),
      (this.z = t[14]),
      (this.w = t[15]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Wt(this.x, e.x, t.x)),
      (this.y = Wt(this.y, e.y, t.y)),
      (this.z = Wt(this.z, e.z, t.z)),
      (this.w = Wt(this.w, e.w, t.w)),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Wt(this.x, e, t)),
      (this.y = Wt(this.y, e, t)),
      (this.z = Wt(this.z, e, t)),
      (this.w = Wt(this.w, e, t)),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Wt(i, e, t));
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w,
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      (this.w = e.w + (t.w - e.w) * i),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    (yield this.x, yield this.y, yield this.z, yield this.w);
  }
}
class Ite extends wu {
  constructor(e = 1, t = 1, i = {}) {
    (super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = i.depth ? i.depth : 1),
      (this.scissor = new ln(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new ln(0, 0, e, t)));
    const r = { width: e, height: t, depth: this.depth };
    i = Object.assign(
      {
        generateMipmaps: !1,
        internalFormat: null,
        minFilter: Yr,
        depthBuffer: !0,
        stencilBuffer: !1,
        resolveDepthBuffer: !0,
        resolveStencilBuffer: !0,
        depthTexture: null,
        samples: 0,
        count: 1,
        multiview: !1,
      },
      i,
    );
    const s = new Oi(
      r,
      i.mapping,
      i.wrapS,
      i.wrapT,
      i.magFilter,
      i.minFilter,
      i.format,
      i.type,
      i.anisotropy,
      i.colorSpace,
    );
    ((s.flipY = !1),
      (s.generateMipmaps = i.generateMipmaps),
      (s.internalFormat = i.internalFormat),
      (this.textures = []));
    const o = i.count;
    for (let a = 0; a < o; a++)
      ((this.textures[a] = s.clone()),
        (this.textures[a].isRenderTargetTexture = !0),
        (this.textures[a].renderTarget = this));
    ((this.depthBuffer = i.depthBuffer),
      (this.stencilBuffer = i.stencilBuffer),
      (this.resolveDepthBuffer = i.resolveDepthBuffer),
      (this.resolveStencilBuffer = i.resolveStencilBuffer),
      (this._depthTexture = null),
      (this.depthTexture = i.depthTexture),
      (this.samples = i.samples),
      (this.multiview = i.multiview));
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  set depthTexture(e) {
    (this._depthTexture !== null && (this._depthTexture.renderTarget = null),
      e !== null && (e.renderTarget = this),
      (this._depthTexture = e));
  }
  get depthTexture() {
    return this._depthTexture;
  }
  setSize(e, t, i = 1) {
    if (this.width !== e || this.height !== t || this.depth !== i) {
      ((this.width = e), (this.height = t), (this.depth = i));
      for (let r = 0, s = this.textures.length; r < s; r++)
        ((this.textures[r].image.width = e),
          (this.textures[r].image.height = t),
          (this.textures[r].image.depth = i));
      this.dispose();
    }
    (this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t));
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    ((this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.textures.length = 0));
    for (let t = 0, i = e.textures.length; t < i; t++) {
      ((this.textures[t] = e.textures[t].clone()),
        (this.textures[t].isRenderTargetTexture = !0),
        (this.textures[t].renderTarget = this));
      const r = Object.assign({}, e.textures[t].image);
      this.textures[t].source = new Ov(r);
    }
    return (
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      (this.resolveDepthBuffer = e.resolveDepthBuffer),
      (this.resolveStencilBuffer = e.resolveStencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class ko extends Ite {
  constructor(e = 1, t = 1, i = {}) {
    (super(e, t, i), (this.isWebGLRenderTarget = !0));
  }
}
class nR extends Oi {
  constructor(e = null, t = 1, i = 1, r = 1) {
    (super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: r }),
      (this.magFilter = gi),
      (this.minFilter = gi),
      (this.wrapR = xo),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.layerUpdates = new Set()));
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class Ate extends Oi {
  constructor(e = null, t = 1, i = 1, r = 1) {
    (super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: r }),
      (this.magFilter = gi),
      (this.minFilter = gi),
      (this.wrapR = xo),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1));
  }
}
class Qs {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    ((this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = r));
  }
  static slerpFlat(e, t, i, r, s, o, a) {
    let l = i[r + 0],
      c = i[r + 1],
      u = i[r + 2],
      h = i[r + 3];
    const d = s[o + 0],
      f = s[o + 1],
      g = s[o + 2],
      p = s[o + 3];
    if (a === 0) {
      ((e[t + 0] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = h));
      return;
    }
    if (a === 1) {
      ((e[t + 0] = d), (e[t + 1] = f), (e[t + 2] = g), (e[t + 3] = p));
      return;
    }
    if (h !== p || l !== d || c !== f || u !== g) {
      let m = 1 - a;
      const C = l * d + c * f + u * g + h * p,
        A = C >= 0 ? 1 : -1,
        I = 1 - C * C;
      if (I > Number.EPSILON) {
        const x = Math.sqrt(I),
          T = Math.atan2(x, C * A);
        ((m = Math.sin(m * T) / x), (a = Math.sin(a * T) / x));
      }
      const y = a * A;
      if (
        ((l = l * m + d * y),
        (c = c * m + f * y),
        (u = u * m + g * y),
        (h = h * m + p * y),
        m === 1 - a)
      ) {
        const x = 1 / Math.sqrt(l * l + c * c + u * u + h * h);
        ((l *= x), (c *= x), (u *= x), (h *= x));
      }
    }
    ((e[t] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = h));
  }
  static multiplyQuaternionsFlat(e, t, i, r, s, o) {
    const a = i[r],
      l = i[r + 1],
      c = i[r + 2],
      u = i[r + 3],
      h = s[o],
      d = s[o + 1],
      f = s[o + 2],
      g = s[o + 3];
    return (
      (e[t] = a * g + u * h + l * f - c * d),
      (e[t + 1] = l * g + u * d + c * h - a * f),
      (e[t + 2] = c * g + u * f + a * d - l * h),
      (e[t + 3] = u * g - a * h - l * d - c * f),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    ((this._x = e), this._onChangeCallback());
  }
  get y() {
    return this._y;
  }
  set y(e) {
    ((this._y = e), this._onChangeCallback());
  }
  get z() {
    return this._z;
  }
  set z(e) {
    ((this._z = e), this._onChangeCallback());
  }
  get w() {
    return this._w;
  }
  set w(e) {
    ((this._w = e), this._onChangeCallback());
  }
  set(e, t, i, r) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t = !0) {
    const i = e._x,
      r = e._y,
      s = e._z,
      o = e._order,
      a = Math.cos,
      l = Math.sin,
      c = a(i / 2),
      u = a(r / 2),
      h = a(s / 2),
      d = l(i / 2),
      f = l(r / 2),
      g = l(s / 2);
    switch (o) {
      case "XYZ":
        ((this._x = d * u * h + c * f * g),
          (this._y = c * f * h - d * u * g),
          (this._z = c * u * g + d * f * h),
          (this._w = c * u * h - d * f * g));
        break;
      case "YXZ":
        ((this._x = d * u * h + c * f * g),
          (this._y = c * f * h - d * u * g),
          (this._z = c * u * g - d * f * h),
          (this._w = c * u * h + d * f * g));
        break;
      case "ZXY":
        ((this._x = d * u * h - c * f * g),
          (this._y = c * f * h + d * u * g),
          (this._z = c * u * g + d * f * h),
          (this._w = c * u * h - d * f * g));
        break;
      case "ZYX":
        ((this._x = d * u * h - c * f * g),
          (this._y = c * f * h + d * u * g),
          (this._z = c * u * g - d * f * h),
          (this._w = c * u * h + d * f * g));
        break;
      case "YZX":
        ((this._x = d * u * h + c * f * g),
          (this._y = c * f * h + d * u * g),
          (this._z = c * u * g - d * f * h),
          (this._w = c * u * h - d * f * g));
        break;
      case "XZY":
        ((this._x = d * u * h - c * f * g),
          (this._y = c * f * h - d * u * g),
          (this._z = c * u * g + d * f * h),
          (this._w = c * u * h + d * f * g));
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
            o,
        );
    }
    return (t === !0 && this._onChangeCallback(), this);
  }
  setFromAxisAngle(e, t) {
    const i = t / 2,
      r = Math.sin(i);
    return (
      (this._x = e.x * r),
      (this._y = e.y * r),
      (this._z = e.z * r),
      (this._w = Math.cos(i)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      i = t[0],
      r = t[4],
      s = t[8],
      o = t[1],
      a = t[5],
      l = t[9],
      c = t[2],
      u = t[6],
      h = t[10],
      d = i + a + h;
    if (d > 0) {
      const f = 0.5 / Math.sqrt(d + 1);
      ((this._w = 0.25 / f),
        (this._x = (u - l) * f),
        (this._y = (s - c) * f),
        (this._z = (o - r) * f));
    } else if (i > a && i > h) {
      const f = 2 * Math.sqrt(1 + i - a - h);
      ((this._w = (u - l) / f),
        (this._x = 0.25 * f),
        (this._y = (r + o) / f),
        (this._z = (s + c) / f));
    } else if (a > h) {
      const f = 2 * Math.sqrt(1 + a - i - h);
      ((this._w = (s - c) / f),
        (this._x = (r + o) / f),
        (this._y = 0.25 * f),
        (this._z = (l + u) / f));
    } else {
      const f = 2 * Math.sqrt(1 + h - i - a);
      ((this._w = (o - r) / f),
        (this._x = (s + c) / f),
        (this._y = (l + u) / f),
        (this._z = 0.25 * f));
    }
    return (this._onChangeCallback(), this);
  }
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1;
    return (
      i < Number.EPSILON
        ? ((i = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = i))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = i)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = i)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Wt(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const r = Math.min(1, t / i);
    return (this.slerp(e, r), this);
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w,
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const i = e._x,
      r = e._y,
      s = e._z,
      o = e._w,
      a = t._x,
      l = t._y,
      c = t._z,
      u = t._w;
    return (
      (this._x = i * u + o * a + r * c - s * l),
      (this._y = r * u + o * l + s * a - i * c),
      (this._z = s * u + o * c + i * l - r * a),
      (this._w = o * u - i * a - r * l - s * c),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const i = this._x,
      r = this._y,
      s = this._z,
      o = this._w;
    let a = o * e._w + i * e._x + r * e._y + s * e._z;
    if (
      (a < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (a = -a))
        : this.copy(e),
      a >= 1)
    )
      return ((this._w = o), (this._x = i), (this._y = r), (this._z = s), this);
    const l = 1 - a * a;
    if (l <= Number.EPSILON) {
      const f = 1 - t;
      return (
        (this._w = f * o + t * this._w),
        (this._x = f * i + t * this._x),
        (this._y = f * r + t * this._y),
        (this._z = f * s + t * this._z),
        this.normalize(),
        this
      );
    }
    const c = Math.sqrt(l),
      u = Math.atan2(c, a),
      h = Math.sin((1 - t) * u) / c,
      d = Math.sin(t * u) / c;
    return (
      (this._w = o * h + this._w * d),
      (this._x = i * h + this._x * d),
      (this._y = r * h + this._y * d),
      (this._z = s * h + this._z * d),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, i) {
    return this.copy(e).slerp(t, i);
  }
  random() {
    const e = 2 * Math.PI * Math.random(),
      t = 2 * Math.PI * Math.random(),
      i = Math.random(),
      r = Math.sqrt(1 - i),
      s = Math.sqrt(i);
    return this.set(
      r * Math.sin(e),
      r * Math.cos(e),
      s * Math.sin(t),
      s * Math.cos(t),
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this._onChangeCallback(),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return ((this._onChangeCallback = e), this);
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    (yield this._x, yield this._y, yield this._z, yield this._w);
  }
}
class X {
  constructor(e = 0, t = 0, i = 0) {
    ((X.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = i));
  }
  set(e, t, i) {
    return (
      i === void 0 && (i = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      this
    );
  }
  setScalar(e) {
    return ((this.x = e), (this.y = e), (this.z = e), this);
  }
  setX(e) {
    return ((this.x = e), this);
  }
  setY(e) {
    return ((this.y = e), this);
  }
  setZ(e) {
    return ((this.z = e), this);
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return ((this.x = e.x), (this.y = e.y), (this.z = e.z), this);
  }
  add(e) {
    return ((this.x += e.x), (this.y += e.y), (this.z += e.z), this);
  }
  addScalar(e) {
    return ((this.x += e), (this.y += e), (this.z += e), this);
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      this
    );
  }
  sub(e) {
    return ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this);
  }
  subScalar(e) {
    return ((this.x -= e), (this.y -= e), (this.z -= e), this);
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      this
    );
  }
  multiply(e) {
    return ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this);
  }
  multiplyScalar(e) {
    return ((this.x *= e), (this.y *= e), (this.z *= e), this);
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x),
      (this.y = e.y * t.y),
      (this.z = e.z * t.z),
      this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(Yx.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(Yx.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[3] * i + s[6] * r),
      (this.y = s[1] * t + s[4] * i + s[7] * r),
      (this.z = s[2] * t + s[5] * i + s[8] * r),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements,
      o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
    return (
      (this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o),
      (this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o),
      (this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.x,
      o = e.y,
      a = e.z,
      l = e.w,
      c = 2 * (o * r - a * i),
      u = 2 * (a * t - s * r),
      h = 2 * (s * i - o * t);
    return (
      (this.x = t + l * c + o * h - a * u),
      (this.y = i + l * u + a * c - s * h),
      (this.z = r + l * h + s * u - o * c),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix,
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld,
    );
  }
  transformDirection(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[4] * i + s[8] * r),
      (this.y = s[1] * t + s[5] * i + s[9] * r),
      (this.z = s[2] * t + s[6] * i + s[10] * r),
      this.normalize()
    );
  }
  divide(e) {
    return ((this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this);
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Wt(this.x, e.x, t.x)),
      (this.y = Wt(this.y, e.y, t.y)),
      (this.z = Wt(this.z, e.z, t.z)),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Wt(this.x, e, t)),
      (this.y = Wt(this.y, e, t)),
      (this.z = Wt(this.z, e, t)),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Wt(i, e, t));
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return ((this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this);
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = t.x,
      a = t.y,
      l = t.z;
    return (
      (this.x = r * l - s * a),
      (this.y = s * o - i * l),
      (this.z = i * a - r * o),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / t;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return (_2.copy(this).projectOnVector(e), this.sub(_2));
  }
  reflect(e) {
    return this.sub(_2.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(Wt(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y,
      r = this.z - e.z;
    return t * t + i * i + r * r;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, i) {
    const r = Math.sin(t) * e;
    return (
      (this.x = r * Math.sin(i)),
      (this.y = Math.cos(t) * e),
      (this.z = r * Math.cos(i)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, i) {
    return (
      (this.x = e * Math.sin(t)),
      (this.y = i),
      (this.z = e * Math.cos(t)),
      this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return ((this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this);
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      i = this.setFromMatrixColumn(e, 1).length(),
      r = this.setFromMatrixColumn(e, 2).length();
    return ((this.x = t), (this.y = i), (this.z = r), this);
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return ((this.x = e._x), (this.y = e._y), (this.z = e._z), this);
  }
  setFromColor(e) {
    return ((this.x = e.r), (this.y = e.g), (this.z = e.b), this);
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return ((this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this);
  }
  toArray(e = [], t = 0) {
    return ((e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e);
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2,
      t = Math.random() * 2 - 1,
      i = Math.sqrt(1 - t * t);
    return (
      (this.x = i * Math.cos(e)),
      (this.y = t),
      (this.z = i * Math.sin(e)),
      this
    );
  }
  *[Symbol.iterator]() {
    (yield this.x, yield this.y, yield this.z);
  }
}
const _2 = new X(),
  Yx = new Qs();
class ka {
  constructor(
    e = new X(1 / 0, 1 / 0, 1 / 0),
    t = new X(-1 / 0, -1 / 0, -1 / 0),
  ) {
    ((this.isBox3 = !0), (this.min = e), (this.max = t));
  }
  set(e, t) {
    return (this.min.copy(e), this.max.copy(t), this);
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t += 3)
      this.expandByPoint(Ds.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, i = e.count; t < i; t++)
      this.expandByPoint(Ds.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = Ds.copy(t).multiplyScalar(0.5);
    return (this.min.copy(e).sub(i), this.max.copy(e).add(i), this);
  }
  setFromObject(e, t = !1) {
    return (this.makeEmpty(), this.expandByObject(e, t));
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.min.copy(e.min), this.max.copy(e.max), this);
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return (this.min.min(e), this.max.max(e), this);
  }
  expandByVector(e) {
    return (this.min.sub(e), this.max.add(e), this);
  }
  expandByScalar(e) {
    return (this.min.addScalar(-e), this.max.addScalar(e), this);
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const i = e.geometry;
    if (i !== void 0) {
      const s = i.getAttribute("position");
      if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
        for (let o = 0, a = s.count; o < a; o++)
          (e.isMesh === !0
            ? e.getVertexPosition(o, Ds)
            : Ds.fromBufferAttribute(s, o),
            Ds.applyMatrix4(e.matrixWorld),
            this.expandByPoint(Ds));
      else
        (e.boundingBox !== void 0
          ? (e.boundingBox === null && e.computeBoundingBox(),
            e1.copy(e.boundingBox))
          : (i.boundingBox === null && i.computeBoundingBox(),
            e1.copy(i.boundingBox)),
          e1.applyMatrix4(e.matrixWorld),
          this.union(e1));
    }
    const r = e.children;
    for (let s = 0, o = r.length; s < o; s++) this.expandByObject(r[s], t);
    return this;
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y &&
      e.z >= this.min.z &&
      e.z <= this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z),
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y &&
      e.max.z >= this.min.z &&
      e.min.z <= this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, Ds),
      Ds.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, i;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (i = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (i = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (i += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (i += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (i += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (i += e.normal.z * this.min.z)),
      t <= -e.constant && i >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    (this.getCenter(uf),
      t1.subVectors(this.max, uf),
      ku.subVectors(e.a, uf),
      Ou.subVectors(e.b, uf),
      Uu.subVectors(e.c, uf),
      Xa.subVectors(Ou, ku),
      Ka.subVectors(Uu, Ou),
      ic.subVectors(ku, Uu));
    let t = [
      0,
      -Xa.z,
      Xa.y,
      0,
      -Ka.z,
      Ka.y,
      0,
      -ic.z,
      ic.y,
      Xa.z,
      0,
      -Xa.x,
      Ka.z,
      0,
      -Ka.x,
      ic.z,
      0,
      -ic.x,
      -Xa.y,
      Xa.x,
      0,
      -Ka.y,
      Ka.x,
      0,
      -ic.y,
      ic.x,
      0,
    ];
    return !b2(t, ku, Ou, Uu, t1) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !b2(t, ku, Ou, Uu, t1))
      ? !1
      : (n1.crossVectors(Xa, Ka),
        (t = [n1.x, n1.y, n1.z]),
        b2(t, ku, Ou, Uu, t1));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Ds).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(Ds).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return (this.min.min(e.min), this.max.max(e.max), this);
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : ($o[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        $o[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        $o[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        $o[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        $o[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        $o[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        $o[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        $o[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints($o),
        this);
  }
  translate(e) {
    return (this.min.add(e), this.max.add(e), this);
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const $o = [
    new X(),
    new X(),
    new X(),
    new X(),
    new X(),
    new X(),
    new X(),
    new X(),
  ],
  Ds = new X(),
  e1 = new ka(),
  ku = new X(),
  Ou = new X(),
  Uu = new X(),
  Xa = new X(),
  Ka = new X(),
  ic = new X(),
  uf = new X(),
  t1 = new X(),
  n1 = new X(),
  rc = new X();
function b2(n, e, t, i, r) {
  for (let s = 0, o = n.length - 3; s <= o; s += 3) {
    rc.fromArray(n, s);
    const a =
        r.x * Math.abs(rc.x) + r.y * Math.abs(rc.y) + r.z * Math.abs(rc.z),
      l = e.dot(rc),
      c = t.dot(rc),
      u = i.dot(rc);
    if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a) return !1;
  }
  return !0;
}
const yte = new ka(),
  hf = new X(),
  v2 = new X();
class Zo {
  constructor(e = new X(), t = -1) {
    ((this.isSphere = !0), (this.center = e), (this.radius = t));
  }
  set(e, t) {
    return (this.center.copy(e), (this.radius = t), this);
  }
  setFromPoints(e, t) {
    const i = this.center;
    t !== void 0 ? i.copy(t) : yte.setFromPoints(e).getCenter(i);
    let r = 0;
    for (let s = 0, o = e.length; s < o; s++)
      r = Math.max(r, i.distanceToSquared(e[s]));
    return ((this.radius = Math.sqrt(r)), this);
  }
  copy(e) {
    return (this.center.copy(e.center), (this.radius = e.radius), this);
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return (this.center.set(0, 0, 0), (this.radius = -1), this);
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const i = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      i > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return (this.center.add(e), this);
  }
  expandByPoint(e) {
    if (this.isEmpty()) return (this.center.copy(e), (this.radius = 0), this);
    hf.subVectors(e, this.center);
    const t = hf.lengthSq();
    if (t > this.radius * this.radius) {
      const i = Math.sqrt(t),
        r = (i - this.radius) * 0.5;
      (this.center.addScaledVector(hf, r / i), (this.radius += r));
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
        ? (this.copy(e), this)
        : (this.center.equals(e.center) === !0
            ? (this.radius = Math.max(this.radius, e.radius))
            : (v2.subVectors(e.center, this.center).setLength(e.radius),
              this.expandByPoint(hf.copy(e.center).add(v2)),
              this.expandByPoint(hf.copy(e.center).sub(v2))),
          this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Jo = new X(),
  x2 = new X(),
  i1 = new X(),
  ja = new X(),
  w2 = new X(),
  r1 = new X(),
  S2 = new X();
class Sp {
  constructor(e = new X(), t = new X(0, 0, -1)) {
    ((this.origin = e), (this.direction = t));
  }
  set(e, t) {
    return (this.origin.copy(e), this.direction.copy(t), this);
  }
  copy(e) {
    return (this.origin.copy(e.origin), this.direction.copy(e.direction), this);
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return (this.direction.copy(e).sub(this.origin).normalize(), this);
  }
  recast(e) {
    return (this.origin.copy(this.at(e, Jo)), this);
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const i = t.dot(this.direction);
    return i < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Jo.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (Jo.copy(this.origin).addScaledVector(this.direction, t),
        Jo.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, i, r) {
    (x2.copy(e).add(t).multiplyScalar(0.5),
      i1.copy(t).sub(e).normalize(),
      ja.copy(this.origin).sub(x2));
    const s = e.distanceTo(t) * 0.5,
      o = -this.direction.dot(i1),
      a = ja.dot(this.direction),
      l = -ja.dot(i1),
      c = ja.lengthSq(),
      u = Math.abs(1 - o * o);
    let h, d, f, g;
    if (u > 0)
      if (((h = o * l - a), (d = o * a - l), (g = s * u), h >= 0))
        if (d >= -g)
          if (d <= g) {
            const p = 1 / u;
            ((h *= p),
              (d *= p),
              (f = h * (h + o * d + 2 * a) + d * (o * h + d + 2 * l) + c));
          } else
            ((d = s),
              (h = Math.max(0, -(o * d + a))),
              (f = -h * h + d * (d + 2 * l) + c));
        else
          ((d = -s),
            (h = Math.max(0, -(o * d + a))),
            (f = -h * h + d * (d + 2 * l) + c));
      else
        d <= -g
          ? ((h = Math.max(0, -(-o * s + a))),
            (d = h > 0 ? -s : Math.min(Math.max(-s, -l), s)),
            (f = -h * h + d * (d + 2 * l) + c))
          : d <= g
            ? ((h = 0),
              (d = Math.min(Math.max(-s, -l), s)),
              (f = d * (d + 2 * l) + c))
            : ((h = Math.max(0, -(o * s + a))),
              (d = h > 0 ? s : Math.min(Math.max(-s, -l), s)),
              (f = -h * h + d * (d + 2 * l) + c));
    else
      ((d = o > 0 ? -s : s),
        (h = Math.max(0, -(o * d + a))),
        (f = -h * h + d * (d + 2 * l) + c));
    return (
      i && i.copy(this.origin).addScaledVector(this.direction, h),
      r && r.copy(x2).addScaledVector(i1, d),
      f
    );
  }
  intersectSphere(e, t) {
    Jo.subVectors(e.center, this.origin);
    const i = Jo.dot(this.direction),
      r = Jo.dot(Jo) - i * i,
      s = e.radius * e.radius;
    if (r > s) return null;
    const o = Math.sqrt(s - r),
      a = i - o,
      l = i + o;
    return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / t;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, t) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let i, r, s, o, a, l;
    const c = 1 / this.direction.x,
      u = 1 / this.direction.y,
      h = 1 / this.direction.z,
      d = this.origin;
    return (
      c >= 0
        ? ((i = (e.min.x - d.x) * c), (r = (e.max.x - d.x) * c))
        : ((i = (e.max.x - d.x) * c), (r = (e.min.x - d.x) * c)),
      u >= 0
        ? ((s = (e.min.y - d.y) * u), (o = (e.max.y - d.y) * u))
        : ((s = (e.max.y - d.y) * u), (o = (e.min.y - d.y) * u)),
      i > o ||
      s > r ||
      ((s > i || isNaN(i)) && (i = s),
      (o < r || isNaN(r)) && (r = o),
      h >= 0
        ? ((a = (e.min.z - d.z) * h), (l = (e.max.z - d.z) * h))
        : ((a = (e.max.z - d.z) * h), (l = (e.min.z - d.z) * h)),
      i > l || a > r) ||
      ((a > i || i !== i) && (i = a), (l < r || r !== r) && (r = l), r < 0)
        ? null
        : this.at(i >= 0 ? i : r, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, Jo) !== null;
  }
  intersectTriangle(e, t, i, r, s) {
    (w2.subVectors(t, e), r1.subVectors(i, e), S2.crossVectors(w2, r1));
    let o = this.direction.dot(S2),
      a;
    if (o > 0) {
      if (r) return null;
      a = 1;
    } else if (o < 0) ((a = -1), (o = -o));
    else return null;
    ja.subVectors(this.origin, e);
    const l = a * this.direction.dot(r1.crossVectors(ja, r1));
    if (l < 0) return null;
    const c = a * this.direction.dot(w2.cross(ja));
    if (c < 0 || l + c > o) return null;
    const u = -a * ja.dot(S2);
    return u < 0 ? null : this.at(u / o, s);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e),
      this.direction.transformDirection(e),
      this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Et {
  constructor(e, t, i, r, s, o, a, l, c, u, h, d, f, g, p, m) {
    ((Et.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, i, r, s, o, a, l, c, u, h, d, f, g, p, m));
  }
  set(e, t, i, r, s, o, a, l, c, u, h, d, f, g, p, m) {
    const C = this.elements;
    return (
      (C[0] = e),
      (C[4] = t),
      (C[8] = i),
      (C[12] = r),
      (C[1] = s),
      (C[5] = o),
      (C[9] = a),
      (C[13] = l),
      (C[2] = c),
      (C[6] = u),
      (C[10] = h),
      (C[14] = d),
      (C[3] = f),
      (C[7] = g),
      (C[11] = p),
      (C[15] = m),
      this
    );
  }
  identity() {
    return (this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this);
  }
  clone() {
    return new Et().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      (t[9] = i[9]),
      (t[10] = i[10]),
      (t[11] = i[11]),
      (t[12] = i[12]),
      (t[13] = i[13]),
      (t[14] = i[14]),
      (t[15] = i[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      i = e.elements;
    return ((t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), this);
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1,
      ),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      i.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, i) {
    return (
      this.set(
        e.x,
        t.x,
        i.x,
        0,
        e.y,
        t.y,
        i.y,
        0,
        e.z,
        t.z,
        i.z,
        0,
        0,
        0,
        0,
        1,
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      i = e.elements,
      r = 1 / Hu.setFromMatrixColumn(e, 0).length(),
      s = 1 / Hu.setFromMatrixColumn(e, 1).length(),
      o = 1 / Hu.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = i[0] * r),
      (t[1] = i[1] * r),
      (t[2] = i[2] * r),
      (t[3] = 0),
      (t[4] = i[4] * s),
      (t[5] = i[5] * s),
      (t[6] = i[6] * s),
      (t[7] = 0),
      (t[8] = i[8] * o),
      (t[9] = i[9] * o),
      (t[10] = i[10] * o),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      i = e.x,
      r = e.y,
      s = e.z,
      o = Math.cos(i),
      a = Math.sin(i),
      l = Math.cos(r),
      c = Math.sin(r),
      u = Math.cos(s),
      h = Math.sin(s);
    if (e.order === "XYZ") {
      const d = o * u,
        f = o * h,
        g = a * u,
        p = a * h;
      ((t[0] = l * u),
        (t[4] = -l * h),
        (t[8] = c),
        (t[1] = f + g * c),
        (t[5] = d - p * c),
        (t[9] = -a * l),
        (t[2] = p - d * c),
        (t[6] = g + f * c),
        (t[10] = o * l));
    } else if (e.order === "YXZ") {
      const d = l * u,
        f = l * h,
        g = c * u,
        p = c * h;
      ((t[0] = d + p * a),
        (t[4] = g * a - f),
        (t[8] = o * c),
        (t[1] = o * h),
        (t[5] = o * u),
        (t[9] = -a),
        (t[2] = f * a - g),
        (t[6] = p + d * a),
        (t[10] = o * l));
    } else if (e.order === "ZXY") {
      const d = l * u,
        f = l * h,
        g = c * u,
        p = c * h;
      ((t[0] = d - p * a),
        (t[4] = -o * h),
        (t[8] = g + f * a),
        (t[1] = f + g * a),
        (t[5] = o * u),
        (t[9] = p - d * a),
        (t[2] = -o * c),
        (t[6] = a),
        (t[10] = o * l));
    } else if (e.order === "ZYX") {
      const d = o * u,
        f = o * h,
        g = a * u,
        p = a * h;
      ((t[0] = l * u),
        (t[4] = g * c - f),
        (t[8] = d * c + p),
        (t[1] = l * h),
        (t[5] = p * c + d),
        (t[9] = f * c - g),
        (t[2] = -c),
        (t[6] = a * l),
        (t[10] = o * l));
    } else if (e.order === "YZX") {
      const d = o * l,
        f = o * c,
        g = a * l,
        p = a * c;
      ((t[0] = l * u),
        (t[4] = p - d * h),
        (t[8] = g * h + f),
        (t[1] = h),
        (t[5] = o * u),
        (t[9] = -a * u),
        (t[2] = -c * u),
        (t[6] = f * h + g),
        (t[10] = d - p * h));
    } else if (e.order === "XZY") {
      const d = o * l,
        f = o * c,
        g = a * l,
        p = a * c;
      ((t[0] = l * u),
        (t[4] = -h),
        (t[8] = c * u),
        (t[1] = d * h + p),
        (t[5] = o * u),
        (t[9] = f * h - g),
        (t[2] = g * h - f),
        (t[6] = a * u),
        (t[10] = p * h + d));
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(_te, e, bte);
  }
  lookAt(e, t, i) {
    const r = this.elements;
    return (
      kr.subVectors(e, t),
      kr.lengthSq() === 0 && (kr.z = 1),
      kr.normalize(),
      $a.crossVectors(i, kr),
      $a.lengthSq() === 0 &&
        (Math.abs(i.z) === 1 ? (kr.x += 1e-4) : (kr.z += 1e-4),
        kr.normalize(),
        $a.crossVectors(i, kr)),
      $a.normalize(),
      s1.crossVectors(kr, $a),
      (r[0] = $a.x),
      (r[4] = s1.x),
      (r[8] = kr.x),
      (r[1] = $a.y),
      (r[5] = s1.y),
      (r[9] = kr.y),
      (r[2] = $a.z),
      (r[6] = s1.z),
      (r[10] = kr.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      r = t.elements,
      s = this.elements,
      o = i[0],
      a = i[4],
      l = i[8],
      c = i[12],
      u = i[1],
      h = i[5],
      d = i[9],
      f = i[13],
      g = i[2],
      p = i[6],
      m = i[10],
      C = i[14],
      A = i[3],
      I = i[7],
      y = i[11],
      x = i[15],
      T = r[0],
      S = r[4],
      E = r[8],
      _ = r[12],
      b = r[1],
      R = r[5],
      M = r[9],
      L = r[13],
      P = r[2],
      U = r[6],
      O = r[10],
      V = r[14],
      W = r[3],
      re = r[7],
      Z = r[11],
      te = r[15];
    return (
      (s[0] = o * T + a * b + l * P + c * W),
      (s[4] = o * S + a * R + l * U + c * re),
      (s[8] = o * E + a * M + l * O + c * Z),
      (s[12] = o * _ + a * L + l * V + c * te),
      (s[1] = u * T + h * b + d * P + f * W),
      (s[5] = u * S + h * R + d * U + f * re),
      (s[9] = u * E + h * M + d * O + f * Z),
      (s[13] = u * _ + h * L + d * V + f * te),
      (s[2] = g * T + p * b + m * P + C * W),
      (s[6] = g * S + p * R + m * U + C * re),
      (s[10] = g * E + p * M + m * O + C * Z),
      (s[14] = g * _ + p * L + m * V + C * te),
      (s[3] = A * T + I * b + y * P + x * W),
      (s[7] = A * S + I * R + y * U + x * re),
      (s[11] = A * E + I * M + y * O + x * Z),
      (s[15] = A * _ + I * L + y * V + x * te),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[4],
      r = e[8],
      s = e[12],
      o = e[1],
      a = e[5],
      l = e[9],
      c = e[13],
      u = e[2],
      h = e[6],
      d = e[10],
      f = e[14],
      g = e[3],
      p = e[7],
      m = e[11],
      C = e[15];
    return (
      g *
        (+s * l * h -
          r * c * h -
          s * a * d +
          i * c * d +
          r * a * f -
          i * l * f) +
      p *
        (+t * l * f -
          t * c * d +
          s * o * d -
          r * o * f +
          r * c * u -
          s * l * u) +
      m *
        (+t * c * h -
          t * a * f -
          s * o * h +
          i * o * f +
          s * a * u -
          i * c * u) +
      C *
        (-r * a * u - t * l * h + t * a * d + r * o * h - i * o * d + i * l * u)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, i) {
    const r = this.elements;
    return (
      e.isVector3
        ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
        : ((r[12] = e), (r[13] = t), (r[14] = i)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      u = e[8],
      h = e[9],
      d = e[10],
      f = e[11],
      g = e[12],
      p = e[13],
      m = e[14],
      C = e[15],
      A = h * m * c - p * d * c + p * l * f - a * m * f - h * l * C + a * d * C,
      I = g * d * c - u * m * c - g * l * f + o * m * f + u * l * C - o * d * C,
      y = u * p * c - g * h * c + g * a * f - o * p * f - u * a * C + o * h * C,
      x = g * h * l - u * p * l - g * a * d + o * p * d + u * a * m - o * h * m,
      T = t * A + i * I + r * y + s * x;
    if (T === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const S = 1 / T;
    return (
      (e[0] = A * S),
      (e[1] =
        (p * d * s -
          h * m * s -
          p * r * f +
          i * m * f +
          h * r * C -
          i * d * C) *
        S),
      (e[2] =
        (a * m * s -
          p * l * s +
          p * r * c -
          i * m * c -
          a * r * C +
          i * l * C) *
        S),
      (e[3] =
        (h * l * s -
          a * d * s -
          h * r * c +
          i * d * c +
          a * r * f -
          i * l * f) *
        S),
      (e[4] = I * S),
      (e[5] =
        (u * m * s -
          g * d * s +
          g * r * f -
          t * m * f -
          u * r * C +
          t * d * C) *
        S),
      (e[6] =
        (g * l * s -
          o * m * s -
          g * r * c +
          t * m * c +
          o * r * C -
          t * l * C) *
        S),
      (e[7] =
        (o * d * s -
          u * l * s +
          u * r * c -
          t * d * c -
          o * r * f +
          t * l * f) *
        S),
      (e[8] = y * S),
      (e[9] =
        (g * h * s -
          u * p * s -
          g * i * f +
          t * p * f +
          u * i * C -
          t * h * C) *
        S),
      (e[10] =
        (o * p * s -
          g * a * s +
          g * i * c -
          t * p * c -
          o * i * C +
          t * a * C) *
        S),
      (e[11] =
        (u * a * s -
          o * h * s -
          u * i * c +
          t * h * c +
          o * i * f -
          t * a * f) *
        S),
      (e[12] = x * S),
      (e[13] =
        (u * p * r -
          g * h * r +
          g * i * d -
          t * p * d -
          u * i * m +
          t * h * m) *
        S),
      (e[14] =
        (g * a * r -
          o * p * r -
          g * i * l +
          t * p * l +
          o * i * m -
          t * a * m) *
        S),
      (e[15] =
        (o * h * r -
          u * a * r +
          u * i * l -
          t * h * l -
          o * i * d +
          t * a * d) *
        S),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      i = e.x,
      r = e.y,
      s = e.z;
    return (
      (t[0] *= i),
      (t[4] *= r),
      (t[8] *= s),
      (t[1] *= i),
      (t[5] *= r),
      (t[9] *= s),
      (t[2] *= i),
      (t[6] *= r),
      (t[10] *= s),
      (t[3] *= i),
      (t[7] *= r),
      (t[11] *= s),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, i, r));
  }
  makeTranslation(e, t, i) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return (this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this);
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return (this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this);
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return (this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this);
  }
  makeRotationAxis(e, t) {
    const i = Math.cos(t),
      r = Math.sin(t),
      s = 1 - i,
      o = e.x,
      a = e.y,
      l = e.z,
      c = s * o,
      u = s * a;
    return (
      this.set(
        c * o + i,
        c * a - r * l,
        c * l + r * a,
        0,
        c * a + r * l,
        u * a + i,
        u * l - r * o,
        0,
        c * l - r * a,
        u * l + r * o,
        s * l * l + i,
        0,
        0,
        0,
        0,
        1,
      ),
      this
    );
  }
  makeScale(e, t, i) {
    return (this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this);
  }
  makeShear(e, t, i, r, s, o) {
    return (this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1), this);
  }
  compose(e, t, i) {
    const r = this.elements,
      s = t._x,
      o = t._y,
      a = t._z,
      l = t._w,
      c = s + s,
      u = o + o,
      h = a + a,
      d = s * c,
      f = s * u,
      g = s * h,
      p = o * u,
      m = o * h,
      C = a * h,
      A = l * c,
      I = l * u,
      y = l * h,
      x = i.x,
      T = i.y,
      S = i.z;
    return (
      (r[0] = (1 - (p + C)) * x),
      (r[1] = (f + y) * x),
      (r[2] = (g - I) * x),
      (r[3] = 0),
      (r[4] = (f - y) * T),
      (r[5] = (1 - (d + C)) * T),
      (r[6] = (m + A) * T),
      (r[7] = 0),
      (r[8] = (g + I) * S),
      (r[9] = (m - A) * S),
      (r[10] = (1 - (d + p)) * S),
      (r[11] = 0),
      (r[12] = e.x),
      (r[13] = e.y),
      (r[14] = e.z),
      (r[15] = 1),
      this
    );
  }
  decompose(e, t, i) {
    const r = this.elements;
    let s = Hu.set(r[0], r[1], r[2]).length();
    const o = Hu.set(r[4], r[5], r[6]).length(),
      a = Hu.set(r[8], r[9], r[10]).length();
    (this.determinant() < 0 && (s = -s),
      (e.x = r[12]),
      (e.y = r[13]),
      (e.z = r[14]),
      Gs.copy(this));
    const c = 1 / s,
      u = 1 / o,
      h = 1 / a;
    return (
      (Gs.elements[0] *= c),
      (Gs.elements[1] *= c),
      (Gs.elements[2] *= c),
      (Gs.elements[4] *= u),
      (Gs.elements[5] *= u),
      (Gs.elements[6] *= u),
      (Gs.elements[8] *= h),
      (Gs.elements[9] *= h),
      (Gs.elements[10] *= h),
      t.setFromRotationMatrix(Gs),
      (i.x = s),
      (i.y = o),
      (i.z = a),
      this
    );
  }
  makePerspective(e, t, i, r, s, o, a = pa) {
    const l = this.elements,
      c = (2 * s) / (t - e),
      u = (2 * s) / (i - r),
      h = (t + e) / (t - e),
      d = (i + r) / (i - r);
    let f, g;
    if (a === pa) ((f = -(o + s) / (o - s)), (g = (-2 * o * s) / (o - s)));
    else if (a === Km) ((f = -o / (o - s)), (g = (-o * s) / (o - s)));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a,
      );
    return (
      (l[0] = c),
      (l[4] = 0),
      (l[8] = h),
      (l[12] = 0),
      (l[1] = 0),
      (l[5] = u),
      (l[9] = d),
      (l[13] = 0),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = f),
      (l[14] = g),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = -1),
      (l[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, i, r, s, o, a = pa) {
    const l = this.elements,
      c = 1 / (t - e),
      u = 1 / (i - r),
      h = 1 / (o - s),
      d = (t + e) * c,
      f = (i + r) * u;
    let g, p;
    if (a === pa) ((g = (o + s) * h), (p = -2 * h));
    else if (a === Km) ((g = s * h), (p = -1 * h));
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a,
      );
    return (
      (l[0] = 2 * c),
      (l[4] = 0),
      (l[8] = 0),
      (l[12] = -d),
      (l[1] = 0),
      (l[5] = 2 * u),
      (l[9] = 0),
      (l[13] = -f),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = p),
      (l[14] = -g),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = 0),
      (l[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      i = e.elements;
    for (let r = 0; r < 16; r++) if (t[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      (e[t + 9] = i[9]),
      (e[t + 10] = i[10]),
      (e[t + 11] = i[11]),
      (e[t + 12] = i[12]),
      (e[t + 13] = i[13]),
      (e[t + 14] = i[14]),
      (e[t + 15] = i[15]),
      e
    );
  }
}
const Hu = new X(),
  Gs = new Et(),
  _te = new X(0, 0, 0),
  bte = new X(1, 1, 1),
  $a = new X(),
  s1 = new X(),
  kr = new X(),
  Xx = new Et(),
  Kx = new Qs();
class Oo {
  constructor(e = 0, t = 0, i = 0, r = Oo.DEFAULT_ORDER) {
    ((this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = r));
  }
  get x() {
    return this._x;
  }
  set x(e) {
    ((this._x = e), this._onChangeCallback());
  }
  get y() {
    return this._y;
  }
  set y(e) {
    ((this._y = e), this._onChangeCallback());
  }
  get z() {
    return this._z;
  }
  set z(e) {
    ((this._z = e), this._onChangeCallback());
  }
  get order() {
    return this._order;
  }
  set order(e) {
    ((this._order = e), this._onChangeCallback());
  }
  set(e, t, i, r = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, i = !0) {
    const r = e.elements,
      s = r[0],
      o = r[4],
      a = r[8],
      l = r[1],
      c = r[5],
      u = r[9],
      h = r[2],
      d = r[6],
      f = r[10];
    switch (t) {
      case "XYZ":
        ((this._y = Math.asin(Wt(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-u, f)), (this._z = Math.atan2(-o, s)))
            : ((this._x = Math.atan2(d, c)), (this._z = 0)));
        break;
      case "YXZ":
        ((this._x = Math.asin(-Wt(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._y = Math.atan2(a, f)), (this._z = Math.atan2(l, c)))
            : ((this._y = Math.atan2(-h, s)), (this._z = 0)));
        break;
      case "ZXY":
        ((this._x = Math.asin(Wt(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._y = Math.atan2(-h, f)), (this._z = Math.atan2(-o, c)))
            : ((this._y = 0), (this._z = Math.atan2(l, s))));
        break;
      case "ZYX":
        ((this._y = Math.asin(-Wt(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._x = Math.atan2(d, f)), (this._z = Math.atan2(l, s)))
            : ((this._x = 0), (this._z = Math.atan2(-o, c))));
        break;
      case "YZX":
        ((this._z = Math.asin(Wt(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-u, c)), (this._y = Math.atan2(-h, s)))
            : ((this._x = 0), (this._y = Math.atan2(a, f))));
        break;
      case "XZY":
        ((this._z = Math.asin(-Wt(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(d, c)), (this._y = Math.atan2(a, s)))
            : ((this._x = Math.atan2(-u, f)), (this._y = 0)));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t,
        );
    }
    return ((this._order = t), i === !0 && this._onChangeCallback(), this);
  }
  setFromQuaternion(e, t, i) {
    return (
      Xx.makeRotationFromQuaternion(e),
      this.setFromRotationMatrix(Xx, t, i)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return (Kx.setFromEuler(this), this.setFromQuaternion(Kx, e));
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return ((this._onChangeCallback = e), this);
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    (yield this._x, yield this._y, yield this._z, yield this._order);
  }
}
Oo.DEFAULT_ORDER = "XYZ";
class Uv {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let vte = 0;
const jx = new X(),
  Wu = new Qs(),
  Qo = new Et(),
  o1 = new X(),
  df = new X(),
  xte = new X(),
  wte = new Qs(),
  $x = new X(1, 0, 0),
  Jx = new X(0, 1, 0),
  Qx = new X(0, 0, 1),
  qx = { type: "added" },
  Ste = { type: "removed" },
  Vu = { type: "childadded", child: null },
  T2 = { type: "childremoved", child: null };
class Hn extends wu {
  constructor() {
    (super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: vte++ }),
      (this.uuid = Js()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Hn.DEFAULT_UP.clone()));
    const e = new X(),
      t = new Oo(),
      i = new Qs(),
      r = new X(1, 1, 1);
    function s() {
      i.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(i, void 0, !1);
    }
    (t._onChange(s),
      i._onChange(o),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: i },
        scale: { configurable: !0, enumerable: !0, value: r },
        modelViewMatrix: { value: new Et() },
        normalMatrix: { value: new Pt() },
      }),
      (this.matrix = new Et()),
      (this.matrixWorld = new Et()),
      (this.matrixAutoUpdate = Hn.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = Hn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new Uv()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.customDepthMaterial = void 0),
      (this.customDistanceMaterial = void 0),
      (this.userData = {}));
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    (this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale));
  }
  applyQuaternion(e) {
    return (this.quaternion.premultiply(e), this);
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return (Wu.setFromAxisAngle(e, t), this.quaternion.multiply(Wu), this);
  }
  rotateOnWorldAxis(e, t) {
    return (Wu.setFromAxisAngle(e, t), this.quaternion.premultiply(Wu), this);
  }
  rotateX(e) {
    return this.rotateOnAxis($x, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(Jx, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(Qx, e);
  }
  translateOnAxis(e, t) {
    return (
      jx.copy(e).applyQuaternion(this.quaternion),
      this.position.add(jx.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis($x, e);
  }
  translateY(e) {
    return this.translateOnAxis(Jx, e);
  }
  translateZ(e) {
    return this.translateOnAxis(Qx, e);
  }
  localToWorld(e) {
    return (this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld));
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(Qo.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, i) {
    e.isVector3 ? o1.copy(e) : o1.set(e, t, i);
    const r = this.parent;
    (this.updateWorldMatrix(!0, !1),
      df.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? Qo.lookAt(df, o1, this.up)
        : Qo.lookAt(o1, df, this.up),
      this.quaternion.setFromRotationMatrix(Qo),
      r &&
        (Qo.extractRotation(r.matrixWorld),
        Wu.setFromRotationMatrix(Qo),
        this.quaternion.premultiply(Wu.invert())));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e,
        ),
        this)
      : (e && e.isObject3D
          ? (e.removeFromParent(),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(qx),
            (Vu.child = e),
            this.dispatchEvent(Vu),
            (Vu.child = null))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e,
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null),
        this.children.splice(t, 1),
        e.dispatchEvent(Ste),
        (T2.child = e),
        this.dispatchEvent(T2),
        (T2.child = null)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return (e !== null && e.remove(this), this);
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      Qo.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), Qo.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(Qo),
      e.removeFromParent(),
      (e.parent = this),
      this.children.push(e),
      e.updateWorldMatrix(!1, !0),
      e.dispatchEvent(qx),
      (Vu.child = e),
      this.dispatchEvent(Vu),
      (Vu.child = null),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let i = 0, r = this.children.length; i < r; i++) {
      const o = this.children[i].getObjectByProperty(e, t);
      if (o !== void 0) return o;
    }
  }
  getObjectsByProperty(e, t, i = []) {
    this[e] === t && i.push(this);
    const r = this.children;
    for (let s = 0, o = r.length; s < o; s++)
      r[s].getObjectsByProperty(e, t, i);
    return i;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      this.matrixWorld.decompose(df, e, xte),
      e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      this.matrixWorld.decompose(df, wte, e),
      e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    (this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0));
  }
  updateMatrixWorld(e) {
    (this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.matrixWorldAutoUpdate === !0 &&
          (this.parent === null
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix,
              )),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0)));
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, t) {
    const i = this.parent;
    if (
      (e === !0 && i !== null && i.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.matrixWorldAutoUpdate === !0 &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix,
            )),
      t === !0)
    ) {
      const r = this.children;
      for (let s = 0, o = r.length; s < o; s++) r[s].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      i = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (i.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const r = {};
    ((r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== "" && (r.name = this.name),
      this.castShadow === !0 && (r.castShadow = !0),
      this.receiveShadow === !0 && (r.receiveShadow = !0),
      this.visible === !1 && (r.visible = !1),
      this.frustumCulled === !1 && (r.frustumCulled = !1),
      this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      (r.layers = this.layers.mask),
      (r.matrix = this.matrix.toArray()),
      (r.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((r.type = "InstancedMesh"),
        (r.count = this.count),
        (r.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (r.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((r.type = "BatchedMesh"),
        (r.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (r.sortObjects = this.sortObjects),
        (r.drawRanges = this._drawRanges),
        (r.reservedRanges = this._reservedRanges),
        (r.geometryInfo = this._geometryInfo.map((a) => ({
          ...a,
          boundingBox: a.boundingBox
            ? {
                min: a.boundingBox.min.toArray(),
                max: a.boundingBox.max.toArray(),
              }
            : void 0,
          boundingSphere: a.boundingSphere
            ? {
                radius: a.boundingSphere.radius,
                center: a.boundingSphere.center.toArray(),
              }
            : void 0,
        }))),
        (r.instanceInfo = this._instanceInfo.map((a) => ({ ...a }))),
        (r.availableInstanceIds = this._availableInstanceIds.slice()),
        (r.availableGeometryIds = this._availableGeometryIds.slice()),
        (r.nextIndexStart = this._nextIndexStart),
        (r.nextVertexStart = this._nextVertexStart),
        (r.geometryCount = this._geometryCount),
        (r.maxInstanceCount = this._maxInstanceCount),
        (r.maxVertexCount = this._maxVertexCount),
        (r.maxIndexCount = this._maxIndexCount),
        (r.geometryInitialized = this._geometryInitialized),
        (r.matricesTexture = this._matricesTexture.toJSON(e)),
        (r.indirectTexture = this._indirectTexture.toJSON(e)),
        this._colorsTexture !== null &&
          (r.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null &&
          (r.boundingSphere = {
            center: this.boundingSphere.center.toArray(),
            radius: this.boundingSphere.radius,
          }),
        this.boundingBox !== null &&
          (r.boundingBox = {
            min: this.boundingBox.min.toArray(),
            max: this.boundingBox.max.toArray(),
          })));
    function s(a, l) {
      return (a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid);
    }
    if (this.isScene)
      (this.background &&
        (this.background.isColor
          ? (r.background = this.background.toJSON())
          : this.background.isTexture &&
            (r.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (r.environment = this.environment.toJSON(e).uuid));
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes;
        if (Array.isArray(l))
          for (let c = 0, u = l.length; c < u; c++) {
            const h = l[c];
            s(e.shapes, h);
          }
        else s(e.shapes, l);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((r.bindMode = this.bindMode),
        (r.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), (r.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const a = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          a.push(s(e.materials, this.material[l]));
        r.material = a;
      } else r.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let a = 0; a < this.children.length; a++)
        r.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a];
        r.animations.push(s(e.animations, l));
      }
    }
    if (t) {
      const a = o(e.geometries),
        l = o(e.materials),
        c = o(e.textures),
        u = o(e.images),
        h = o(e.shapes),
        d = o(e.skeletons),
        f = o(e.animations),
        g = o(e.nodes);
      (a.length > 0 && (i.geometries = a),
        l.length > 0 && (i.materials = l),
        c.length > 0 && (i.textures = c),
        u.length > 0 && (i.images = u),
        h.length > 0 && (i.shapes = h),
        d.length > 0 && (i.skeletons = d),
        f.length > 0 && (i.animations = f),
        g.length > 0 && (i.nodes = g));
    }
    return ((i.object = r), i);
    function o(a) {
      const l = [];
      for (const c in a) {
        const u = a[c];
        (delete u.metadata, l.push(u));
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let i = 0; i < e.children.length; i++) {
        const r = e.children[i];
        this.add(r.clone());
      }
    return this;
  }
}
Hn.DEFAULT_UP = new X(0, 1, 0);
Hn.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Hn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Fs = new X(),
  qo = new X(),
  E2 = new X(),
  ea = new X(),
  Zu = new X(),
  zu = new X(),
  ew = new X(),
  M2 = new X(),
  L2 = new X(),
  R2 = new X(),
  B2 = new ln(),
  P2 = new ln(),
  N2 = new ln();
class Ys {
  constructor(e = new X(), t = new X(), i = new X()) {
    ((this.a = e), (this.b = t), (this.c = i));
  }
  static getNormal(e, t, i, r) {
    (r.subVectors(i, t), Fs.subVectors(e, t), r.cross(Fs));
    const s = r.lengthSq();
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
  }
  static getBarycoord(e, t, i, r, s) {
    (Fs.subVectors(r, t), qo.subVectors(i, t), E2.subVectors(e, t));
    const o = Fs.dot(Fs),
      a = Fs.dot(qo),
      l = Fs.dot(E2),
      c = qo.dot(qo),
      u = qo.dot(E2),
      h = o * c - a * a;
    if (h === 0) return (s.set(0, 0, 0), null);
    const d = 1 / h,
      f = (c * l - a * u) * d,
      g = (o * u - a * l) * d;
    return s.set(1 - f - g, g, f);
  }
  static containsPoint(e, t, i, r) {
    return this.getBarycoord(e, t, i, r, ea) === null
      ? !1
      : ea.x >= 0 && ea.y >= 0 && ea.x + ea.y <= 1;
  }
  static getInterpolation(e, t, i, r, s, o, a, l) {
    return this.getBarycoord(e, t, i, r, ea) === null
      ? ((l.x = 0),
        (l.y = 0),
        "z" in l && (l.z = 0),
        "w" in l && (l.w = 0),
        null)
      : (l.setScalar(0),
        l.addScaledVector(s, ea.x),
        l.addScaledVector(o, ea.y),
        l.addScaledVector(a, ea.z),
        l);
  }
  static getInterpolatedAttribute(e, t, i, r, s, o) {
    return (
      B2.setScalar(0),
      P2.setScalar(0),
      N2.setScalar(0),
      B2.fromBufferAttribute(e, t),
      P2.fromBufferAttribute(e, i),
      N2.fromBufferAttribute(e, r),
      o.setScalar(0),
      o.addScaledVector(B2, s.x),
      o.addScaledVector(P2, s.y),
      o.addScaledVector(N2, s.z),
      o
    );
  }
  static isFrontFacing(e, t, i, r) {
    return (Fs.subVectors(i, t), qo.subVectors(e, t), Fs.cross(qo).dot(r) < 0);
  }
  set(e, t, i) {
    return (this.a.copy(e), this.b.copy(t), this.c.copy(i), this);
  }
  setFromPointsAndIndices(e, t, i, r) {
    return (this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this);
  }
  setFromAttributeAndIndices(e, t, i, r) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, i),
      this.c.fromBufferAttribute(e, r),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this);
  }
  getArea() {
    return (
      Fs.subVectors(this.c, this.b),
      qo.subVectors(this.a, this.b),
      Fs.cross(qo).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Ys.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return Ys.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, i, r, s) {
    return Ys.getInterpolation(e, this.a, this.b, this.c, t, i, r, s);
  }
  containsPoint(e) {
    return Ys.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Ys.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const i = this.a,
      r = this.b,
      s = this.c;
    let o, a;
    (Zu.subVectors(r, i), zu.subVectors(s, i), M2.subVectors(e, i));
    const l = Zu.dot(M2),
      c = zu.dot(M2);
    if (l <= 0 && c <= 0) return t.copy(i);
    L2.subVectors(e, r);
    const u = Zu.dot(L2),
      h = zu.dot(L2);
    if (u >= 0 && h <= u) return t.copy(r);
    const d = l * h - u * c;
    if (d <= 0 && l >= 0 && u <= 0)
      return ((o = l / (l - u)), t.copy(i).addScaledVector(Zu, o));
    R2.subVectors(e, s);
    const f = Zu.dot(R2),
      g = zu.dot(R2);
    if (g >= 0 && f <= g) return t.copy(s);
    const p = f * c - l * g;
    if (p <= 0 && c >= 0 && g <= 0)
      return ((a = c / (c - g)), t.copy(i).addScaledVector(zu, a));
    const m = u * g - f * h;
    if (m <= 0 && h - u >= 0 && f - g >= 0)
      return (
        ew.subVectors(s, r),
        (a = (h - u) / (h - u + (f - g))),
        t.copy(r).addScaledVector(ew, a)
      );
    const C = 1 / (m + p + d);
    return (
      (o = p * C),
      (a = d * C),
      t.copy(i).addScaledVector(Zu, o).addScaledVector(zu, a)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const iR = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  Ja = { h: 0, s: 0, l: 0 },
  a1 = { h: 0, s: 0, l: 0 };
function D2(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
        ? e
        : t < 2 / 3
          ? n + (e - n) * 6 * (2 / 3 - t)
          : n
  );
}
let vt = class {
  constructor(e, t, i) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, t, i)
    );
  }
  set(e, t, i) {
    if (t === void 0 && i === void 0) {
      const r = e;
      r && r.isColor
        ? this.copy(r)
        : typeof r == "number"
          ? this.setHex(r)
          : typeof r == "string" && this.setStyle(r);
    } else this.setRGB(e, t, i);
    return this;
  }
  setScalar(e) {
    return ((this.r = e), (this.g = e), (this.b = e), this);
  }
  setHex(e, t = Gi) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      Kt.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, i, r = Kt.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = i),
      Kt.toWorkingColorSpace(this, r),
      this
    );
  }
  setHSL(e, t, i, r = Kt.workingColorSpace) {
    if (((e = kv(e, 1)), (t = Wt(t, 0, 1)), (i = Wt(i, 0, 1)), t === 0))
      this.r = this.g = this.b = i;
    else {
      const s = i <= 0.5 ? i * (1 + t) : i + t - i * t,
        o = 2 * i - s;
      ((this.r = D2(o, s, e + 1 / 3)),
        (this.g = D2(o, s, e)),
        (this.b = D2(o, s, e - 1 / 3)));
    }
    return (Kt.toWorkingColorSpace(this, r), this);
  }
  setStyle(e, t = Gi) {
    function i(s) {
      s !== void 0 &&
        parseFloat(s) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored.",
        );
    }
    let r;
    if ((r = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let s;
      const o = r[1],
        a = r[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (
            (s =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a,
              ))
          )
            return (
              i(s[4]),
              this.setRGB(
                Math.min(255, parseInt(s[1], 10)) / 255,
                Math.min(255, parseInt(s[2], 10)) / 255,
                Math.min(255, parseInt(s[3], 10)) / 255,
                t,
              )
            );
          if (
            (s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a,
              ))
          )
            return (
              i(s[4]),
              this.setRGB(
                Math.min(100, parseInt(s[1], 10)) / 100,
                Math.min(100, parseInt(s[2], 10)) / 100,
                Math.min(100, parseInt(s[3], 10)) / 100,
                t,
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a,
              ))
          )
            return (
              i(s[4]),
              this.setHSL(
                parseFloat(s[1]) / 360,
                parseFloat(s[2]) / 100,
                parseFloat(s[3]) / 100,
                t,
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((r = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const s = r[1],
        o = s.length;
      if (o === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          t,
        );
      if (o === 6) return this.setHex(parseInt(s, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = Gi) {
    const i = iR[e.toLowerCase()];
    return (
      i !== void 0
        ? this.setHex(i, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return ((this.r = e.r), (this.g = e.g), (this.b = e.b), this);
  }
  copySRGBToLinear(e) {
    return ((this.r = Sa(e.r)), (this.g = Sa(e.g)), (this.b = Sa(e.b)), this);
  }
  copyLinearToSRGB(e) {
    return ((this.r = Nh(e.r)), (this.g = Nh(e.g)), (this.b = Nh(e.b)), this);
  }
  convertSRGBToLinear() {
    return (this.copySRGBToLinear(this), this);
  }
  convertLinearToSRGB() {
    return (this.copyLinearToSRGB(this), this);
  }
  getHex(e = Gi) {
    return (
      Kt.fromWorkingColorSpace(Wi.copy(this), e),
      Math.round(Wt(Wi.r * 255, 0, 255)) * 65536 +
        Math.round(Wt(Wi.g * 255, 0, 255)) * 256 +
        Math.round(Wt(Wi.b * 255, 0, 255))
    );
  }
  getHexString(e = Gi) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = Kt.workingColorSpace) {
    Kt.fromWorkingColorSpace(Wi.copy(this), t);
    const i = Wi.r,
      r = Wi.g,
      s = Wi.b,
      o = Math.max(i, r, s),
      a = Math.min(i, r, s);
    let l, c;
    const u = (a + o) / 2;
    if (a === o) ((l = 0), (c = 0));
    else {
      const h = o - a;
      switch (((c = u <= 0.5 ? h / (o + a) : h / (2 - o - a)), o)) {
        case i:
          l = (r - s) / h + (r < s ? 6 : 0);
          break;
        case r:
          l = (s - i) / h + 2;
          break;
        case s:
          l = (i - r) / h + 4;
          break;
      }
      l /= 6;
    }
    return ((e.h = l), (e.s = c), (e.l = u), e);
  }
  getRGB(e, t = Kt.workingColorSpace) {
    return (
      Kt.fromWorkingColorSpace(Wi.copy(this), t),
      (e.r = Wi.r),
      (e.g = Wi.g),
      (e.b = Wi.b),
      e
    );
  }
  getStyle(e = Gi) {
    Kt.fromWorkingColorSpace(Wi.copy(this), e);
    const t = Wi.r,
      i = Wi.g,
      r = Wi.b;
    return e !== Gi
      ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})`
      : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(r * 255)})`;
  }
  offsetHSL(e, t, i) {
    return (this.getHSL(Ja), this.setHSL(Ja.h + e, Ja.s + t, Ja.l + i));
  }
  add(e) {
    return ((this.r += e.r), (this.g += e.g), (this.b += e.b), this);
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r),
      (this.g = e.g + t.g),
      (this.b = e.b + t.b),
      this
    );
  }
  addScalar(e) {
    return ((this.r += e), (this.g += e), (this.b += e), this);
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return ((this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this);
  }
  multiplyScalar(e) {
    return ((this.r *= e), (this.g *= e), (this.b *= e), this);
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, i) {
    return (
      (this.r = e.r + (t.r - e.r) * i),
      (this.g = e.g + (t.g - e.g) * i),
      (this.b = e.b + (t.b - e.b) * i),
      this
    );
  }
  lerpHSL(e, t) {
    (this.getHSL(Ja), e.getHSL(a1));
    const i = ng(Ja.h, a1.h, t),
      r = ng(Ja.s, a1.s, t),
      s = ng(Ja.l, a1.l, t);
    return (this.setHSL(i, r, s), this);
  }
  setFromVector3(e) {
    return ((this.r = e.x), (this.g = e.y), (this.b = e.z), this);
  }
  applyMatrix3(e) {
    const t = this.r,
      i = this.g,
      r = this.b,
      s = e.elements;
    return (
      (this.r = s[0] * t + s[3] * i + s[6] * r),
      (this.g = s[1] * t + s[4] * i + s[7] * r),
      (this.b = s[2] * t + s[5] * i + s[8] * r),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return ((this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this);
  }
  toArray(e = [], t = 0) {
    return ((e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e);
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)),
      (this.g = e.getY(t)),
      (this.b = e.getZ(t)),
      this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    (yield this.r, yield this.g, yield this.b);
  }
};
const Wi = new vt();
vt.NAMES = iR;
let Tte = 0;
class Mo extends wu {
  constructor() {
    (super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: Tte++ }),
      (this.uuid = Js()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = Ph),
      (this.side = Go),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = u_),
      (this.blendDst = h_),
      (this.blendEquation = Fc),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new vt(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = rd),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = Ux),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = Gu),
      (this.stencilZFail = Gu),
      (this.stencilZPass = Gu),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.allowOverride = !0),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0));
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    (this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e));
  }
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const i = e[t];
        if (i === void 0) {
          console.warn(
            `THREE.Material: parameter '${t}' has value of undefined.`,
          );
          continue;
        }
        const r = this[t];
        if (r === void 0) {
          console.warn(
            `THREE.Material: '${t}' is not a property of THREE.${this.type}.`,
          );
          continue;
        }
        r && r.isColor
          ? r.set(i)
          : r && r.isVector3 && i && i.isVector3
            ? r.copy(i)
            : (this[t] = i);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const i = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    ((i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.color && this.color.isColor && (i.color = this.color.getHex()),
      this.roughness !== void 0 && (i.roughness = this.roughness),
      this.metalness !== void 0 && (i.metalness = this.metalness),
      this.sheen !== void 0 && (i.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (i.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (i.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (i.emissive = this.emissive.getHex()),
      this.emissiveIntensity !== void 0 &&
        this.emissiveIntensity !== 1 &&
        (i.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (i.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (i.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (i.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (i.shininess = this.shininess),
      this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.dispersion !== void 0 && (i.dispersion = this.dispersion),
      this.iridescence !== void 0 && (i.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (i.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (i.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (i.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (i.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (i.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((i.lightMap = this.lightMap.toJSON(e).uuid),
        (i.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((i.aoMap = this.aoMap.toJSON(e).uuid),
        (i.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((i.bumpMap = this.bumpMap.toJSON(e).uuid),
        (i.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((i.normalMap = this.normalMap.toJSON(e).uuid),
        (i.normalMapType = this.normalMapType),
        (i.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((i.displacementMap = this.displacementMap.toJSON(e).uuid),
        (i.displacementScale = this.displacementScale),
        (i.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (i.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((i.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (i.combine = this.combine)),
      this.envMapRotation !== void 0 &&
        (i.envMapRotation = this.envMapRotation.toArray()),
      this.envMapIntensity !== void 0 &&
        (i.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (i.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (i.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (i.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (i.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (i.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (i.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (i.size = this.size),
      this.shadowSide !== null && (i.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (i.sizeAttenuation = this.sizeAttenuation),
      this.blending !== Ph && (i.blending = this.blending),
      this.side !== Go && (i.side = this.side),
      this.vertexColors === !0 && (i.vertexColors = !0),
      this.opacity < 1 && (i.opacity = this.opacity),
      this.transparent === !0 && (i.transparent = !0),
      this.blendSrc !== u_ && (i.blendSrc = this.blendSrc),
      this.blendDst !== h_ && (i.blendDst = this.blendDst),
      this.blendEquation !== Fc && (i.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (i.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (i.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha),
      this.depthFunc !== rd && (i.depthFunc = this.depthFunc),
      this.depthTest === !1 && (i.depthTest = this.depthTest),
      this.depthWrite === !1 && (i.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (i.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (i.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== Ux && (i.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (i.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (i.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== Gu && (i.stencilFail = this.stencilFail),
      this.stencilZFail !== Gu && (i.stencilZFail = this.stencilZFail),
      this.stencilZPass !== Gu && (i.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (i.rotation = this.rotation),
      this.polygonOffset === !0 && (i.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (i.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (i.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (i.linewidth = this.linewidth),
      this.dashSize !== void 0 && (i.dashSize = this.dashSize),
      this.gapSize !== void 0 && (i.gapSize = this.gapSize),
      this.scale !== void 0 && (i.scale = this.scale),
      this.dithering === !0 && (i.dithering = !0),
      this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (i.alphaHash = !0),
      this.alphaToCoverage === !0 && (i.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (i.forceSinglePass = !0),
      this.wireframe === !0 && (i.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (i.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (i.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (i.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (i.flatShading = !0),
      this.visible === !1 && (i.visible = !1),
      this.toneMapped === !1 && (i.toneMapped = !1),
      this.fog === !1 && (i.fog = !1),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData));
    function r(s) {
      const o = [];
      for (const a in s) {
        const l = s[a];
        (delete l.metadata, o.push(l));
      }
      return o;
    }
    if (t) {
      const s = r(e.textures),
        o = r(e.images);
      (s.length > 0 && (i.textures = s), o.length > 0 && (i.images = o));
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    ((this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite));
    const t = e.clippingPlanes;
    let i = null;
    if (t !== null) {
      const r = t.length;
      i = new Array(r);
      for (let s = 0; s !== r; ++s) i[s] = t[s].clone();
    }
    return (
      (this.clippingPlanes = i),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class ma extends Mo {
  constructor(e) {
    (super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new vt(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Oo()),
      (this.combine = WL),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const ei = new X(),
  l1 = new Gt();
let Ete = 0;
class Pi {
  constructor(e, t, i = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array.",
      );
    ((this.isBufferAttribute = !0),
      Object.defineProperty(this, "id", { value: Ete++ }),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = i),
      (this.usage = j_),
      (this.updateRanges = []),
      (this.gpuType = Xr),
      (this.version = 0));
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return ((this.usage = e), this);
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, t, i) {
    ((e *= this.itemSize), (i *= t.itemSize));
    for (let r = 0, s = this.itemSize; r < s; r++)
      this.array[e + r] = t.array[i + r];
    return this;
  }
  copyArray(e) {
    return (this.array.set(e), this);
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, i = this.count; t < i; t++)
        (l1.fromBufferAttribute(this, t),
          l1.applyMatrix3(e),
          this.setXY(t, l1.x, l1.y));
    else if (this.itemSize === 3)
      for (let t = 0, i = this.count; t < i; t++)
        (ei.fromBufferAttribute(this, t),
          ei.applyMatrix3(e),
          this.setXYZ(t, ei.x, ei.y, ei.z));
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.count; t < i; t++)
      (ei.fromBufferAttribute(this, t),
        ei.applyMatrix4(e),
        this.setXYZ(t, ei.x, ei.y, ei.z));
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      (ei.fromBufferAttribute(this, t),
        ei.applyNormalMatrix(e),
        this.setXYZ(t, ei.x, ei.y, ei.z));
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      (ei.fromBufferAttribute(this, t),
        ei.transformDirection(e),
        this.setXYZ(t, ei.x, ei.y, ei.z));
    return this;
  }
  set(e, t = 0) {
    return (this.array.set(e, t), this);
  }
  getComponent(e, t) {
    let i = this.array[e * this.itemSize + t];
    return (this.normalized && (i = zs(i, this.array)), i);
  }
  setComponent(e, t, i) {
    return (
      this.normalized && (i = gn(i, this.array)),
      (this.array[e * this.itemSize + t] = i),
      this
    );
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return (this.normalized && (t = zs(t, this.array)), t);
  }
  setX(e, t) {
    return (
      this.normalized && (t = gn(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return (this.normalized && (t = zs(t, this.array)), t);
  }
  setY(e, t) {
    return (
      this.normalized && (t = gn(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return (this.normalized && (t = zs(t, this.array)), t);
  }
  setZ(e, t) {
    return (
      this.normalized && (t = gn(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return (this.normalized && (t = zs(t, this.array)), t);
  }
  setW(e, t) {
    return (
      this.normalized && (t = gn(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, i) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = gn(t, this.array)), (i = gn(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = gn(t, this.array)),
        (i = gn(i, this.array)),
        (r = gn(r, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = gn(t, this.array)),
        (i = gn(i, this.array)),
        (r = gn(r, this.array)),
        (s = gn(s, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      (this.array[e + 3] = s),
      this
    );
  }
  onUpload(e) {
    return ((this.onUploadCallback = e), this);
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== j_ && (e.usage = this.usage),
      e
    );
  }
}
class rR extends Pi {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i);
  }
}
class sR extends Pi {
  constructor(e, t, i) {
    super(new Uint32Array(e), t, i);
  }
}
class tr extends Pi {
  constructor(e, t, i) {
    super(new Float32Array(e), t, i);
  }
}
let Mte = 0;
const cs = new Et(),
  G2 = new Hn(),
  Yu = new X(),
  Or = new ka(),
  ff = new ka(),
  yi = new X();
class Pr extends wu {
  constructor() {
    (super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: Mte++ }),
      (this.uuid = Js()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.indirect = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {}));
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (tR(e) ? sR : rR)(e, 1))
        : (this.index = e),
      this
    );
  }
  setIndirect(e) {
    return ((this.indirect = e), this);
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return ((this.attributes[e] = t), this);
  }
  deleteAttribute(e) {
    return (delete this.attributes[e], this);
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, i = 0) {
    this.groups.push({ start: e, count: t, materialIndex: i });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    ((this.drawRange.start = e), (this.drawRange.count = t));
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const i = this.attributes.normal;
    if (i !== void 0) {
      const s = new Pt().getNormalMatrix(e);
      (i.applyNormalMatrix(s), (i.needsUpdate = !0));
    }
    const r = this.attributes.tangent;
    return (
      r !== void 0 && (r.transformDirection(e), (r.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return (cs.makeRotationFromQuaternion(e), this.applyMatrix4(cs), this);
  }
  rotateX(e) {
    return (cs.makeRotationX(e), this.applyMatrix4(cs), this);
  }
  rotateY(e) {
    return (cs.makeRotationY(e), this.applyMatrix4(cs), this);
  }
  rotateZ(e) {
    return (cs.makeRotationZ(e), this.applyMatrix4(cs), this);
  }
  translate(e, t, i) {
    return (cs.makeTranslation(e, t, i), this.applyMatrix4(cs), this);
  }
  scale(e, t, i) {
    return (cs.makeScale(e, t, i), this.applyMatrix4(cs), this);
  }
  lookAt(e) {
    return (
      G2.lookAt(e),
      G2.updateMatrix(),
      this.applyMatrix4(G2.matrix),
      this
    );
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(Yu).negate(),
      this.translate(Yu.x, Yu.y, Yu.z),
      this
    );
  }
  setFromPoints(e) {
    const t = this.getAttribute("position");
    if (t === void 0) {
      const i = [];
      for (let r = 0, s = e.length; r < s; r++) {
        const o = e[r];
        i.push(o.x, o.y, o.z || 0);
      }
      this.setAttribute("position", new tr(i, 3));
    } else {
      const i = Math.min(e.length, t.count);
      for (let r = 0; r < i; r++) {
        const s = e[r];
        t.setXYZ(r, s.x, s.y, s.z || 0);
      }
      (e.length > t.count &&
        console.warn(
          "THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.",
        ),
        (t.needsUpdate = !0));
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new ka());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      (console.error(
        "THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
        this,
      ),
        this.boundingBox.set(
          new X(-1 / 0, -1 / 0, -1 / 0),
          new X(1 / 0, 1 / 0, 1 / 0),
        ));
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let i = 0, r = t.length; i < r; i++) {
          const s = t[i];
          (Or.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (yi.addVectors(this.boundingBox.min, Or.min),
                this.boundingBox.expandByPoint(yi),
                yi.addVectors(this.boundingBox.max, Or.max),
                this.boundingBox.expandByPoint(yi))
              : (this.boundingBox.expandByPoint(Or.min),
                this.boundingBox.expandByPoint(Or.max)));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this,
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Zo());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      (console.error(
        "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
        this,
      ),
        this.boundingSphere.set(new X(), 1 / 0));
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if ((Or.setFromBufferAttribute(e), t))
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s];
          (ff.setFromBufferAttribute(a),
            this.morphTargetsRelative
              ? (yi.addVectors(Or.min, ff.min),
                Or.expandByPoint(yi),
                yi.addVectors(Or.max, ff.max),
                Or.expandByPoint(yi))
              : (Or.expandByPoint(ff.min), Or.expandByPoint(ff.max)));
        }
      Or.getCenter(i);
      let r = 0;
      for (let s = 0, o = e.count; s < o; s++)
        (yi.fromBufferAttribute(e, s),
          (r = Math.max(r, i.distanceToSquared(yi))));
      if (t)
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s],
            l = this.morphTargetsRelative;
          for (let c = 0, u = a.count; c < u; c++)
            (yi.fromBufferAttribute(a, c),
              l && (Yu.fromBufferAttribute(e, c), yi.add(Yu)),
              (r = Math.max(r, i.distanceToSquared(yi))));
        }
      ((this.boundingSphere.radius = Math.sqrt(r)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this,
          ));
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)",
      );
      return;
    }
    const i = t.position,
      r = t.normal,
      s = t.uv;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new Pi(new Float32Array(4 * i.count), 4));
    const o = this.getAttribute("tangent"),
      a = [],
      l = [];
    for (let E = 0; E < i.count; E++) ((a[E] = new X()), (l[E] = new X()));
    const c = new X(),
      u = new X(),
      h = new X(),
      d = new Gt(),
      f = new Gt(),
      g = new Gt(),
      p = new X(),
      m = new X();
    function C(E, _, b) {
      (c.fromBufferAttribute(i, E),
        u.fromBufferAttribute(i, _),
        h.fromBufferAttribute(i, b),
        d.fromBufferAttribute(s, E),
        f.fromBufferAttribute(s, _),
        g.fromBufferAttribute(s, b),
        u.sub(c),
        h.sub(c),
        f.sub(d),
        g.sub(d));
      const R = 1 / (f.x * g.y - g.x * f.y);
      isFinite(R) &&
        (p
          .copy(u)
          .multiplyScalar(g.y)
          .addScaledVector(h, -f.y)
          .multiplyScalar(R),
        m
          .copy(h)
          .multiplyScalar(f.x)
          .addScaledVector(u, -g.x)
          .multiplyScalar(R),
        a[E].add(p),
        a[_].add(p),
        a[b].add(p),
        l[E].add(m),
        l[_].add(m),
        l[b].add(m));
    }
    let A = this.groups;
    A.length === 0 && (A = [{ start: 0, count: e.count }]);
    for (let E = 0, _ = A.length; E < _; ++E) {
      const b = A[E],
        R = b.start,
        M = b.count;
      for (let L = R, P = R + M; L < P; L += 3)
        C(e.getX(L + 0), e.getX(L + 1), e.getX(L + 2));
    }
    const I = new X(),
      y = new X(),
      x = new X(),
      T = new X();
    function S(E) {
      (x.fromBufferAttribute(r, E), T.copy(x));
      const _ = a[E];
      (I.copy(_),
        I.sub(x.multiplyScalar(x.dot(_))).normalize(),
        y.crossVectors(T, _));
      const R = y.dot(l[E]) < 0 ? -1 : 1;
      o.setXYZW(E, I.x, I.y, I.z, R);
    }
    for (let E = 0, _ = A.length; E < _; ++E) {
      const b = A[E],
        R = b.start,
        M = b.count;
      for (let L = R, P = R + M; L < P; L += 3)
        (S(e.getX(L + 0)), S(e.getX(L + 1)), S(e.getX(L + 2)));
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        ((i = new Pi(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", i));
      else for (let d = 0, f = i.count; d < f; d++) i.setXYZ(d, 0, 0, 0);
      const r = new X(),
        s = new X(),
        o = new X(),
        a = new X(),
        l = new X(),
        c = new X(),
        u = new X(),
        h = new X();
      if (e)
        for (let d = 0, f = e.count; d < f; d += 3) {
          const g = e.getX(d + 0),
            p = e.getX(d + 1),
            m = e.getX(d + 2);
          (r.fromBufferAttribute(t, g),
            s.fromBufferAttribute(t, p),
            o.fromBufferAttribute(t, m),
            u.subVectors(o, s),
            h.subVectors(r, s),
            u.cross(h),
            a.fromBufferAttribute(i, g),
            l.fromBufferAttribute(i, p),
            c.fromBufferAttribute(i, m),
            a.add(u),
            l.add(u),
            c.add(u),
            i.setXYZ(g, a.x, a.y, a.z),
            i.setXYZ(p, l.x, l.y, l.z),
            i.setXYZ(m, c.x, c.y, c.z));
        }
      else
        for (let d = 0, f = t.count; d < f; d += 3)
          (r.fromBufferAttribute(t, d + 0),
            s.fromBufferAttribute(t, d + 1),
            o.fromBufferAttribute(t, d + 2),
            u.subVectors(o, s),
            h.subVectors(r, s),
            u.cross(h),
            i.setXYZ(d + 0, u.x, u.y, u.z),
            i.setXYZ(d + 1, u.x, u.y, u.z),
            i.setXYZ(d + 2, u.x, u.y, u.z));
      (this.normalizeNormals(), (i.needsUpdate = !0));
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, i = e.count; t < i; t++)
      (yi.fromBufferAttribute(e, t),
        yi.normalize(),
        e.setXYZ(t, yi.x, yi.y, yi.z));
  }
  toNonIndexed() {
    function e(a, l) {
      const c = a.array,
        u = a.itemSize,
        h = a.normalized,
        d = new c.constructor(l.length * u);
      let f = 0,
        g = 0;
      for (let p = 0, m = l.length; p < m; p++) {
        a.isInterleavedBufferAttribute
          ? (f = l[p] * a.data.stride + a.offset)
          : (f = l[p] * u);
        for (let C = 0; C < u; C++) d[g++] = c[f++];
      }
      return new Pi(d, u, h);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.",
        ),
        this
      );
    const t = new Pr(),
      i = this.index.array,
      r = this.attributes;
    for (const a in r) {
      const l = r[a],
        c = e(l, i);
      t.setAttribute(a, c);
    }
    const s = this.morphAttributes;
    for (const a in s) {
      const l = [],
        c = s[a];
      for (let u = 0, h = c.length; u < h; u++) {
        const d = c[u],
          f = e(d, i);
        l.push(f);
      }
      t.morphAttributes[a] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let a = 0, l = o.length; a < l; a++) {
      const c = o[a];
      t.addGroup(c.start, c.count, c.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const l = this.parameters;
      for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const i = this.attributes;
    for (const l in i) {
      const c = i[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const r = {};
    let s = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l],
        u = [];
      for (let h = 0, d = c.length; h < d; h++) {
        const f = c[h];
        u.push(f.toJSON(e.data));
      }
      u.length > 0 && ((r[l] = u), (s = !0));
    }
    s &&
      ((e.data.morphAttributes = r),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const a = this.boundingSphere;
    return (
      a !== null &&
        (e.data.boundingSphere = {
          center: a.center.toArray(),
          radius: a.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    ((this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null));
    const t = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone());
    const r = e.attributes;
    for (const c in r) {
      const u = r[c];
      this.setAttribute(c, u.clone(t));
    }
    const s = e.morphAttributes;
    for (const c in s) {
      const u = [],
        h = s[c];
      for (let d = 0, f = h.length; d < f; d++) u.push(h[d].clone(t));
      this.morphAttributes[c] = u;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let c = 0, u = o.length; c < u; c++) {
      const h = o[c];
      this.addGroup(h.start, h.count, h.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const l = e.boundingSphere;
    return (
      l !== null && (this.boundingSphere = l.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const tw = new Et(),
  sc = new Sp(),
  c1 = new Zo(),
  nw = new X(),
  u1 = new X(),
  h1 = new X(),
  d1 = new X(),
  F2 = new X(),
  f1 = new X(),
  iw = new X(),
  g1 = new X();
let si = class extends Hn {
  constructor(e = new Pr(), t = new ma()) {
    (super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      (this.morphTargetDictionary = void 0),
      (this.morphTargetInfluences = void 0),
      this.updateMorphTargets());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary,
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        ((this.morphTargetInfluences = []), (this.morphTargetDictionary = {}));
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          (this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s));
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const i = this.geometry,
      r = i.attributes.position,
      s = i.morphAttributes.position,
      o = i.morphTargetsRelative;
    t.fromBufferAttribute(r, e);
    const a = this.morphTargetInfluences;
    if (s && a) {
      f1.set(0, 0, 0);
      for (let l = 0, c = s.length; l < c; l++) {
        const u = a[l],
          h = s[l];
        u !== 0 &&
          (F2.fromBufferAttribute(h, e),
          o ? f1.addScaledVector(F2, u) : f1.addScaledVector(F2.sub(t), u));
      }
      t.add(f1);
    }
    return t;
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.material,
      s = this.matrixWorld;
    r !== void 0 &&
      (i.boundingSphere === null && i.computeBoundingSphere(),
      c1.copy(i.boundingSphere),
      c1.applyMatrix4(s),
      sc.copy(e.ray).recast(e.near),
      !(
        c1.containsPoint(sc.origin) === !1 &&
        (sc.intersectSphere(c1, nw) === null ||
          sc.origin.distanceToSquared(nw) > (e.far - e.near) ** 2)
      ) &&
        (tw.copy(s).invert(),
        sc.copy(e.ray).applyMatrix4(tw),
        !(i.boundingBox !== null && sc.intersectsBox(i.boundingBox) === !1) &&
          this._computeIntersections(e, t, sc)));
  }
  _computeIntersections(e, t, i) {
    let r;
    const s = this.geometry,
      o = this.material,
      a = s.index,
      l = s.attributes.position,
      c = s.attributes.uv,
      u = s.attributes.uv1,
      h = s.attributes.normal,
      d = s.groups,
      f = s.drawRange;
    if (a !== null)
      if (Array.isArray(o))
        for (let g = 0, p = d.length; g < p; g++) {
          const m = d[g],
            C = o[m.materialIndex],
            A = Math.max(m.start, f.start),
            I = Math.min(
              a.count,
              Math.min(m.start + m.count, f.start + f.count),
            );
          for (let y = A, x = I; y < x; y += 3) {
            const T = a.getX(y),
              S = a.getX(y + 1),
              E = a.getX(y + 2);
            ((r = p1(this, C, e, i, c, u, h, T, S, E)),
              r &&
                ((r.faceIndex = Math.floor(y / 3)),
                (r.face.materialIndex = m.materialIndex),
                t.push(r)));
          }
        }
      else {
        const g = Math.max(0, f.start),
          p = Math.min(a.count, f.start + f.count);
        for (let m = g, C = p; m < C; m += 3) {
          const A = a.getX(m),
            I = a.getX(m + 1),
            y = a.getX(m + 2);
          ((r = p1(this, o, e, i, c, u, h, A, I, y)),
            r && ((r.faceIndex = Math.floor(m / 3)), t.push(r)));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(o))
        for (let g = 0, p = d.length; g < p; g++) {
          const m = d[g],
            C = o[m.materialIndex],
            A = Math.max(m.start, f.start),
            I = Math.min(
              l.count,
              Math.min(m.start + m.count, f.start + f.count),
            );
          for (let y = A, x = I; y < x; y += 3) {
            const T = y,
              S = y + 1,
              E = y + 2;
            ((r = p1(this, C, e, i, c, u, h, T, S, E)),
              r &&
                ((r.faceIndex = Math.floor(y / 3)),
                (r.face.materialIndex = m.materialIndex),
                t.push(r)));
          }
        }
      else {
        const g = Math.max(0, f.start),
          p = Math.min(l.count, f.start + f.count);
        for (let m = g, C = p; m < C; m += 3) {
          const A = m,
            I = m + 1,
            y = m + 2;
          ((r = p1(this, o, e, i, c, u, h, A, I, y)),
            r && ((r.faceIndex = Math.floor(m / 3)), t.push(r)));
        }
      }
  }
};
function Lte(n, e, t, i, r, s, o, a) {
  let l;
  if (
    (e.side === er
      ? (l = i.intersectTriangle(o, s, r, !0, a))
      : (l = i.intersectTriangle(r, s, o, e.side === Go, a)),
    l === null)
  )
    return null;
  (g1.copy(a), g1.applyMatrix4(n.matrixWorld));
  const c = t.ray.origin.distanceTo(g1);
  return c < t.near || c > t.far
    ? null
    : { distance: c, point: g1.clone(), object: n };
}
function p1(n, e, t, i, r, s, o, a, l, c) {
  (n.getVertexPosition(a, u1),
    n.getVertexPosition(l, h1),
    n.getVertexPosition(c, d1));
  const u = Lte(n, e, t, i, u1, h1, d1, iw);
  if (u) {
    const h = new X();
    (Ys.getBarycoord(iw, u1, h1, d1, h),
      r && (u.uv = Ys.getInterpolatedAttribute(r, a, l, c, h, new Gt())),
      s && (u.uv1 = Ys.getInterpolatedAttribute(s, a, l, c, h, new Gt())),
      o &&
        ((u.normal = Ys.getInterpolatedAttribute(o, a, l, c, h, new X())),
        u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1)));
    const d = { a, b: l, c, normal: new X(), materialIndex: 0 };
    (Ys.getNormal(u1, h1, d1, d.normal), (u.face = d), (u.barycoord = h));
  }
  return u;
}
class Tp extends Pr {
  constructor(e = 1, t = 1, i = 1, r = 1, s = 1, o = 1) {
    (super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: i,
        widthSegments: r,
        heightSegments: s,
        depthSegments: o,
      }));
    const a = this;
    ((r = Math.floor(r)), (s = Math.floor(s)), (o = Math.floor(o)));
    const l = [],
      c = [],
      u = [],
      h = [];
    let d = 0,
      f = 0;
    (g("z", "y", "x", -1, -1, i, t, e, o, s, 0),
      g("z", "y", "x", 1, -1, i, t, -e, o, s, 1),
      g("x", "z", "y", 1, 1, e, i, t, r, o, 2),
      g("x", "z", "y", 1, -1, e, i, -t, r, o, 3),
      g("x", "y", "z", 1, -1, e, t, i, r, s, 4),
      g("x", "y", "z", -1, -1, e, t, -i, r, s, 5),
      this.setIndex(l),
      this.setAttribute("position", new tr(c, 3)),
      this.setAttribute("normal", new tr(u, 3)),
      this.setAttribute("uv", new tr(h, 2)));
    function g(p, m, C, A, I, y, x, T, S, E, _) {
      const b = y / S,
        R = x / E,
        M = y / 2,
        L = x / 2,
        P = T / 2,
        U = S + 1,
        O = E + 1;
      let V = 0,
        W = 0;
      const re = new X();
      for (let Z = 0; Z < O; Z++) {
        const te = Z * R - L;
        for (let ge = 0; ge < U; ge++) {
          const be = ge * b - M;
          ((re[p] = be * A),
            (re[m] = te * I),
            (re[C] = P),
            c.push(re.x, re.y, re.z),
            (re[p] = 0),
            (re[m] = 0),
            (re[C] = T > 0 ? 1 : -1),
            u.push(re.x, re.y, re.z),
            h.push(ge / S),
            h.push(1 - Z / E),
            (V += 1));
        }
      }
      for (let Z = 0; Z < E; Z++)
        for (let te = 0; te < S; te++) {
          const ge = d + te + U * Z,
            be = d + te + U * (Z + 1),
            J = d + (te + 1) + U * (Z + 1),
            se = d + (te + 1) + U * Z;
          (l.push(ge, be, se), l.push(be, J, se), (W += 6));
        }
      (a.addGroup(f, W, _), (f += W), (d += V));
    }
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new Tp(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments,
    );
  }
}
function cd(n) {
  const e = {};
  for (const t in n) {
    e[t] = {};
    for (const i in n[t]) {
      const r = n[t][i];
      r &&
      (r.isColor ||
        r.isMatrix3 ||
        r.isMatrix4 ||
        r.isVector2 ||
        r.isVector3 ||
        r.isVector4 ||
        r.isTexture ||
        r.isQuaternion)
        ? r.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().",
            ),
            (e[t][i] = null))
          : (e[t][i] = r.clone())
        : Array.isArray(r)
          ? (e[t][i] = r.slice())
          : (e[t][i] = r);
    }
  }
  return e;
}
function cr(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const i = cd(n[t]);
    for (const r in i) e[r] = i[r];
  }
  return e;
}
function Rte(n) {
  const e = [];
  for (let t = 0; t < n.length; t++) e.push(n[t].clone());
  return e;
}
function oR(n) {
  const e = n.getRenderTarget();
  return e === null
    ? n.outputColorSpace
    : e.isXRRenderTarget === !0
      ? e.texture.colorSpace
      : Kt.workingColorSpace;
}
const Bte = { clone: cd, merge: cr };
var Pte = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  Nte = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Qi extends Mo {
  constructor(e) {
    (super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = Pte),
      (this.fragmentShader = Nte),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = cd(e.uniforms)),
      (this.uniformsGroups = Rte(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    ((t.glslVersion = this.glslVersion), (t.uniforms = {}));
    for (const r in this.uniforms) {
      const o = this.uniforms[r].value;
      o && o.isTexture
        ? (t.uniforms[r] = { type: "t", value: o.toJSON(e).uuid })
        : o && o.isColor
          ? (t.uniforms[r] = { type: "c", value: o.getHex() })
          : o && o.isVector2
            ? (t.uniforms[r] = { type: "v2", value: o.toArray() })
            : o && o.isVector3
              ? (t.uniforms[r] = { type: "v3", value: o.toArray() })
              : o && o.isVector4
                ? (t.uniforms[r] = { type: "v4", value: o.toArray() })
                : o && o.isMatrix3
                  ? (t.uniforms[r] = { type: "m3", value: o.toArray() })
                  : o && o.isMatrix4
                    ? (t.uniforms[r] = { type: "m4", value: o.toArray() })
                    : (t.uniforms[r] = { value: o });
    }
    (Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping));
    const i = {};
    for (const r in this.extensions) this.extensions[r] === !0 && (i[r] = !0);
    return (Object.keys(i).length > 0 && (t.extensions = i), t);
  }
}
class aR extends Hn {
  constructor() {
    (super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new Et()),
      (this.projectionMatrix = new Et()),
      (this.projectionMatrixInverse = new Et()),
      (this.coordinateSystem = pa));
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    (super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert());
  }
  updateWorldMatrix(e, t) {
    (super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert());
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Qa = new X(),
  rw = new Gt(),
  sw = new Gt();
class Ri extends aR {
  constructor(e = 50, t = 1, i = 0.1, r = 2e3) {
    (super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = i),
      (this.far = r),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    ((this.fov = ld * 2 * Math.atan(t)), this.updateProjectionMatrix());
  }
  getFocalLength() {
    const e = Math.tan(tg * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return ld * 2 * Math.atan(Math.tan(tg * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(e, t, i) {
    (Qa.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      t.set(Qa.x, Qa.y).multiplyScalar(-e / Qa.z),
      Qa.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      i.set(Qa.x, Qa.y).multiplyScalar(-e / Qa.z));
  }
  getViewSize(e, t) {
    return (this.getViewBounds(e, rw, sw), t.subVectors(sw, rw));
  }
  setViewOffset(e, t, i, r, s, o) {
    ((this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix());
  }
  clearViewOffset() {
    (this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix());
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(tg * 0.5 * this.fov)) / this.zoom,
      i = 2 * t,
      r = this.aspect * i,
      s = -0.5 * r;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = o.fullWidth,
        c = o.fullHeight;
      ((s += (o.offsetX * r) / l),
        (t -= (o.offsetY * i) / c),
        (r *= o.width / l),
        (i *= o.height / c));
    }
    const a = this.filmOffset;
    (a !== 0 && (s += (e * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        s,
        s + r,
        t,
        t - i,
        e,
        this.far,
        this.coordinateSystem,
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert());
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const Xu = -90,
  Ku = 1;
class Dte extends Hn {
  constructor(e, t, i) {
    (super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = i),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0));
    const r = new Ri(Xu, Ku, e, t);
    ((r.layers = this.layers), this.add(r));
    const s = new Ri(Xu, Ku, e, t);
    ((s.layers = this.layers), this.add(s));
    const o = new Ri(Xu, Ku, e, t);
    ((o.layers = this.layers), this.add(o));
    const a = new Ri(Xu, Ku, e, t);
    ((a.layers = this.layers), this.add(a));
    const l = new Ri(Xu, Ku, e, t);
    ((l.layers = this.layers), this.add(l));
    const c = new Ri(Xu, Ku, e, t);
    ((c.layers = this.layers), this.add(c));
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      t = this.children.concat(),
      [i, r, s, o, a, l] = t;
    for (const c of t) this.remove(c);
    if (e === pa)
      (i.up.set(0, 1, 0),
        i.lookAt(1, 0, 0),
        r.up.set(0, 1, 0),
        r.lookAt(-1, 0, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, 1),
        o.lookAt(0, -1, 0),
        a.up.set(0, 1, 0),
        a.lookAt(0, 0, 1),
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, -1));
    else if (e === Km)
      (i.up.set(0, -1, 0),
        i.lookAt(-1, 0, 0),
        r.up.set(0, -1, 0),
        r.lookAt(1, 0, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, -1),
        o.lookAt(0, -1, 0),
        a.up.set(0, -1, 0),
        a.lookAt(0, 0, 1),
        l.up.set(0, -1, 0),
        l.lookAt(0, 0, -1));
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e,
      );
    for (const c of t) (this.add(c), c.updateMatrixWorld());
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: i, activeMipmapLevel: r } = this;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [s, o, a, l, c, u] = this.children,
      h = e.getRenderTarget(),
      d = e.getActiveCubeFace(),
      f = e.getActiveMipmapLevel(),
      g = e.xr.enabled;
    e.xr.enabled = !1;
    const p = i.texture.generateMipmaps;
    ((i.texture.generateMipmaps = !1),
      e.setRenderTarget(i, 0, r),
      e.render(t, s),
      e.setRenderTarget(i, 1, r),
      e.render(t, o),
      e.setRenderTarget(i, 2, r),
      e.render(t, a),
      e.setRenderTarget(i, 3, r),
      e.render(t, l),
      e.setRenderTarget(i, 4, r),
      e.render(t, c),
      (i.texture.generateMipmaps = p),
      e.setRenderTarget(i, 5, r),
      e.render(t, u),
      e.setRenderTarget(h, d, f),
      (e.xr.enabled = g),
      (i.texture.needsPMREMUpdate = !0));
  }
}
class lR extends Oi {
  constructor(e = [], t = sd, i, r, s, o, a, l, c, u) {
    (super(e, t, i, r, s, o, a, l, c, u),
      (this.isCubeTexture = !0),
      (this.flipY = !1));
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class Gte extends ko {
  constructor(e = 1, t = {}) {
    (super(e, e, t), (this.isWebGLCubeRenderTarget = !0));
    const i = { width: e, height: e, depth: 1 },
      r = [i, i, i, i, i, i];
    ((this.texture = new lR(
      r,
      t.mapping,
      t.wrapS,
      t.wrapT,
      t.magFilter,
      t.minFilter,
      t.format,
      t.type,
      t.anisotropy,
      t.colorSpace,
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Yr));
  }
  fromEquirectangularTexture(e, t) {
    ((this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter));
    const i = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      r = new Tp(5, 5, 5),
      s = new Qi({
        name: "CubemapFromEquirect",
        uniforms: cd(i.uniforms),
        vertexShader: i.vertexShader,
        fragmentShader: i.fragmentShader,
        side: er,
        blending: wl,
      });
    s.uniforms.tEquirect.value = t;
    const o = new si(r, s),
      a = t.minFilter;
    return (
      t.minFilter === ga && (t.minFilter = Yr),
      new Dte(1, 10, this).update(e, o),
      (t.minFilter = a),
      o.geometry.dispose(),
      o.material.dispose(),
      this
    );
  }
  clear(e, t = !0, i = !0, r = !0) {
    const s = e.getRenderTarget();
    for (let o = 0; o < 6; o++) (e.setRenderTarget(this, o), e.clear(t, i, r));
    e.setRenderTarget(s);
  }
}
class Is extends Hn {
  constructor() {
    (super(), (this.isGroup = !0), (this.type = "Group"));
  }
}
const Fte = { type: "move" };
class k2 {
  constructor() {
    ((this._targetRay = null), (this._grip = null), (this._hand = null));
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new Is()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new Is()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new X()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new X())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new Is()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new X()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new X())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const i of e.hand.values()) this._getHandJoint(t, i);
    }
    return (this.dispatchEvent({ type: "connected", data: e }), this);
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, i) {
    let r = null,
      s = null,
      o = null;
    const a = this._targetRay,
      l = this._grip,
      c = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        o = !0;
        for (const p of e.hand.values()) {
          const m = t.getJointPose(p, i),
            C = this._getHandJoint(c, p);
          (m !== null &&
            (C.matrix.fromArray(m.transform.matrix),
            C.matrix.decompose(C.position, C.rotation, C.scale),
            (C.matrixWorldNeedsUpdate = !0),
            (C.jointRadius = m.radius)),
            (C.visible = m !== null));
        }
        const u = c.joints["index-finger-tip"],
          h = c.joints["thumb-tip"],
          d = u.position.distanceTo(h.position),
          f = 0.02,
          g = 0.005;
        c.inputState.pinching && d > f + g
          ? ((c.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !c.inputState.pinching &&
            d <= f - g &&
            ((c.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        l !== null &&
          e.gripSpace &&
          ((s = t.getPose(e.gripSpace, i)),
          s !== null &&
            (l.matrix.fromArray(s.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            (l.matrixWorldNeedsUpdate = !0),
            s.linearVelocity
              ? ((l.hasLinearVelocity = !0),
                l.linearVelocity.copy(s.linearVelocity))
              : (l.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((l.hasAngularVelocity = !0),
                l.angularVelocity.copy(s.angularVelocity))
              : (l.hasAngularVelocity = !1)));
      a !== null &&
        ((r = t.getPose(e.targetRaySpace, i)),
        r === null && s !== null && (r = s),
        r !== null &&
          (a.matrix.fromArray(r.transform.matrix),
          a.matrix.decompose(a.position, a.rotation, a.scale),
          (a.matrixWorldNeedsUpdate = !0),
          r.linearVelocity
            ? ((a.hasLinearVelocity = !0),
              a.linearVelocity.copy(r.linearVelocity))
            : (a.hasLinearVelocity = !1),
          r.angularVelocity
            ? ((a.hasAngularVelocity = !0),
              a.angularVelocity.copy(r.angularVelocity))
            : (a.hasAngularVelocity = !1),
          this.dispatchEvent(Fte)));
    }
    return (
      a !== null && (a.visible = r !== null),
      l !== null && (l.visible = s !== null),
      c !== null && (c.visible = o !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const i = new Is();
      ((i.matrixAutoUpdate = !1),
        (i.visible = !1),
        (e.joints[t.jointName] = i),
        e.add(i));
    }
    return e.joints[t.jointName];
  }
}
class Hv extends Hn {
  constructor() {
    (super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.backgroundRotation = new Oo()),
      (this.environmentIntensity = 1),
      (this.environmentRotation = new Oo()),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this }),
        ));
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      this.backgroundRotation.copy(e.backgroundRotation),
      (this.environmentIntensity = e.environmentIntensity),
      this.environmentRotation.copy(e.environmentRotation),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      (t.object.backgroundRotation = this.backgroundRotation.toArray()),
      this.environmentIntensity !== 1 &&
        (t.object.environmentIntensity = this.environmentIntensity),
      (t.object.environmentRotation = this.environmentRotation.toArray()),
      t
    );
  }
}
class kte {
  constructor(e, t) {
    ((this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = j_),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = Js()));
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return ((this.usage = e), this);
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, i) {
    ((e *= this.stride), (i *= t.stride));
    for (let r = 0, s = this.stride; r < s; r++)
      this.array[e + r] = t.array[i + r];
    return this;
  }
  set(e, t = 0) {
    return (this.array.set(e, t), this);
  }
  clone(e) {
    (e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Js()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer));
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid],
      ),
      i = new this.constructor(t, this.stride);
    return (i.setUsage(this.usage), i);
  }
  onUpload(e) {
    return ((this.onUploadCallback = e), this);
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Js()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer),
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const ar = new X();
class Wv {
  constructor(e, t, i, r = !1) {
    ((this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = i),
      (this.normalized = r));
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.data.count; t < i; t++)
      (ar.fromBufferAttribute(this, t),
        ar.applyMatrix4(e),
        this.setXYZ(t, ar.x, ar.y, ar.z));
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      (ar.fromBufferAttribute(this, t),
        ar.applyNormalMatrix(e),
        this.setXYZ(t, ar.x, ar.y, ar.z));
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      (ar.fromBufferAttribute(this, t),
        ar.transformDirection(e),
        this.setXYZ(t, ar.x, ar.y, ar.z));
    return this;
  }
  getComponent(e, t) {
    let i = this.array[e * this.data.stride + this.offset + t];
    return (this.normalized && (i = zs(i, this.array)), i);
  }
  setComponent(e, t, i) {
    return (
      this.normalized && (i = gn(i, this.array)),
      (this.data.array[e * this.data.stride + this.offset + t] = i),
      this
    );
  }
  setX(e, t) {
    return (
      this.normalized && (t = gn(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = gn(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = gn(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = gn(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return (this.normalized && (t = zs(t, this.array)), t);
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return (this.normalized && (t = zs(t, this.array)), t);
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return (this.normalized && (t = zs(t, this.array)), t);
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return (this.normalized && (t = zs(t, this.array)), t);
  }
  setXY(e, t, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = gn(t, this.array)), (i = gn(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = gn(t, this.array)),
        (i = gn(i, this.array)),
        (r = gn(r, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = gn(t, this.array)),
        (i = gn(i, this.array)),
        (r = gn(r, this.array)),
        (s = gn(s, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      (this.data.array[e + 3] = s),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.",
      );
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
      }
      return new Pi(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized,
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new Wv(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized,
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.",
      );
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
const ow = new X(),
  aw = new ln(),
  lw = new ln(),
  Ote = new X(),
  cw = new Et(),
  m1 = new X(),
  O2 = new Zo(),
  uw = new Et(),
  U2 = new Sp();
class Ute extends si {
  constructor(e, t) {
    (super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = Ox),
      (this.bindMatrix = new Et()),
      (this.bindMatrixInverse = new Et()),
      (this.boundingBox = null),
      (this.boundingSphere = null));
  }
  computeBoundingBox() {
    const e = this.geometry;
    (this.boundingBox === null && (this.boundingBox = new ka()),
      this.boundingBox.makeEmpty());
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++)
      (this.getVertexPosition(i, m1), this.boundingBox.expandByPoint(m1));
  }
  computeBoundingSphere() {
    const e = this.geometry;
    (this.boundingSphere === null && (this.boundingSphere = new Zo()),
      this.boundingSphere.makeEmpty());
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++)
      (this.getVertexPosition(i, m1), this.boundingSphere.expandByPoint(m1));
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, t) {
    const i = this.material,
      r = this.matrixWorld;
    i !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      O2.copy(this.boundingSphere),
      O2.applyMatrix4(r),
      e.ray.intersectsSphere(O2) !== !1 &&
        (uw.copy(r).invert(),
        U2.copy(e.ray).applyMatrix4(uw),
        !(
          this.boundingBox !== null && U2.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, t, U2)));
  }
  getVertexPosition(e, t) {
    return (super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t);
  }
  bind(e, t) {
    ((this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert());
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new ln(),
      t = this.geometry.attributes.skinWeight;
    for (let i = 0, r = t.count; i < r; i++) {
      e.fromBufferAttribute(t, i);
      const s = 1 / e.manhattanLength();
      (s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
        t.setXYZW(i, e.x, e.y, e.z, e.w));
    }
  }
  updateMatrixWorld(e) {
    (super.updateMatrixWorld(e),
      this.bindMode === Ox
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === Pee
          ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
          : console.warn(
              "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode,
            ));
  }
  applyBoneTransform(e, t) {
    const i = this.skeleton,
      r = this.geometry;
    (aw.fromBufferAttribute(r.attributes.skinIndex, e),
      lw.fromBufferAttribute(r.attributes.skinWeight, e),
      ow.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0));
    for (let s = 0; s < 4; s++) {
      const o = lw.getComponent(s);
      if (o !== 0) {
        const a = aw.getComponent(s);
        (cw.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]),
          t.addScaledVector(Ote.copy(ow).applyMatrix4(cw), o));
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class cR extends Hn {
  constructor() {
    (super(), (this.isBone = !0), (this.type = "Bone"));
  }
}
class Vv extends Oi {
  constructor(e = null, t = 1, i = 1, r, s, o, a, l, c = gi, u = gi, h, d) {
    (super(null, o, a, l, c, u, r, s, h, d),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: i }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1));
  }
}
const hw = new Et(),
  Hte = new Et();
class Zv {
  constructor(e = [], t = []) {
    ((this.uuid = Js()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      this.init());
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      (console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.",
      ),
        (this.boneInverses = []));
      for (let i = 0, r = this.bones.length; i < r; i++)
        this.boneInverses.push(new Et());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = new Et();
      (this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(i));
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && i.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i &&
        (i.parent && i.parent.isBone
          ? (i.matrix.copy(i.parent.matrixWorld).invert(),
            i.matrix.multiply(i.matrixWorld))
          : i.matrix.copy(i.matrixWorld),
        i.matrix.decompose(i.position, i.quaternion, i.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      i = this.boneMatrices,
      r = this.boneTexture;
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s] ? e[s].matrixWorld : Hte;
      (hw.multiplyMatrices(a, t[s]), hw.toArray(i, s * 16));
    }
    r !== null && (r.needsUpdate = !0);
  }
  clone() {
    return new Zv(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    ((e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4)));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const i = new Vv(t, e, e, Sr, Xr);
    return (
      (i.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = i),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, i = this.bones.length; t < i; t++) {
      const r = this.bones[t];
      if (r.name === e) return r;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let i = 0, r = e.bones.length; i < r; i++) {
      const s = e.bones[i];
      let o = t[s];
      (o === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", s),
        (o = new cR())),
        this.bones.push(o),
        this.boneInverses.push(new Et().fromArray(e.boneInverses[i])));
    }
    return (this.init(), this);
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      i = this.boneInverses;
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r];
      e.bones.push(o.uuid);
      const a = i[r];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
class $_ extends Pi {
  constructor(e, t, i, r = 1) {
    (super(e, t, i),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = r));
  }
  copy(e) {
    return (super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this);
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const ju = new Et(),
  dw = new Et(),
  C1 = [],
  fw = new ka(),
  Wte = new Et(),
  gf = new si(),
  pf = new Zo();
class Vte extends si {
  constructor(e, t, i) {
    (super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new $_(new Float32Array(i * 16), 16)),
      (this.instanceColor = null),
      (this.morphTexture = null),
      (this.count = i),
      (this.boundingBox = null),
      (this.boundingSphere = null));
    for (let r = 0; r < i; r++) this.setMatrixAt(r, Wte);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    (this.boundingBox === null && (this.boundingBox = new ka()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty());
    for (let i = 0; i < t; i++)
      (this.getMatrixAt(i, ju),
        fw.copy(e.boundingBox).applyMatrix4(ju),
        this.boundingBox.union(fw));
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    (this.boundingSphere === null && (this.boundingSphere = new Zo()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty());
    for (let i = 0; i < t; i++)
      (this.getMatrixAt(i, ju),
        pf.copy(e.boundingSphere).applyMatrix4(ju),
        this.boundingSphere.union(pf));
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  getMorphAt(e, t) {
    const i = t.morphTargetInfluences,
      r = this.morphTexture.source.data.data,
      s = i.length + 1,
      o = e * s + 1;
    for (let a = 0; a < i.length; a++) i[a] = r[o + a];
  }
  raycast(e, t) {
    const i = this.matrixWorld,
      r = this.count;
    if (
      ((gf.geometry = this.geometry),
      (gf.material = this.material),
      gf.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        pf.copy(this.boundingSphere),
        pf.applyMatrix4(i),
        e.ray.intersectsSphere(pf) !== !1))
    )
      for (let s = 0; s < r; s++) {
        (this.getMatrixAt(s, ju),
          dw.multiplyMatrices(i, ju),
          (gf.matrixWorld = dw),
          gf.raycast(e, C1));
        for (let o = 0, a = C1.length; o < a; o++) {
          const l = C1[o];
          ((l.instanceId = s), (l.object = this), t.push(l));
        }
        C1.length = 0;
      }
  }
  setColorAt(e, t) {
    (this.instanceColor === null &&
      (this.instanceColor = new $_(
        new Float32Array(this.instanceMatrix.count * 3).fill(1),
        3,
      )),
      t.toArray(this.instanceColor.array, e * 3));
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  setMorphAt(e, t) {
    const i = t.morphTargetInfluences,
      r = i.length + 1;
    this.morphTexture === null &&
      (this.morphTexture = new Vv(
        new Float32Array(r * this.count),
        r,
        this.count,
        Pv,
        Xr,
      ));
    const s = this.morphTexture.source.data.data;
    let o = 0;
    for (let c = 0; c < i.length; c++) o += i[c];
    const a = this.geometry.morphTargetsRelative ? 1 : 1 - o,
      l = r * e;
    ((s[l] = a), s.set(i, l + 1));
  }
  updateMorphTargets() {}
  dispose() {
    (this.dispatchEvent({ type: "dispose" }),
      this.morphTexture !== null &&
        (this.morphTexture.dispose(), (this.morphTexture = null)));
  }
}
const H2 = new X(),
  Zte = new X(),
  zte = new Pt();
class Sc {
  constructor(e = new X(1, 0, 0), t = 0) {
    ((this.isPlane = !0), (this.normal = e), (this.constant = t));
  }
  set(e, t) {
    return (this.normal.copy(e), (this.constant = t), this);
  }
  setComponents(e, t, i, r) {
    return (this.normal.set(e, t, i), (this.constant = r), this);
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return (this.normal.copy(e), (this.constant = -t.dot(this.normal)), this);
  }
  setFromCoplanarPoints(e, t, i) {
    const r = H2.subVectors(i, t).cross(Zte.subVectors(e, t)).normalize();
    return (this.setFromNormalAndCoplanarPoint(r, e), this);
  }
  copy(e) {
    return (this.normal.copy(e.normal), (this.constant = e.constant), this);
  }
  normalize() {
    const e = 1 / this.normal.length();
    return (this.normal.multiplyScalar(e), (this.constant *= e), this);
  }
  negate() {
    return ((this.constant *= -1), this.normal.negate(), this);
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const i = e.delta(H2),
      r = this.normal.dot(i);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / r;
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      i = this.distanceToPoint(e.end);
    return (t < 0 && i > 0) || (i < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const i = t || zte.getNormalMatrix(e),
      r = this.coplanarPoint(H2).applyMatrix4(e),
      s = this.normal.applyMatrix3(i).normalize();
    return ((this.constant = -r.dot(s)), this);
  }
  translate(e) {
    return ((this.constant -= e.dot(this.normal)), this);
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const oc = new Zo(),
  I1 = new X();
class zv {
  constructor(
    e = new Sc(),
    t = new Sc(),
    i = new Sc(),
    r = new Sc(),
    s = new Sc(),
    o = new Sc(),
  ) {
    this.planes = [e, t, i, r, s, o];
  }
  set(e, t, i, r, s, o) {
    const a = this.planes;
    return (
      a[0].copy(e),
      a[1].copy(t),
      a[2].copy(i),
      a[3].copy(r),
      a[4].copy(s),
      a[5].copy(o),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e, t = pa) {
    const i = this.planes,
      r = e.elements,
      s = r[0],
      o = r[1],
      a = r[2],
      l = r[3],
      c = r[4],
      u = r[5],
      h = r[6],
      d = r[7],
      f = r[8],
      g = r[9],
      p = r[10],
      m = r[11],
      C = r[12],
      A = r[13],
      I = r[14],
      y = r[15];
    if (
      (i[0].setComponents(l - s, d - c, m - f, y - C).normalize(),
      i[1].setComponents(l + s, d + c, m + f, y + C).normalize(),
      i[2].setComponents(l + o, d + u, m + g, y + A).normalize(),
      i[3].setComponents(l - o, d - u, m - g, y - A).normalize(),
      i[4].setComponents(l - a, d - h, m - p, y - I).normalize(),
      t === pa)
    )
      i[5].setComponents(l + a, d + h, m + p, y + I).normalize();
    else if (t === Km) i[5].setComponents(a, h, p, I).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          t,
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      (e.boundingSphere === null && e.computeBoundingSphere(),
        oc.copy(e.boundingSphere).applyMatrix4(e.matrixWorld));
    else {
      const t = e.geometry;
      (t.boundingSphere === null && t.computeBoundingSphere(),
        oc.copy(t.boundingSphere).applyMatrix4(e.matrixWorld));
    }
    return this.intersectsSphere(oc);
  }
  intersectsSprite(e) {
    return (
      oc.center.set(0, 0, 0),
      (oc.radius = 0.7071067811865476),
      oc.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(oc)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      i = e.center,
      r = -e.radius;
    for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(i) < r) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) {
      const r = t[i];
      if (
        ((I1.x = r.normal.x > 0 ? e.max.x : e.min.x),
        (I1.y = r.normal.y > 0 ? e.max.y : e.min.y),
        (I1.z = r.normal.z > 0 ? e.max.z : e.min.z),
        r.distanceToPoint(I1) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class uR extends Mo {
  constructor(e) {
    (super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new vt(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const jm = new X(),
  $m = new X(),
  gw = new Et(),
  mf = new Sp(),
  A1 = new Zo(),
  W2 = new X(),
  pw = new X();
class Yv extends Hn {
  constructor(e = new Pr(), t = new uR()) {
    (super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      (this.morphTargetDictionary = void 0),
      (this.morphTargetInfluences = void 0),
      this.updateMorphTargets());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        i = [0];
      for (let r = 1, s = t.count; r < s; r++)
        (jm.fromBufferAttribute(t, r - 1),
          $m.fromBufferAttribute(t, r),
          (i[r] = i[r - 1]),
          (i[r] += jm.distanceTo($m)));
      e.setAttribute("lineDistance", new tr(i, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.",
      );
    return this;
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Line.threshold,
      o = i.drawRange;
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      A1.copy(i.boundingSphere),
      A1.applyMatrix4(r),
      (A1.radius += s),
      e.ray.intersectsSphere(A1) === !1)
    )
      return;
    (gw.copy(r).invert(), mf.copy(e.ray).applyMatrix4(gw));
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      c = this.isLineSegments ? 2 : 1,
      u = i.index,
      d = i.attributes.position;
    if (u !== null) {
      const f = Math.max(0, o.start),
        g = Math.min(u.count, o.start + o.count);
      for (let p = f, m = g - 1; p < m; p += c) {
        const C = u.getX(p),
          A = u.getX(p + 1),
          I = y1(this, e, mf, l, C, A, p);
        I && t.push(I);
      }
      if (this.isLineLoop) {
        const p = u.getX(g - 1),
          m = u.getX(f),
          C = y1(this, e, mf, l, p, m, g - 1);
        C && t.push(C);
      }
    } else {
      const f = Math.max(0, o.start),
        g = Math.min(d.count, o.start + o.count);
      for (let p = f, m = g - 1; p < m; p += c) {
        const C = y1(this, e, mf, l, p, p + 1, p);
        C && t.push(C);
      }
      if (this.isLineLoop) {
        const p = y1(this, e, mf, l, g - 1, f, g - 1);
        p && t.push(p);
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        ((this.morphTargetInfluences = []), (this.morphTargetDictionary = {}));
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          (this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s));
        }
      }
    }
  }
}
function y1(n, e, t, i, r, s, o) {
  const a = n.geometry.attributes.position;
  if (
    (jm.fromBufferAttribute(a, r),
    $m.fromBufferAttribute(a, s),
    t.distanceSqToSegment(jm, $m, W2, pw) > i)
  )
    return;
  W2.applyMatrix4(n.matrixWorld);
  const c = e.ray.origin.distanceTo(W2);
  if (!(c < e.near || c > e.far))
    return {
      distance: c,
      point: pw.clone().applyMatrix4(n.matrixWorld),
      index: o,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: n,
    };
}
const mw = new X(),
  Cw = new X();
class Yte extends Yv {
  constructor(e, t) {
    (super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments"));
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        i = [];
      for (let r = 0, s = t.count; r < s; r += 2)
        (mw.fromBufferAttribute(t, r),
          Cw.fromBufferAttribute(t, r + 1),
          (i[r] = r === 0 ? 0 : i[r - 1]),
          (i[r + 1] = i[r] + mw.distanceTo(Cw)));
      e.setAttribute("lineDistance", new tr(i, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.",
      );
    return this;
  }
}
class Xte extends Yv {
  constructor(e, t) {
    (super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop"));
  }
}
class hR extends Mo {
  constructor(e) {
    (super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new vt(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const Iw = new Et(),
  J_ = new Sp(),
  _1 = new Zo(),
  b1 = new X();
class dR extends Hn {
  constructor(e = new Pr(), t = new hR()) {
    (super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      (this.morphTargetDictionary = void 0),
      (this.morphTargetInfluences = void 0),
      this.updateMorphTargets());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Points.threshold,
      o = i.drawRange;
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      _1.copy(i.boundingSphere),
      _1.applyMatrix4(r),
      (_1.radius += s),
      e.ray.intersectsSphere(_1) === !1)
    )
      return;
    (Iw.copy(r).invert(), J_.copy(e.ray).applyMatrix4(Iw));
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      c = i.index,
      h = i.attributes.position;
    if (c !== null) {
      const d = Math.max(0, o.start),
        f = Math.min(c.count, o.start + o.count);
      for (let g = d, p = f; g < p; g++) {
        const m = c.getX(g);
        (b1.fromBufferAttribute(h, m), Aw(b1, m, l, r, e, t, this));
      }
    } else {
      const d = Math.max(0, o.start),
        f = Math.min(h.count, o.start + o.count);
      for (let g = d, p = f; g < p; g++)
        (b1.fromBufferAttribute(h, g), Aw(b1, g, l, r, e, t, this));
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        ((this.morphTargetInfluences = []), (this.morphTargetDictionary = {}));
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          (this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s));
        }
      }
    }
  }
}
function Aw(n, e, t, i, r, s, o) {
  const a = J_.distanceSqToPoint(n);
  if (a < t) {
    const l = new X();
    (J_.closestPointToPoint(n, l), l.applyMatrix4(i));
    const c = r.ray.origin.distanceTo(l);
    if (c < r.near || c > r.far) return;
    s.push({
      distance: c,
      distanceToRay: Math.sqrt(a),
      point: l,
      index: e,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: o,
    });
  }
}
class fR extends Oi {
  constructor(e, t, i, r, s, o, a, l, c) {
    (super(e, t, i, r, s, o, a, l, c),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0));
  }
}
class gR extends Oi {
  constructor(e, t, i = gu, r, s, o, a = gi, l = gi, c, u = Bg) {
    if (u !== Bg && u !== Pg)
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat",
      );
    (super(null, r, s, o, a, l, u, i, c),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.source = new Ov(Object.assign({}, e.image))),
      (this.compareFunction = e.compareFunction),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (t.compareFunction = this.compareFunction),
      t
    );
  }
}
class Vd extends Pr {
  constructor(e = 1, t = 1, i = 1, r = 1) {
    (super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: i,
        heightSegments: r,
      }));
    const s = e / 2,
      o = t / 2,
      a = Math.floor(i),
      l = Math.floor(r),
      c = a + 1,
      u = l + 1,
      h = e / a,
      d = t / l,
      f = [],
      g = [],
      p = [],
      m = [];
    for (let C = 0; C < u; C++) {
      const A = C * d - o;
      for (let I = 0; I < c; I++) {
        const y = I * h - s;
        (g.push(y, -A, 0), p.push(0, 0, 1), m.push(I / a), m.push(1 - C / l));
      }
    }
    for (let C = 0; C < l; C++)
      for (let A = 0; A < a; A++) {
        const I = A + c * C,
          y = A + c * (C + 1),
          x = A + 1 + c * (C + 1),
          T = A + 1 + c * C;
        (f.push(I, y, T), f.push(y, x, T));
      }
    (this.setIndex(f),
      this.setAttribute("position", new tr(g, 3)),
      this.setAttribute("normal", new tr(p, 3)),
      this.setAttribute("uv", new tr(m, 2)));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new Vd(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
class ig extends Pr {
  constructor(
    e = 1,
    t = 32,
    i = 16,
    r = 0,
    s = Math.PI * 2,
    o = 0,
    a = Math.PI,
  ) {
    (super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: i,
        phiStart: r,
        phiLength: s,
        thetaStart: o,
        thetaLength: a,
      }),
      (t = Math.max(3, Math.floor(t))),
      (i = Math.max(2, Math.floor(i))));
    const l = Math.min(o + a, Math.PI);
    let c = 0;
    const u = [],
      h = new X(),
      d = new X(),
      f = [],
      g = [],
      p = [],
      m = [];
    for (let C = 0; C <= i; C++) {
      const A = [],
        I = C / i;
      let y = 0;
      C === 0 && o === 0
        ? (y = 0.5 / t)
        : C === i && l === Math.PI && (y = -0.5 / t);
      for (let x = 0; x <= t; x++) {
        const T = x / t;
        ((h.x = -e * Math.cos(r + T * s) * Math.sin(o + I * a)),
          (h.y = e * Math.cos(o + I * a)),
          (h.z = e * Math.sin(r + T * s) * Math.sin(o + I * a)),
          g.push(h.x, h.y, h.z),
          d.copy(h).normalize(),
          p.push(d.x, d.y, d.z),
          m.push(T + y, 1 - I),
          A.push(c++));
      }
      u.push(A);
    }
    for (let C = 0; C < i; C++)
      for (let A = 0; A < t; A++) {
        const I = u[C][A + 1],
          y = u[C][A],
          x = u[C + 1][A],
          T = u[C + 1][A + 1];
        ((C !== 0 || o > 0) && f.push(I, y, T),
          (C !== i - 1 || l < Math.PI) && f.push(y, x, T));
      }
    (this.setIndex(f),
      this.setAttribute("position", new tr(g, 3)),
      this.setAttribute("normal", new tr(p, 3)),
      this.setAttribute("uv", new tr(m, 2)));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.parameters = Object.assign({}, e.parameters)),
      this
    );
  }
  static fromJSON(e) {
    return new ig(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength,
    );
  }
}
class Kte extends Qi {
  constructor(e) {
    (super(e),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial"));
  }
}
class sI extends Mo {
  constructor(e) {
    (super(),
      (this.isMeshStandardMaterial = !0),
      (this.type = "MeshStandardMaterial"),
      (this.defines = { STANDARD: "" }),
      (this.color = new vt(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new vt(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = qL),
      (this.normalScale = new Gt(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Oo()),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class zo extends sI {
  constructor(e) {
    (super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new Gt(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return Wt((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new vt(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new vt(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new vt(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._dispersion = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e));
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    (this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e));
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    (this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e));
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    (this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e));
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    (this._dispersion > 0 != e > 0 && this.version++, (this._dispersion = e));
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    (this._sheen > 0 != e > 0 && this.version++, (this._sheen = e));
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    (this._transmission > 0 != e > 0 && this.version++,
      (this._transmission = e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.dispersion = e.dispersion),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
class jte extends Mo {
  constructor(e) {
    (super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = kee),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class $te extends Mo {
  constructor(e) {
    (super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e));
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
function v1(n, e) {
  return !n || n.constructor === e
    ? n
    : typeof e.BYTES_PER_ELEMENT == "number"
      ? new e(n)
      : Array.prototype.slice.call(n);
}
function Jte(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function Qte(n) {
  function e(r, s) {
    return n[r] - n[s];
  }
  const t = n.length,
    i = new Array(t);
  for (let r = 0; r !== t; ++r) i[r] = r;
  return (i.sort(e), i);
}
function yw(n, e, t) {
  const i = n.length,
    r = new n.constructor(i);
  for (let s = 0, o = 0; o !== i; ++s) {
    const a = t[s] * e;
    for (let l = 0; l !== e; ++l) r[o++] = n[a + l];
  }
  return r;
}
function pR(n, e, t, i) {
  let r = 1,
    s = n[0];
  for (; s !== void 0 && s[i] === void 0; ) s = n[r++];
  if (s === void 0) return;
  let o = s[i];
  if (o !== void 0)
    if (Array.isArray(o))
      do
        ((o = s[i]),
          o !== void 0 && (e.push(s.time), t.push(...o)),
          (s = n[r++]));
      while (s !== void 0);
    else if (o.toArray !== void 0)
      do
        ((o = s[i]),
          o !== void 0 && (e.push(s.time), o.toArray(t, t.length)),
          (s = n[r++]));
      while (s !== void 0);
    else
      do
        ((o = s[i]), o !== void 0 && (e.push(s.time), t.push(o)), (s = n[r++]));
      while (s !== void 0);
}
class Ep {
  constructor(e, t, i, r) {
    ((this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = r !== void 0 ? r : new t.constructor(i)),
      (this.sampleValues = t),
      (this.valueSize = i),
      (this.settings = null),
      (this.DefaultSettings_ = {}));
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let i = this._cachedIndex,
      r = t[i],
      s = t[i - 1];
    e: {
      t: {
        let o;
        n: {
          i: if (!(e < r)) {
            for (let a = i + 2; ; ) {
              if (r === void 0) {
                if (e < s) break i;
                return (
                  (i = t.length),
                  (this._cachedIndex = i),
                  this.copySampleValue_(i - 1)
                );
              }
              if (i === a) break;
              if (((s = r), (r = t[++i]), e < r)) break t;
            }
            o = t.length;
            break n;
          }
          if (!(e >= s)) {
            const a = t[1];
            e < a && ((i = 2), (s = a));
            for (let l = i - 2; ; ) {
              if (s === void 0)
                return ((this._cachedIndex = 0), this.copySampleValue_(0));
              if (i === l) break;
              if (((r = s), (s = t[--i - 1]), e >= s)) break t;
            }
            ((o = i), (i = 0));
            break n;
          }
          break e;
        }
        for (; i < o; ) {
          const a = (i + o) >>> 1;
          e < t[a] ? (o = a) : (i = a + 1);
        }
        if (((r = t[i]), (s = t[i - 1]), s === void 0))
          return ((this._cachedIndex = 0), this.copySampleValue_(0));
        if (r === void 0)
          return (
            (i = t.length),
            (this._cachedIndex = i),
            this.copySampleValue_(i - 1)
          );
      }
      ((this._cachedIndex = i), this.intervalChanged_(i, s, r));
    }
    return this.interpolate_(i, s, e, r);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      i = this.sampleValues,
      r = this.valueSize,
      s = e * r;
    for (let o = 0; o !== r; ++o) t[o] = i[s + o];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class qte extends Ep {
  constructor(e, t, i, r) {
    (super(e, t, i, r),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: Ih, endingEnd: Ih }));
  }
  intervalChanged_(e, t, i) {
    const r = this.parameterPositions;
    let s = e - 2,
      o = e + 1,
      a = r[s],
      l = r[o];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case Ah:
          ((s = e), (a = 2 * t - i));
          break;
        case Ym:
          ((s = r.length - 2), (a = t + r[s] - r[s + 1]));
          break;
        default:
          ((s = e), (a = i));
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case Ah:
          ((o = e), (l = 2 * i - t));
          break;
        case Ym:
          ((o = 1), (l = i + r[1] - r[0]));
          break;
        default:
          ((o = e - 1), (l = t));
      }
    const c = (i - t) * 0.5,
      u = this.valueSize;
    ((this._weightPrev = c / (t - a)),
      (this._weightNext = c / (l - i)),
      (this._offsetPrev = s * u),
      (this._offsetNext = o * u));
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      c = l - a,
      u = this._offsetPrev,
      h = this._offsetNext,
      d = this._weightPrev,
      f = this._weightNext,
      g = (i - t) / (r - t),
      p = g * g,
      m = p * g,
      C = -d * m + 2 * d * p - d * g,
      A = (1 + d) * m + (-1.5 - 2 * d) * p + (-0.5 + d) * g + 1,
      I = (-1 - f) * m + (1.5 + f) * p + 0.5 * g,
      y = f * m - f * p;
    for (let x = 0; x !== a; ++x)
      s[x] = C * o[u + x] + A * o[c + x] + I * o[l + x] + y * o[h + x];
    return s;
  }
}
class mR extends Ep {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      c = l - a,
      u = (i - t) / (r - t),
      h = 1 - u;
    for (let d = 0; d !== a; ++d) s[d] = o[c + d] * h + o[l + d] * u;
    return s;
  }
}
class ene extends Ep {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class so {
  constructor(e, t, i, r) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    ((this.name = e),
      (this.times = v1(t, this.TimeBufferType)),
      (this.values = v1(i, this.ValueBufferType)),
      this.setInterpolation(r || this.DefaultInterpolation));
  }
  static toJSON(e) {
    const t = e.constructor;
    let i;
    if (t.toJSON !== this.toJSON) i = t.toJSON(e);
    else {
      i = {
        name: e.name,
        times: v1(e.times, Array),
        values: v1(e.values, Array),
      };
      const r = e.getInterpolation();
      r !== e.DefaultInterpolation && (i.interpolation = r);
    }
    return ((i.type = e.ValueTypeName), i);
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new ene(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new mR(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new qte(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case Ng:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case Dg:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case I2:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const i =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(i);
      return (console.warn("THREE.KeyframeTrack:", i), this);
    }
    return ((this.createInterpolant = t), this);
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Ng;
      case this.InterpolantFactoryMethodLinear:
        return Dg;
      case this.InterpolantFactoryMethodSmooth:
        return I2;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i) t[i] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i) t[i] *= e;
    }
    return this;
  }
  trim(e, t) {
    const i = this.times,
      r = i.length;
    let s = 0,
      o = r - 1;
    for (; s !== r && i[s] < e; ) ++s;
    for (; o !== -1 && i[o] > t; ) --o;
    if ((++o, s !== 0 || o !== r)) {
      s >= o && ((o = Math.max(o, 1)), (s = o - 1));
      const a = this.getValueSize();
      ((this.times = i.slice(s, o)),
        (this.values = this.values.slice(s * a, o * a)));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const i = this.times,
      r = this.values,
      s = i.length;
    s === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let o = null;
    for (let a = 0; a !== s; a++) {
      const l = i[a];
      if (typeof l == "number" && isNaN(l)) {
        (console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          a,
          l,
        ),
          (e = !1));
        break;
      }
      if (o !== null && o > l) {
        (console.error(
          "THREE.KeyframeTrack: Out of order keys.",
          this,
          a,
          l,
          o,
        ),
          (e = !1));
        break;
      }
      o = l;
    }
    if (r !== void 0 && Jte(r))
      for (let a = 0, l = r.length; a !== l; ++a) {
        const c = r[a];
        if (isNaN(c)) {
          (console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            a,
            c,
          ),
            (e = !1));
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = this.times.slice(),
      t = this.values.slice(),
      i = this.getValueSize(),
      r = this.getInterpolation() === I2,
      s = e.length - 1;
    let o = 1;
    for (let a = 1; a < s; ++a) {
      let l = !1;
      const c = e[a],
        u = e[a + 1];
      if (c !== u && (a !== 1 || c !== e[0]))
        if (r) l = !0;
        else {
          const h = a * i,
            d = h - i,
            f = h + i;
          for (let g = 0; g !== i; ++g) {
            const p = t[h + g];
            if (p !== t[d + g] || p !== t[f + g]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (a !== o) {
          e[o] = e[a];
          const h = a * i,
            d = o * i;
          for (let f = 0; f !== i; ++f) t[d + f] = t[h + f];
        }
        ++o;
      }
    }
    if (s > 0) {
      e[o] = e[s];
      for (let a = s * i, l = o * i, c = 0; c !== i; ++c) t[l + c] = t[a + c];
      ++o;
    }
    return (
      o !== e.length
        ? ((this.times = e.slice(0, o)), (this.values = t.slice(0, o * i)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = this.times.slice(),
      t = this.values.slice(),
      i = this.constructor,
      r = new i(this.name, e, t);
    return ((r.createInterpolant = this.createInterpolant), r);
  }
}
so.prototype.ValueTypeName = "";
so.prototype.TimeBufferType = Float32Array;
so.prototype.ValueBufferType = Float32Array;
so.prototype.DefaultInterpolation = Dg;
class Zd extends so {
  constructor(e, t, i) {
    super(e, t, i);
  }
}
Zd.prototype.ValueTypeName = "bool";
Zd.prototype.ValueBufferType = Array;
Zd.prototype.DefaultInterpolation = Ng;
Zd.prototype.InterpolantFactoryMethodLinear = void 0;
Zd.prototype.InterpolantFactoryMethodSmooth = void 0;
class CR extends so {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
}
CR.prototype.ValueTypeName = "color";
class ud extends so {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
}
ud.prototype.ValueTypeName = "number";
class tne extends Ep {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = (i - t) / (r - t);
    let c = e * a;
    for (let u = c + a; c !== u; c += 4) Qs.slerpFlat(s, 0, o, c - a, o, c, l);
    return s;
  }
}
class hd extends so {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  InterpolantFactoryMethodLinear(e) {
    return new tne(this.times, this.values, this.getValueSize(), e);
  }
}
hd.prototype.ValueTypeName = "quaternion";
hd.prototype.InterpolantFactoryMethodSmooth = void 0;
class zd extends so {
  constructor(e, t, i) {
    super(e, t, i);
  }
}
zd.prototype.ValueTypeName = "string";
zd.prototype.ValueBufferType = Array;
zd.prototype.DefaultInterpolation = Ng;
zd.prototype.InterpolantFactoryMethodLinear = void 0;
zd.prototype.InterpolantFactoryMethodSmooth = void 0;
class dd extends so {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
}
dd.prototype.ValueTypeName = "vector";
class Q_ {
  constructor(e = "", t = -1, i = [], r = Fv) {
    ((this.name = e),
      (this.tracks = i),
      (this.duration = t),
      (this.blendMode = r),
      (this.uuid = Js()),
      this.duration < 0 && this.resetDuration());
  }
  static parse(e) {
    const t = [],
      i = e.tracks,
      r = 1 / (e.fps || 1);
    for (let o = 0, a = i.length; o !== a; ++o) t.push(ine(i[o]).scale(r));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return ((s.uuid = e.uuid), s);
  }
  static toJSON(e) {
    const t = [],
      i = e.tracks,
      r = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let s = 0, o = i.length; s !== o; ++s) t.push(so.toJSON(i[s]));
    return r;
  }
  static CreateFromMorphTargetSequence(e, t, i, r) {
    const s = t.length,
      o = [];
    for (let a = 0; a < s; a++) {
      let l = [],
        c = [];
      (l.push((a + s - 1) % s, a, (a + 1) % s), c.push(0, 1, 0));
      const u = Qte(l);
      ((l = yw(l, 1, u)),
        (c = yw(c, 1, u)),
        !r && l[0] === 0 && (l.push(s), c.push(c[0])),
        o.push(
          new ud(".morphTargetInfluences[" + t[a].name + "]", l, c).scale(
            1 / i,
          ),
        ));
    }
    return new this(e, -1, o);
  }
  static findByName(e, t) {
    let i = e;
    if (!Array.isArray(e)) {
      const r = e;
      i = (r.geometry && r.geometry.animations) || r.animations;
    }
    for (let r = 0; r < i.length; r++) if (i[r].name === t) return i[r];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, i) {
    const r = {},
      s = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a],
        u = c.name.match(s);
      if (u && u.length > 1) {
        const h = u[1];
        let d = r[h];
        (d || (r[h] = d = []), d.push(c));
      }
    }
    const o = [];
    for (const a in r)
      o.push(this.CreateFromMorphTargetSequence(a, r[a], t, i));
    return o;
  }
  static parseAnimation(e, t) {
    if (
      (console.warn(
        "THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185",
      ),
      !e)
    )
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const i = function (h, d, f, g, p) {
        if (f.length !== 0) {
          const m = [],
            C = [];
          (pR(f, m, C, g), m.length !== 0 && p.push(new h(d, m, C)));
        }
      },
      r = [],
      s = e.name || "default",
      o = e.fps || 30,
      a = e.blendMode;
    let l = e.length || -1;
    const c = e.hierarchy || [];
    for (let h = 0; h < c.length; h++) {
      const d = c[h].keys;
      if (!(!d || d.length === 0))
        if (d[0].morphTargets) {
          const f = {};
          let g;
          for (g = 0; g < d.length; g++)
            if (d[g].morphTargets)
              for (let p = 0; p < d[g].morphTargets.length; p++)
                f[d[g].morphTargets[p]] = -1;
          for (const p in f) {
            const m = [],
              C = [];
            for (let A = 0; A !== d[g].morphTargets.length; ++A) {
              const I = d[g];
              (m.push(I.time), C.push(I.morphTarget === p ? 1 : 0));
            }
            r.push(new ud(".morphTargetInfluence[" + p + "]", m, C));
          }
          l = f.length * o;
        } else {
          const f = ".bones[" + t[h].name + "]";
          (i(dd, f + ".position", d, "pos", r),
            i(hd, f + ".quaternion", d, "rot", r),
            i(dd, f + ".scale", d, "scl", r));
        }
    }
    return r.length === 0 ? null : new this(s, l, r, a);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let i = 0, r = e.length; i !== r; ++i) {
      const s = this.tracks[i];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return ((this.duration = t), this);
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function nne(n) {
  switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return ud;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return dd;
    case "color":
      return CR;
    case "quaternion":
      return hd;
    case "bool":
    case "boolean":
      return Zd;
    case "string":
      return zd;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n);
}
function ine(n) {
  if (n.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = nne(n.type);
  if (n.times === void 0) {
    const t = [],
      i = [];
    (pR(n.keys, t, i, "value"), (n.times = t), (n.values = i));
  }
  return e.parse !== void 0
    ? e.parse(n)
    : new e(n.name, n.times, n.values, n.interpolation);
}
const Cl = {
  enabled: !1,
  files: {},
  add: function (n, e) {
    this.enabled !== !1 && (this.files[n] = e);
  },
  get: function (n) {
    if (this.enabled !== !1) return this.files[n];
  },
  remove: function (n) {
    delete this.files[n];
  },
  clear: function () {
    this.files = {};
  },
};
class rne {
  constructor(e, t, i) {
    const r = this;
    let s = !1,
      o = 0,
      a = 0,
      l;
    const c = [];
    ((this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = i),
      (this.itemStart = function (u) {
        (a++, s === !1 && r.onStart !== void 0 && r.onStart(u, o, a), (s = !0));
      }),
      (this.itemEnd = function (u) {
        (o++,
          r.onProgress !== void 0 && r.onProgress(u, o, a),
          o === a && ((s = !1), r.onLoad !== void 0 && r.onLoad()));
      }),
      (this.itemError = function (u) {
        r.onError !== void 0 && r.onError(u);
      }),
      (this.resolveURL = function (u) {
        return l ? l(u) : u;
      }),
      (this.setURLModifier = function (u) {
        return ((l = u), this);
      }),
      (this.addHandler = function (u, h) {
        return (c.push(u, h), this);
      }),
      (this.removeHandler = function (u) {
        const h = c.indexOf(u);
        return (h !== -1 && c.splice(h, 2), this);
      }),
      (this.getHandler = function (u) {
        for (let h = 0, d = c.length; h < d; h += 2) {
          const f = c[h],
            g = c[h + 1];
          if ((f.global && (f.lastIndex = 0), f.test(u))) return g;
        }
        return null;
      }));
  }
}
const sne = new rne();
let Yd = class {
  constructor(e) {
    ((this.manager = e !== void 0 ? e : sne),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {}));
  }
  load() {}
  loadAsync(e, t) {
    const i = this;
    return new Promise(function (r, s) {
      i.load(e, r, t, s);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return ((this.crossOrigin = e), this);
  }
  setWithCredentials(e) {
    return ((this.withCredentials = e), this);
  }
  setPath(e) {
    return ((this.path = e), this);
  }
  setResourcePath(e) {
    return ((this.resourcePath = e), this);
  }
  setRequestHeader(e) {
    return ((this.requestHeader = e), this);
  }
};
Yd.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const ta = {};
class one extends Error {
  constructor(e, t) {
    (super(e), (this.response = t));
  }
}
class IR extends Yd {
  constructor(e) {
    (super(e), (this.mimeType = ""), (this.responseType = ""));
  }
  load(e, t, i, r) {
    (e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e)));
    const s = Cl.get(e);
    if (s !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          (t && t(s), this.manager.itemEnd(e));
        }, 0),
        s
      );
    if (ta[e] !== void 0) {
      ta[e].push({ onLoad: t, onProgress: i, onError: r });
      return;
    }
    ((ta[e] = []), ta[e].push({ onLoad: t, onProgress: i, onError: r }));
    const o = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      a = this.mimeType,
      l = this.responseType;
    (fetch(o)
      .then((c) => {
        if (c.status === 200 || c.status === 0) {
          if (
            (c.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              c.body === void 0 ||
              c.body.getReader === void 0)
          )
            return c;
          const u = ta[e],
            h = c.body.getReader(),
            d = c.headers.get("X-File-Size") || c.headers.get("Content-Length"),
            f = d ? parseInt(d) : 0,
            g = f !== 0;
          let p = 0;
          const m = new ReadableStream({
            start(C) {
              A();
              function A() {
                h.read().then(
                  ({ done: I, value: y }) => {
                    if (I) C.close();
                    else {
                      p += y.byteLength;
                      const x = new ProgressEvent("progress", {
                        lengthComputable: g,
                        loaded: p,
                        total: f,
                      });
                      for (let T = 0, S = u.length; T < S; T++) {
                        const E = u[T];
                        E.onProgress && E.onProgress(x);
                      }
                      (C.enqueue(y), A());
                    }
                  },
                  (I) => {
                    C.error(I);
                  },
                );
              }
            },
          });
          return new Response(m);
        } else
          throw new one(
            `fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,
            c,
          );
      })
      .then((c) => {
        switch (l) {
          case "arraybuffer":
            return c.arrayBuffer();
          case "blob":
            return c.blob();
          case "document":
            return c.text().then((u) => new DOMParser().parseFromString(u, a));
          case "json":
            return c.json();
          default:
            if (a === "") return c.text();
            {
              const h = /charset="?([^;"\s]*)"?/i.exec(a),
                d = h && h[1] ? h[1].toLowerCase() : void 0,
                f = new TextDecoder(d);
              return c.arrayBuffer().then((g) => f.decode(g));
            }
        }
      })
      .then((c) => {
        Cl.add(e, c);
        const u = ta[e];
        delete ta[e];
        for (let h = 0, d = u.length; h < d; h++) {
          const f = u[h];
          f.onLoad && f.onLoad(c);
        }
      })
      .catch((c) => {
        const u = ta[e];
        if (u === void 0) throw (this.manager.itemError(e), c);
        delete ta[e];
        for (let h = 0, d = u.length; h < d; h++) {
          const f = u[h];
          f.onError && f.onError(c);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e));
  }
  setResponseType(e) {
    return ((this.responseType = e), this);
  }
  setMimeType(e) {
    return ((this.mimeType = e), this);
  }
}
class ane extends Yd {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    (this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e)));
    const s = this,
      o = Cl.get(e);
    if (o !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          (t && t(o), s.manager.itemEnd(e));
        }, 0),
        o
      );
    const a = Gg("img");
    function l() {
      (u(), Cl.add(e, this), t && t(this), s.manager.itemEnd(e));
    }
    function c(h) {
      (u(), r && r(h), s.manager.itemError(e), s.manager.itemEnd(e));
    }
    function u() {
      (a.removeEventListener("load", l, !1),
        a.removeEventListener("error", c, !1));
    }
    return (
      a.addEventListener("load", l, !1),
      a.addEventListener("error", c, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (a.crossOrigin = this.crossOrigin),
      s.manager.itemStart(e),
      (a.src = e),
      a
    );
  }
}
class AR extends Yd {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = new Oi(),
      o = new ane(this.manager);
    return (
      o.setCrossOrigin(this.crossOrigin),
      o.setPath(this.path),
      o.load(
        e,
        function (a) {
          ((s.image = a), (s.needsUpdate = !0), t !== void 0 && t(s));
        },
        i,
        r,
      ),
      s
    );
  }
}
class oI extends Hn {
  constructor(e, t = 1) {
    (super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new vt(e)),
      (this.intensity = t));
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      this.target !== void 0 && (t.object.target = this.target.uuid),
      t
    );
  }
}
const V2 = new Et(),
  _w = new X(),
  bw = new X();
class Xv {
  constructor(e) {
    ((this.camera = e),
      (this.intensity = 1),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new Gt(512, 512)),
      (this.mapType = Fo),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new Et()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new zv()),
      (this._frameExtents = new Gt(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new ln(0, 0, 1, 1)]));
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      i = this.matrix;
    (_w.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(_w),
      bw.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(bw),
      t.updateMatrixWorld(),
      V2.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(V2),
      i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      i.multiply(V2));
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    (this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose());
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.intensity = e.intensity),
      (this.bias = e.bias),
      (this.radius = e.radius),
      (this.autoUpdate = e.autoUpdate),
      (this.needsUpdate = e.needsUpdate),
      (this.normalBias = e.normalBias),
      (this.blurSamples = e.blurSamples),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.intensity !== 1 && (e.intensity = this.intensity),
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class lne extends Xv {
  constructor() {
    (super(new Ri(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1));
  }
  updateMatrices(e) {
    const t = this.camera,
      i = ld * 2 * e.angle * this.focus,
      r = this.mapSize.width / this.mapSize.height,
      s = e.distance || t.far;
    ((i !== t.fov || r !== t.aspect || s !== t.far) &&
      ((t.fov = i), (t.aspect = r), (t.far = s), t.updateProjectionMatrix()),
      super.updateMatrices(e));
  }
  copy(e) {
    return (super.copy(e), (this.focus = e.focus), this);
  }
}
class cne extends oI {
  constructor(e, t, i = 0, r = Math.PI / 3, s = 0, o = 2) {
    (super(e, t),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(Hn.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Hn()),
      (this.distance = i),
      (this.angle = r),
      (this.penumbra = s),
      (this.decay = o),
      (this.map = null),
      (this.shadow = new lne()));
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const vw = new Et(),
  Cf = new X(),
  Z2 = new X();
class une extends Xv {
  constructor() {
    (super(new Ri(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new Gt(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new ln(2, 1, 1, 1),
        new ln(0, 1, 1, 1),
        new ln(3, 1, 1, 1),
        new ln(1, 1, 1, 1),
        new ln(3, 0, 1, 1),
        new ln(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new X(1, 0, 0),
        new X(-1, 0, 0),
        new X(0, 0, 1),
        new X(0, 0, -1),
        new X(0, 1, 0),
        new X(0, -1, 0),
      ]),
      (this._cubeUps = [
        new X(0, 1, 0),
        new X(0, 1, 0),
        new X(0, 1, 0),
        new X(0, 1, 0),
        new X(0, 0, 1),
        new X(0, 0, -1),
      ]));
  }
  updateMatrices(e, t = 0) {
    const i = this.camera,
      r = this.matrix,
      s = e.distance || i.far;
    (s !== i.far && ((i.far = s), i.updateProjectionMatrix()),
      Cf.setFromMatrixPosition(e.matrixWorld),
      i.position.copy(Cf),
      Z2.copy(i.position),
      Z2.add(this._cubeDirections[t]),
      i.up.copy(this._cubeUps[t]),
      i.lookAt(Z2),
      i.updateMatrixWorld(),
      r.makeTranslation(-Cf.x, -Cf.y, -Cf.z),
      vw.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(vw));
  }
}
class yR extends oI {
  constructor(e, t, i = 0, r = 2) {
    (super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = i),
      (this.decay = r),
      (this.shadow = new une()));
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class aI extends aR {
  constructor(e = -1, t = 1, i = 1, r = -1, s = 0.1, o = 2e3) {
    (super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = i),
      (this.bottom = r),
      (this.near = s),
      (this.far = o),
      this.updateProjectionMatrix());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, i, r, s, o) {
    (this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix());
  }
  clearViewOffset() {
    (this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix());
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      i = (this.right + this.left) / 2,
      r = (this.top + this.bottom) / 2;
    let s = i - e,
      o = i + e,
      a = r + t,
      l = r - t;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
        u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      ((s += c * this.view.offsetX),
        (o = s + c * this.view.width),
        (a -= u * this.view.offsetY),
        (l = a - u * this.view.height));
    }
    (this.projectionMatrix.makeOrthographic(
      s,
      o,
      a,
      l,
      this.near,
      this.far,
      this.coordinateSystem,
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert());
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
class hne extends Xv {
  constructor() {
    (super(new aI(-5, 5, 5, -5, 0.5, 500)),
      (this.isDirectionalLightShadow = !0));
  }
}
class dne extends oI {
  constructor(e, t) {
    (super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(Hn.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Hn()),
      (this.shadow = new hne()));
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class _R extends oI {
  constructor(e, t) {
    (super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight"));
  }
}
class rg {
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class fne extends Yd {
  constructor(e) {
    (super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported.",
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" }));
  }
  setOptions(e) {
    return ((this.options = e), this);
  }
  load(e, t, i, r) {
    (e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e)));
    const s = this,
      o = Cl.get(e);
    if (o !== void 0) {
      if ((s.manager.itemStart(e), o.then)) {
        o.then((c) => {
          (t && t(c), s.manager.itemEnd(e));
        }).catch((c) => {
          r && r(c);
        });
        return;
      }
      return (
        setTimeout(function () {
          (t && t(o), s.manager.itemEnd(e));
        }, 0),
        o
      );
    }
    const a = {};
    ((a.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (a.headers = this.requestHeader));
    const l = fetch(e, a)
      .then(function (c) {
        return c.blob();
      })
      .then(function (c) {
        return createImageBitmap(
          c,
          Object.assign(s.options, { colorSpaceConversion: "none" }),
        );
      })
      .then(function (c) {
        return (Cl.add(e, c), t && t(c), s.manager.itemEnd(e), c);
      })
      .catch(function (c) {
        (r && r(c), Cl.remove(e), s.manager.itemError(e), s.manager.itemEnd(e));
      });
    (Cl.add(e, l), s.manager.itemStart(e));
  }
}
class gne extends Ri {
  constructor(e = []) {
    (super(),
      (this.isArrayCamera = !0),
      (this.isMultiViewCamera = !1),
      (this.cameras = e));
  }
}
class bR {
  constructor(e = !0) {
    ((this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1));
  }
  start() {
    ((this.startTime = xw()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0));
  }
  stop() {
    (this.getElapsedTime(), (this.running = !1), (this.autoStart = !1));
  }
  getElapsedTime() {
    return (this.getDelta(), this.elapsedTime);
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return (this.start(), 0);
    if (this.running) {
      const t = xw();
      ((e = (t - this.oldTime) / 1e3),
        (this.oldTime = t),
        (this.elapsedTime += e));
    }
    return e;
  }
}
function xw() {
  return performance.now();
}
class pne {
  constructor(e, t, i) {
    ((this.binding = e), (this.valueSize = i));
    let r, s, o;
    switch (t) {
      case "quaternion":
        ((r = this._slerp),
          (s = this._slerpAdditive),
          (o = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(i * 6)),
          (this._workIndex = 5));
        break;
      case "string":
      case "bool":
        ((r = this._select),
          (s = this._select),
          (o = this._setAdditiveIdentityOther),
          (this.buffer = new Array(i * 5)));
        break;
      default:
        ((r = this._lerp),
          (s = this._lerpAdditive),
          (o = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(i * 5)));
    }
    ((this._mixBufferRegion = r),
      (this._mixBufferRegionAdditive = s),
      (this._setIdentity = o),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0));
  }
  accumulate(e, t) {
    const i = this.buffer,
      r = this.valueSize,
      s = e * r + r;
    let o = this.cumulativeWeight;
    if (o === 0) {
      for (let a = 0; a !== r; ++a) i[s + a] = i[a];
      o = t;
    } else {
      o += t;
      const a = t / o;
      this._mixBufferRegion(i, s, 0, a, r);
    }
    this.cumulativeWeight = o;
  }
  accumulateAdditive(e) {
    const t = this.buffer,
      i = this.valueSize,
      r = i * this._addIndex;
    (this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(t, r, 0, e, i),
      (this.cumulativeWeightAdditive += e));
  }
  apply(e) {
    const t = this.valueSize,
      i = this.buffer,
      r = e * t + t,
      s = this.cumulativeWeight,
      o = this.cumulativeWeightAdditive,
      a = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), s < 1)
    ) {
      const l = t * this._origIndex;
      this._mixBufferRegion(i, r, l, 1 - s, t);
    }
    o > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t);
    for (let l = t, c = t + t; l !== c; ++l)
      if (i[l] !== i[l + t]) {
        a.setValue(i, r);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding,
      t = this.buffer,
      i = this.valueSize,
      r = i * this._origIndex;
    e.getValue(t, r);
    for (let s = i, o = r; s !== o; ++s) t[s] = t[r + (s % i)];
    (this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0));
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      t = e + this.valueSize;
    for (let i = e; i < t; i++) this.buffer[i] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    (this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1));
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      t = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++)
      this.buffer[t + i] = this.buffer[e + i];
  }
  _select(e, t, i, r, s) {
    if (r >= 0.5) for (let o = 0; o !== s; ++o) e[t + o] = e[i + o];
  }
  _slerp(e, t, i, r) {
    Qs.slerpFlat(e, t, e, t, e, i, r);
  }
  _slerpAdditive(e, t, i, r, s) {
    const o = this._workIndex * s;
    (Qs.multiplyQuaternionsFlat(e, o, e, t, e, i),
      Qs.slerpFlat(e, t, e, t, e, o, r));
  }
  _lerp(e, t, i, r, s) {
    const o = 1 - r;
    for (let a = 0; a !== s; ++a) {
      const l = t + a;
      e[l] = e[l] * o + e[i + a] * r;
    }
  }
  _lerpAdditive(e, t, i, r, s) {
    for (let o = 0; o !== s; ++o) {
      const a = t + o;
      e[a] = e[a] + e[i + o] * r;
    }
  }
}
const Kv = "\\[\\]\\.:\\/",
  mne = new RegExp("[" + Kv + "]", "g"),
  jv = "[^" + Kv + "]",
  Cne = "[^" + Kv.replace("\\.", "") + "]",
  Ine = /((?:WC+[\/:])*)/.source.replace("WC", jv),
  Ane = /(WCOD+)?/.source.replace("WCOD", Cne),
  yne = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", jv),
  _ne = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", jv),
  bne = new RegExp("^" + Ine + Ane + yne + _ne + "$"),
  vne = ["material", "materials", "bones", "map"];
class xne {
  constructor(e, t, i) {
    const r = i || hn.parseTrackName(t);
    ((this._targetGroup = e), (this._bindings = e.subscribe_(t, r)));
  }
  getValue(e, t) {
    this.bind();
    const i = this._targetGroup.nCachedObjects_,
      r = this._bindings[i];
    r !== void 0 && r.getValue(e, t);
  }
  setValue(e, t) {
    const i = this._bindings;
    for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r)
      i[r].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].unbind();
  }
}
class hn {
  constructor(e, t, i) {
    ((this.path = t),
      (this.parsedPath = i || hn.parseTrackName(t)),
      (this.node = hn.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound));
  }
  static create(e, t, i) {
    return e && e.isAnimationObjectGroup
      ? new hn.Composite(e, t, i)
      : new hn(e, t, i);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(mne, "");
  }
  static parseTrackName(e) {
    const t = bne.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const i = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      r = i.nodeName && i.nodeName.lastIndexOf(".");
    if (r !== void 0 && r !== -1) {
      const s = i.nodeName.substring(r + 1);
      vne.indexOf(s) !== -1 &&
        ((i.nodeName = i.nodeName.substring(0, r)), (i.objectName = s));
    }
    if (i.propertyName === null || i.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e,
      );
    return i;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === "" ||
      t === "." ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const i = e.skeleton.getBoneByName(t);
      if (i !== void 0) return i;
    }
    if (e.children) {
      const i = function (s) {
          for (let o = 0; o < s.length; o++) {
            const a = s[o];
            if (a.name === t || a.uuid === t) return a;
            const l = i(a.children);
            if (l) return l;
          }
          return null;
        },
        r = i(e.children);
      if (r) return r;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) e[t++] = i[r];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    ((this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0));
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    ((this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0));
  }
  _setValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    ((this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0));
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    ((this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0));
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    (this.resolvedProperty.fromArray(e, t),
      (this.targetObject.needsUpdate = !0));
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0));
  }
  _getValue_unbound(e, t) {
    (this.bind(), this.getValue(e, t));
  }
  _setValue_unbound(e, t) {
    (this.bind(), this.setValue(e, t));
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      i = t.objectName,
      r = t.propertyName;
    let s = t.propertyIndex;
    if (
      (e || ((e = hn.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.warn(
        "THREE.PropertyBinding: No target node found for track: " +
          this.path +
          ".",
      );
      return;
    }
    if (i) {
      let c = t.objectIndex;
      switch (i) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this,
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this,
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this,
            );
            return;
          }
          e = e.skeleton.bones;
          for (let u = 0; u < e.length; u++)
            if (e[u].name === c) {
              c = u;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this,
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this,
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[i] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this,
            );
            return;
          }
          e = e[i];
      }
      if (c !== void 0) {
        if (e[c] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e,
          );
          return;
        }
        e = e[c];
      }
    }
    const o = e[r];
    if (o === void 0) {
      const c = t.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          c +
          "." +
          r +
          " but it wasn't found.",
        e,
      );
      return;
    }
    let a = this.Versioning.None;
    ((this.targetObject = e),
      e.isMaterial === !0
        ? (a = this.Versioning.NeedsUpdate)
        : e.isObject3D === !0 && (a = this.Versioning.MatrixWorldNeedsUpdate));
    let l = this.BindingType.Direct;
    if (s !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this,
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this,
          );
          return;
        }
        e.morphTargetDictionary[s] !== void 0 &&
          (s = e.morphTargetDictionary[s]);
      }
      ((l = this.BindingType.ArrayElement),
        (this.resolvedProperty = o),
        (this.propertyIndex = s));
    } else
      o.fromArray !== void 0 && o.toArray !== void 0
        ? ((l = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
        : Array.isArray(o)
          ? ((l = this.BindingType.EntireArray), (this.resolvedProperty = o))
          : (this.propertyName = r);
    ((this.getValue = this.GetterByBindingType[l]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[l][a]));
  }
  unbind() {
    ((this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound));
  }
}
hn.Composite = xne;
hn.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
hn.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
hn.prototype.GetterByBindingType = [
  hn.prototype._getValue_direct,
  hn.prototype._getValue_array,
  hn.prototype._getValue_arrayElement,
  hn.prototype._getValue_toArray,
];
hn.prototype.SetterByBindingTypeAndVersioning = [
  [
    hn.prototype._setValue_direct,
    hn.prototype._setValue_direct_setNeedsUpdate,
    hn.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    hn.prototype._setValue_array,
    hn.prototype._setValue_array_setNeedsUpdate,
    hn.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    hn.prototype._setValue_arrayElement,
    hn.prototype._setValue_arrayElement_setNeedsUpdate,
    hn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    hn.prototype._setValue_fromArray,
    hn.prototype._setValue_fromArray_setNeedsUpdate,
    hn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class wne {
  constructor(e, t, i = null, r = t.blendMode) {
    ((this._mixer = e),
      (this._clip = t),
      (this._localRoot = i),
      (this.blendMode = r));
    const s = t.tracks,
      o = s.length,
      a = new Array(o),
      l = { endingStart: Ih, endingEnd: Ih };
    for (let c = 0; c !== o; ++c) {
      const u = s[c].createInterpolant(null);
      ((a[c] = u), (u.settings = l));
    }
    ((this._interpolantSettings = l),
      (this._interpolants = a),
      (this._propertyBindings = new Array(o)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = Nee),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0));
  }
  play() {
    return (this._mixer._activateAction(this), this);
  }
  stop() {
    return (this._mixer._deactivateAction(this), this.reset());
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return ((this._startTime = e), this);
  }
  setLoop(e, t) {
    return ((this.loop = e), (this.repetitions = t), this);
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, i = !1) {
    if ((e.fadeOut(t), this.fadeIn(t), i === !0)) {
      const r = this._clip.duration,
        s = e._clip.duration,
        o = s / r,
        a = r / s;
      (e.warp(1, o, t), this.warp(a, 1, t));
    }
    return this;
  }
  crossFadeTo(e, t, i = !1) {
    return e.crossFadeFrom(this, t, i);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return ((this.timeScale = this._clip.duration / e), this.stopWarping());
  }
  syncWith(e) {
    return (
      (this.time = e.time),
      (this.timeScale = e.timeScale),
      this.stopWarping()
    );
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, i) {
    const r = this._mixer,
      s = r.time,
      o = this.timeScale;
    let a = this._timeScaleInterpolant;
    a === null &&
      ((a = r._lendControlInterpolant()), (this._timeScaleInterpolant = a));
    const l = a.parameterPositions,
      c = a.sampleValues;
    return ((l[0] = s), (l[1] = s + i), (c[0] = e / o), (c[1] = t / o), this);
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, i, r) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const s = this._startTime;
    if (s !== null) {
      const l = (e - s) * i;
      l < 0 || i === 0 ? (t = 0) : ((this._startTime = null), (t = i * l));
    }
    t *= this._updateTimeScale(e);
    const o = this._updateTime(t),
      a = this._updateWeight(e);
    if (a > 0) {
      const l = this._interpolants,
        c = this._propertyBindings;
      switch (this.blendMode) {
        case Gee:
          for (let u = 0, h = l.length; u !== h; ++u)
            (l[u].evaluate(o), c[u].accumulateAdditive(a));
          break;
        case Fv:
        default:
          for (let u = 0, h = l.length; u !== h; ++u)
            (l[u].evaluate(o), c[u].accumulate(r, a));
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const i = this._weightInterpolant;
      if (i !== null) {
        const r = i.evaluate(e)[0];
        ((t *= r),
          e > i.parameterPositions[1] &&
            (this.stopFading(), r === 0 && (this.enabled = !1)));
      }
    }
    return ((this._effectiveWeight = t), t);
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const i = this._timeScaleInterpolant;
      if (i !== null) {
        const r = i.evaluate(e)[0];
        ((t *= r),
          e > i.parameterPositions[1] &&
            (this.stopWarping(),
            t === 0 ? (this.paused = !0) : (this.timeScale = t)));
      }
    }
    return ((this._effectiveTimeScale = t), t);
  }
  _updateTime(e) {
    const t = this._clip.duration,
      i = this.loop;
    let r = this.time + e,
      s = this._loopCount;
    const o = i === Dee;
    if (e === 0) return s === -1 ? r : o && (s & 1) === 1 ? t - r : r;
    if (i === X_) {
      s === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (r >= t) r = t;
        else if (r < 0) r = 0;
        else {
          this.time = r;
          break e;
        }
        (this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = r),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1,
          }));
      }
    } else {
      if (
        (s === -1 &&
          (e >= 0
            ? ((s = 0), this._setEndings(!0, this.repetitions === 0, o))
            : this._setEndings(this.repetitions === 0, !0, o)),
        r >= t || r < 0)
      ) {
        const a = Math.floor(r / t);
        ((r -= t * a), (s += Math.abs(a)));
        const l = this.repetitions - s;
        if (l <= 0)
          (this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (r = e > 0 ? t : 0),
            (this.time = r),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1,
            }));
        else {
          if (l === 1) {
            const c = e < 0;
            this._setEndings(c, !c, o);
          } else this._setEndings(!1, !1, o);
          ((this._loopCount = s),
            (this.time = r),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: a,
            }));
        }
      } else this.time = r;
      if (o && (s & 1) === 1) return t - r;
    }
    return r;
  }
  _setEndings(e, t, i) {
    const r = this._interpolantSettings;
    i
      ? ((r.endingStart = Ah), (r.endingEnd = Ah))
      : (e
          ? (r.endingStart = this.zeroSlopeAtStart ? Ah : Ih)
          : (r.endingStart = Ym),
        t ? (r.endingEnd = this.zeroSlopeAtEnd ? Ah : Ih) : (r.endingEnd = Ym));
  }
  _scheduleFading(e, t, i) {
    const r = this._mixer,
      s = r.time;
    let o = this._weightInterpolant;
    o === null &&
      ((o = r._lendControlInterpolant()), (this._weightInterpolant = o));
    const a = o.parameterPositions,
      l = o.sampleValues;
    return ((a[0] = s), (l[0] = t), (a[1] = s + e), (l[1] = i), this);
  }
}
const Sne = new Float32Array(1);
class ww extends wu {
  constructor(e) {
    (super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1));
  }
  _bindAction(e, t) {
    const i = e._localRoot || this._root,
      r = e._clip.tracks,
      s = r.length,
      o = e._propertyBindings,
      a = e._interpolants,
      l = i.uuid,
      c = this._bindingsByRootAndName;
    let u = c[l];
    u === void 0 && ((u = {}), (c[l] = u));
    for (let h = 0; h !== s; ++h) {
      const d = r[h],
        f = d.name;
      let g = u[f];
      if (g !== void 0) (++g.referenceCount, (o[h] = g));
      else {
        if (((g = o[h]), g !== void 0)) {
          g._cacheIndex === null &&
            (++g.referenceCount, this._addInactiveBinding(g, l, f));
          continue;
        }
        const p = t && t._propertyBindings[h].binding.parsedPath;
        ((g = new pne(hn.create(i, f, p), d.ValueTypeName, d.getValueSize())),
          ++g.referenceCount,
          this._addInactiveBinding(g, l, f),
          (o[h] = g));
      }
      a[h].resultBuffer = g.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const i = (e._localRoot || this._root).uuid,
          r = e._clip.uuid,
          s = this._actionsByClip[r];
        (this._bindAction(e, s && s.knownActions[0]),
          this._addInactiveAction(e, r, i));
      }
      const t = e._propertyBindings;
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i];
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i];
        --s.useCount === 0 &&
          (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    ((this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0));
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, i) {
    const r = this._actions,
      s = this._actionsByClip;
    let o = s[t];
    if (o === void 0)
      ((o = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (s[t] = o));
    else {
      const a = o.knownActions;
      ((e._byClipCacheIndex = a.length), a.push(e));
    }
    ((e._cacheIndex = r.length), r.push(e), (o.actionByRoot[i] = e));
  }
  _removeInactiveAction(e) {
    const t = this._actions,
      i = t[t.length - 1],
      r = e._cacheIndex;
    ((i._cacheIndex = r), (t[r] = i), t.pop(), (e._cacheIndex = null));
    const s = e._clip.uuid,
      o = this._actionsByClip,
      a = o[s],
      l = a.knownActions,
      c = l[l.length - 1],
      u = e._byClipCacheIndex;
    ((c._byClipCacheIndex = u),
      (l[u] = c),
      l.pop(),
      (e._byClipCacheIndex = null));
    const h = a.actionByRoot,
      d = (e._localRoot || this._root).uuid;
    (delete h[d],
      l.length === 0 && delete o[s],
      this._removeInactiveBindingsForAction(e));
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let i = 0, r = t.length; i !== r; ++i) {
      const s = t[i];
      --s.referenceCount === 0 && this._removeInactiveBinding(s);
    }
  }
  _lendAction(e) {
    const t = this._actions,
      i = e._cacheIndex,
      r = this._nActiveActions++,
      s = t[r];
    ((e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s));
  }
  _takeBackAction(e) {
    const t = this._actions,
      i = e._cacheIndex,
      r = --this._nActiveActions,
      s = t[r];
    ((e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s));
  }
  _addInactiveBinding(e, t, i) {
    const r = this._bindingsByRootAndName,
      s = this._bindings;
    let o = r[t];
    (o === void 0 && ((o = {}), (r[t] = o)),
      (o[i] = e),
      (e._cacheIndex = s.length),
      s.push(e));
  }
  _removeInactiveBinding(e) {
    const t = this._bindings,
      i = e.binding,
      r = i.rootNode.uuid,
      s = i.path,
      o = this._bindingsByRootAndName,
      a = o[r],
      l = t[t.length - 1],
      c = e._cacheIndex;
    ((l._cacheIndex = c),
      (t[c] = l),
      t.pop(),
      delete a[s],
      Object.keys(a).length === 0 && delete o[r]);
  }
  _lendBinding(e) {
    const t = this._bindings,
      i = e._cacheIndex,
      r = this._nActiveBindings++,
      s = t[r];
    ((e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s));
  }
  _takeBackBinding(e) {
    const t = this._bindings,
      i = e._cacheIndex,
      r = --this._nActiveBindings,
      s = t[r];
    ((e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s));
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      t = this._nActiveControlInterpolants++;
    let i = e[t];
    return (
      i === void 0 &&
        ((i = new mR(new Float32Array(2), new Float32Array(2), 1, Sne)),
        (i.__cacheIndex = t),
        (e[t] = i)),
      i
    );
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants,
      i = e.__cacheIndex,
      r = --this._nActiveControlInterpolants,
      s = t[r];
    ((e.__cacheIndex = r), (t[r] = e), (s.__cacheIndex = i), (t[i] = s));
  }
  clipAction(e, t, i) {
    const r = t || this._root,
      s = r.uuid;
    let o = typeof e == "string" ? Q_.findByName(r, e) : e;
    const a = o !== null ? o.uuid : e,
      l = this._actionsByClip[a];
    let c = null;
    if (
      (i === void 0 && (o !== null ? (i = o.blendMode) : (i = Fv)),
      l !== void 0)
    ) {
      const h = l.actionByRoot[s];
      if (h !== void 0 && h.blendMode === i) return h;
      ((c = l.knownActions[0]), o === null && (o = c._clip));
    }
    if (o === null) return null;
    const u = new wne(this, o, t, i);
    return (this._bindAction(u, c), this._addInactiveAction(u, a, s), u);
  }
  existingAction(e, t) {
    const i = t || this._root,
      r = i.uuid,
      s = typeof e == "string" ? Q_.findByName(i, e) : e,
      o = s ? s.uuid : e,
      a = this._actionsByClip[o];
    return (a !== void 0 && a.actionByRoot[r]) || null;
  }
  stopAllAction() {
    const e = this._actions,
      t = this._nActiveActions;
    for (let i = t - 1; i >= 0; --i) e[i].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions,
      i = this._nActiveActions,
      r = (this.time += e),
      s = Math.sign(e),
      o = (this._accuIndex ^= 1);
    for (let c = 0; c !== i; ++c) t[c]._update(r, e, s, o);
    const a = this._bindings,
      l = this._nActiveBindings;
    for (let c = 0; c !== l; ++c) a[c].apply(o);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions,
      i = e.uuid,
      r = this._actionsByClip,
      s = r[i];
    if (s !== void 0) {
      const o = s.knownActions;
      for (let a = 0, l = o.length; a !== l; ++a) {
        const c = o[a];
        this._deactivateAction(c);
        const u = c._cacheIndex,
          h = t[t.length - 1];
        ((c._cacheIndex = null),
          (c._byClipCacheIndex = null),
          (h._cacheIndex = u),
          (t[u] = h),
          t.pop(),
          this._removeInactiveBindingsForAction(c));
      }
      delete r[i];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid,
      i = this._actionsByClip;
    for (const o in i) {
      const a = i[o].actionByRoot,
        l = a[t];
      l !== void 0 &&
        (this._deactivateAction(l), this._removeInactiveAction(l));
    }
    const r = this._bindingsByRootAndName,
      s = r[t];
    if (s !== void 0)
      for (const o in s) {
        const a = s[o];
        (a.restoreOriginalState(), this._removeInactiveBinding(a));
      }
  }
  uncacheAction(e, t) {
    const i = this.existingAction(e, t);
    i !== null && (this._deactivateAction(i), this._removeInactiveAction(i));
  }
}
class ur {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new ur(
      this.value.clone === void 0 ? this.value : this.value.clone(),
    );
  }
}
const Sw = new Et();
class vR {
  constructor(e, t, i = 0, r = 1 / 0) {
    ((this.ray = new Sp(e, t)),
      (this.near = i),
      (this.far = r),
      (this.camera = null),
      (this.layers = new Uv()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      }));
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(t)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = t))
      : t.isOrthographicCamera
        ? (this.ray.origin
            .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
            .unproject(t),
          this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
          (this.camera = t))
        : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  setFromXRController(e) {
    return (
      Sw.identity().extractRotation(e.matrixWorld),
      this.ray.origin.setFromMatrixPosition(e.matrixWorld),
      this.ray.direction.set(0, 0, -1).applyMatrix4(Sw),
      this
    );
  }
  intersectObject(e, t = !0, i = []) {
    return (q_(e, this, i, t), i.sort(Tw), i);
  }
  intersectObjects(e, t = !0, i = []) {
    for (let r = 0, s = e.length; r < s; r++) q_(e[r], this, i, t);
    return (i.sort(Tw), i);
  }
}
function Tw(n, e) {
  return n.distance - e.distance;
}
function q_(n, e, t, i) {
  let r = !0;
  if (
    (n.layers.test(e.layers) && n.raycast(e, t) === !1 && (r = !1),
    r === !0 && i === !0)
  ) {
    const s = n.children;
    for (let o = 0, a = s.length; o < a; o++) q_(s[o], e, t, !0);
  }
}
function Ew(n, e, t, i) {
  const r = Tne(i);
  switch (t) {
    case KL:
      return n * e;
    case Pv:
      return ((n * e) / r.components) * r.byteLength;
    case Nv:
      return ((n * e) / r.components) * r.byteLength;
    case $L:
      return ((n * e * 2) / r.components) * r.byteLength;
    case Dv:
      return ((n * e * 2) / r.components) * r.byteLength;
    case jL:
      return ((n * e * 3) / r.components) * r.byteLength;
    case Sr:
      return ((n * e * 4) / r.components) * r.byteLength;
    case Gv:
      return ((n * e * 4) / r.components) * r.byteLength;
    case k0:
    case O0:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case U0:
    case H0:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case b_:
    case x_:
      return (Math.max(n, 16) * Math.max(e, 8)) / 4;
    case __:
    case v_:
      return (Math.max(n, 8) * Math.max(e, 8)) / 2;
    case w_:
    case S_:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case T_:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case E_:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case M_:
      return Math.floor((n + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case L_:
      return Math.floor((n + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case R_:
      return Math.floor((n + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case B_:
      return Math.floor((n + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case P_:
      return Math.floor((n + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case N_:
      return Math.floor((n + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case D_:
      return Math.floor((n + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case G_:
      return Math.floor((n + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case F_:
      return Math.floor((n + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case k_:
      return Math.floor((n + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case O_:
      return Math.floor((n + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case U_:
      return Math.floor((n + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case H_:
      return Math.floor((n + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case W0:
    case W_:
    case V_:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
    case JL:
    case Z_:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 8;
    case z_:
    case Y_:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(`Unable to determine texture byte length for ${t} format.`);
}
function Tne(n) {
  switch (n) {
    case Fo:
    case zL:
      return { byteLength: 1, components: 1 };
    case Lg:
    case YL:
    case wp:
      return { byteLength: 2, components: 1 };
    case Rv:
    case Bv:
      return { byteLength: 2, components: 4 };
    case gu:
    case Lv:
    case Xr:
      return { byteLength: 4, components: 1 };
    case XL:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${n}.`);
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: Mv } }),
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = Mv));
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ function xR() {
  let n = null,
    e = !1,
    t = null,
    i = null;
  function r(s, o) {
    (t(s, o), (i = n.requestAnimationFrame(r)));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((i = n.requestAnimationFrame(r)), (e = !0));
    },
    stop: function () {
      (n.cancelAnimationFrame(i), (e = !1));
    },
    setAnimationLoop: function (s) {
      t = s;
    },
    setContext: function (s) {
      n = s;
    },
  };
}
function Ene(n) {
  const e = new WeakMap();
  function t(a, l) {
    const c = a.array,
      u = a.usage,
      h = c.byteLength,
      d = n.createBuffer();
    (n.bindBuffer(l, d), n.bufferData(l, c, u), a.onUploadCallback());
    let f;
    if (c instanceof Float32Array) f = n.FLOAT;
    else if (c instanceof Uint16Array)
      a.isFloat16BufferAttribute ? (f = n.HALF_FLOAT) : (f = n.UNSIGNED_SHORT);
    else if (c instanceof Int16Array) f = n.SHORT;
    else if (c instanceof Uint32Array) f = n.UNSIGNED_INT;
    else if (c instanceof Int32Array) f = n.INT;
    else if (c instanceof Int8Array) f = n.BYTE;
    else if (c instanceof Uint8Array) f = n.UNSIGNED_BYTE;
    else if (c instanceof Uint8ClampedArray) f = n.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + c,
      );
    return {
      buffer: d,
      type: f,
      bytesPerElement: c.BYTES_PER_ELEMENT,
      version: a.version,
      size: h,
    };
  }
  function i(a, l, c) {
    const u = l.array,
      h = l.updateRanges;
    if ((n.bindBuffer(c, a), h.length === 0)) n.bufferSubData(c, 0, u);
    else {
      h.sort((f, g) => f.start - g.start);
      let d = 0;
      for (let f = 1; f < h.length; f++) {
        const g = h[d],
          p = h[f];
        p.start <= g.start + g.count + 1
          ? (g.count = Math.max(g.count, p.start + p.count - g.start))
          : (++d, (h[d] = p));
      }
      h.length = d + 1;
      for (let f = 0, g = h.length; f < g; f++) {
        const p = h[f];
        n.bufferSubData(c, p.start * u.BYTES_PER_ELEMENT, u, p.start, p.count);
      }
      l.clearUpdateRanges();
    }
    l.onUploadCallback();
  }
  function r(a) {
    return (a.isInterleavedBufferAttribute && (a = a.data), e.get(a));
  }
  function s(a) {
    a.isInterleavedBufferAttribute && (a = a.data);
    const l = e.get(a);
    l && (n.deleteBuffer(l.buffer), e.delete(a));
  }
  function o(a, l) {
    if (
      (a.isInterleavedBufferAttribute && (a = a.data), a.isGLBufferAttribute)
    ) {
      const u = e.get(a);
      (!u || u.version < a.version) &&
        e.set(a, {
          buffer: a.buffer,
          type: a.type,
          bytesPerElement: a.elementSize,
          version: a.version,
        });
      return;
    }
    const c = e.get(a);
    if (c === void 0) e.set(a, t(a, l));
    else if (c.version < a.version) {
      if (c.size !== a.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.",
        );
      (i(c.buffer, a, l), (c.version = a.version));
    }
  }
  return { get: r, remove: s, update: o };
}
var Mne = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  Lne = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  Rne = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  Bne = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  Pne = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
  Nne = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  Dne = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  Gne = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  Fne = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
  kne = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
  One = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  Une = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  Hne = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  Wne = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  Vne = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  Zne = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
  zne = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  Yne = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  Xne = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  Kne = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  jne = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  $ne = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
  Jne = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
  Qne = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  qne = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  eie = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  tie = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  nie = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  iie = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  rie = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  sie = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  oie = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  aie = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  lie = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  cie = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  uie = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  hie = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  die = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  fie = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  gie = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  pie = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  mie = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  Cie = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  Iie = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  Aie = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  yie = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  _ie = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  bie = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  vie = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  xie = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  wie = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  Sie = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  Tie = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  Eie = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  Mie = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  Lie = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  Rie = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  Bie = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  Pie = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  Nie = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
  Die = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  Gie = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  Fie = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  kie = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  Oie = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  Uie = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  Hie = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
  Wie = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  Vie = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  Zie = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
  zie = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  Yie = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  Xie = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  Kie = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  jie = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  $ie = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  Jie = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  Qie = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  qie = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  ere = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  tre = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  nre = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  ire = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  rre = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  sre = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  ore = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  are = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  lre = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  cre = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  ure = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
  hre = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  dre = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  fre = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  gre = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  pre = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  mre = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  Cre = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  Ire = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  Are = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  yre = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  _re = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  bre = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  vre = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  xre = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  wre = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  Sre = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  Tre = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const Ere = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  Mre = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  Lre = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  Rre = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  Bre = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  Pre = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  Nre = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  Dre = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
  Gre = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  Fre = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  kre = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  Ore = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  Ure = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  Hre = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  Wre = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  Vre = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Zre = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  zre = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Yre = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  Xre = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Kre = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  jre = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  $re = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  Jre = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Qre = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  qre = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  ese = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  tse = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  nse = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  ise = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  rse = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  sse = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  ose = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  ase = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  Nt = {
    alphahash_fragment: Mne,
    alphahash_pars_fragment: Lne,
    alphamap_fragment: Rne,
    alphamap_pars_fragment: Bne,
    alphatest_fragment: Pne,
    alphatest_pars_fragment: Nne,
    aomap_fragment: Dne,
    aomap_pars_fragment: Gne,
    batching_pars_vertex: Fne,
    batching_vertex: kne,
    begin_vertex: One,
    beginnormal_vertex: Une,
    bsdfs: Hne,
    iridescence_fragment: Wne,
    bumpmap_pars_fragment: Vne,
    clipping_planes_fragment: Zne,
    clipping_planes_pars_fragment: zne,
    clipping_planes_pars_vertex: Yne,
    clipping_planes_vertex: Xne,
    color_fragment: Kne,
    color_pars_fragment: jne,
    color_pars_vertex: $ne,
    color_vertex: Jne,
    common: Qne,
    cube_uv_reflection_fragment: qne,
    defaultnormal_vertex: eie,
    displacementmap_pars_vertex: tie,
    displacementmap_vertex: nie,
    emissivemap_fragment: iie,
    emissivemap_pars_fragment: rie,
    colorspace_fragment: sie,
    colorspace_pars_fragment: oie,
    envmap_fragment: aie,
    envmap_common_pars_fragment: lie,
    envmap_pars_fragment: cie,
    envmap_pars_vertex: uie,
    envmap_physical_pars_fragment: _ie,
    envmap_vertex: hie,
    fog_vertex: die,
    fog_pars_vertex: fie,
    fog_fragment: gie,
    fog_pars_fragment: pie,
    gradientmap_pars_fragment: mie,
    lightmap_pars_fragment: Cie,
    lights_lambert_fragment: Iie,
    lights_lambert_pars_fragment: Aie,
    lights_pars_begin: yie,
    lights_toon_fragment: bie,
    lights_toon_pars_fragment: vie,
    lights_phong_fragment: xie,
    lights_phong_pars_fragment: wie,
    lights_physical_fragment: Sie,
    lights_physical_pars_fragment: Tie,
    lights_fragment_begin: Eie,
    lights_fragment_maps: Mie,
    lights_fragment_end: Lie,
    logdepthbuf_fragment: Rie,
    logdepthbuf_pars_fragment: Bie,
    logdepthbuf_pars_vertex: Pie,
    logdepthbuf_vertex: Nie,
    map_fragment: Die,
    map_pars_fragment: Gie,
    map_particle_fragment: Fie,
    map_particle_pars_fragment: kie,
    metalnessmap_fragment: Oie,
    metalnessmap_pars_fragment: Uie,
    morphinstance_vertex: Hie,
    morphcolor_vertex: Wie,
    morphnormal_vertex: Vie,
    morphtarget_pars_vertex: Zie,
    morphtarget_vertex: zie,
    normal_fragment_begin: Yie,
    normal_fragment_maps: Xie,
    normal_pars_fragment: Kie,
    normal_pars_vertex: jie,
    normal_vertex: $ie,
    normalmap_pars_fragment: Jie,
    clearcoat_normal_fragment_begin: Qie,
    clearcoat_normal_fragment_maps: qie,
    clearcoat_pars_fragment: ere,
    iridescence_pars_fragment: tre,
    opaque_fragment: nre,
    packing: ire,
    premultiplied_alpha_fragment: rre,
    project_vertex: sre,
    dithering_fragment: ore,
    dithering_pars_fragment: are,
    roughnessmap_fragment: lre,
    roughnessmap_pars_fragment: cre,
    shadowmap_pars_fragment: ure,
    shadowmap_pars_vertex: hre,
    shadowmap_vertex: dre,
    shadowmask_pars_fragment: fre,
    skinbase_vertex: gre,
    skinning_pars_vertex: pre,
    skinning_vertex: mre,
    skinnormal_vertex: Cre,
    specularmap_fragment: Ire,
    specularmap_pars_fragment: Are,
    tonemapping_fragment: yre,
    tonemapping_pars_fragment: _re,
    transmission_fragment: bre,
    transmission_pars_fragment: vre,
    uv_pars_fragment: xre,
    uv_pars_vertex: wre,
    uv_vertex: Sre,
    worldpos_vertex: Tre,
    background_vert: Ere,
    background_frag: Mre,
    backgroundCube_vert: Lre,
    backgroundCube_frag: Rre,
    cube_vert: Bre,
    cube_frag: Pre,
    depth_vert: Nre,
    depth_frag: Dre,
    distanceRGBA_vert: Gre,
    distanceRGBA_frag: Fre,
    equirect_vert: kre,
    equirect_frag: Ore,
    linedashed_vert: Ure,
    linedashed_frag: Hre,
    meshbasic_vert: Wre,
    meshbasic_frag: Vre,
    meshlambert_vert: Zre,
    meshlambert_frag: zre,
    meshmatcap_vert: Yre,
    meshmatcap_frag: Xre,
    meshnormal_vert: Kre,
    meshnormal_frag: jre,
    meshphong_vert: $re,
    meshphong_frag: Jre,
    meshphysical_vert: Qre,
    meshphysical_frag: qre,
    meshtoon_vert: ese,
    meshtoon_frag: tse,
    points_vert: nse,
    points_frag: ise,
    shadow_vert: rse,
    shadow_frag: sse,
    sprite_vert: ose,
    sprite_frag: ase,
  },
  Be = {
    common: {
      diffuse: { value: new vt(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new Pt() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Pt() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new Pt() },
    },
    envmap: {
      envMap: { value: null },
      envMapRotation: { value: new Pt() },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new Pt() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new Pt() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new Pt() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new Pt() },
      normalScale: { value: new Gt(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new Pt() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new Pt() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new Pt() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new Pt() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new vt(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new vt(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Pt() },
      alphaTest: { value: 0 },
      uvTransform: { value: new Pt() },
    },
    sprite: {
      diffuse: { value: new vt(16777215) },
      opacity: { value: 1 },
      center: { value: new Gt(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new Pt() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Pt() },
      alphaTest: { value: 0 },
    },
  },
  mo = {
    basic: {
      uniforms: cr([
        Be.common,
        Be.specularmap,
        Be.envmap,
        Be.aomap,
        Be.lightmap,
        Be.fog,
      ]),
      vertexShader: Nt.meshbasic_vert,
      fragmentShader: Nt.meshbasic_frag,
    },
    lambert: {
      uniforms: cr([
        Be.common,
        Be.specularmap,
        Be.envmap,
        Be.aomap,
        Be.lightmap,
        Be.emissivemap,
        Be.bumpmap,
        Be.normalmap,
        Be.displacementmap,
        Be.fog,
        Be.lights,
        { emissive: { value: new vt(0) } },
      ]),
      vertexShader: Nt.meshlambert_vert,
      fragmentShader: Nt.meshlambert_frag,
    },
    phong: {
      uniforms: cr([
        Be.common,
        Be.specularmap,
        Be.envmap,
        Be.aomap,
        Be.lightmap,
        Be.emissivemap,
        Be.bumpmap,
        Be.normalmap,
        Be.displacementmap,
        Be.fog,
        Be.lights,
        {
          emissive: { value: new vt(0) },
          specular: { value: new vt(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: Nt.meshphong_vert,
      fragmentShader: Nt.meshphong_frag,
    },
    standard: {
      uniforms: cr([
        Be.common,
        Be.envmap,
        Be.aomap,
        Be.lightmap,
        Be.emissivemap,
        Be.bumpmap,
        Be.normalmap,
        Be.displacementmap,
        Be.roughnessmap,
        Be.metalnessmap,
        Be.fog,
        Be.lights,
        {
          emissive: { value: new vt(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: Nt.meshphysical_vert,
      fragmentShader: Nt.meshphysical_frag,
    },
    toon: {
      uniforms: cr([
        Be.common,
        Be.aomap,
        Be.lightmap,
        Be.emissivemap,
        Be.bumpmap,
        Be.normalmap,
        Be.displacementmap,
        Be.gradientmap,
        Be.fog,
        Be.lights,
        { emissive: { value: new vt(0) } },
      ]),
      vertexShader: Nt.meshtoon_vert,
      fragmentShader: Nt.meshtoon_frag,
    },
    matcap: {
      uniforms: cr([
        Be.common,
        Be.bumpmap,
        Be.normalmap,
        Be.displacementmap,
        Be.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: Nt.meshmatcap_vert,
      fragmentShader: Nt.meshmatcap_frag,
    },
    points: {
      uniforms: cr([Be.points, Be.fog]),
      vertexShader: Nt.points_vert,
      fragmentShader: Nt.points_frag,
    },
    dashed: {
      uniforms: cr([
        Be.common,
        Be.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: Nt.linedashed_vert,
      fragmentShader: Nt.linedashed_frag,
    },
    depth: {
      uniforms: cr([Be.common, Be.displacementmap]),
      vertexShader: Nt.depth_vert,
      fragmentShader: Nt.depth_frag,
    },
    normal: {
      uniforms: cr([
        Be.common,
        Be.bumpmap,
        Be.normalmap,
        Be.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: Nt.meshnormal_vert,
      fragmentShader: Nt.meshnormal_frag,
    },
    sprite: {
      uniforms: cr([Be.sprite, Be.fog]),
      vertexShader: Nt.sprite_vert,
      fragmentShader: Nt.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new Pt() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Nt.background_vert,
      fragmentShader: Nt.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
        backgroundRotation: { value: new Pt() },
      },
      vertexShader: Nt.backgroundCube_vert,
      fragmentShader: Nt.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: Nt.cube_vert,
      fragmentShader: Nt.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Nt.equirect_vert,
      fragmentShader: Nt.equirect_frag,
    },
    distanceRGBA: {
      uniforms: cr([
        Be.common,
        Be.displacementmap,
        {
          referencePosition: { value: new X() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: Nt.distanceRGBA_vert,
      fragmentShader: Nt.distanceRGBA_frag,
    },
    shadow: {
      uniforms: cr([
        Be.lights,
        Be.fog,
        { color: { value: new vt(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: Nt.shadow_vert,
      fragmentShader: Nt.shadow_frag,
    },
  };
mo.physical = {
  uniforms: cr([
    mo.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new Pt() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new Pt() },
      clearcoatNormalScale: { value: new Gt(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new Pt() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new Pt() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new Pt() },
      sheen: { value: 0 },
      sheenColor: { value: new vt(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new Pt() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new Pt() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new Pt() },
      transmissionSamplerSize: { value: new Gt() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new Pt() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new vt(0) },
      specularColor: { value: new vt(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new Pt() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new Pt() },
      anisotropyVector: { value: new Gt() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new Pt() },
    },
  ]),
  vertexShader: Nt.meshphysical_vert,
  fragmentShader: Nt.meshphysical_frag,
};
const x1 = { r: 0, b: 0, g: 0 },
  ac = new Oo(),
  lse = new Et();
function cse(n, e, t, i, r, s, o) {
  const a = new vt(0);
  let l = s === !0 ? 0 : 1,
    c,
    u,
    h = null,
    d = 0,
    f = null;
  function g(I) {
    let y = I.isScene === !0 ? I.background : null;
    return (
      y && y.isTexture && (y = (I.backgroundBlurriness > 0 ? t : e).get(y)),
      y
    );
  }
  function p(I) {
    let y = !1;
    const x = g(I);
    x === null ? C(a, l) : x && x.isColor && (C(x, 1), (y = !0));
    const T = n.xr.getEnvironmentBlendMode();
    (T === "additive"
      ? i.buffers.color.setClear(0, 0, 0, 1, o)
      : T === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, o),
      (n.autoClear || y) &&
        (i.buffers.depth.setTest(!0),
        i.buffers.depth.setMask(!0),
        i.buffers.color.setMask(!0),
        n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil)));
  }
  function m(I, y) {
    const x = g(y);
    x && (x.isCubeTexture || x.mapping === rI)
      ? (u === void 0 &&
          ((u = new si(
            new Tp(1, 1, 1),
            new Qi({
              name: "BackgroundCubeMaterial",
              uniforms: cd(mo.backgroundCube.uniforms),
              vertexShader: mo.backgroundCube.vertexShader,
              fragmentShader: mo.backgroundCube.fragmentShader,
              side: er,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
              allowOverride: !1,
            }),
          )),
          u.geometry.deleteAttribute("normal"),
          u.geometry.deleteAttribute("uv"),
          (u.onBeforeRender = function (T, S, E) {
            this.matrixWorld.copyPosition(E.matrixWorld);
          }),
          Object.defineProperty(u.material, "envMap", {
            get: function () {
              return this.uniforms.envMap.value;
            },
          }),
          r.update(u)),
        ac.copy(y.backgroundRotation),
        (ac.x *= -1),
        (ac.y *= -1),
        (ac.z *= -1),
        x.isCubeTexture &&
          x.isRenderTargetTexture === !1 &&
          ((ac.y *= -1), (ac.z *= -1)),
        (u.material.uniforms.envMap.value = x),
        (u.material.uniforms.flipEnvMap.value =
          x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1),
        (u.material.uniforms.backgroundBlurriness.value =
          y.backgroundBlurriness),
        (u.material.uniforms.backgroundIntensity.value = y.backgroundIntensity),
        u.material.uniforms.backgroundRotation.value.setFromMatrix4(
          lse.makeRotationFromEuler(ac),
        ),
        (u.material.toneMapped = Kt.getTransfer(x.colorSpace) !== mn),
        (h !== x || d !== x.version || f !== n.toneMapping) &&
          ((u.material.needsUpdate = !0),
          (h = x),
          (d = x.version),
          (f = n.toneMapping)),
        u.layers.enableAll(),
        I.unshift(u, u.geometry, u.material, 0, 0, null))
      : x &&
        x.isTexture &&
        (c === void 0 &&
          ((c = new si(
            new Vd(2, 2),
            new Qi({
              name: "BackgroundMaterial",
              uniforms: cd(mo.background.uniforms),
              vertexShader: mo.background.vertexShader,
              fragmentShader: mo.background.fragmentShader,
              side: Go,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
              allowOverride: !1,
            }),
          )),
          c.geometry.deleteAttribute("normal"),
          Object.defineProperty(c.material, "map", {
            get: function () {
              return this.uniforms.t2D.value;
            },
          }),
          r.update(c)),
        (c.material.uniforms.t2D.value = x),
        (c.material.uniforms.backgroundIntensity.value = y.backgroundIntensity),
        (c.material.toneMapped = Kt.getTransfer(x.colorSpace) !== mn),
        x.matrixAutoUpdate === !0 && x.updateMatrix(),
        c.material.uniforms.uvTransform.value.copy(x.matrix),
        (h !== x || d !== x.version || f !== n.toneMapping) &&
          ((c.material.needsUpdate = !0),
          (h = x),
          (d = x.version),
          (f = n.toneMapping)),
        c.layers.enableAll(),
        I.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function C(I, y) {
    (I.getRGB(x1, oR(n)), i.buffers.color.setClear(x1.r, x1.g, x1.b, y, o));
  }
  function A() {
    (u !== void 0 && (u.geometry.dispose(), u.material.dispose(), (u = void 0)),
      c !== void 0 &&
        (c.geometry.dispose(), c.material.dispose(), (c = void 0)));
  }
  return {
    getClearColor: function () {
      return a;
    },
    setClearColor: function (I, y = 1) {
      (a.set(I), (l = y), C(a, l));
    },
    getClearAlpha: function () {
      return l;
    },
    setClearAlpha: function (I) {
      ((l = I), C(a, l));
    },
    render: p,
    addToRenderList: m,
    dispose: A,
  };
}
function use(n, e) {
  const t = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    i = {},
    r = d(null);
  let s = r,
    o = !1;
  function a(b, R, M, L, P) {
    let U = !1;
    const O = h(L, M, R);
    (s !== O && ((s = O), c(s.object)),
      (U = f(b, L, M, P)),
      U && g(b, L, M, P),
      P !== null && e.update(P, n.ELEMENT_ARRAY_BUFFER),
      (U || o) &&
        ((o = !1),
        y(b, R, M, L),
        P !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.get(P).buffer)));
  }
  function l() {
    return n.createVertexArray();
  }
  function c(b) {
    return n.bindVertexArray(b);
  }
  function u(b) {
    return n.deleteVertexArray(b);
  }
  function h(b, R, M) {
    const L = M.wireframe === !0;
    let P = i[b.id];
    P === void 0 && ((P = {}), (i[b.id] = P));
    let U = P[R.id];
    U === void 0 && ((U = {}), (P[R.id] = U));
    let O = U[L];
    return (O === void 0 && ((O = d(l())), (U[L] = O)), O);
  }
  function d(b) {
    const R = [],
      M = [],
      L = [];
    for (let P = 0; P < t; P++) ((R[P] = 0), (M[P] = 0), (L[P] = 0));
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: R,
      enabledAttributes: M,
      attributeDivisors: L,
      object: b,
      attributes: {},
      index: null,
    };
  }
  function f(b, R, M, L) {
    const P = s.attributes,
      U = R.attributes;
    let O = 0;
    const V = M.getAttributes();
    for (const W in V)
      if (V[W].location >= 0) {
        const Z = P[W];
        let te = U[W];
        if (
          (te === void 0 &&
            (W === "instanceMatrix" &&
              b.instanceMatrix &&
              (te = b.instanceMatrix),
            W === "instanceColor" && b.instanceColor && (te = b.instanceColor)),
          Z === void 0 || Z.attribute !== te || (te && Z.data !== te.data))
        )
          return !0;
        O++;
      }
    return s.attributesNum !== O || s.index !== L;
  }
  function g(b, R, M, L) {
    const P = {},
      U = R.attributes;
    let O = 0;
    const V = M.getAttributes();
    for (const W in V)
      if (V[W].location >= 0) {
        let Z = U[W];
        Z === void 0 &&
          (W === "instanceMatrix" && b.instanceMatrix && (Z = b.instanceMatrix),
          W === "instanceColor" && b.instanceColor && (Z = b.instanceColor));
        const te = {};
        ((te.attribute = Z),
          Z && Z.data && (te.data = Z.data),
          (P[W] = te),
          O++);
      }
    ((s.attributes = P), (s.attributesNum = O), (s.index = L));
  }
  function p() {
    const b = s.newAttributes;
    for (let R = 0, M = b.length; R < M; R++) b[R] = 0;
  }
  function m(b) {
    C(b, 0);
  }
  function C(b, R) {
    const M = s.newAttributes,
      L = s.enabledAttributes,
      P = s.attributeDivisors;
    ((M[b] = 1),
      L[b] === 0 && (n.enableVertexAttribArray(b), (L[b] = 1)),
      P[b] !== R && (n.vertexAttribDivisor(b, R), (P[b] = R)));
  }
  function A() {
    const b = s.newAttributes,
      R = s.enabledAttributes;
    for (let M = 0, L = R.length; M < L; M++)
      R[M] !== b[M] && (n.disableVertexAttribArray(M), (R[M] = 0));
  }
  function I(b, R, M, L, P, U, O) {
    O === !0
      ? n.vertexAttribIPointer(b, R, M, P, U)
      : n.vertexAttribPointer(b, R, M, L, P, U);
  }
  function y(b, R, M, L) {
    p();
    const P = L.attributes,
      U = M.getAttributes(),
      O = R.defaultAttributeValues;
    for (const V in U) {
      const W = U[V];
      if (W.location >= 0) {
        let re = P[V];
        if (
          (re === void 0 &&
            (V === "instanceMatrix" &&
              b.instanceMatrix &&
              (re = b.instanceMatrix),
            V === "instanceColor" && b.instanceColor && (re = b.instanceColor)),
          re !== void 0)
        ) {
          const Z = re.normalized,
            te = re.itemSize,
            ge = e.get(re);
          if (ge === void 0) continue;
          const be = ge.buffer,
            J = ge.type,
            se = ge.bytesPerElement,
            ce = J === n.INT || J === n.UNSIGNED_INT || re.gpuType === Lv;
          if (re.isInterleavedBufferAttribute) {
            const ae = re.data,
              Ce = ae.stride,
              $e = re.offset;
            if (ae.isInstancedInterleavedBuffer) {
              for (let Te = 0; Te < W.locationSize; Te++)
                C(W.location + Te, ae.meshPerAttribute);
              b.isInstancedMesh !== !0 &&
                L._maxInstanceCount === void 0 &&
                (L._maxInstanceCount = ae.meshPerAttribute * ae.count);
            } else
              for (let Te = 0; Te < W.locationSize; Te++) m(W.location + Te);
            n.bindBuffer(n.ARRAY_BUFFER, be);
            for (let Te = 0; Te < W.locationSize; Te++)
              I(
                W.location + Te,
                te / W.locationSize,
                J,
                Z,
                Ce * se,
                ($e + (te / W.locationSize) * Te) * se,
                ce,
              );
          } else {
            if (re.isInstancedBufferAttribute) {
              for (let ae = 0; ae < W.locationSize; ae++)
                C(W.location + ae, re.meshPerAttribute);
              b.isInstancedMesh !== !0 &&
                L._maxInstanceCount === void 0 &&
                (L._maxInstanceCount = re.meshPerAttribute * re.count);
            } else
              for (let ae = 0; ae < W.locationSize; ae++) m(W.location + ae);
            n.bindBuffer(n.ARRAY_BUFFER, be);
            for (let ae = 0; ae < W.locationSize; ae++)
              I(
                W.location + ae,
                te / W.locationSize,
                J,
                Z,
                te * se,
                (te / W.locationSize) * ae * se,
                ce,
              );
          }
        } else if (O !== void 0) {
          const Z = O[V];
          if (Z !== void 0)
            switch (Z.length) {
              case 2:
                n.vertexAttrib2fv(W.location, Z);
                break;
              case 3:
                n.vertexAttrib3fv(W.location, Z);
                break;
              case 4:
                n.vertexAttrib4fv(W.location, Z);
                break;
              default:
                n.vertexAttrib1fv(W.location, Z);
            }
        }
      }
    }
    A();
  }
  function x() {
    E();
    for (const b in i) {
      const R = i[b];
      for (const M in R) {
        const L = R[M];
        for (const P in L) (u(L[P].object), delete L[P]);
        delete R[M];
      }
      delete i[b];
    }
  }
  function T(b) {
    if (i[b.id] === void 0) return;
    const R = i[b.id];
    for (const M in R) {
      const L = R[M];
      for (const P in L) (u(L[P].object), delete L[P]);
      delete R[M];
    }
    delete i[b.id];
  }
  function S(b) {
    for (const R in i) {
      const M = i[R];
      if (M[b.id] === void 0) continue;
      const L = M[b.id];
      for (const P in L) (u(L[P].object), delete L[P]);
      delete M[b.id];
    }
  }
  function E() {
    (_(), (o = !0), s !== r && ((s = r), c(s.object)));
  }
  function _() {
    ((r.geometry = null), (r.program = null), (r.wireframe = !1));
  }
  return {
    setup: a,
    reset: E,
    resetDefaultState: _,
    dispose: x,
    releaseStatesOfGeometry: T,
    releaseStatesOfProgram: S,
    initAttributes: p,
    enableAttribute: m,
    disableUnusedAttributes: A,
  };
}
function hse(n, e, t) {
  let i;
  function r(c) {
    i = c;
  }
  function s(c, u) {
    (n.drawArrays(i, c, u), t.update(u, i, 1));
  }
  function o(c, u, h) {
    h !== 0 && (n.drawArraysInstanced(i, c, u, h), t.update(u, i, h));
  }
  function a(c, u, h) {
    if (h === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, c, 0, u, 0, h);
    let f = 0;
    for (let g = 0; g < h; g++) f += u[g];
    t.update(f, i, 1);
  }
  function l(c, u, h, d) {
    if (h === 0) return;
    const f = e.get("WEBGL_multi_draw");
    if (f === null) for (let g = 0; g < c.length; g++) o(c[g], u[g], d[g]);
    else {
      f.multiDrawArraysInstancedWEBGL(i, c, 0, u, 0, d, 0, h);
      let g = 0;
      for (let p = 0; p < h; p++) g += u[p] * d[p];
      t.update(g, i, 1);
    }
  }
  ((this.setMode = r),
    (this.render = s),
    (this.renderInstances = o),
    (this.renderMultiDraw = a),
    (this.renderMultiDrawInstances = l));
}
function dse(n, e, t, i) {
  let r;
  function s() {
    if (r !== void 0) return r;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const S = e.get("EXT_texture_filter_anisotropic");
      r = n.getParameter(S.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else r = 0;
    return r;
  }
  function o(S) {
    return !(
      S !== Sr &&
      i.convert(S) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT)
    );
  }
  function a(S) {
    const E =
      S === wp &&
      (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(
      S !== Fo &&
      i.convert(S) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE) &&
      S !== Xr &&
      !E
    );
  }
  function l(S) {
    if (S === "highp") {
      if (
        n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision >
          0 &&
        n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      S = "mediump";
    }
    return S === "mediump" &&
      n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision >
        0 &&
      n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  let c = t.precision !== void 0 ? t.precision : "highp";
  const u = l(c);
  u !== c &&
    (console.warn(
      "THREE.WebGLRenderer:",
      c,
      "not supported, using",
      u,
      "instead.",
    ),
    (c = u));
  const h = t.logarithmicDepthBuffer === !0,
    d = t.reverseDepthBuffer === !0 && e.has("EXT_clip_control"),
    f = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
    g = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    p = n.getParameter(n.MAX_TEXTURE_SIZE),
    m = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
    C = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    A = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
    I = n.getParameter(n.MAX_VARYING_VECTORS),
    y = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
    x = g > 0,
    T = n.getParameter(n.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    getMaxAnisotropy: s,
    getMaxPrecision: l,
    textureFormatReadable: o,
    textureTypeReadable: a,
    precision: c,
    logarithmicDepthBuffer: h,
    reverseDepthBuffer: d,
    maxTextures: f,
    maxVertexTextures: g,
    maxTextureSize: p,
    maxCubemapSize: m,
    maxAttributes: C,
    maxVertexUniforms: A,
    maxVaryings: I,
    maxFragmentUniforms: y,
    vertexTextures: x,
    maxSamples: T,
  };
}
function fse(n) {
  const e = this;
  let t = null,
    i = 0,
    r = !1,
    s = !1;
  const o = new Sc(),
    a = new Pt(),
    l = { value: null, needsUpdate: !1 };
  ((this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (h, d) {
      const f = h.length !== 0 || d || i !== 0 || r;
      return ((r = d), (i = h.length), f);
    }),
    (this.beginShadows = function () {
      ((s = !0), u(null));
    }),
    (this.endShadows = function () {
      s = !1;
    }),
    (this.setGlobalState = function (h, d) {
      t = u(h, d, 0);
    }),
    (this.setState = function (h, d, f) {
      const g = h.clippingPlanes,
        p = h.clipIntersection,
        m = h.clipShadows,
        C = n.get(h);
      if (!r || g === null || g.length === 0 || (s && !m)) s ? u(null) : c();
      else {
        const A = s ? 0 : i,
          I = A * 4;
        let y = C.clippingState || null;
        ((l.value = y), (y = u(g, d, I, f)));
        for (let x = 0; x !== I; ++x) y[x] = t[x];
        ((C.clippingState = y),
          (this.numIntersection = p ? this.numPlanes : 0),
          (this.numPlanes += A));
      }
    }));
  function c() {
    (l.value !== t && ((l.value = t), (l.needsUpdate = i > 0)),
      (e.numPlanes = i),
      (e.numIntersection = 0));
  }
  function u(h, d, f, g) {
    const p = h !== null ? h.length : 0;
    let m = null;
    if (p !== 0) {
      if (((m = l.value), g !== !0 || m === null)) {
        const C = f + p * 4,
          A = d.matrixWorldInverse;
        (a.getNormalMatrix(A),
          (m === null || m.length < C) && (m = new Float32Array(C)));
        for (let I = 0, y = f; I !== p; ++I, y += 4)
          (o.copy(h[I]).applyMatrix4(A, a),
            o.normal.toArray(m, y),
            (m[y + 3] = o.constant));
      }
      ((l.value = m), (l.needsUpdate = !0));
    }
    return ((e.numPlanes = p), (e.numIntersection = 0), m);
  }
}
function gse(n) {
  let e = new WeakMap();
  function t(o, a) {
    return (a === A_ ? (o.mapping = sd) : a === y_ && (o.mapping = od), o);
  }
  function i(o) {
    if (o && o.isTexture) {
      const a = o.mapping;
      if (a === A_ || a === y_)
        if (e.has(o)) {
          const l = e.get(o).texture;
          return t(l, o.mapping);
        } else {
          const l = o.image;
          if (l && l.height > 0) {
            const c = new Gte(l.height);
            return (
              c.fromEquirectangularTexture(n, o),
              e.set(o, c),
              o.addEventListener("dispose", r),
              t(c.texture, o.mapping)
            );
          } else return null;
        }
    }
    return o;
  }
  function r(o) {
    const a = o.target;
    a.removeEventListener("dispose", r);
    const l = e.get(a);
    l !== void 0 && (e.delete(a), l.dispose());
  }
  function s() {
    e = new WeakMap();
  }
  return { get: i, dispose: s };
}
const yh = 4,
  Mw = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  kc = 20,
  z2 = new aI(),
  Lw = new vt();
let Y2 = null,
  X2 = 0,
  K2 = 0,
  j2 = !1;
const Tc = (1 + Math.sqrt(5)) / 2,
  $u = 1 / Tc,
  Rw = [
    new X(-Tc, $u, 0),
    new X(Tc, $u, 0),
    new X(-$u, 0, Tc),
    new X($u, 0, Tc),
    new X(0, Tc, -$u),
    new X(0, Tc, $u),
    new X(-1, 1, -1),
    new X(1, 1, -1),
    new X(-1, 1, 1),
    new X(1, 1, 1),
  ],
  pse = new X();
class Bw {
  constructor(e) {
    ((this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial));
  }
  fromScene(e, t = 0, i = 0.1, r = 100, s = {}) {
    const { size: o = 256, position: a = pse } = s;
    ((Y2 = this._renderer.getRenderTarget()),
      (X2 = this._renderer.getActiveCubeFace()),
      (K2 = this._renderer.getActiveMipmapLevel()),
      (j2 = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1),
      this._setSize(o));
    const l = this._allocateTargets();
    return (
      (l.depthBuffer = !0),
      this._sceneToCubeUV(e, i, r, l, a),
      t > 0 && this._blur(l, 0, 0, t),
      this._applyPMREM(l),
      this._cleanup(l),
      l
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = Dw()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = Nw()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    (this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose());
  }
  _setSize(e) {
    ((this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax)));
  }
  _dispose() {
    (this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose());
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    (this._renderer.setRenderTarget(Y2, X2, K2),
      (this._renderer.xr.enabled = j2),
      (e.scissorTest = !1),
      w1(e, 0, 0, e.width, e.height));
  }
  _fromTexture(e, t) {
    (e.mapping === sd || e.mapping === od
      ? this._setSize(
          e.image.length === 0
            ? 16
            : e.image[0].width || e.image[0].image.width,
        )
      : this._setSize(e.image.width / 4),
      (Y2 = this._renderer.getRenderTarget()),
      (X2 = this._renderer.getActiveCubeFace()),
      (K2 = this._renderer.getActiveMipmapLevel()),
      (j2 = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1));
    const i = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, i),
      this._applyPMREM(i),
      this._cleanup(i),
      i
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      i = {
        magFilter: Yr,
        minFilter: Yr,
        generateMipmaps: !1,
        type: wp,
        format: Sr,
        colorSpace: Ir,
        depthBuffer: !1,
      },
      r = Pw(e, t, i);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      (this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = Pw(e, t, i)));
      const { _lodMax: s } = this;
      (({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = mse(s)),
        (this._blurMaterial = Cse(s, e, t)));
    }
    return r;
  }
  _compileMaterial(e) {
    const t = new si(this._lodPlanes[0], e);
    this._renderer.compile(t, z2);
  }
  _sceneToCubeUV(e, t, i, r, s) {
    const l = new Ri(90, 1, t, i),
      c = [1, -1, 1, 1, 1, 1],
      u = [1, 1, 1, -1, -1, -1],
      h = this._renderer,
      d = h.autoClear,
      f = h.toneMapping;
    (h.getClearColor(Lw), (h.toneMapping = Sl), (h.autoClear = !1));
    const g = new ma({
        name: "PMREM.Background",
        side: er,
        depthWrite: !1,
        depthTest: !1,
      }),
      p = new si(new Tp(), g);
    let m = !1;
    const C = e.background;
    C
      ? C.isColor && (g.color.copy(C), (e.background = null), (m = !0))
      : (g.color.copy(Lw), (m = !0));
    for (let A = 0; A < 6; A++) {
      const I = A % 3;
      I === 0
        ? (l.up.set(0, c[A], 0),
          l.position.set(s.x, s.y, s.z),
          l.lookAt(s.x + u[A], s.y, s.z))
        : I === 1
          ? (l.up.set(0, 0, c[A]),
            l.position.set(s.x, s.y, s.z),
            l.lookAt(s.x, s.y + u[A], s.z))
          : (l.up.set(0, c[A], 0),
            l.position.set(s.x, s.y, s.z),
            l.lookAt(s.x, s.y, s.z + u[A]));
      const y = this._cubeSize;
      (w1(r, I * y, A > 2 ? y : 0, y, y),
        h.setRenderTarget(r),
        m && h.render(p, l),
        h.render(e, l));
    }
    (p.geometry.dispose(),
      p.material.dispose(),
      (h.toneMapping = f),
      (h.autoClear = d),
      (e.background = C));
  }
  _textureToCubeUV(e, t) {
    const i = this._renderer,
      r = e.mapping === sd || e.mapping === od;
    r
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = Dw()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = Nw());
    const s = r ? this._cubemapMaterial : this._equirectMaterial,
      o = new si(this._lodPlanes[0], s),
      a = s.uniforms;
    a.envMap.value = e;
    const l = this._cubeSize;
    (w1(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(o, z2));
  }
  _applyPMREM(e) {
    const t = this._renderer,
      i = t.autoClear;
    t.autoClear = !1;
    const r = this._lodPlanes.length;
    for (let s = 1; s < r; s++) {
      const o = Math.sqrt(
          this._sigmas[s] * this._sigmas[s] -
            this._sigmas[s - 1] * this._sigmas[s - 1],
        ),
        a = Rw[(r - s - 1) % Rw.length];
      this._blur(e, s - 1, s, o, a);
    }
    t.autoClear = i;
  }
  _blur(e, t, i, r, s) {
    const o = this._pingPongRenderTarget;
    (this._halfBlur(e, o, t, i, r, "latitudinal", s),
      this._halfBlur(o, e, i, i, r, "longitudinal", s));
  }
  _halfBlur(e, t, i, r, s, o, a) {
    const l = this._renderer,
      c = this._blurMaterial;
    o !== "latitudinal" &&
      o !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!",
      );
    const u = 3,
      h = new si(this._lodPlanes[r], c),
      d = c.uniforms,
      f = this._sizeLods[i] - 1,
      g = isFinite(s) ? Math.PI / (2 * f) : (2 * Math.PI) / (2 * kc - 1),
      p = s / g,
      m = isFinite(s) ? 1 + Math.floor(u * p) : kc;
    m > kc &&
      console.warn(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${kc}`,
      );
    const C = [];
    let A = 0;
    for (let S = 0; S < kc; ++S) {
      const E = S / p,
        _ = Math.exp((-E * E) / 2);
      (C.push(_), S === 0 ? (A += _) : S < m && (A += 2 * _));
    }
    for (let S = 0; S < C.length; S++) C[S] = C[S] / A;
    ((d.envMap.value = e.texture),
      (d.samples.value = m),
      (d.weights.value = C),
      (d.latitudinal.value = o === "latitudinal"),
      a && (d.poleAxis.value = a));
    const { _lodMax: I } = this;
    ((d.dTheta.value = g), (d.mipInt.value = I - i));
    const y = this._sizeLods[r],
      x = 3 * y * (r > I - yh ? r - I + yh : 0),
      T = 4 * (this._cubeSize - y);
    (w1(t, x, T, 3 * y, 2 * y), l.setRenderTarget(t), l.render(h, z2));
  }
}
function mse(n) {
  const e = [],
    t = [],
    i = [];
  let r = n;
  const s = n - yh + 1 + Mw.length;
  for (let o = 0; o < s; o++) {
    const a = Math.pow(2, r);
    t.push(a);
    let l = 1 / a;
    (o > n - yh ? (l = Mw[o - n + yh - 1]) : o === 0 && (l = 0), i.push(l));
    const c = 1 / (a - 2),
      u = -c,
      h = 1 + c,
      d = [u, u, h, u, h, h, u, u, h, h, u, h],
      f = 6,
      g = 6,
      p = 3,
      m = 2,
      C = 1,
      A = new Float32Array(p * g * f),
      I = new Float32Array(m * g * f),
      y = new Float32Array(C * g * f);
    for (let T = 0; T < f; T++) {
      const S = ((T % 3) * 2) / 3 - 1,
        E = T > 2 ? 0 : -1,
        _ = [
          S,
          E,
          0,
          S + 2 / 3,
          E,
          0,
          S + 2 / 3,
          E + 1,
          0,
          S,
          E,
          0,
          S + 2 / 3,
          E + 1,
          0,
          S,
          E + 1,
          0,
        ];
      (A.set(_, p * g * T), I.set(d, m * g * T));
      const b = [T, T, T, T, T, T];
      y.set(b, C * g * T);
    }
    const x = new Pr();
    (x.setAttribute("position", new Pi(A, p)),
      x.setAttribute("uv", new Pi(I, m)),
      x.setAttribute("faceIndex", new Pi(y, C)),
      e.push(x),
      r > yh && r--);
  }
  return { lodPlanes: e, sizeLods: t, sigmas: i };
}
function Pw(n, e, t) {
  const i = new ko(n, e, t);
  return (
    (i.texture.mapping = rI),
    (i.texture.name = "PMREM.cubeUv"),
    (i.scissorTest = !0),
    i
  );
}
function w1(n, e, t, i, r) {
  (n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r));
}
function Cse(n, e, t) {
  const i = new Float32Array(kc),
    r = new X(0, 1, 0);
  return new Qi({
    name: "SphericalGaussianBlur",
    defines: {
      n: kc,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${n}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: i },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r },
    },
    vertexShader: $v(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: wl,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Nw() {
  return new Qi({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: $v(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: wl,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Dw() {
  return new Qi({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: $v(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: wl,
    depthTest: !1,
    depthWrite: !1,
  });
}
function $v() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function Ise(n) {
  let e = new WeakMap(),
    t = null;
  function i(a) {
    if (a && a.isTexture) {
      const l = a.mapping,
        c = l === A_ || l === y_,
        u = l === sd || l === od;
      if (c || u) {
        let h = e.get(a);
        const d = h !== void 0 ? h.texture.pmremVersion : 0;
        if (a.isRenderTargetTexture && a.pmremVersion !== d)
          return (
            t === null && (t = new Bw(n)),
            (h = c ? t.fromEquirectangular(a, h) : t.fromCubemap(a, h)),
            (h.texture.pmremVersion = a.pmremVersion),
            e.set(a, h),
            h.texture
          );
        if (h !== void 0) return h.texture;
        {
          const f = a.image;
          return (c && f && f.height > 0) || (u && f && r(f))
            ? (t === null && (t = new Bw(n)),
              (h = c ? t.fromEquirectangular(a) : t.fromCubemap(a)),
              (h.texture.pmremVersion = a.pmremVersion),
              e.set(a, h),
              a.addEventListener("dispose", s),
              h.texture)
            : null;
        }
      }
    }
    return a;
  }
  function r(a) {
    let l = 0;
    const c = 6;
    for (let u = 0; u < c; u++) a[u] !== void 0 && l++;
    return l === c;
  }
  function s(a) {
    const l = a.target;
    l.removeEventListener("dispose", s);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function o() {
    ((e = new WeakMap()), t !== null && (t.dispose(), (t = null)));
  }
  return { get: i, dispose: o };
}
function Ase(n) {
  const e = {};
  function t(i) {
    if (e[i] !== void 0) return e[i];
    let r;
    switch (i) {
      case "WEBGL_depth_texture":
        r =
          n.getExtension("WEBGL_depth_texture") ||
          n.getExtension("MOZ_WEBGL_depth_texture") ||
          n.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r =
          n.getExtension("EXT_texture_filter_anisotropic") ||
          n.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r =
          n.getExtension("WEBGL_compressed_texture_s3tc") ||
          n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r =
          n.getExtension("WEBGL_compressed_texture_pvrtc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = n.getExtension(i);
    }
    return ((e[i] = r), r);
  }
  return {
    has: function (i) {
      return t(i) !== null;
    },
    init: function () {
      (t("EXT_color_buffer_float"),
        t("WEBGL_clip_cull_distance"),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture"),
        t("WEBGL_render_shared_exponent"));
    },
    get: function (i) {
      const r = t(i);
      return (
        r === null &&
          V0("THREE.WebGLRenderer: " + i + " extension not supported."),
        r
      );
    },
  };
}
function yse(n, e, t, i) {
  const r = {},
    s = new WeakMap();
  function o(h) {
    const d = h.target;
    d.index !== null && e.remove(d.index);
    for (const g in d.attributes) e.remove(d.attributes[g]);
    (d.removeEventListener("dispose", o), delete r[d.id]);
    const f = s.get(d);
    (f && (e.remove(f), s.delete(d)),
      i.releaseStatesOfGeometry(d),
      d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount,
      t.memory.geometries--);
  }
  function a(h, d) {
    return (
      r[d.id] === !0 ||
        (d.addEventListener("dispose", o),
        (r[d.id] = !0),
        t.memory.geometries++),
      d
    );
  }
  function l(h) {
    const d = h.attributes;
    for (const f in d) e.update(d[f], n.ARRAY_BUFFER);
  }
  function c(h) {
    const d = [],
      f = h.index,
      g = h.attributes.position;
    let p = 0;
    if (f !== null) {
      const A = f.array;
      p = f.version;
      for (let I = 0, y = A.length; I < y; I += 3) {
        const x = A[I + 0],
          T = A[I + 1],
          S = A[I + 2];
        d.push(x, T, T, S, S, x);
      }
    } else if (g !== void 0) {
      const A = g.array;
      p = g.version;
      for (let I = 0, y = A.length / 3 - 1; I < y; I += 3) {
        const x = I + 0,
          T = I + 1,
          S = I + 2;
        d.push(x, T, T, S, S, x);
      }
    } else return;
    const m = new (tR(d) ? sR : rR)(d, 1);
    m.version = p;
    const C = s.get(h);
    (C && e.remove(C), s.set(h, m));
  }
  function u(h) {
    const d = s.get(h);
    if (d) {
      const f = h.index;
      f !== null && d.version < f.version && c(h);
    } else c(h);
    return s.get(h);
  }
  return { get: a, update: l, getWireframeAttribute: u };
}
function _se(n, e, t) {
  let i;
  function r(d) {
    i = d;
  }
  let s, o;
  function a(d) {
    ((s = d.type), (o = d.bytesPerElement));
  }
  function l(d, f) {
    (n.drawElements(i, f, s, d * o), t.update(f, i, 1));
  }
  function c(d, f, g) {
    g !== 0 && (n.drawElementsInstanced(i, f, s, d * o, g), t.update(f, i, g));
  }
  function u(d, f, g) {
    if (g === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, f, 0, s, d, 0, g);
    let m = 0;
    for (let C = 0; C < g; C++) m += f[C];
    t.update(m, i, 1);
  }
  function h(d, f, g, p) {
    if (g === 0) return;
    const m = e.get("WEBGL_multi_draw");
    if (m === null) for (let C = 0; C < d.length; C++) c(d[C] / o, f[C], p[C]);
    else {
      m.multiDrawElementsInstancedWEBGL(i, f, 0, s, d, 0, p, 0, g);
      let C = 0;
      for (let A = 0; A < g; A++) C += f[A] * p[A];
      t.update(C, i, 1);
    }
  }
  ((this.setMode = r),
    (this.setIndex = a),
    (this.render = l),
    (this.renderInstances = c),
    (this.renderMultiDraw = u),
    (this.renderMultiDrawInstances = h));
}
function bse(n) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function i(s, o, a) {
    switch ((t.calls++, o)) {
      case n.TRIANGLES:
        t.triangles += a * (s / 3);
        break;
      case n.LINES:
        t.lines += a * (s / 2);
        break;
      case n.LINE_STRIP:
        t.lines += a * (s - 1);
        break;
      case n.LINE_LOOP:
        t.lines += a * s;
        break;
      case n.POINTS:
        t.points += a * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function r() {
    ((t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0));
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: r,
    update: i,
  };
}
function vse(n, e, t) {
  const i = new WeakMap(),
    r = new ln();
  function s(o, a, l) {
    const c = o.morphTargetInfluences,
      u =
        a.morphAttributes.position ||
        a.morphAttributes.normal ||
        a.morphAttributes.color,
      h = u !== void 0 ? u.length : 0;
    let d = i.get(a);
    if (d === void 0 || d.count !== h) {
      let _ = function () {
        (S.dispose(), i.delete(a), a.removeEventListener("dispose", _));
      };
      d !== void 0 && d.texture.dispose();
      const f = a.morphAttributes.position !== void 0,
        g = a.morphAttributes.normal !== void 0,
        p = a.morphAttributes.color !== void 0,
        m = a.morphAttributes.position || [],
        C = a.morphAttributes.normal || [],
        A = a.morphAttributes.color || [];
      let I = 0;
      (f === !0 && (I = 1), g === !0 && (I = 2), p === !0 && (I = 3));
      let y = a.attributes.position.count * I,
        x = 1;
      y > e.maxTextureSize &&
        ((x = Math.ceil(y / e.maxTextureSize)), (y = e.maxTextureSize));
      const T = new Float32Array(y * x * 4 * h),
        S = new nR(T, y, x, h);
      ((S.type = Xr), (S.needsUpdate = !0));
      const E = I * 4;
      for (let b = 0; b < h; b++) {
        const R = m[b],
          M = C[b],
          L = A[b],
          P = y * x * 4 * b;
        for (let U = 0; U < R.count; U++) {
          const O = U * E;
          (f === !0 &&
            (r.fromBufferAttribute(R, U),
            (T[P + O + 0] = r.x),
            (T[P + O + 1] = r.y),
            (T[P + O + 2] = r.z),
            (T[P + O + 3] = 0)),
            g === !0 &&
              (r.fromBufferAttribute(M, U),
              (T[P + O + 4] = r.x),
              (T[P + O + 5] = r.y),
              (T[P + O + 6] = r.z),
              (T[P + O + 7] = 0)),
            p === !0 &&
              (r.fromBufferAttribute(L, U),
              (T[P + O + 8] = r.x),
              (T[P + O + 9] = r.y),
              (T[P + O + 10] = r.z),
              (T[P + O + 11] = L.itemSize === 4 ? r.w : 1)));
        }
      }
      ((d = { count: h, texture: S, size: new Gt(y, x) }),
        i.set(a, d),
        a.addEventListener("dispose", _));
    }
    if (o.isInstancedMesh === !0 && o.morphTexture !== null)
      l.getUniforms().setValue(n, "morphTexture", o.morphTexture, t);
    else {
      let f = 0;
      for (let p = 0; p < c.length; p++) f += c[p];
      const g = a.morphTargetsRelative ? 1 : 1 - f;
      (l.getUniforms().setValue(n, "morphTargetBaseInfluence", g),
        l.getUniforms().setValue(n, "morphTargetInfluences", c));
    }
    (l.getUniforms().setValue(n, "morphTargetsTexture", d.texture, t),
      l.getUniforms().setValue(n, "morphTargetsTextureSize", d.size));
  }
  return { update: s };
}
function xse(n, e, t, i) {
  let r = new WeakMap();
  function s(l) {
    const c = i.render.frame,
      u = l.geometry,
      h = e.get(l, u);
    if (
      (r.get(h) !== c && (e.update(h), r.set(h, c)),
      l.isInstancedMesh &&
        (l.hasEventListener("dispose", a) === !1 &&
          l.addEventListener("dispose", a),
        r.get(l) !== c &&
          (t.update(l.instanceMatrix, n.ARRAY_BUFFER),
          l.instanceColor !== null && t.update(l.instanceColor, n.ARRAY_BUFFER),
          r.set(l, c))),
      l.isSkinnedMesh)
    ) {
      const d = l.skeleton;
      r.get(d) !== c && (d.update(), r.set(d, c));
    }
    return h;
  }
  function o() {
    r = new WeakMap();
  }
  function a(l) {
    const c = l.target;
    (c.removeEventListener("dispose", a),
      t.remove(c.instanceMatrix),
      c.instanceColor !== null && t.remove(c.instanceColor));
  }
  return { update: s, dispose: o };
}
const wR = new Oi(),
  Gw = new gR(1, 1),
  SR = new nR(),
  TR = new Ate(),
  ER = new lR(),
  Fw = [],
  kw = [],
  Ow = new Float32Array(16),
  Uw = new Float32Array(9),
  Hw = new Float32Array(4);
function Xd(n, e, t) {
  const i = n[0];
  if (i <= 0 || i > 0) return n;
  const r = e * t;
  let s = Fw[r];
  if ((s === void 0 && ((s = new Float32Array(r)), (Fw[r] = s)), e !== 0)) {
    i.toArray(s, 0);
    for (let o = 1, a = 0; o !== e; ++o) ((a += t), n[o].toArray(s, a));
  }
  return s;
}
function mi(n, e) {
  if (n.length !== e.length) return !1;
  for (let t = 0, i = n.length; t < i; t++) if (n[t] !== e[t]) return !1;
  return !0;
}
function Ci(n, e) {
  for (let t = 0, i = e.length; t < i; t++) n[t] = e[t];
}
function lI(n, e) {
  let t = kw[e];
  t === void 0 && ((t = new Int32Array(e)), (kw[e] = t));
  for (let i = 0; i !== e; ++i) t[i] = n.allocateTextureUnit();
  return t;
}
function wse(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e));
}
function Sse(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (mi(t, e)) return;
    (n.uniform2fv(this.addr, e), Ci(t, e));
  }
}
function Tse(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (n.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (mi(t, e)) return;
    (n.uniform3fv(this.addr, e), Ci(t, e));
  }
}
function Ese(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (mi(t, e)) return;
    (n.uniform4fv(this.addr, e), Ci(t, e));
  }
}
function Mse(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (mi(t, e)) return;
    (n.uniformMatrix2fv(this.addr, !1, e), Ci(t, e));
  } else {
    if (mi(t, i)) return;
    (Hw.set(i), n.uniformMatrix2fv(this.addr, !1, Hw), Ci(t, i));
  }
}
function Lse(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (mi(t, e)) return;
    (n.uniformMatrix3fv(this.addr, !1, e), Ci(t, e));
  } else {
    if (mi(t, i)) return;
    (Uw.set(i), n.uniformMatrix3fv(this.addr, !1, Uw), Ci(t, i));
  }
}
function Rse(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (mi(t, e)) return;
    (n.uniformMatrix4fv(this.addr, !1, e), Ci(t, e));
  } else {
    if (mi(t, i)) return;
    (Ow.set(i), n.uniformMatrix4fv(this.addr, !1, Ow), Ci(t, i));
  }
}
function Bse(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e));
}
function Pse(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (mi(t, e)) return;
    (n.uniform2iv(this.addr, e), Ci(t, e));
  }
}
function Nse(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (mi(t, e)) return;
    (n.uniform3iv(this.addr, e), Ci(t, e));
  }
}
function Dse(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (mi(t, e)) return;
    (n.uniform4iv(this.addr, e), Ci(t, e));
  }
}
function Gse(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e));
}
function Fse(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (mi(t, e)) return;
    (n.uniform2uiv(this.addr, e), Ci(t, e));
  }
}
function kse(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (mi(t, e)) return;
    (n.uniform3uiv(this.addr, e), Ci(t, e));
  }
}
function Ose(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (mi(t, e)) return;
    (n.uniform4uiv(this.addr, e), Ci(t, e));
  }
}
function Use(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r));
  let s;
  (this.type === n.SAMPLER_2D_SHADOW
    ? ((Gw.compareFunction = eR), (s = Gw))
    : (s = wR),
    t.setTexture2D(e || s, r));
}
function Hse(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  (i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture3D(e || TR, r));
}
function Wse(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  (i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTextureCube(e || ER, r));
}
function Vse(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  (i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture2DArray(e || SR, r));
}
function Zse(n) {
  switch (n) {
    case 5126:
      return wse;
    case 35664:
      return Sse;
    case 35665:
      return Tse;
    case 35666:
      return Ese;
    case 35674:
      return Mse;
    case 35675:
      return Lse;
    case 35676:
      return Rse;
    case 5124:
    case 35670:
      return Bse;
    case 35667:
    case 35671:
      return Pse;
    case 35668:
    case 35672:
      return Nse;
    case 35669:
    case 35673:
      return Dse;
    case 5125:
      return Gse;
    case 36294:
      return Fse;
    case 36295:
      return kse;
    case 36296:
      return Ose;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return Use;
    case 35679:
    case 36299:
    case 36307:
      return Hse;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Wse;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return Vse;
  }
}
function zse(n, e) {
  n.uniform1fv(this.addr, e);
}
function Yse(n, e) {
  const t = Xd(e, this.size, 2);
  n.uniform2fv(this.addr, t);
}
function Xse(n, e) {
  const t = Xd(e, this.size, 3);
  n.uniform3fv(this.addr, t);
}
function Kse(n, e) {
  const t = Xd(e, this.size, 4);
  n.uniform4fv(this.addr, t);
}
function jse(n, e) {
  const t = Xd(e, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, t);
}
function $se(n, e) {
  const t = Xd(e, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, t);
}
function Jse(n, e) {
  const t = Xd(e, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, t);
}
function Qse(n, e) {
  n.uniform1iv(this.addr, e);
}
function qse(n, e) {
  n.uniform2iv(this.addr, e);
}
function eoe(n, e) {
  n.uniform3iv(this.addr, e);
}
function toe(n, e) {
  n.uniform4iv(this.addr, e);
}
function noe(n, e) {
  n.uniform1uiv(this.addr, e);
}
function ioe(n, e) {
  n.uniform2uiv(this.addr, e);
}
function roe(n, e) {
  n.uniform3uiv(this.addr, e);
}
function soe(n, e) {
  n.uniform4uiv(this.addr, e);
}
function ooe(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = lI(t, r);
  mi(i, s) || (n.uniform1iv(this.addr, s), Ci(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture2D(e[o] || wR, s[o]);
}
function aoe(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = lI(t, r);
  mi(i, s) || (n.uniform1iv(this.addr, s), Ci(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture3D(e[o] || TR, s[o]);
}
function loe(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = lI(t, r);
  mi(i, s) || (n.uniform1iv(this.addr, s), Ci(i, s));
  for (let o = 0; o !== r; ++o) t.setTextureCube(e[o] || ER, s[o]);
}
function coe(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = lI(t, r);
  mi(i, s) || (n.uniform1iv(this.addr, s), Ci(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture2DArray(e[o] || SR, s[o]);
}
function uoe(n) {
  switch (n) {
    case 5126:
      return zse;
    case 35664:
      return Yse;
    case 35665:
      return Xse;
    case 35666:
      return Kse;
    case 35674:
      return jse;
    case 35675:
      return $se;
    case 35676:
      return Jse;
    case 5124:
    case 35670:
      return Qse;
    case 35667:
    case 35671:
      return qse;
    case 35668:
    case 35672:
      return eoe;
    case 35669:
    case 35673:
      return toe;
    case 5125:
      return noe;
    case 36294:
      return ioe;
    case 36295:
      return roe;
    case 36296:
      return soe;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return ooe;
    case 35679:
    case 36299:
    case 36307:
      return aoe;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return loe;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return coe;
  }
}
class hoe {
  constructor(e, t, i) {
    ((this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.type = t.type),
      (this.setValue = Zse(t.type)));
  }
}
class doe {
  constructor(e, t, i) {
    ((this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.type = t.type),
      (this.size = t.size),
      (this.setValue = uoe(t.type)));
  }
}
class foe {
  constructor(e) {
    ((this.id = e), (this.seq = []), (this.map = {}));
  }
  setValue(e, t, i) {
    const r = this.seq;
    for (let s = 0, o = r.length; s !== o; ++s) {
      const a = r[s];
      a.setValue(e, t[a.id], i);
    }
  }
}
const $2 = /(\w+)(\])?(\[|\.)?/g;
function Ww(n, e) {
  (n.seq.push(e), (n.map[e.id] = e));
}
function goe(n, e, t) {
  const i = n.name,
    r = i.length;
  for ($2.lastIndex = 0; ; ) {
    const s = $2.exec(i),
      o = $2.lastIndex;
    let a = s[1];
    const l = s[2] === "]",
      c = s[3];
    if ((l && (a = a | 0), c === void 0 || (c === "[" && o + 2 === r))) {
      Ww(t, c === void 0 ? new hoe(a, n, e) : new doe(a, n, e));
      break;
    } else {
      let h = t.map[a];
      (h === void 0 && ((h = new foe(a)), Ww(t, h)), (t = h));
    }
  }
}
class z0 {
  constructor(e, t) {
    ((this.seq = []), (this.map = {}));
    const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let r = 0; r < i; ++r) {
      const s = e.getActiveUniform(t, r),
        o = e.getUniformLocation(t, s.name);
      goe(s, o, this);
    }
  }
  setValue(e, t, i, r) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, i, r);
  }
  setOptional(e, t, i) {
    const r = t[i];
    r !== void 0 && this.setValue(e, i, r);
  }
  static upload(e, t, i, r) {
    for (let s = 0, o = t.length; s !== o; ++s) {
      const a = t[s],
        l = i[a.id];
      l.needsUpdate !== !1 && a.setValue(e, l.value, r);
    }
  }
  static seqWithValue(e, t) {
    const i = [];
    for (let r = 0, s = e.length; r !== s; ++r) {
      const o = e[r];
      o.id in t && i.push(o);
    }
    return i;
  }
}
function Vw(n, e, t) {
  const i = n.createShader(e);
  return (n.shaderSource(i, t), n.compileShader(i), i);
}
const poe = 37297;
let moe = 0;
function Coe(n, e) {
  const t = n.split(`
`),
    i = [],
    r = Math.max(e - 6, 0),
    s = Math.min(e + 6, t.length);
  for (let o = r; o < s; o++) {
    const a = o + 1;
    i.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`);
  }
  return i.join(`
`);
}
const Zw = new Pt();
function Ioe(n) {
  Kt._getMatrix(Zw, Kt.workingColorSpace, n);
  const e = `mat3( ${Zw.elements.map((t) => t.toFixed(4))} )`;
  switch (Kt.getTransfer(n)) {
    case Xm:
      return [e, "LinearTransferOETF"];
    case mn:
      return [e, "sRGBTransferOETF"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space: ", n),
        [e, "LinearTransferOETF"]
      );
  }
}
function zw(n, e, t) {
  const i = n.getShaderParameter(e, n.COMPILE_STATUS),
    r = n.getShaderInfoLog(e).trim();
  if (i && r === "") return "";
  const s = /ERROR: 0:(\d+)/.exec(r);
  if (s) {
    const o = parseInt(s[1]);
    return (
      t.toUpperCase() +
      `

` +
      r +
      `

` +
      Coe(n.getShaderSource(e), o)
    );
  } else return r;
}
function Aoe(n, e) {
  const t = Ioe(e);
  return [
    `vec4 ${n}( vec4 value ) {`,
    `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,
    "}",
  ].join(`
`);
}
function yoe(n, e) {
  let t;
  switch (e) {
    case See:
      t = "Linear";
      break;
    case Tee:
      t = "Reinhard";
      break;
    case Eee:
      t = "Cineon";
      break;
    case Mee:
      t = "ACESFilmic";
      break;
    case Ree:
      t = "AgX";
      break;
    case Bee:
      t = "Neutral";
      break;
    case Lee:
      t = "Custom";
      break;
    default:
      (console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear"));
  }
  return (
    "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  );
}
const S1 = new X();
function _oe() {
  Kt.getLuminanceCoefficients(S1);
  const n = S1.x.toFixed(4),
    e = S1.y.toFixed(4),
    t = S1.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${n}, ${e}, ${t} );`,
    "	return dot( weights, rgb );",
    "}",
  ].join(`
`);
}
function boe(n) {
  return [
    n.extensionClipCullDistance
      ? "#extension GL_ANGLE_clip_cull_distance : require"
      : "",
    n.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : "",
  ].filter(kf).join(`
`);
}
function voe(n) {
  const e = [];
  for (const t in n) {
    const i = n[t];
    i !== !1 && e.push("#define " + t + " " + i);
  }
  return e.join(`
`);
}
function xoe(n, e) {
  const t = {},
    i = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
  for (let r = 0; r < i; r++) {
    const s = n.getActiveAttrib(e, r),
      o = s.name;
    let a = 1;
    (s.type === n.FLOAT_MAT2 && (a = 2),
      s.type === n.FLOAT_MAT3 && (a = 3),
      s.type === n.FLOAT_MAT4 && (a = 4),
      (t[o] = {
        type: s.type,
        location: n.getAttribLocation(e, o),
        locationSize: a,
      }));
  }
  return t;
}
function kf(n) {
  return n !== "";
}
function Yw(n, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return n
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function Xw(n, e) {
  return n
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection,
    );
}
const woe = /^[ \t]*#include +<([\w\d./]+)>/gm;
function e3(n) {
  return n.replace(woe, Toe);
}
const Soe = new Map();
function Toe(n, e) {
  let t = Nt[e];
  if (t === void 0) {
    const i = Soe.get(e);
    if (i !== void 0)
      ((t = Nt[i]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          i,
        ));
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return e3(t);
}
const Eoe =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Kw(n) {
  return n.replace(Eoe, Moe);
}
function Moe(n, e, t, i) {
  let r = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    r += i
      .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, s);
  return r;
}
function jw(n) {
  let e = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;
  return (
    n.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : n.precision === "mediump"
        ? (e += `
#define MEDIUM_PRECISION`)
        : n.precision === "lowp" &&
          (e += `
#define LOW_PRECISION`),
    e
  );
}
function Loe(n) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    n.shadowMapType === HL
      ? (e = "SHADOWMAP_TYPE_PCF")
      : n.shadowMapType === see
        ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
        : n.shadowMapType === sa && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function Roe(n) {
  let e = "ENVMAP_TYPE_CUBE";
  if (n.envMap)
    switch (n.envMapMode) {
      case sd:
      case od:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case rI:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function Boe(n) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (n.envMap)
    switch (n.envMapMode) {
      case od:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function Poe(n) {
  let e = "ENVMAP_BLENDING_NONE";
  if (n.envMap)
    switch (n.combine) {
      case WL:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case xee:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case wee:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function Noe(n) {
  const e = n.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    i = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: i,
    maxMip: t,
  };
}
function Doe(n, e, t, i) {
  const r = n.getContext(),
    s = t.defines;
  let o = t.vertexShader,
    a = t.fragmentShader;
  const l = Loe(t),
    c = Roe(t),
    u = Boe(t),
    h = Poe(t),
    d = Noe(t),
    f = boe(t),
    g = voe(s),
    p = r.createProgram();
  let m,
    C,
    A = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  (t.isRawShaderMaterial
    ? ((m = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        g,
      ].filter(kf).join(`
`)),
      m.length > 0 &&
        (m += `
`),
      (C = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        g,
      ].filter(kf).join(`
`)),
      C.length > 0 &&
        (C += `
`))
    : ((m = [
        jw(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        g,
        t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
        t.batching ? "#define USE_BATCHING" : "",
        t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + u : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.mapUv ? "#define MAP_UV " + t.mapUv : "",
        t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
        t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
        t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
        t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
        t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
        t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
        t.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv
          : "",
        t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
        t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
        t.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv
          : "",
        t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
        t.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv
          : "",
        t.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv
          : "",
        t.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv
          : "",
        t.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv
          : "",
        t.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv
          : "",
        t.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv
          : "",
        t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
        t.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv
          : "",
        t.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv
          : "",
        t.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv
          : "",
        t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "#ifdef USE_INSTANCING_MORPH",
        "	uniform sampler2D morphTexture;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(kf).join(`
`)),
      (C = [
        jw(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        g,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + c : "",
        t.envMap ? "#define " + u : "",
        t.envMap ? "#define " + h : "",
        d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
        d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
        d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.dispersion ? "#define USE_DISPERSION" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor || t.batchingColor
          ? "#define USE_COLOR"
          : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.decodeVideoTextureEmissive
          ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE"
          : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== Sl ? "#define TONE_MAPPING" : "",
        t.toneMapping !== Sl ? Nt.tonemapping_pars_fragment : "",
        t.toneMapping !== Sl ? yoe("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        Nt.colorspace_pars_fragment,
        Aoe("linearToOutputTexel", t.outputColorSpace),
        _oe(),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(kf).join(`
`))),
    (o = e3(o)),
    (o = Yw(o, t)),
    (o = Xw(o, t)),
    (a = e3(a)),
    (a = Yw(a, t)),
    (a = Xw(a, t)),
    (o = Kw(o)),
    (a = Kw(a)),
    t.isRawShaderMaterial !== !0 &&
      ((A = `#version 300 es
`),
      (m =
        [
          f,
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        m),
      (C =
        [
          "#define varying in",
          t.glslVersion === Hx
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === Hx ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        C)));
  const I = A + m + o,
    y = A + C + a,
    x = Vw(r, r.VERTEX_SHADER, I),
    T = Vw(r, r.FRAGMENT_SHADER, y);
  (r.attachShader(p, x),
    r.attachShader(p, T),
    t.index0AttributeName !== void 0
      ? r.bindAttribLocation(p, 0, t.index0AttributeName)
      : t.morphTargets === !0 && r.bindAttribLocation(p, 0, "position"),
    r.linkProgram(p));
  function S(R) {
    if (n.debug.checkShaderErrors) {
      const M = r.getProgramInfoLog(p).trim(),
        L = r.getShaderInfoLog(x).trim(),
        P = r.getShaderInfoLog(T).trim();
      let U = !0,
        O = !0;
      if (r.getProgramParameter(p, r.LINK_STATUS) === !1)
        if (((U = !1), typeof n.debug.onShaderError == "function"))
          n.debug.onShaderError(r, p, x, T);
        else {
          const V = zw(r, x, "vertex"),
            W = zw(r, T, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              r.getError() +
              " - VALIDATE_STATUS " +
              r.getProgramParameter(p, r.VALIDATE_STATUS) +
              `

Material Name: ` +
              R.name +
              `
Material Type: ` +
              R.type +
              `

Program Info Log: ` +
              M +
              `
` +
              V +
              `
` +
              W,
          );
        }
      else
        M !== ""
          ? console.warn("THREE.WebGLProgram: Program Info Log:", M)
          : (L === "" || P === "") && (O = !1);
      O &&
        (R.diagnostics = {
          runnable: U,
          programLog: M,
          vertexShader: { log: L, prefix: m },
          fragmentShader: { log: P, prefix: C },
        });
    }
    (r.deleteShader(x), r.deleteShader(T), (E = new z0(r, p)), (_ = xoe(r, p)));
  }
  let E;
  this.getUniforms = function () {
    return (E === void 0 && S(this), E);
  };
  let _;
  this.getAttributes = function () {
    return (_ === void 0 && S(this), _);
  };
  let b = t.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return (b === !1 && (b = r.getProgramParameter(p, poe)), b);
    }),
    (this.destroy = function () {
      (i.releaseStatesOfProgram(this),
        r.deleteProgram(p),
        (this.program = void 0));
    }),
    (this.type = t.shaderType),
    (this.name = t.shaderName),
    (this.id = moe++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = p),
    (this.vertexShader = x),
    (this.fragmentShader = T),
    this
  );
}
let Goe = 0;
class Foe {
  constructor() {
    ((this.shaderCache = new Map()), (this.materialCache = new Map()));
  }
  update(e) {
    const t = e.vertexShader,
      i = e.fragmentShader,
      r = this._getShaderStage(t),
      s = this._getShaderStage(i),
      o = this._getShaderCacheForMaterial(e);
    return (
      o.has(r) === !1 && (o.add(r), r.usedTimes++),
      o.has(s) === !1 && (o.add(s), s.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const i of t)
      (i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code));
    return (this.materialCache.delete(e), this);
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    (this.shaderCache.clear(), this.materialCache.clear());
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let i = t.get(e);
    return (i === void 0 && ((i = new Set()), t.set(e, i)), i);
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let i = t.get(e);
    return (i === void 0 && ((i = new koe(e)), t.set(e, i)), i);
  }
}
class koe {
  constructor(e) {
    ((this.id = Goe++), (this.code = e), (this.usedTimes = 0));
  }
}
function Ooe(n, e, t, i, r, s, o) {
  const a = new Uv(),
    l = new Foe(),
    c = new Set(),
    u = [],
    h = r.logarithmicDepthBuffer,
    d = r.vertexTextures;
  let f = r.precision;
  const g = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function p(_) {
    return (c.add(_), _ === 0 ? "uv" : `uv${_}`);
  }
  function m(_, b, R, M, L) {
    const P = M.fog,
      U = L.geometry,
      O = _.isMeshStandardMaterial ? M.environment : null,
      V = (_.isMeshStandardMaterial ? t : e).get(_.envMap || O),
      W = V && V.mapping === rI ? V.image.height : null,
      re = g[_.type];
    _.precision !== null &&
      ((f = r.getMaxPrecision(_.precision)),
      f !== _.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          _.precision,
          "not supported, using",
          f,
          "instead.",
        ));
    const Z =
        U.morphAttributes.position ||
        U.morphAttributes.normal ||
        U.morphAttributes.color,
      te = Z !== void 0 ? Z.length : 0;
    let ge = 0;
    (U.morphAttributes.position !== void 0 && (ge = 1),
      U.morphAttributes.normal !== void 0 && (ge = 2),
      U.morphAttributes.color !== void 0 && (ge = 3));
    let be, J, se, ce;
    if (re) {
      const yt = mo[re];
      ((be = yt.vertexShader), (J = yt.fragmentShader));
    } else
      ((be = _.vertexShader),
        (J = _.fragmentShader),
        l.update(_),
        (se = l.getVertexShaderID(_)),
        (ce = l.getFragmentShaderID(_)));
    const ae = n.getRenderTarget(),
      Ce = n.state.buffers.depth.getReversed(),
      $e = L.isInstancedMesh === !0,
      Te = L.isBatchedMesh === !0,
      it = !!_.map,
      ct = !!_.matcap,
      qe = !!V,
      H = !!_.aoMap,
      tn = !!_.lightMap,
      Mt = !!_.bumpMap,
      ot = !!_.normalMap,
      Ae = !!_.displacementMap,
      _n = !!_.emissiveMap,
      Ze = !!_.metalnessMap,
      k = !!_.roughnessMap,
      B = _.anisotropy > 0,
      q = _.clearcoat > 0,
      fe = _.dispersion > 0,
      Ie = _.iridescence > 0,
      le = _.sheen > 0,
      Ke = _.transmission > 0,
      Ee = B && !!_.anisotropyMap,
      rt = q && !!_.clearcoatMap,
      pt = q && !!_.clearcoatNormalMap,
      ye = q && !!_.clearcoatRoughnessMap,
      Ue = Ie && !!_.iridescenceMap,
      ut = Ie && !!_.iridescenceThicknessMap,
      ht = le && !!_.sheenColorMap,
      ze = le && !!_.sheenRoughnessMap,
      Ft = !!_.specularMap,
      Lt = !!_.specularColorMap,
      pn = !!_.specularIntensityMap,
      Y = Ke && !!_.transmissionMap,
      Fe = Ke && !!_.thicknessMap,
      oe = !!_.gradientMap,
      me = !!_.alphaMap,
      Re = _.alphaTest > 0,
      Ge = !!_.alphaHash,
      at = !!_.extensions;
    let Bn = Sl;
    _.toneMapped &&
      (ae === null || ae.isXRRenderTarget === !0) &&
      (Bn = n.toneMapping);
    const Ii = {
      shaderID: re,
      shaderType: _.type,
      shaderName: _.name,
      vertexShader: be,
      fragmentShader: J,
      defines: _.defines,
      customVertexShaderID: se,
      customFragmentShaderID: ce,
      isRawShaderMaterial: _.isRawShaderMaterial === !0,
      glslVersion: _.glslVersion,
      precision: f,
      batching: Te,
      batchingColor: Te && L._colorsTexture !== null,
      instancing: $e,
      instancingColor: $e && L.instanceColor !== null,
      instancingMorph: $e && L.morphTexture !== null,
      supportsVertexTextures: d,
      outputColorSpace:
        ae === null
          ? n.outputColorSpace
          : ae.isXRRenderTarget === !0
            ? ae.texture.colorSpace
            : Ir,
      alphaToCoverage: !!_.alphaToCoverage,
      map: it,
      matcap: ct,
      envMap: qe,
      envMapMode: qe && V.mapping,
      envMapCubeUVHeight: W,
      aoMap: H,
      lightMap: tn,
      bumpMap: Mt,
      normalMap: ot,
      displacementMap: d && Ae,
      emissiveMap: _n,
      normalMapObjectSpace: ot && _.normalMapType === Uee,
      normalMapTangentSpace: ot && _.normalMapType === qL,
      metalnessMap: Ze,
      roughnessMap: k,
      anisotropy: B,
      anisotropyMap: Ee,
      clearcoat: q,
      clearcoatMap: rt,
      clearcoatNormalMap: pt,
      clearcoatRoughnessMap: ye,
      dispersion: fe,
      iridescence: Ie,
      iridescenceMap: Ue,
      iridescenceThicknessMap: ut,
      sheen: le,
      sheenColorMap: ht,
      sheenRoughnessMap: ze,
      specularMap: Ft,
      specularColorMap: Lt,
      specularIntensityMap: pn,
      transmission: Ke,
      transmissionMap: Y,
      thicknessMap: Fe,
      gradientMap: oe,
      opaque:
        _.transparent === !1 && _.blending === Ph && _.alphaToCoverage === !1,
      alphaMap: me,
      alphaTest: Re,
      alphaHash: Ge,
      combine: _.combine,
      mapUv: it && p(_.map.channel),
      aoMapUv: H && p(_.aoMap.channel),
      lightMapUv: tn && p(_.lightMap.channel),
      bumpMapUv: Mt && p(_.bumpMap.channel),
      normalMapUv: ot && p(_.normalMap.channel),
      displacementMapUv: Ae && p(_.displacementMap.channel),
      emissiveMapUv: _n && p(_.emissiveMap.channel),
      metalnessMapUv: Ze && p(_.metalnessMap.channel),
      roughnessMapUv: k && p(_.roughnessMap.channel),
      anisotropyMapUv: Ee && p(_.anisotropyMap.channel),
      clearcoatMapUv: rt && p(_.clearcoatMap.channel),
      clearcoatNormalMapUv: pt && p(_.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: ye && p(_.clearcoatRoughnessMap.channel),
      iridescenceMapUv: Ue && p(_.iridescenceMap.channel),
      iridescenceThicknessMapUv: ut && p(_.iridescenceThicknessMap.channel),
      sheenColorMapUv: ht && p(_.sheenColorMap.channel),
      sheenRoughnessMapUv: ze && p(_.sheenRoughnessMap.channel),
      specularMapUv: Ft && p(_.specularMap.channel),
      specularColorMapUv: Lt && p(_.specularColorMap.channel),
      specularIntensityMapUv: pn && p(_.specularIntensityMap.channel),
      transmissionMapUv: Y && p(_.transmissionMap.channel),
      thicknessMapUv: Fe && p(_.thicknessMap.channel),
      alphaMapUv: me && p(_.alphaMap.channel),
      vertexTangents: !!U.attributes.tangent && (ot || B),
      vertexColors: _.vertexColors,
      vertexAlphas:
        _.vertexColors === !0 &&
        !!U.attributes.color &&
        U.attributes.color.itemSize === 4,
      pointsUvs: L.isPoints === !0 && !!U.attributes.uv && (it || me),
      fog: !!P,
      useFog: _.fog === !0,
      fogExp2: !!P && P.isFogExp2,
      flatShading: _.flatShading === !0,
      sizeAttenuation: _.sizeAttenuation === !0,
      logarithmicDepthBuffer: h,
      reverseDepthBuffer: Ce,
      skinning: L.isSkinnedMesh === !0,
      morphTargets: U.morphAttributes.position !== void 0,
      morphNormals: U.morphAttributes.normal !== void 0,
      morphColors: U.morphAttributes.color !== void 0,
      morphTargetsCount: te,
      morphTextureStride: ge,
      numDirLights: b.directional.length,
      numPointLights: b.point.length,
      numSpotLights: b.spot.length,
      numSpotLightMaps: b.spotLightMap.length,
      numRectAreaLights: b.rectArea.length,
      numHemiLights: b.hemi.length,
      numDirLightShadows: b.directionalShadowMap.length,
      numPointLightShadows: b.pointShadowMap.length,
      numSpotLightShadows: b.spotShadowMap.length,
      numSpotLightShadowsWithMaps: b.numSpotLightShadowsWithMaps,
      numLightProbes: b.numLightProbes,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: _.dithering,
      shadowMapEnabled: n.shadowMap.enabled && R.length > 0,
      shadowMapType: n.shadowMap.type,
      toneMapping: Bn,
      decodeVideoTexture:
        it &&
        _.map.isVideoTexture === !0 &&
        Kt.getTransfer(_.map.colorSpace) === mn,
      decodeVideoTextureEmissive:
        _n &&
        _.emissiveMap.isVideoTexture === !0 &&
        Kt.getTransfer(_.emissiveMap.colorSpace) === mn,
      premultipliedAlpha: _.premultipliedAlpha,
      doubleSided: _.side === Ao,
      flipSided: _.side === er,
      useDepthPacking: _.depthPacking >= 0,
      depthPacking: _.depthPacking || 0,
      index0AttributeName: _.index0AttributeName,
      extensionClipCullDistance:
        at &&
        _.extensions.clipCullDistance === !0 &&
        i.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw:
        ((at && _.extensions.multiDraw === !0) || Te) &&
        i.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: i.has(
        "KHR_parallel_shader_compile",
      ),
      customProgramCacheKey: _.customProgramCacheKey(),
    };
    return (
      (Ii.vertexUv1s = c.has(1)),
      (Ii.vertexUv2s = c.has(2)),
      (Ii.vertexUv3s = c.has(3)),
      c.clear(),
      Ii
    );
  }
  function C(_) {
    const b = [];
    if (
      (_.shaderID
        ? b.push(_.shaderID)
        : (b.push(_.customVertexShaderID), b.push(_.customFragmentShaderID)),
      _.defines !== void 0)
    )
      for (const R in _.defines) (b.push(R), b.push(_.defines[R]));
    return (
      _.isRawShaderMaterial === !1 &&
        (A(b, _), I(b, _), b.push(n.outputColorSpace)),
      b.push(_.customProgramCacheKey),
      b.join()
    );
  }
  function A(_, b) {
    (_.push(b.precision),
      _.push(b.outputColorSpace),
      _.push(b.envMapMode),
      _.push(b.envMapCubeUVHeight),
      _.push(b.mapUv),
      _.push(b.alphaMapUv),
      _.push(b.lightMapUv),
      _.push(b.aoMapUv),
      _.push(b.bumpMapUv),
      _.push(b.normalMapUv),
      _.push(b.displacementMapUv),
      _.push(b.emissiveMapUv),
      _.push(b.metalnessMapUv),
      _.push(b.roughnessMapUv),
      _.push(b.anisotropyMapUv),
      _.push(b.clearcoatMapUv),
      _.push(b.clearcoatNormalMapUv),
      _.push(b.clearcoatRoughnessMapUv),
      _.push(b.iridescenceMapUv),
      _.push(b.iridescenceThicknessMapUv),
      _.push(b.sheenColorMapUv),
      _.push(b.sheenRoughnessMapUv),
      _.push(b.specularMapUv),
      _.push(b.specularColorMapUv),
      _.push(b.specularIntensityMapUv),
      _.push(b.transmissionMapUv),
      _.push(b.thicknessMapUv),
      _.push(b.combine),
      _.push(b.fogExp2),
      _.push(b.sizeAttenuation),
      _.push(b.morphTargetsCount),
      _.push(b.morphAttributeCount),
      _.push(b.numDirLights),
      _.push(b.numPointLights),
      _.push(b.numSpotLights),
      _.push(b.numSpotLightMaps),
      _.push(b.numHemiLights),
      _.push(b.numRectAreaLights),
      _.push(b.numDirLightShadows),
      _.push(b.numPointLightShadows),
      _.push(b.numSpotLightShadows),
      _.push(b.numSpotLightShadowsWithMaps),
      _.push(b.numLightProbes),
      _.push(b.shadowMapType),
      _.push(b.toneMapping),
      _.push(b.numClippingPlanes),
      _.push(b.numClipIntersection),
      _.push(b.depthPacking));
  }
  function I(_, b) {
    (a.disableAll(),
      b.supportsVertexTextures && a.enable(0),
      b.instancing && a.enable(1),
      b.instancingColor && a.enable(2),
      b.instancingMorph && a.enable(3),
      b.matcap && a.enable(4),
      b.envMap && a.enable(5),
      b.normalMapObjectSpace && a.enable(6),
      b.normalMapTangentSpace && a.enable(7),
      b.clearcoat && a.enable(8),
      b.iridescence && a.enable(9),
      b.alphaTest && a.enable(10),
      b.vertexColors && a.enable(11),
      b.vertexAlphas && a.enable(12),
      b.vertexUv1s && a.enable(13),
      b.vertexUv2s && a.enable(14),
      b.vertexUv3s && a.enable(15),
      b.vertexTangents && a.enable(16),
      b.anisotropy && a.enable(17),
      b.alphaHash && a.enable(18),
      b.batching && a.enable(19),
      b.dispersion && a.enable(20),
      b.batchingColor && a.enable(21),
      _.push(a.mask),
      a.disableAll(),
      b.fog && a.enable(0),
      b.useFog && a.enable(1),
      b.flatShading && a.enable(2),
      b.logarithmicDepthBuffer && a.enable(3),
      b.reverseDepthBuffer && a.enable(4),
      b.skinning && a.enable(5),
      b.morphTargets && a.enable(6),
      b.morphNormals && a.enable(7),
      b.morphColors && a.enable(8),
      b.premultipliedAlpha && a.enable(9),
      b.shadowMapEnabled && a.enable(10),
      b.doubleSided && a.enable(11),
      b.flipSided && a.enable(12),
      b.useDepthPacking && a.enable(13),
      b.dithering && a.enable(14),
      b.transmission && a.enable(15),
      b.sheen && a.enable(16),
      b.opaque && a.enable(17),
      b.pointsUvs && a.enable(18),
      b.decodeVideoTexture && a.enable(19),
      b.decodeVideoTextureEmissive && a.enable(20),
      b.alphaToCoverage && a.enable(21),
      _.push(a.mask));
  }
  function y(_) {
    const b = g[_.type];
    let R;
    if (b) {
      const M = mo[b];
      R = Bte.clone(M.uniforms);
    } else R = _.uniforms;
    return R;
  }
  function x(_, b) {
    let R;
    for (let M = 0, L = u.length; M < L; M++) {
      const P = u[M];
      if (P.cacheKey === b) {
        ((R = P), ++R.usedTimes);
        break;
      }
    }
    return (R === void 0 && ((R = new Doe(n, b, _, s)), u.push(R)), R);
  }
  function T(_) {
    if (--_.usedTimes === 0) {
      const b = u.indexOf(_);
      ((u[b] = u[u.length - 1]), u.pop(), _.destroy());
    }
  }
  function S(_) {
    l.remove(_);
  }
  function E() {
    l.dispose();
  }
  return {
    getParameters: m,
    getProgramCacheKey: C,
    getUniforms: y,
    acquireProgram: x,
    releaseProgram: T,
    releaseShaderCache: S,
    programs: u,
    dispose: E,
  };
}
function Uoe() {
  let n = new WeakMap();
  function e(o) {
    return n.has(o);
  }
  function t(o) {
    let a = n.get(o);
    return (a === void 0 && ((a = {}), n.set(o, a)), a);
  }
  function i(o) {
    n.delete(o);
  }
  function r(o, a, l) {
    n.get(o)[a] = l;
  }
  function s() {
    n = new WeakMap();
  }
  return { has: e, get: t, remove: i, update: r, dispose: s };
}
function Hoe(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
      ? n.renderOrder - e.renderOrder
      : n.material.id !== e.material.id
        ? n.material.id - e.material.id
        : n.z !== e.z
          ? n.z - e.z
          : n.id - e.id;
}
function $w(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
      ? n.renderOrder - e.renderOrder
      : n.z !== e.z
        ? e.z - n.z
        : n.id - e.id;
}
function Jw() {
  const n = [];
  let e = 0;
  const t = [],
    i = [],
    r = [];
  function s() {
    ((e = 0), (t.length = 0), (i.length = 0), (r.length = 0));
  }
  function o(h, d, f, g, p, m) {
    let C = n[e];
    return (
      C === void 0
        ? ((C = {
            id: h.id,
            object: h,
            geometry: d,
            material: f,
            groupOrder: g,
            renderOrder: h.renderOrder,
            z: p,
            group: m,
          }),
          (n[e] = C))
        : ((C.id = h.id),
          (C.object = h),
          (C.geometry = d),
          (C.material = f),
          (C.groupOrder = g),
          (C.renderOrder = h.renderOrder),
          (C.z = p),
          (C.group = m)),
      e++,
      C
    );
  }
  function a(h, d, f, g, p, m) {
    const C = o(h, d, f, g, p, m);
    f.transmission > 0
      ? i.push(C)
      : f.transparent === !0
        ? r.push(C)
        : t.push(C);
  }
  function l(h, d, f, g, p, m) {
    const C = o(h, d, f, g, p, m);
    f.transmission > 0
      ? i.unshift(C)
      : f.transparent === !0
        ? r.unshift(C)
        : t.unshift(C);
  }
  function c(h, d) {
    (t.length > 1 && t.sort(h || Hoe),
      i.length > 1 && i.sort(d || $w),
      r.length > 1 && r.sort(d || $w));
  }
  function u() {
    for (let h = e, d = n.length; h < d; h++) {
      const f = n[h];
      if (f.id === null) break;
      ((f.id = null),
        (f.object = null),
        (f.geometry = null),
        (f.material = null),
        (f.group = null));
    }
  }
  return {
    opaque: t,
    transmissive: i,
    transparent: r,
    init: s,
    push: a,
    unshift: l,
    finish: u,
    sort: c,
  };
}
function Woe() {
  let n = new WeakMap();
  function e(i, r) {
    const s = n.get(i);
    let o;
    return (
      s === void 0
        ? ((o = new Jw()), n.set(i, [o]))
        : r >= s.length
          ? ((o = new Jw()), s.push(o))
          : (o = s[r]),
      o
    );
  }
  function t() {
    n = new WeakMap();
  }
  return { get: e, dispose: t };
}
function Voe() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new X(), color: new vt() };
          break;
        case "SpotLight":
          t = {
            position: new X(),
            direction: new X(),
            color: new vt(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new X(), color: new vt(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = { direction: new X(), skyColor: new vt(), groundColor: new vt() };
          break;
        case "RectAreaLight":
          t = {
            color: new vt(),
            position: new X(),
            halfWidth: new X(),
            halfHeight: new X(),
          };
          break;
      }
      return ((n[e.id] = t), t);
    },
  };
}
function Zoe() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Gt(),
          };
          break;
        case "SpotLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Gt(),
          };
          break;
        case "PointLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Gt(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return ((n[e.id] = t), t);
    },
  };
}
let zoe = 0;
function Yoe(n, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (n.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (n.map ? 1 : 0)
  );
}
function Xoe(n) {
  const e = new Voe(),
    t = Zoe(),
    i = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let c = 0; c < 9; c++) i.probe.push(new X());
  const r = new X(),
    s = new Et(),
    o = new Et();
  function a(c) {
    let u = 0,
      h = 0,
      d = 0;
    for (let _ = 0; _ < 9; _++) i.probe[_].set(0, 0, 0);
    let f = 0,
      g = 0,
      p = 0,
      m = 0,
      C = 0,
      A = 0,
      I = 0,
      y = 0,
      x = 0,
      T = 0,
      S = 0;
    c.sort(Yoe);
    for (let _ = 0, b = c.length; _ < b; _++) {
      const R = c[_],
        M = R.color,
        L = R.intensity,
        P = R.distance,
        U = R.shadow && R.shadow.map ? R.shadow.map.texture : null;
      if (R.isAmbientLight) ((u += M.r * L), (h += M.g * L), (d += M.b * L));
      else if (R.isLightProbe) {
        for (let O = 0; O < 9; O++)
          i.probe[O].addScaledVector(R.sh.coefficients[O], L);
        S++;
      } else if (R.isDirectionalLight) {
        const O = e.get(R);
        if ((O.color.copy(R.color).multiplyScalar(R.intensity), R.castShadow)) {
          const V = R.shadow,
            W = t.get(R);
          ((W.shadowIntensity = V.intensity),
            (W.shadowBias = V.bias),
            (W.shadowNormalBias = V.normalBias),
            (W.shadowRadius = V.radius),
            (W.shadowMapSize = V.mapSize),
            (i.directionalShadow[f] = W),
            (i.directionalShadowMap[f] = U),
            (i.directionalShadowMatrix[f] = R.shadow.matrix),
            A++);
        }
        ((i.directional[f] = O), f++);
      } else if (R.isSpotLight) {
        const O = e.get(R);
        (O.position.setFromMatrixPosition(R.matrixWorld),
          O.color.copy(M).multiplyScalar(L),
          (O.distance = P),
          (O.coneCos = Math.cos(R.angle)),
          (O.penumbraCos = Math.cos(R.angle * (1 - R.penumbra))),
          (O.decay = R.decay),
          (i.spot[p] = O));
        const V = R.shadow;
        if (
          (R.map &&
            ((i.spotLightMap[x] = R.map),
            x++,
            V.updateMatrices(R),
            R.castShadow && T++),
          (i.spotLightMatrix[p] = V.matrix),
          R.castShadow)
        ) {
          const W = t.get(R);
          ((W.shadowIntensity = V.intensity),
            (W.shadowBias = V.bias),
            (W.shadowNormalBias = V.normalBias),
            (W.shadowRadius = V.radius),
            (W.shadowMapSize = V.mapSize),
            (i.spotShadow[p] = W),
            (i.spotShadowMap[p] = U),
            y++);
        }
        p++;
      } else if (R.isRectAreaLight) {
        const O = e.get(R);
        (O.color.copy(M).multiplyScalar(L),
          O.halfWidth.set(R.width * 0.5, 0, 0),
          O.halfHeight.set(0, R.height * 0.5, 0),
          (i.rectArea[m] = O),
          m++);
      } else if (R.isPointLight) {
        const O = e.get(R);
        if (
          (O.color.copy(R.color).multiplyScalar(R.intensity),
          (O.distance = R.distance),
          (O.decay = R.decay),
          R.castShadow)
        ) {
          const V = R.shadow,
            W = t.get(R);
          ((W.shadowIntensity = V.intensity),
            (W.shadowBias = V.bias),
            (W.shadowNormalBias = V.normalBias),
            (W.shadowRadius = V.radius),
            (W.shadowMapSize = V.mapSize),
            (W.shadowCameraNear = V.camera.near),
            (W.shadowCameraFar = V.camera.far),
            (i.pointShadow[g] = W),
            (i.pointShadowMap[g] = U),
            (i.pointShadowMatrix[g] = R.shadow.matrix),
            I++);
        }
        ((i.point[g] = O), g++);
      } else if (R.isHemisphereLight) {
        const O = e.get(R);
        (O.skyColor.copy(R.color).multiplyScalar(L),
          O.groundColor.copy(R.groundColor).multiplyScalar(L),
          (i.hemi[C] = O),
          C++);
      }
    }
    (m > 0 &&
      (n.has("OES_texture_float_linear") === !0
        ? ((i.rectAreaLTC1 = Be.LTC_FLOAT_1), (i.rectAreaLTC2 = Be.LTC_FLOAT_2))
        : ((i.rectAreaLTC1 = Be.LTC_HALF_1), (i.rectAreaLTC2 = Be.LTC_HALF_2))),
      (i.ambient[0] = u),
      (i.ambient[1] = h),
      (i.ambient[2] = d));
    const E = i.hash;
    (E.directionalLength !== f ||
      E.pointLength !== g ||
      E.spotLength !== p ||
      E.rectAreaLength !== m ||
      E.hemiLength !== C ||
      E.numDirectionalShadows !== A ||
      E.numPointShadows !== I ||
      E.numSpotShadows !== y ||
      E.numSpotMaps !== x ||
      E.numLightProbes !== S) &&
      ((i.directional.length = f),
      (i.spot.length = p),
      (i.rectArea.length = m),
      (i.point.length = g),
      (i.hemi.length = C),
      (i.directionalShadow.length = A),
      (i.directionalShadowMap.length = A),
      (i.pointShadow.length = I),
      (i.pointShadowMap.length = I),
      (i.spotShadow.length = y),
      (i.spotShadowMap.length = y),
      (i.directionalShadowMatrix.length = A),
      (i.pointShadowMatrix.length = I),
      (i.spotLightMatrix.length = y + x - T),
      (i.spotLightMap.length = x),
      (i.numSpotLightShadowsWithMaps = T),
      (i.numLightProbes = S),
      (E.directionalLength = f),
      (E.pointLength = g),
      (E.spotLength = p),
      (E.rectAreaLength = m),
      (E.hemiLength = C),
      (E.numDirectionalShadows = A),
      (E.numPointShadows = I),
      (E.numSpotShadows = y),
      (E.numSpotMaps = x),
      (E.numLightProbes = S),
      (i.version = zoe++));
  }
  function l(c, u) {
    let h = 0,
      d = 0,
      f = 0,
      g = 0,
      p = 0;
    const m = u.matrixWorldInverse;
    for (let C = 0, A = c.length; C < A; C++) {
      const I = c[C];
      if (I.isDirectionalLight) {
        const y = i.directional[h];
        (y.direction.setFromMatrixPosition(I.matrixWorld),
          r.setFromMatrixPosition(I.target.matrixWorld),
          y.direction.sub(r),
          y.direction.transformDirection(m),
          h++);
      } else if (I.isSpotLight) {
        const y = i.spot[f];
        (y.position.setFromMatrixPosition(I.matrixWorld),
          y.position.applyMatrix4(m),
          y.direction.setFromMatrixPosition(I.matrixWorld),
          r.setFromMatrixPosition(I.target.matrixWorld),
          y.direction.sub(r),
          y.direction.transformDirection(m),
          f++);
      } else if (I.isRectAreaLight) {
        const y = i.rectArea[g];
        (y.position.setFromMatrixPosition(I.matrixWorld),
          y.position.applyMatrix4(m),
          o.identity(),
          s.copy(I.matrixWorld),
          s.premultiply(m),
          o.extractRotation(s),
          y.halfWidth.set(I.width * 0.5, 0, 0),
          y.halfHeight.set(0, I.height * 0.5, 0),
          y.halfWidth.applyMatrix4(o),
          y.halfHeight.applyMatrix4(o),
          g++);
      } else if (I.isPointLight) {
        const y = i.point[d];
        (y.position.setFromMatrixPosition(I.matrixWorld),
          y.position.applyMatrix4(m),
          d++);
      } else if (I.isHemisphereLight) {
        const y = i.hemi[p];
        (y.direction.setFromMatrixPosition(I.matrixWorld),
          y.direction.transformDirection(m),
          p++);
      }
    }
  }
  return { setup: a, setupView: l, state: i };
}
function Qw(n) {
  const e = new Xoe(n),
    t = [],
    i = [];
  function r(u) {
    ((c.camera = u), (t.length = 0), (i.length = 0));
  }
  function s(u) {
    t.push(u);
  }
  function o(u) {
    i.push(u);
  }
  function a() {
    e.setup(t);
  }
  function l(u) {
    e.setupView(t, u);
  }
  const c = {
    lightsArray: t,
    shadowsArray: i,
    camera: null,
    lights: e,
    transmissionRenderTarget: {},
  };
  return {
    init: r,
    state: c,
    setupLights: a,
    setupLightsView: l,
    pushLight: s,
    pushShadow: o,
  };
}
function Koe(n) {
  let e = new WeakMap();
  function t(r, s = 0) {
    const o = e.get(r);
    let a;
    return (
      o === void 0
        ? ((a = new Qw(n)), e.set(r, [a]))
        : s >= o.length
          ? ((a = new Qw(n)), o.push(a))
          : (a = o[s]),
      a
    );
  }
  function i() {
    e = new WeakMap();
  }
  return { get: t, dispose: i };
}
const joe = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  $oe = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function Joe(n, e, t) {
  let i = new zv();
  const r = new Gt(),
    s = new Gt(),
    o = new ln(),
    a = new jte({ depthPacking: Oee }),
    l = new $te(),
    c = {},
    u = t.maxTextureSize,
    h = { [Go]: er, [er]: Go, [Ao]: Ao },
    d = new Qi({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Gt() },
        radius: { value: 4 },
      },
      vertexShader: joe,
      fragmentShader: $oe,
    }),
    f = d.clone();
  f.defines.HORIZONTAL_PASS = 1;
  const g = new Pr();
  g.setAttribute(
    "position",
    new Pi(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3),
  );
  const p = new si(g, d),
    m = this;
  ((this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = HL));
  let C = this.type;
  this.render = function (T, S, E) {
    if (
      m.enabled === !1 ||
      (m.autoUpdate === !1 && m.needsUpdate === !1) ||
      T.length === 0
    )
      return;
    const _ = n.getRenderTarget(),
      b = n.getActiveCubeFace(),
      R = n.getActiveMipmapLevel(),
      M = n.state;
    (M.setBlending(wl),
      M.buffers.color.setClear(1, 1, 1, 1),
      M.buffers.depth.setTest(!0),
      M.setScissorTest(!1));
    const L = C !== sa && this.type === sa,
      P = C === sa && this.type !== sa;
    for (let U = 0, O = T.length; U < O; U++) {
      const V = T[U],
        W = V.shadow;
      if (W === void 0) {
        console.warn("THREE.WebGLShadowMap:", V, "has no shadow.");
        continue;
      }
      if (W.autoUpdate === !1 && W.needsUpdate === !1) continue;
      r.copy(W.mapSize);
      const re = W.getFrameExtents();
      if (
        (r.multiply(re),
        s.copy(W.mapSize),
        (r.x > u || r.y > u) &&
          (r.x > u &&
            ((s.x = Math.floor(u / re.x)),
            (r.x = s.x * re.x),
            (W.mapSize.x = s.x)),
          r.y > u &&
            ((s.y = Math.floor(u / re.y)),
            (r.y = s.y * re.y),
            (W.mapSize.y = s.y))),
        W.map === null || L === !0 || P === !0)
      ) {
        const te = this.type !== sa ? { minFilter: gi, magFilter: gi } : {};
        (W.map !== null && W.map.dispose(),
          (W.map = new ko(r.x, r.y, te)),
          (W.map.texture.name = V.name + ".shadowMap"),
          W.camera.updateProjectionMatrix());
      }
      (n.setRenderTarget(W.map), n.clear());
      const Z = W.getViewportCount();
      for (let te = 0; te < Z; te++) {
        const ge = W.getViewport(te);
        (o.set(s.x * ge.x, s.y * ge.y, s.x * ge.z, s.y * ge.w),
          M.viewport(o),
          W.updateMatrices(V, te),
          (i = W.getFrustum()),
          y(S, E, W.camera, V, this.type));
      }
      (W.isPointLightShadow !== !0 && this.type === sa && A(W, E),
        (W.needsUpdate = !1));
    }
    ((C = this.type), (m.needsUpdate = !1), n.setRenderTarget(_, b, R));
  };
  function A(T, S) {
    const E = e.update(p);
    (d.defines.VSM_SAMPLES !== T.blurSamples &&
      ((d.defines.VSM_SAMPLES = T.blurSamples),
      (f.defines.VSM_SAMPLES = T.blurSamples),
      (d.needsUpdate = !0),
      (f.needsUpdate = !0)),
      T.mapPass === null && (T.mapPass = new ko(r.x, r.y)),
      (d.uniforms.shadow_pass.value = T.map.texture),
      (d.uniforms.resolution.value = T.mapSize),
      (d.uniforms.radius.value = T.radius),
      n.setRenderTarget(T.mapPass),
      n.clear(),
      n.renderBufferDirect(S, null, E, d, p, null),
      (f.uniforms.shadow_pass.value = T.mapPass.texture),
      (f.uniforms.resolution.value = T.mapSize),
      (f.uniforms.radius.value = T.radius),
      n.setRenderTarget(T.map),
      n.clear(),
      n.renderBufferDirect(S, null, E, f, p, null));
  }
  function I(T, S, E, _) {
    let b = null;
    const R =
      E.isPointLight === !0 ? T.customDistanceMaterial : T.customDepthMaterial;
    if (R !== void 0) b = R;
    else if (
      ((b = E.isPointLight === !0 ? l : a),
      (n.localClippingEnabled &&
        S.clipShadows === !0 &&
        Array.isArray(S.clippingPlanes) &&
        S.clippingPlanes.length !== 0) ||
        (S.displacementMap && S.displacementScale !== 0) ||
        (S.alphaMap && S.alphaTest > 0) ||
        (S.map && S.alphaTest > 0) ||
        S.alphaToCoverage === !0)
    ) {
      const M = b.uuid,
        L = S.uuid;
      let P = c[M];
      P === void 0 && ((P = {}), (c[M] = P));
      let U = P[L];
      (U === void 0 &&
        ((U = b.clone()), (P[L] = U), S.addEventListener("dispose", x)),
        (b = U));
    }
    if (
      ((b.visible = S.visible),
      (b.wireframe = S.wireframe),
      _ === sa
        ? (b.side = S.shadowSide !== null ? S.shadowSide : S.side)
        : (b.side = S.shadowSide !== null ? S.shadowSide : h[S.side]),
      (b.alphaMap = S.alphaMap),
      (b.alphaTest = S.alphaToCoverage === !0 ? 0.5 : S.alphaTest),
      (b.map = S.map),
      (b.clipShadows = S.clipShadows),
      (b.clippingPlanes = S.clippingPlanes),
      (b.clipIntersection = S.clipIntersection),
      (b.displacementMap = S.displacementMap),
      (b.displacementScale = S.displacementScale),
      (b.displacementBias = S.displacementBias),
      (b.wireframeLinewidth = S.wireframeLinewidth),
      (b.linewidth = S.linewidth),
      E.isPointLight === !0 && b.isMeshDistanceMaterial === !0)
    ) {
      const M = n.properties.get(b);
      M.light = E;
    }
    return b;
  }
  function y(T, S, E, _, b) {
    if (T.visible === !1) return;
    if (
      T.layers.test(S.layers) &&
      (T.isMesh || T.isLine || T.isPoints) &&
      (T.castShadow || (T.receiveShadow && b === sa)) &&
      (!T.frustumCulled || i.intersectsObject(T))
    ) {
      T.modelViewMatrix.multiplyMatrices(E.matrixWorldInverse, T.matrixWorld);
      const L = e.update(T),
        P = T.material;
      if (Array.isArray(P)) {
        const U = L.groups;
        for (let O = 0, V = U.length; O < V; O++) {
          const W = U[O],
            re = P[W.materialIndex];
          if (re && re.visible) {
            const Z = I(T, re, _, b);
            (T.onBeforeShadow(n, T, S, E, L, Z, W),
              n.renderBufferDirect(E, null, L, Z, T, W),
              T.onAfterShadow(n, T, S, E, L, Z, W));
          }
        }
      } else if (P.visible) {
        const U = I(T, P, _, b);
        (T.onBeforeShadow(n, T, S, E, L, U, null),
          n.renderBufferDirect(E, null, L, U, T, null),
          T.onAfterShadow(n, T, S, E, L, U, null));
      }
    }
    const M = T.children;
    for (let L = 0, P = M.length; L < P; L++) y(M[L], S, E, _, b);
  }
  function x(T) {
    T.target.removeEventListener("dispose", x);
    for (const E in c) {
      const _ = c[E],
        b = T.target.uuid;
      b in _ && (_[b].dispose(), delete _[b]);
    }
  }
}
const Qoe = {
  [d_]: f_,
  [g_]: C_,
  [p_]: I_,
  [rd]: m_,
  [f_]: d_,
  [C_]: g_,
  [I_]: p_,
  [m_]: rd,
};
function qoe(n, e) {
  function t() {
    let Y = !1;
    const Fe = new ln();
    let oe = null;
    const me = new ln(0, 0, 0, 0);
    return {
      setMask: function (Re) {
        oe !== Re && !Y && (n.colorMask(Re, Re, Re, Re), (oe = Re));
      },
      setLocked: function (Re) {
        Y = Re;
      },
      setClear: function (Re, Ge, at, Bn, Ii) {
        (Ii === !0 && ((Re *= Bn), (Ge *= Bn), (at *= Bn)),
          Fe.set(Re, Ge, at, Bn),
          me.equals(Fe) === !1 && (n.clearColor(Re, Ge, at, Bn), me.copy(Fe)));
      },
      reset: function () {
        ((Y = !1), (oe = null), me.set(-1, 0, 0, 0));
      },
    };
  }
  function i() {
    let Y = !1,
      Fe = !1,
      oe = null,
      me = null,
      Re = null;
    return {
      setReversed: function (Ge) {
        if (Fe !== Ge) {
          const at = e.get("EXT_clip_control");
          (Ge
            ? at.clipControlEXT(at.LOWER_LEFT_EXT, at.ZERO_TO_ONE_EXT)
            : at.clipControlEXT(at.LOWER_LEFT_EXT, at.NEGATIVE_ONE_TO_ONE_EXT),
            (Fe = Ge));
          const Bn = Re;
          ((Re = null), this.setClear(Bn));
        }
      },
      getReversed: function () {
        return Fe;
      },
      setTest: function (Ge) {
        Ge ? ae(n.DEPTH_TEST) : Ce(n.DEPTH_TEST);
      },
      setMask: function (Ge) {
        oe !== Ge && !Y && (n.depthMask(Ge), (oe = Ge));
      },
      setFunc: function (Ge) {
        if ((Fe && (Ge = Qoe[Ge]), me !== Ge)) {
          switch (Ge) {
            case d_:
              n.depthFunc(n.NEVER);
              break;
            case f_:
              n.depthFunc(n.ALWAYS);
              break;
            case g_:
              n.depthFunc(n.LESS);
              break;
            case rd:
              n.depthFunc(n.LEQUAL);
              break;
            case p_:
              n.depthFunc(n.EQUAL);
              break;
            case m_:
              n.depthFunc(n.GEQUAL);
              break;
            case C_:
              n.depthFunc(n.GREATER);
              break;
            case I_:
              n.depthFunc(n.NOTEQUAL);
              break;
            default:
              n.depthFunc(n.LEQUAL);
          }
          me = Ge;
        }
      },
      setLocked: function (Ge) {
        Y = Ge;
      },
      setClear: function (Ge) {
        Re !== Ge && (Fe && (Ge = 1 - Ge), n.clearDepth(Ge), (Re = Ge));
      },
      reset: function () {
        ((Y = !1), (oe = null), (me = null), (Re = null), (Fe = !1));
      },
    };
  }
  function r() {
    let Y = !1,
      Fe = null,
      oe = null,
      me = null,
      Re = null,
      Ge = null,
      at = null,
      Bn = null,
      Ii = null;
    return {
      setTest: function (yt) {
        Y || (yt ? ae(n.STENCIL_TEST) : Ce(n.STENCIL_TEST));
      },
      setMask: function (yt) {
        Fe !== yt && !Y && (n.stencilMask(yt), (Fe = yt));
      },
      setFunc: function (yt, Ar, ss) {
        (oe !== yt || me !== Ar || Re !== ss) &&
          (n.stencilFunc(yt, Ar, ss), (oe = yt), (me = Ar), (Re = ss));
      },
      setOp: function (yt, Ar, ss) {
        (Ge !== yt || at !== Ar || Bn !== ss) &&
          (n.stencilOp(yt, Ar, ss), (Ge = yt), (at = Ar), (Bn = ss));
      },
      setLocked: function (yt) {
        Y = yt;
      },
      setClear: function (yt) {
        Ii !== yt && (n.clearStencil(yt), (Ii = yt));
      },
      reset: function () {
        ((Y = !1),
          (Fe = null),
          (oe = null),
          (me = null),
          (Re = null),
          (Ge = null),
          (at = null),
          (Bn = null),
          (Ii = null));
      },
    };
  }
  const s = new t(),
    o = new i(),
    a = new r(),
    l = new WeakMap(),
    c = new WeakMap();
  let u = {},
    h = {},
    d = new WeakMap(),
    f = [],
    g = null,
    p = !1,
    m = null,
    C = null,
    A = null,
    I = null,
    y = null,
    x = null,
    T = null,
    S = new vt(0, 0, 0),
    E = 0,
    _ = !1,
    b = null,
    R = null,
    M = null,
    L = null,
    P = null;
  const U = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let O = !1,
    V = 0;
  const W = n.getParameter(n.VERSION);
  W.indexOf("WebGL") !== -1
    ? ((V = parseFloat(/^WebGL (\d)/.exec(W)[1])), (O = V >= 1))
    : W.indexOf("OpenGL ES") !== -1 &&
      ((V = parseFloat(/^OpenGL ES (\d)/.exec(W)[1])), (O = V >= 2));
  let re = null,
    Z = {};
  const te = n.getParameter(n.SCISSOR_BOX),
    ge = n.getParameter(n.VIEWPORT),
    be = new ln().fromArray(te),
    J = new ln().fromArray(ge);
  function se(Y, Fe, oe, me) {
    const Re = new Uint8Array(4),
      Ge = n.createTexture();
    (n.bindTexture(Y, Ge),
      n.texParameteri(Y, n.TEXTURE_MIN_FILTER, n.NEAREST),
      n.texParameteri(Y, n.TEXTURE_MAG_FILTER, n.NEAREST));
    for (let at = 0; at < oe; at++)
      Y === n.TEXTURE_3D || Y === n.TEXTURE_2D_ARRAY
        ? n.texImage3D(Fe, 0, n.RGBA, 1, 1, me, 0, n.RGBA, n.UNSIGNED_BYTE, Re)
        : n.texImage2D(
            Fe + at,
            0,
            n.RGBA,
            1,
            1,
            0,
            n.RGBA,
            n.UNSIGNED_BYTE,
            Re,
          );
    return Ge;
  }
  const ce = {};
  ((ce[n.TEXTURE_2D] = se(n.TEXTURE_2D, n.TEXTURE_2D, 1)),
    (ce[n.TEXTURE_CUBE_MAP] = se(
      n.TEXTURE_CUBE_MAP,
      n.TEXTURE_CUBE_MAP_POSITIVE_X,
      6,
    )),
    (ce[n.TEXTURE_2D_ARRAY] = se(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1)),
    (ce[n.TEXTURE_3D] = se(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1)),
    s.setClear(0, 0, 0, 1),
    o.setClear(1),
    a.setClear(0),
    ae(n.DEPTH_TEST),
    o.setFunc(rd),
    Mt(!1),
    ot(Gx),
    ae(n.CULL_FACE),
    H(wl));
  function ae(Y) {
    u[Y] !== !0 && (n.enable(Y), (u[Y] = !0));
  }
  function Ce(Y) {
    u[Y] !== !1 && (n.disable(Y), (u[Y] = !1));
  }
  function $e(Y, Fe) {
    return h[Y] !== Fe
      ? (n.bindFramebuffer(Y, Fe),
        (h[Y] = Fe),
        Y === n.DRAW_FRAMEBUFFER && (h[n.FRAMEBUFFER] = Fe),
        Y === n.FRAMEBUFFER && (h[n.DRAW_FRAMEBUFFER] = Fe),
        !0)
      : !1;
  }
  function Te(Y, Fe) {
    let oe = f,
      me = !1;
    if (Y) {
      ((oe = d.get(Fe)), oe === void 0 && ((oe = []), d.set(Fe, oe)));
      const Re = Y.textures;
      if (oe.length !== Re.length || oe[0] !== n.COLOR_ATTACHMENT0) {
        for (let Ge = 0, at = Re.length; Ge < at; Ge++)
          oe[Ge] = n.COLOR_ATTACHMENT0 + Ge;
        ((oe.length = Re.length), (me = !0));
      }
    } else oe[0] !== n.BACK && ((oe[0] = n.BACK), (me = !0));
    me && n.drawBuffers(oe);
  }
  function it(Y) {
    return g !== Y ? (n.useProgram(Y), (g = Y), !0) : !1;
  }
  const ct = {
    [Fc]: n.FUNC_ADD,
    [aee]: n.FUNC_SUBTRACT,
    [lee]: n.FUNC_REVERSE_SUBTRACT,
  };
  ((ct[cee] = n.MIN), (ct[uee] = n.MAX));
  const qe = {
    [hee]: n.ZERO,
    [dee]: n.ONE,
    [fee]: n.SRC_COLOR,
    [u_]: n.SRC_ALPHA,
    [Aee]: n.SRC_ALPHA_SATURATE,
    [Cee]: n.DST_COLOR,
    [pee]: n.DST_ALPHA,
    [gee]: n.ONE_MINUS_SRC_COLOR,
    [h_]: n.ONE_MINUS_SRC_ALPHA,
    [Iee]: n.ONE_MINUS_DST_COLOR,
    [mee]: n.ONE_MINUS_DST_ALPHA,
    [yee]: n.CONSTANT_COLOR,
    [_ee]: n.ONE_MINUS_CONSTANT_COLOR,
    [bee]: n.CONSTANT_ALPHA,
    [vee]: n.ONE_MINUS_CONSTANT_ALPHA,
  };
  function H(Y, Fe, oe, me, Re, Ge, at, Bn, Ii, yt) {
    if (Y === wl) {
      p === !0 && (Ce(n.BLEND), (p = !1));
      return;
    }
    if ((p === !1 && (ae(n.BLEND), (p = !0)), Y !== oee)) {
      if (Y !== m || yt !== _) {
        if (
          ((C !== Fc || y !== Fc) &&
            (n.blendEquation(n.FUNC_ADD), (C = Fc), (y = Fc)),
          yt)
        )
          switch (Y) {
            case Ph:
              n.blendFuncSeparate(
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA,
              );
              break;
            case c_:
              n.blendFunc(n.ONE, n.ONE);
              break;
            case Fx:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case kx:
              n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Y);
              break;
          }
        else
          switch (Y) {
            case Ph:
              n.blendFuncSeparate(
                n.SRC_ALPHA,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA,
              );
              break;
            case c_:
              n.blendFunc(n.SRC_ALPHA, n.ONE);
              break;
            case Fx:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case kx:
              n.blendFunc(n.ZERO, n.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Y);
              break;
          }
        ((A = null),
          (I = null),
          (x = null),
          (T = null),
          S.set(0, 0, 0),
          (E = 0),
          (m = Y),
          (_ = yt));
      }
      return;
    }
    ((Re = Re || Fe),
      (Ge = Ge || oe),
      (at = at || me),
      (Fe !== C || Re !== y) &&
        (n.blendEquationSeparate(ct[Fe], ct[Re]), (C = Fe), (y = Re)),
      (oe !== A || me !== I || Ge !== x || at !== T) &&
        (n.blendFuncSeparate(qe[oe], qe[me], qe[Ge], qe[at]),
        (A = oe),
        (I = me),
        (x = Ge),
        (T = at)),
      (Bn.equals(S) === !1 || Ii !== E) &&
        (n.blendColor(Bn.r, Bn.g, Bn.b, Ii), S.copy(Bn), (E = Ii)),
      (m = Y),
      (_ = !1));
  }
  function tn(Y, Fe) {
    Y.side === Ao ? Ce(n.CULL_FACE) : ae(n.CULL_FACE);
    let oe = Y.side === er;
    (Fe && (oe = !oe),
      Mt(oe),
      Y.blending === Ph && Y.transparent === !1
        ? H(wl)
        : H(
            Y.blending,
            Y.blendEquation,
            Y.blendSrc,
            Y.blendDst,
            Y.blendEquationAlpha,
            Y.blendSrcAlpha,
            Y.blendDstAlpha,
            Y.blendColor,
            Y.blendAlpha,
            Y.premultipliedAlpha,
          ),
      o.setFunc(Y.depthFunc),
      o.setTest(Y.depthTest),
      o.setMask(Y.depthWrite),
      s.setMask(Y.colorWrite));
    const me = Y.stencilWrite;
    (a.setTest(me),
      me &&
        (a.setMask(Y.stencilWriteMask),
        a.setFunc(Y.stencilFunc, Y.stencilRef, Y.stencilFuncMask),
        a.setOp(Y.stencilFail, Y.stencilZFail, Y.stencilZPass)),
      _n(Y.polygonOffset, Y.polygonOffsetFactor, Y.polygonOffsetUnits),
      Y.alphaToCoverage === !0
        ? ae(n.SAMPLE_ALPHA_TO_COVERAGE)
        : Ce(n.SAMPLE_ALPHA_TO_COVERAGE));
  }
  function Mt(Y) {
    b !== Y && (Y ? n.frontFace(n.CW) : n.frontFace(n.CCW), (b = Y));
  }
  function ot(Y) {
    (Y !== iee
      ? (ae(n.CULL_FACE),
        Y !== R &&
          (Y === Gx
            ? n.cullFace(n.BACK)
            : Y === ree
              ? n.cullFace(n.FRONT)
              : n.cullFace(n.FRONT_AND_BACK)))
      : Ce(n.CULL_FACE),
      (R = Y));
  }
  function Ae(Y) {
    Y !== M && (O && n.lineWidth(Y), (M = Y));
  }
  function _n(Y, Fe, oe) {
    Y
      ? (ae(n.POLYGON_OFFSET_FILL),
        (L !== Fe || P !== oe) && (n.polygonOffset(Fe, oe), (L = Fe), (P = oe)))
      : Ce(n.POLYGON_OFFSET_FILL);
  }
  function Ze(Y) {
    Y ? ae(n.SCISSOR_TEST) : Ce(n.SCISSOR_TEST);
  }
  function k(Y) {
    (Y === void 0 && (Y = n.TEXTURE0 + U - 1),
      re !== Y && (n.activeTexture(Y), (re = Y)));
  }
  function B(Y, Fe, oe) {
    oe === void 0 && (re === null ? (oe = n.TEXTURE0 + U - 1) : (oe = re));
    let me = Z[oe];
    (me === void 0 && ((me = { type: void 0, texture: void 0 }), (Z[oe] = me)),
      (me.type !== Y || me.texture !== Fe) &&
        (re !== oe && (n.activeTexture(oe), (re = oe)),
        n.bindTexture(Y, Fe || ce[Y]),
        (me.type = Y),
        (me.texture = Fe)));
  }
  function q() {
    const Y = Z[re];
    Y !== void 0 &&
      Y.type !== void 0 &&
      (n.bindTexture(Y.type, null), (Y.type = void 0), (Y.texture = void 0));
  }
  function fe() {
    try {
      n.compressedTexImage2D(...arguments);
    } catch (Y) {
      console.error("THREE.WebGLState:", Y);
    }
  }
  function Ie() {
    try {
      n.compressedTexImage3D(...arguments);
    } catch (Y) {
      console.error("THREE.WebGLState:", Y);
    }
  }
  function le() {
    try {
      n.texSubImage2D(...arguments);
    } catch (Y) {
      console.error("THREE.WebGLState:", Y);
    }
  }
  function Ke() {
    try {
      n.texSubImage3D(...arguments);
    } catch (Y) {
      console.error("THREE.WebGLState:", Y);
    }
  }
  function Ee() {
    try {
      n.compressedTexSubImage2D(...arguments);
    } catch (Y) {
      console.error("THREE.WebGLState:", Y);
    }
  }
  function rt() {
    try {
      n.compressedTexSubImage3D(...arguments);
    } catch (Y) {
      console.error("THREE.WebGLState:", Y);
    }
  }
  function pt() {
    try {
      n.texStorage2D(...arguments);
    } catch (Y) {
      console.error("THREE.WebGLState:", Y);
    }
  }
  function ye() {
    try {
      n.texStorage3D(...arguments);
    } catch (Y) {
      console.error("THREE.WebGLState:", Y);
    }
  }
  function Ue() {
    try {
      n.texImage2D(...arguments);
    } catch (Y) {
      console.error("THREE.WebGLState:", Y);
    }
  }
  function ut() {
    try {
      n.texImage3D(...arguments);
    } catch (Y) {
      console.error("THREE.WebGLState:", Y);
    }
  }
  function ht(Y) {
    be.equals(Y) === !1 && (n.scissor(Y.x, Y.y, Y.z, Y.w), be.copy(Y));
  }
  function ze(Y) {
    J.equals(Y) === !1 && (n.viewport(Y.x, Y.y, Y.z, Y.w), J.copy(Y));
  }
  function Ft(Y, Fe) {
    let oe = c.get(Fe);
    oe === void 0 && ((oe = new WeakMap()), c.set(Fe, oe));
    let me = oe.get(Y);
    me === void 0 && ((me = n.getUniformBlockIndex(Fe, Y.name)), oe.set(Y, me));
  }
  function Lt(Y, Fe) {
    const me = c.get(Fe).get(Y);
    l.get(Fe) !== me &&
      (n.uniformBlockBinding(Fe, me, Y.__bindingPointIndex), l.set(Fe, me));
  }
  function pn() {
    (n.disable(n.BLEND),
      n.disable(n.CULL_FACE),
      n.disable(n.DEPTH_TEST),
      n.disable(n.POLYGON_OFFSET_FILL),
      n.disable(n.SCISSOR_TEST),
      n.disable(n.STENCIL_TEST),
      n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
      n.blendEquation(n.FUNC_ADD),
      n.blendFunc(n.ONE, n.ZERO),
      n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
      n.blendColor(0, 0, 0, 0),
      n.colorMask(!0, !0, !0, !0),
      n.clearColor(0, 0, 0, 0),
      n.depthMask(!0),
      n.depthFunc(n.LESS),
      o.setReversed(!1),
      n.clearDepth(1),
      n.stencilMask(4294967295),
      n.stencilFunc(n.ALWAYS, 0, 4294967295),
      n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
      n.clearStencil(0),
      n.cullFace(n.BACK),
      n.frontFace(n.CCW),
      n.polygonOffset(0, 0),
      n.activeTexture(n.TEXTURE0),
      n.bindFramebuffer(n.FRAMEBUFFER, null),
      n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
      n.bindFramebuffer(n.READ_FRAMEBUFFER, null),
      n.useProgram(null),
      n.lineWidth(1),
      n.scissor(0, 0, n.canvas.width, n.canvas.height),
      n.viewport(0, 0, n.canvas.width, n.canvas.height),
      (u = {}),
      (re = null),
      (Z = {}),
      (h = {}),
      (d = new WeakMap()),
      (f = []),
      (g = null),
      (p = !1),
      (m = null),
      (C = null),
      (A = null),
      (I = null),
      (y = null),
      (x = null),
      (T = null),
      (S = new vt(0, 0, 0)),
      (E = 0),
      (_ = !1),
      (b = null),
      (R = null),
      (M = null),
      (L = null),
      (P = null),
      be.set(0, 0, n.canvas.width, n.canvas.height),
      J.set(0, 0, n.canvas.width, n.canvas.height),
      s.reset(),
      o.reset(),
      a.reset());
  }
  return {
    buffers: { color: s, depth: o, stencil: a },
    enable: ae,
    disable: Ce,
    bindFramebuffer: $e,
    drawBuffers: Te,
    useProgram: it,
    setBlending: H,
    setMaterial: tn,
    setFlipSided: Mt,
    setCullFace: ot,
    setLineWidth: Ae,
    setPolygonOffset: _n,
    setScissorTest: Ze,
    activeTexture: k,
    bindTexture: B,
    unbindTexture: q,
    compressedTexImage2D: fe,
    compressedTexImage3D: Ie,
    texImage2D: Ue,
    texImage3D: ut,
    updateUBOMapping: Ft,
    uniformBlockBinding: Lt,
    texStorage2D: pt,
    texStorage3D: ye,
    texSubImage2D: le,
    texSubImage3D: Ke,
    compressedTexSubImage2D: Ee,
    compressedTexSubImage3D: rt,
    scissor: ht,
    viewport: ze,
    reset: pn,
  };
}
function eae(n, e, t, i, r, s, o) {
  const a = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    l =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    c = new Gt(),
    u = new WeakMap();
  let h;
  const d = new WeakMap();
  let f = !1;
  try {
    f =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function g(k, B) {
    return f ? new OffscreenCanvas(k, B) : Gg("canvas");
  }
  function p(k, B, q) {
    let fe = 1;
    const Ie = Ze(k);
    if (
      ((Ie.width > q || Ie.height > q) &&
        (fe = q / Math.max(Ie.width, Ie.height)),
      fe < 1)
    )
      if (
        (typeof HTMLImageElement < "u" && k instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && k instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && k instanceof ImageBitmap) ||
        (typeof VideoFrame < "u" && k instanceof VideoFrame)
      ) {
        const le = Math.floor(fe * Ie.width),
          Ke = Math.floor(fe * Ie.height);
        h === void 0 && (h = g(le, Ke));
        const Ee = B ? g(le, Ke) : h;
        return (
          (Ee.width = le),
          (Ee.height = Ke),
          Ee.getContext("2d").drawImage(k, 0, 0, le, Ke),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              Ie.width +
              "x" +
              Ie.height +
              ") to (" +
              le +
              "x" +
              Ke +
              ").",
          ),
          Ee
        );
      } else
        return (
          "data" in k &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                Ie.width +
                "x" +
                Ie.height +
                ").",
            ),
          k
        );
    return k;
  }
  function m(k) {
    return k.generateMipmaps;
  }
  function C(k) {
    n.generateMipmap(k);
  }
  function A(k) {
    return k.isWebGLCubeRenderTarget
      ? n.TEXTURE_CUBE_MAP
      : k.isWebGL3DRenderTarget
        ? n.TEXTURE_3D
        : k.isWebGLArrayRenderTarget || k.isCompressedArrayTexture
          ? n.TEXTURE_2D_ARRAY
          : n.TEXTURE_2D;
  }
  function I(k, B, q, fe, Ie = !1) {
    if (k !== null) {
      if (n[k] !== void 0) return n[k];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          k +
          "'",
      );
    }
    let le = B;
    if (
      (B === n.RED &&
        (q === n.FLOAT && (le = n.R32F),
        q === n.HALF_FLOAT && (le = n.R16F),
        q === n.UNSIGNED_BYTE && (le = n.R8)),
      B === n.RED_INTEGER &&
        (q === n.UNSIGNED_BYTE && (le = n.R8UI),
        q === n.UNSIGNED_SHORT && (le = n.R16UI),
        q === n.UNSIGNED_INT && (le = n.R32UI),
        q === n.BYTE && (le = n.R8I),
        q === n.SHORT && (le = n.R16I),
        q === n.INT && (le = n.R32I)),
      B === n.RG &&
        (q === n.FLOAT && (le = n.RG32F),
        q === n.HALF_FLOAT && (le = n.RG16F),
        q === n.UNSIGNED_BYTE && (le = n.RG8)),
      B === n.RG_INTEGER &&
        (q === n.UNSIGNED_BYTE && (le = n.RG8UI),
        q === n.UNSIGNED_SHORT && (le = n.RG16UI),
        q === n.UNSIGNED_INT && (le = n.RG32UI),
        q === n.BYTE && (le = n.RG8I),
        q === n.SHORT && (le = n.RG16I),
        q === n.INT && (le = n.RG32I)),
      B === n.RGB_INTEGER &&
        (q === n.UNSIGNED_BYTE && (le = n.RGB8UI),
        q === n.UNSIGNED_SHORT && (le = n.RGB16UI),
        q === n.UNSIGNED_INT && (le = n.RGB32UI),
        q === n.BYTE && (le = n.RGB8I),
        q === n.SHORT && (le = n.RGB16I),
        q === n.INT && (le = n.RGB32I)),
      B === n.RGBA_INTEGER &&
        (q === n.UNSIGNED_BYTE && (le = n.RGBA8UI),
        q === n.UNSIGNED_SHORT && (le = n.RGBA16UI),
        q === n.UNSIGNED_INT && (le = n.RGBA32UI),
        q === n.BYTE && (le = n.RGBA8I),
        q === n.SHORT && (le = n.RGBA16I),
        q === n.INT && (le = n.RGBA32I)),
      B === n.RGB && q === n.UNSIGNED_INT_5_9_9_9_REV && (le = n.RGB9_E5),
      B === n.RGBA)
    ) {
      const Ke = Ie ? Xm : Kt.getTransfer(fe);
      (q === n.FLOAT && (le = n.RGBA32F),
        q === n.HALF_FLOAT && (le = n.RGBA16F),
        q === n.UNSIGNED_BYTE && (le = Ke === mn ? n.SRGB8_ALPHA8 : n.RGBA8),
        q === n.UNSIGNED_SHORT_4_4_4_4 && (le = n.RGBA4),
        q === n.UNSIGNED_SHORT_5_5_5_1 && (le = n.RGB5_A1));
    }
    return (
      (le === n.R16F ||
        le === n.R32F ||
        le === n.RG16F ||
        le === n.RG32F ||
        le === n.RGBA16F ||
        le === n.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      le
    );
  }
  function y(k, B) {
    let q;
    return (
      k
        ? B === null || B === gu || B === Rg
          ? (q = n.DEPTH24_STENCIL8)
          : B === Xr
            ? (q = n.DEPTH32F_STENCIL8)
            : B === Lg &&
              ((q = n.DEPTH24_STENCIL8),
              console.warn(
                "DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.",
              ))
        : B === null || B === gu || B === Rg
          ? (q = n.DEPTH_COMPONENT24)
          : B === Xr
            ? (q = n.DEPTH_COMPONENT32F)
            : B === Lg && (q = n.DEPTH_COMPONENT16),
      q
    );
  }
  function x(k, B) {
    return m(k) === !0 ||
      (k.isFramebufferTexture && k.minFilter !== gi && k.minFilter !== Yr)
      ? Math.log2(Math.max(B.width, B.height)) + 1
      : k.mipmaps !== void 0 && k.mipmaps.length > 0
        ? k.mipmaps.length
        : k.isCompressedTexture && Array.isArray(k.image)
          ? B.mipmaps.length
          : 1;
  }
  function T(k) {
    const B = k.target;
    (B.removeEventListener("dispose", T),
      E(B),
      B.isVideoTexture && u.delete(B));
  }
  function S(k) {
    const B = k.target;
    (B.removeEventListener("dispose", S), b(B));
  }
  function E(k) {
    const B = i.get(k);
    if (B.__webglInit === void 0) return;
    const q = k.source,
      fe = d.get(q);
    if (fe) {
      const Ie = fe[B.__cacheKey];
      (Ie.usedTimes--,
        Ie.usedTimes === 0 && _(k),
        Object.keys(fe).length === 0 && d.delete(q));
    }
    i.remove(k);
  }
  function _(k) {
    const B = i.get(k);
    n.deleteTexture(B.__webglTexture);
    const q = k.source,
      fe = d.get(q);
    (delete fe[B.__cacheKey], o.memory.textures--);
  }
  function b(k) {
    const B = i.get(k);
    if (
      (k.depthTexture && (k.depthTexture.dispose(), i.remove(k.depthTexture)),
      k.isWebGLCubeRenderTarget)
    )
      for (let fe = 0; fe < 6; fe++) {
        if (Array.isArray(B.__webglFramebuffer[fe]))
          for (let Ie = 0; Ie < B.__webglFramebuffer[fe].length; Ie++)
            n.deleteFramebuffer(B.__webglFramebuffer[fe][Ie]);
        else n.deleteFramebuffer(B.__webglFramebuffer[fe]);
        B.__webglDepthbuffer && n.deleteRenderbuffer(B.__webglDepthbuffer[fe]);
      }
    else {
      if (Array.isArray(B.__webglFramebuffer))
        for (let fe = 0; fe < B.__webglFramebuffer.length; fe++)
          n.deleteFramebuffer(B.__webglFramebuffer[fe]);
      else n.deleteFramebuffer(B.__webglFramebuffer);
      if (
        (B.__webglDepthbuffer && n.deleteRenderbuffer(B.__webglDepthbuffer),
        B.__webglMultisampledFramebuffer &&
          n.deleteFramebuffer(B.__webglMultisampledFramebuffer),
        B.__webglColorRenderbuffer)
      )
        for (let fe = 0; fe < B.__webglColorRenderbuffer.length; fe++)
          B.__webglColorRenderbuffer[fe] &&
            n.deleteRenderbuffer(B.__webglColorRenderbuffer[fe]);
      B.__webglDepthRenderbuffer &&
        n.deleteRenderbuffer(B.__webglDepthRenderbuffer);
    }
    const q = k.textures;
    for (let fe = 0, Ie = q.length; fe < Ie; fe++) {
      const le = i.get(q[fe]);
      (le.__webglTexture &&
        (n.deleteTexture(le.__webglTexture), o.memory.textures--),
        i.remove(q[fe]));
    }
    i.remove(k);
  }
  let R = 0;
  function M() {
    R = 0;
  }
  function L() {
    const k = R;
    return (
      k >= r.maxTextures &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            k +
            " texture units while this GPU supports only " +
            r.maxTextures,
        ),
      (R += 1),
      k
    );
  }
  function P(k) {
    const B = [];
    return (
      B.push(k.wrapS),
      B.push(k.wrapT),
      B.push(k.wrapR || 0),
      B.push(k.magFilter),
      B.push(k.minFilter),
      B.push(k.anisotropy),
      B.push(k.internalFormat),
      B.push(k.format),
      B.push(k.type),
      B.push(k.generateMipmaps),
      B.push(k.premultiplyAlpha),
      B.push(k.flipY),
      B.push(k.unpackAlignment),
      B.push(k.colorSpace),
      B.join()
    );
  }
  function U(k, B) {
    const q = i.get(k);
    if (
      (k.isVideoTexture && Ae(k),
      k.isRenderTargetTexture === !1 &&
        k.version > 0 &&
        q.__version !== k.version)
    ) {
      const fe = k.image;
      if (fe === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found.",
        );
      else if (fe.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete",
        );
      else {
        J(q, k, B);
        return;
      }
    }
    t.bindTexture(n.TEXTURE_2D, q.__webglTexture, n.TEXTURE0 + B);
  }
  function O(k, B) {
    const q = i.get(k);
    if (k.version > 0 && q.__version !== k.version) {
      J(q, k, B);
      return;
    }
    t.bindTexture(n.TEXTURE_2D_ARRAY, q.__webglTexture, n.TEXTURE0 + B);
  }
  function V(k, B) {
    const q = i.get(k);
    if (k.version > 0 && q.__version !== k.version) {
      J(q, k, B);
      return;
    }
    t.bindTexture(n.TEXTURE_3D, q.__webglTexture, n.TEXTURE0 + B);
  }
  function W(k, B) {
    const q = i.get(k);
    if (k.version > 0 && q.__version !== k.version) {
      se(q, k, B);
      return;
    }
    t.bindTexture(n.TEXTURE_CUBE_MAP, q.__webglTexture, n.TEXTURE0 + B);
  }
  const re = { [ad]: n.REPEAT, [xo]: n.CLAMP_TO_EDGE, [zm]: n.MIRRORED_REPEAT },
    Z = {
      [gi]: n.NEAREST,
      [ZL]: n.NEAREST_MIPMAP_NEAREST,
      [Ff]: n.NEAREST_MIPMAP_LINEAR,
      [Yr]: n.LINEAR,
      [F0]: n.LINEAR_MIPMAP_NEAREST,
      [ga]: n.LINEAR_MIPMAP_LINEAR,
    },
    te = {
      [Hee]: n.NEVER,
      [Xee]: n.ALWAYS,
      [Wee]: n.LESS,
      [eR]: n.LEQUAL,
      [Vee]: n.EQUAL,
      [Yee]: n.GEQUAL,
      [Zee]: n.GREATER,
      [zee]: n.NOTEQUAL,
    };
  function ge(k, B) {
    if (
      (B.type === Xr &&
        e.has("OES_texture_float_linear") === !1 &&
        (B.magFilter === Yr ||
          B.magFilter === F0 ||
          B.magFilter === Ff ||
          B.magFilter === ga ||
          B.minFilter === Yr ||
          B.minFilter === F0 ||
          B.minFilter === Ff ||
          B.minFilter === ga) &&
        console.warn(
          "THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.",
        ),
      n.texParameteri(k, n.TEXTURE_WRAP_S, re[B.wrapS]),
      n.texParameteri(k, n.TEXTURE_WRAP_T, re[B.wrapT]),
      (k === n.TEXTURE_3D || k === n.TEXTURE_2D_ARRAY) &&
        n.texParameteri(k, n.TEXTURE_WRAP_R, re[B.wrapR]),
      n.texParameteri(k, n.TEXTURE_MAG_FILTER, Z[B.magFilter]),
      n.texParameteri(k, n.TEXTURE_MIN_FILTER, Z[B.minFilter]),
      B.compareFunction &&
        (n.texParameteri(k, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE),
        n.texParameteri(k, n.TEXTURE_COMPARE_FUNC, te[B.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      if (
        B.magFilter === gi ||
        (B.minFilter !== Ff && B.minFilter !== ga) ||
        (B.type === Xr && e.has("OES_texture_float_linear") === !1)
      )
        return;
      if (B.anisotropy > 1 || i.get(B).__currentAnisotropy) {
        const q = e.get("EXT_texture_filter_anisotropic");
        (n.texParameterf(
          k,
          q.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(B.anisotropy, r.getMaxAnisotropy()),
        ),
          (i.get(B).__currentAnisotropy = B.anisotropy));
      }
    }
  }
  function be(k, B) {
    let q = !1;
    k.__webglInit === void 0 &&
      ((k.__webglInit = !0), B.addEventListener("dispose", T));
    const fe = B.source;
    let Ie = d.get(fe);
    Ie === void 0 && ((Ie = {}), d.set(fe, Ie));
    const le = P(B);
    if (le !== k.__cacheKey) {
      (Ie[le] === void 0 &&
        ((Ie[le] = { texture: n.createTexture(), usedTimes: 0 }),
        o.memory.textures++,
        (q = !0)),
        Ie[le].usedTimes++);
      const Ke = Ie[k.__cacheKey];
      (Ke !== void 0 &&
        (Ie[k.__cacheKey].usedTimes--, Ke.usedTimes === 0 && _(B)),
        (k.__cacheKey = le),
        (k.__webglTexture = Ie[le].texture));
    }
    return q;
  }
  function J(k, B, q) {
    let fe = n.TEXTURE_2D;
    ((B.isDataArrayTexture || B.isCompressedArrayTexture) &&
      (fe = n.TEXTURE_2D_ARRAY),
      B.isData3DTexture && (fe = n.TEXTURE_3D));
    const Ie = be(k, B),
      le = B.source;
    t.bindTexture(fe, k.__webglTexture, n.TEXTURE0 + q);
    const Ke = i.get(le);
    if (le.version !== Ke.__version || Ie === !0) {
      t.activeTexture(n.TEXTURE0 + q);
      const Ee = Kt.getPrimaries(Kt.workingColorSpace),
        rt = B.colorSpace === dl ? null : Kt.getPrimaries(B.colorSpace),
        pt =
          B.colorSpace === dl || Ee === rt ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      (n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, B.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, B.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, B.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, pt));
      let ye = p(B.image, !1, r.maxTextureSize);
      ye = _n(B, ye);
      const Ue = s.convert(B.format, B.colorSpace),
        ut = s.convert(B.type);
      let ht = I(B.internalFormat, Ue, ut, B.colorSpace, B.isVideoTexture);
      ge(fe, B);
      let ze;
      const Ft = B.mipmaps,
        Lt = B.isVideoTexture !== !0,
        pn = Ke.__version === void 0 || Ie === !0,
        Y = le.dataReady,
        Fe = x(B, ye);
      if (B.isDepthTexture)
        ((ht = y(B.format === Pg, B.type)),
          pn &&
            (Lt
              ? t.texStorage2D(n.TEXTURE_2D, 1, ht, ye.width, ye.height)
              : t.texImage2D(
                  n.TEXTURE_2D,
                  0,
                  ht,
                  ye.width,
                  ye.height,
                  0,
                  Ue,
                  ut,
                  null,
                )));
      else if (B.isDataTexture)
        if (Ft.length > 0) {
          Lt &&
            pn &&
            t.texStorage2D(n.TEXTURE_2D, Fe, ht, Ft[0].width, Ft[0].height);
          for (let oe = 0, me = Ft.length; oe < me; oe++)
            ((ze = Ft[oe]),
              Lt
                ? Y &&
                  t.texSubImage2D(
                    n.TEXTURE_2D,
                    oe,
                    0,
                    0,
                    ze.width,
                    ze.height,
                    Ue,
                    ut,
                    ze.data,
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    oe,
                    ht,
                    ze.width,
                    ze.height,
                    0,
                    Ue,
                    ut,
                    ze.data,
                  ));
          B.generateMipmaps = !1;
        } else
          Lt
            ? (pn && t.texStorage2D(n.TEXTURE_2D, Fe, ht, ye.width, ye.height),
              Y &&
                t.texSubImage2D(
                  n.TEXTURE_2D,
                  0,
                  0,
                  0,
                  ye.width,
                  ye.height,
                  Ue,
                  ut,
                  ye.data,
                ))
            : t.texImage2D(
                n.TEXTURE_2D,
                0,
                ht,
                ye.width,
                ye.height,
                0,
                Ue,
                ut,
                ye.data,
              );
      else if (B.isCompressedTexture)
        if (B.isCompressedArrayTexture) {
          Lt &&
            pn &&
            t.texStorage3D(
              n.TEXTURE_2D_ARRAY,
              Fe,
              ht,
              Ft[0].width,
              Ft[0].height,
              ye.depth,
            );
          for (let oe = 0, me = Ft.length; oe < me; oe++)
            if (((ze = Ft[oe]), B.format !== Sr))
              if (Ue !== null)
                if (Lt) {
                  if (Y)
                    if (B.layerUpdates.size > 0) {
                      const Re = Ew(ze.width, ze.height, B.format, B.type);
                      for (const Ge of B.layerUpdates) {
                        const at = ze.data.subarray(
                          (Ge * Re) / ze.data.BYTES_PER_ELEMENT,
                          ((Ge + 1) * Re) / ze.data.BYTES_PER_ELEMENT,
                        );
                        t.compressedTexSubImage3D(
                          n.TEXTURE_2D_ARRAY,
                          oe,
                          0,
                          0,
                          Ge,
                          ze.width,
                          ze.height,
                          1,
                          Ue,
                          at,
                        );
                      }
                      B.clearLayerUpdates();
                    } else
                      t.compressedTexSubImage3D(
                        n.TEXTURE_2D_ARRAY,
                        oe,
                        0,
                        0,
                        0,
                        ze.width,
                        ze.height,
                        ye.depth,
                        Ue,
                        ze.data,
                      );
                } else
                  t.compressedTexImage3D(
                    n.TEXTURE_2D_ARRAY,
                    oe,
                    ht,
                    ze.width,
                    ze.height,
                    ye.depth,
                    0,
                    ze.data,
                    0,
                    0,
                  );
              else
                console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()",
                );
            else
              Lt
                ? Y &&
                  t.texSubImage3D(
                    n.TEXTURE_2D_ARRAY,
                    oe,
                    0,
                    0,
                    0,
                    ze.width,
                    ze.height,
                    ye.depth,
                    Ue,
                    ut,
                    ze.data,
                  )
                : t.texImage3D(
                    n.TEXTURE_2D_ARRAY,
                    oe,
                    ht,
                    ze.width,
                    ze.height,
                    ye.depth,
                    0,
                    Ue,
                    ut,
                    ze.data,
                  );
        } else {
          Lt &&
            pn &&
            t.texStorage2D(n.TEXTURE_2D, Fe, ht, Ft[0].width, Ft[0].height);
          for (let oe = 0, me = Ft.length; oe < me; oe++)
            ((ze = Ft[oe]),
              B.format !== Sr
                ? Ue !== null
                  ? Lt
                    ? Y &&
                      t.compressedTexSubImage2D(
                        n.TEXTURE_2D,
                        oe,
                        0,
                        0,
                        ze.width,
                        ze.height,
                        Ue,
                        ze.data,
                      )
                    : t.compressedTexImage2D(
                        n.TEXTURE_2D,
                        oe,
                        ht,
                        ze.width,
                        ze.height,
                        0,
                        ze.data,
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()",
                    )
                : Lt
                  ? Y &&
                    t.texSubImage2D(
                      n.TEXTURE_2D,
                      oe,
                      0,
                      0,
                      ze.width,
                      ze.height,
                      Ue,
                      ut,
                      ze.data,
                    )
                  : t.texImage2D(
                      n.TEXTURE_2D,
                      oe,
                      ht,
                      ze.width,
                      ze.height,
                      0,
                      Ue,
                      ut,
                      ze.data,
                    ));
        }
      else if (B.isDataArrayTexture)
        if (Lt) {
          if (
            (pn &&
              t.texStorage3D(
                n.TEXTURE_2D_ARRAY,
                Fe,
                ht,
                ye.width,
                ye.height,
                ye.depth,
              ),
            Y)
          )
            if (B.layerUpdates.size > 0) {
              const oe = Ew(ye.width, ye.height, B.format, B.type);
              for (const me of B.layerUpdates) {
                const Re = ye.data.subarray(
                  (me * oe) / ye.data.BYTES_PER_ELEMENT,
                  ((me + 1) * oe) / ye.data.BYTES_PER_ELEMENT,
                );
                t.texSubImage3D(
                  n.TEXTURE_2D_ARRAY,
                  0,
                  0,
                  0,
                  me,
                  ye.width,
                  ye.height,
                  1,
                  Ue,
                  ut,
                  Re,
                );
              }
              B.clearLayerUpdates();
            } else
              t.texSubImage3D(
                n.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                ye.width,
                ye.height,
                ye.depth,
                Ue,
                ut,
                ye.data,
              );
        } else
          t.texImage3D(
            n.TEXTURE_2D_ARRAY,
            0,
            ht,
            ye.width,
            ye.height,
            ye.depth,
            0,
            Ue,
            ut,
            ye.data,
          );
      else if (B.isData3DTexture)
        Lt
          ? (pn &&
              t.texStorage3D(
                n.TEXTURE_3D,
                Fe,
                ht,
                ye.width,
                ye.height,
                ye.depth,
              ),
            Y &&
              t.texSubImage3D(
                n.TEXTURE_3D,
                0,
                0,
                0,
                0,
                ye.width,
                ye.height,
                ye.depth,
                Ue,
                ut,
                ye.data,
              ))
          : t.texImage3D(
              n.TEXTURE_3D,
              0,
              ht,
              ye.width,
              ye.height,
              ye.depth,
              0,
              Ue,
              ut,
              ye.data,
            );
      else if (B.isFramebufferTexture) {
        if (pn)
          if (Lt) t.texStorage2D(n.TEXTURE_2D, Fe, ht, ye.width, ye.height);
          else {
            let oe = ye.width,
              me = ye.height;
            for (let Re = 0; Re < Fe; Re++)
              (t.texImage2D(n.TEXTURE_2D, Re, ht, oe, me, 0, Ue, ut, null),
                (oe >>= 1),
                (me >>= 1));
          }
      } else if (Ft.length > 0) {
        if (Lt && pn) {
          const oe = Ze(Ft[0]);
          t.texStorage2D(n.TEXTURE_2D, Fe, ht, oe.width, oe.height);
        }
        for (let oe = 0, me = Ft.length; oe < me; oe++)
          ((ze = Ft[oe]),
            Lt
              ? Y && t.texSubImage2D(n.TEXTURE_2D, oe, 0, 0, Ue, ut, ze)
              : t.texImage2D(n.TEXTURE_2D, oe, ht, Ue, ut, ze));
        B.generateMipmaps = !1;
      } else if (Lt) {
        if (pn) {
          const oe = Ze(ye);
          t.texStorage2D(n.TEXTURE_2D, Fe, ht, oe.width, oe.height);
        }
        Y && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, Ue, ut, ye);
      } else t.texImage2D(n.TEXTURE_2D, 0, ht, Ue, ut, ye);
      (m(B) && C(fe), (Ke.__version = le.version), B.onUpdate && B.onUpdate(B));
    }
    k.__version = B.version;
  }
  function se(k, B, q) {
    if (B.image.length !== 6) return;
    const fe = be(k, B),
      Ie = B.source;
    t.bindTexture(n.TEXTURE_CUBE_MAP, k.__webglTexture, n.TEXTURE0 + q);
    const le = i.get(Ie);
    if (Ie.version !== le.__version || fe === !0) {
      t.activeTexture(n.TEXTURE0 + q);
      const Ke = Kt.getPrimaries(Kt.workingColorSpace),
        Ee = B.colorSpace === dl ? null : Kt.getPrimaries(B.colorSpace),
        rt =
          B.colorSpace === dl || Ke === Ee ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      (n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, B.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, B.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, B.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, rt));
      const pt = B.isCompressedTexture || B.image[0].isCompressedTexture,
        ye = B.image[0] && B.image[0].isDataTexture,
        Ue = [];
      for (let me = 0; me < 6; me++)
        (!pt && !ye
          ? (Ue[me] = p(B.image[me], !0, r.maxCubemapSize))
          : (Ue[me] = ye ? B.image[me].image : B.image[me]),
          (Ue[me] = _n(B, Ue[me])));
      const ut = Ue[0],
        ht = s.convert(B.format, B.colorSpace),
        ze = s.convert(B.type),
        Ft = I(B.internalFormat, ht, ze, B.colorSpace),
        Lt = B.isVideoTexture !== !0,
        pn = le.__version === void 0 || fe === !0,
        Y = Ie.dataReady;
      let Fe = x(B, ut);
      ge(n.TEXTURE_CUBE_MAP, B);
      let oe;
      if (pt) {
        Lt &&
          pn &&
          t.texStorage2D(n.TEXTURE_CUBE_MAP, Fe, Ft, ut.width, ut.height);
        for (let me = 0; me < 6; me++) {
          oe = Ue[me].mipmaps;
          for (let Re = 0; Re < oe.length; Re++) {
            const Ge = oe[Re];
            B.format !== Sr
              ? ht !== null
                ? Lt
                  ? Y &&
                    t.compressedTexSubImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + me,
                      Re,
                      0,
                      0,
                      Ge.width,
                      Ge.height,
                      ht,
                      Ge.data,
                    )
                  : t.compressedTexImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + me,
                      Re,
                      Ft,
                      Ge.width,
                      Ge.height,
                      0,
                      Ge.data,
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()",
                  )
              : Lt
                ? Y &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + me,
                    Re,
                    0,
                    0,
                    Ge.width,
                    Ge.height,
                    ht,
                    ze,
                    Ge.data,
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + me,
                    Re,
                    Ft,
                    Ge.width,
                    Ge.height,
                    0,
                    ht,
                    ze,
                    Ge.data,
                  );
          }
        }
      } else {
        if (((oe = B.mipmaps), Lt && pn)) {
          oe.length > 0 && Fe++;
          const me = Ze(Ue[0]);
          t.texStorage2D(n.TEXTURE_CUBE_MAP, Fe, Ft, me.width, me.height);
        }
        for (let me = 0; me < 6; me++)
          if (ye) {
            Lt
              ? Y &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + me,
                  0,
                  0,
                  0,
                  Ue[me].width,
                  Ue[me].height,
                  ht,
                  ze,
                  Ue[me].data,
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + me,
                  0,
                  Ft,
                  Ue[me].width,
                  Ue[me].height,
                  0,
                  ht,
                  ze,
                  Ue[me].data,
                );
            for (let Re = 0; Re < oe.length; Re++) {
              const at = oe[Re].image[me].image;
              Lt
                ? Y &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + me,
                    Re + 1,
                    0,
                    0,
                    at.width,
                    at.height,
                    ht,
                    ze,
                    at.data,
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + me,
                    Re + 1,
                    Ft,
                    at.width,
                    at.height,
                    0,
                    ht,
                    ze,
                    at.data,
                  );
            }
          } else {
            Lt
              ? Y &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + me,
                  0,
                  0,
                  0,
                  ht,
                  ze,
                  Ue[me],
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + me,
                  0,
                  Ft,
                  ht,
                  ze,
                  Ue[me],
                );
            for (let Re = 0; Re < oe.length; Re++) {
              const Ge = oe[Re];
              Lt
                ? Y &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + me,
                    Re + 1,
                    0,
                    0,
                    ht,
                    ze,
                    Ge.image[me],
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + me,
                    Re + 1,
                    Ft,
                    ht,
                    ze,
                    Ge.image[me],
                  );
            }
          }
      }
      (m(B) && C(n.TEXTURE_CUBE_MAP),
        (le.__version = Ie.version),
        B.onUpdate && B.onUpdate(B));
    }
    k.__version = B.version;
  }
  function ce(k, B, q, fe, Ie, le) {
    const Ke = s.convert(q.format, q.colorSpace),
      Ee = s.convert(q.type),
      rt = I(q.internalFormat, Ke, Ee, q.colorSpace),
      pt = i.get(B),
      ye = i.get(q);
    if (((ye.__renderTarget = B), !pt.__hasExternalTextures)) {
      const Ue = Math.max(1, B.width >> le),
        ut = Math.max(1, B.height >> le);
      Ie === n.TEXTURE_3D || Ie === n.TEXTURE_2D_ARRAY
        ? t.texImage3D(Ie, le, rt, Ue, ut, B.depth, 0, Ke, Ee, null)
        : t.texImage2D(Ie, le, rt, Ue, ut, 0, Ke, Ee, null);
    }
    (t.bindFramebuffer(n.FRAMEBUFFER, k),
      ot(B)
        ? a.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            fe,
            Ie,
            ye.__webglTexture,
            0,
            Mt(B),
          )
        : (Ie === n.TEXTURE_2D ||
            (Ie >= n.TEXTURE_CUBE_MAP_POSITIVE_X &&
              Ie <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          n.framebufferTexture2D(n.FRAMEBUFFER, fe, Ie, ye.__webglTexture, le),
      t.bindFramebuffer(n.FRAMEBUFFER, null));
  }
  function ae(k, B, q) {
    if ((n.bindRenderbuffer(n.RENDERBUFFER, k), B.depthBuffer)) {
      const fe = B.depthTexture,
        Ie = fe && fe.isDepthTexture ? fe.type : null,
        le = y(B.stencilBuffer, Ie),
        Ke = B.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
        Ee = Mt(B);
      (ot(B)
        ? a.renderbufferStorageMultisampleEXT(
            n.RENDERBUFFER,
            Ee,
            le,
            B.width,
            B.height,
          )
        : q
          ? n.renderbufferStorageMultisample(
              n.RENDERBUFFER,
              Ee,
              le,
              B.width,
              B.height,
            )
          : n.renderbufferStorage(n.RENDERBUFFER, le, B.width, B.height),
        n.framebufferRenderbuffer(n.FRAMEBUFFER, Ke, n.RENDERBUFFER, k));
    } else {
      const fe = B.textures;
      for (let Ie = 0; Ie < fe.length; Ie++) {
        const le = fe[Ie],
          Ke = s.convert(le.format, le.colorSpace),
          Ee = s.convert(le.type),
          rt = I(le.internalFormat, Ke, Ee, le.colorSpace),
          pt = Mt(B);
        q && ot(B) === !1
          ? n.renderbufferStorageMultisample(
              n.RENDERBUFFER,
              pt,
              rt,
              B.width,
              B.height,
            )
          : ot(B)
            ? a.renderbufferStorageMultisampleEXT(
                n.RENDERBUFFER,
                pt,
                rt,
                B.width,
                B.height,
              )
            : n.renderbufferStorage(n.RENDERBUFFER, rt, B.width, B.height);
      }
    }
    n.bindRenderbuffer(n.RENDERBUFFER, null);
  }
  function Ce(k, B) {
    if (B && B.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported",
      );
    if (
      (t.bindFramebuffer(n.FRAMEBUFFER, k),
      !(B.depthTexture && B.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture",
      );
    const fe = i.get(B.depthTexture);
    ((fe.__renderTarget = B),
      (!fe.__webglTexture ||
        B.depthTexture.image.width !== B.width ||
        B.depthTexture.image.height !== B.height) &&
        ((B.depthTexture.image.width = B.width),
        (B.depthTexture.image.height = B.height),
        (B.depthTexture.needsUpdate = !0)),
      U(B.depthTexture, 0));
    const Ie = fe.__webglTexture,
      le = Mt(B);
    if (B.depthTexture.format === Bg)
      ot(B)
        ? a.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            Ie,
            0,
            le,
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            Ie,
            0,
          );
    else if (B.depthTexture.format === Pg)
      ot(B)
        ? a.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            Ie,
            0,
            le,
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            Ie,
            0,
          );
    else throw new Error("Unknown depthTexture format");
  }
  function $e(k) {
    const B = i.get(k),
      q = k.isWebGLCubeRenderTarget === !0;
    if (B.__boundDepthTexture !== k.depthTexture) {
      const fe = k.depthTexture;
      if ((B.__depthDisposeCallback && B.__depthDisposeCallback(), fe)) {
        const Ie = () => {
          (delete B.__boundDepthTexture,
            delete B.__depthDisposeCallback,
            fe.removeEventListener("dispose", Ie));
        };
        (fe.addEventListener("dispose", Ie), (B.__depthDisposeCallback = Ie));
      }
      B.__boundDepthTexture = fe;
    }
    if (k.depthTexture && !B.__autoAllocateDepthBuffer) {
      if (q)
        throw new Error(
          "target.depthTexture not supported in Cube render targets",
        );
      const fe = k.texture.mipmaps;
      fe && fe.length > 0
        ? Ce(B.__webglFramebuffer[0], k)
        : Ce(B.__webglFramebuffer, k);
    } else if (q) {
      B.__webglDepthbuffer = [];
      for (let fe = 0; fe < 6; fe++)
        if (
          (t.bindFramebuffer(n.FRAMEBUFFER, B.__webglFramebuffer[fe]),
          B.__webglDepthbuffer[fe] === void 0)
        )
          ((B.__webglDepthbuffer[fe] = n.createRenderbuffer()),
            ae(B.__webglDepthbuffer[fe], k, !1));
        else {
          const Ie = k.stencilBuffer
              ? n.DEPTH_STENCIL_ATTACHMENT
              : n.DEPTH_ATTACHMENT,
            le = B.__webglDepthbuffer[fe];
          (n.bindRenderbuffer(n.RENDERBUFFER, le),
            n.framebufferRenderbuffer(n.FRAMEBUFFER, Ie, n.RENDERBUFFER, le));
        }
    } else {
      const fe = k.texture.mipmaps;
      if (
        (fe && fe.length > 0
          ? t.bindFramebuffer(n.FRAMEBUFFER, B.__webglFramebuffer[0])
          : t.bindFramebuffer(n.FRAMEBUFFER, B.__webglFramebuffer),
        B.__webglDepthbuffer === void 0)
      )
        ((B.__webglDepthbuffer = n.createRenderbuffer()),
          ae(B.__webglDepthbuffer, k, !1));
      else {
        const Ie = k.stencilBuffer
            ? n.DEPTH_STENCIL_ATTACHMENT
            : n.DEPTH_ATTACHMENT,
          le = B.__webglDepthbuffer;
        (n.bindRenderbuffer(n.RENDERBUFFER, le),
          n.framebufferRenderbuffer(n.FRAMEBUFFER, Ie, n.RENDERBUFFER, le));
      }
    }
    t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function Te(k, B, q) {
    const fe = i.get(k);
    (B !== void 0 &&
      ce(
        fe.__webglFramebuffer,
        k,
        k.texture,
        n.COLOR_ATTACHMENT0,
        n.TEXTURE_2D,
        0,
      ),
      q !== void 0 && $e(k));
  }
  function it(k) {
    const B = k.texture,
      q = i.get(k),
      fe = i.get(B);
    k.addEventListener("dispose", S);
    const Ie = k.textures,
      le = k.isWebGLCubeRenderTarget === !0,
      Ke = Ie.length > 1;
    if (
      (Ke ||
        (fe.__webglTexture === void 0 &&
          (fe.__webglTexture = n.createTexture()),
        (fe.__version = B.version),
        o.memory.textures++),
      le)
    ) {
      q.__webglFramebuffer = [];
      for (let Ee = 0; Ee < 6; Ee++)
        if (B.mipmaps && B.mipmaps.length > 0) {
          q.__webglFramebuffer[Ee] = [];
          for (let rt = 0; rt < B.mipmaps.length; rt++)
            q.__webglFramebuffer[Ee][rt] = n.createFramebuffer();
        } else q.__webglFramebuffer[Ee] = n.createFramebuffer();
    } else {
      if (B.mipmaps && B.mipmaps.length > 0) {
        q.__webglFramebuffer = [];
        for (let Ee = 0; Ee < B.mipmaps.length; Ee++)
          q.__webglFramebuffer[Ee] = n.createFramebuffer();
      } else q.__webglFramebuffer = n.createFramebuffer();
      if (Ke)
        for (let Ee = 0, rt = Ie.length; Ee < rt; Ee++) {
          const pt = i.get(Ie[Ee]);
          pt.__webglTexture === void 0 &&
            ((pt.__webglTexture = n.createTexture()), o.memory.textures++);
        }
      if (k.samples > 0 && ot(k) === !1) {
        ((q.__webglMultisampledFramebuffer = n.createFramebuffer()),
          (q.__webglColorRenderbuffer = []),
          t.bindFramebuffer(n.FRAMEBUFFER, q.__webglMultisampledFramebuffer));
        for (let Ee = 0; Ee < Ie.length; Ee++) {
          const rt = Ie[Ee];
          ((q.__webglColorRenderbuffer[Ee] = n.createRenderbuffer()),
            n.bindRenderbuffer(n.RENDERBUFFER, q.__webglColorRenderbuffer[Ee]));
          const pt = s.convert(rt.format, rt.colorSpace),
            ye = s.convert(rt.type),
            Ue = I(
              rt.internalFormat,
              pt,
              ye,
              rt.colorSpace,
              k.isXRRenderTarget === !0,
            ),
            ut = Mt(k);
          (n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            ut,
            Ue,
            k.width,
            k.height,
          ),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + Ee,
              n.RENDERBUFFER,
              q.__webglColorRenderbuffer[Ee],
            ));
        }
        (n.bindRenderbuffer(n.RENDERBUFFER, null),
          k.depthBuffer &&
            ((q.__webglDepthRenderbuffer = n.createRenderbuffer()),
            ae(q.__webglDepthRenderbuffer, k, !0)),
          t.bindFramebuffer(n.FRAMEBUFFER, null));
      }
    }
    if (le) {
      (t.bindTexture(n.TEXTURE_CUBE_MAP, fe.__webglTexture),
        ge(n.TEXTURE_CUBE_MAP, B));
      for (let Ee = 0; Ee < 6; Ee++)
        if (B.mipmaps && B.mipmaps.length > 0)
          for (let rt = 0; rt < B.mipmaps.length; rt++)
            ce(
              q.__webglFramebuffer[Ee][rt],
              k,
              B,
              n.COLOR_ATTACHMENT0,
              n.TEXTURE_CUBE_MAP_POSITIVE_X + Ee,
              rt,
            );
        else
          ce(
            q.__webglFramebuffer[Ee],
            k,
            B,
            n.COLOR_ATTACHMENT0,
            n.TEXTURE_CUBE_MAP_POSITIVE_X + Ee,
            0,
          );
      (m(B) && C(n.TEXTURE_CUBE_MAP), t.unbindTexture());
    } else if (Ke) {
      for (let Ee = 0, rt = Ie.length; Ee < rt; Ee++) {
        const pt = Ie[Ee],
          ye = i.get(pt);
        (t.bindTexture(n.TEXTURE_2D, ye.__webglTexture),
          ge(n.TEXTURE_2D, pt),
          ce(
            q.__webglFramebuffer,
            k,
            pt,
            n.COLOR_ATTACHMENT0 + Ee,
            n.TEXTURE_2D,
            0,
          ),
          m(pt) && C(n.TEXTURE_2D));
      }
      t.unbindTexture();
    } else {
      let Ee = n.TEXTURE_2D;
      if (
        ((k.isWebGL3DRenderTarget || k.isWebGLArrayRenderTarget) &&
          (Ee = k.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY),
        t.bindTexture(Ee, fe.__webglTexture),
        ge(Ee, B),
        B.mipmaps && B.mipmaps.length > 0)
      )
        for (let rt = 0; rt < B.mipmaps.length; rt++)
          ce(q.__webglFramebuffer[rt], k, B, n.COLOR_ATTACHMENT0, Ee, rt);
      else ce(q.__webglFramebuffer, k, B, n.COLOR_ATTACHMENT0, Ee, 0);
      (m(B) && C(Ee), t.unbindTexture());
    }
    k.depthBuffer && $e(k);
  }
  function ct(k) {
    const B = k.textures;
    for (let q = 0, fe = B.length; q < fe; q++) {
      const Ie = B[q];
      if (m(Ie)) {
        const le = A(k),
          Ke = i.get(Ie).__webglTexture;
        (t.bindTexture(le, Ke), C(le), t.unbindTexture());
      }
    }
  }
  const qe = [],
    H = [];
  function tn(k) {
    if (k.samples > 0) {
      if (ot(k) === !1) {
        const B = k.textures,
          q = k.width,
          fe = k.height;
        let Ie = n.COLOR_BUFFER_BIT;
        const le = k.stencilBuffer
            ? n.DEPTH_STENCIL_ATTACHMENT
            : n.DEPTH_ATTACHMENT,
          Ke = i.get(k),
          Ee = B.length > 1;
        if (Ee)
          for (let pt = 0; pt < B.length; pt++)
            (t.bindFramebuffer(
              n.FRAMEBUFFER,
              Ke.__webglMultisampledFramebuffer,
            ),
              n.framebufferRenderbuffer(
                n.FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + pt,
                n.RENDERBUFFER,
                null,
              ),
              t.bindFramebuffer(n.FRAMEBUFFER, Ke.__webglFramebuffer),
              n.framebufferTexture2D(
                n.DRAW_FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + pt,
                n.TEXTURE_2D,
                null,
                0,
              ));
        t.bindFramebuffer(
          n.READ_FRAMEBUFFER,
          Ke.__webglMultisampledFramebuffer,
        );
        const rt = k.texture.mipmaps;
        rt && rt.length > 0
          ? t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Ke.__webglFramebuffer[0])
          : t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Ke.__webglFramebuffer);
        for (let pt = 0; pt < B.length; pt++) {
          if (
            (k.resolveDepthBuffer &&
              (k.depthBuffer && (Ie |= n.DEPTH_BUFFER_BIT),
              k.stencilBuffer &&
                k.resolveStencilBuffer &&
                (Ie |= n.STENCIL_BUFFER_BIT)),
            Ee)
          ) {
            n.framebufferRenderbuffer(
              n.READ_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.RENDERBUFFER,
              Ke.__webglColorRenderbuffer[pt],
            );
            const ye = i.get(B[pt]).__webglTexture;
            n.framebufferTexture2D(
              n.DRAW_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.TEXTURE_2D,
              ye,
              0,
            );
          }
          (n.blitFramebuffer(0, 0, q, fe, 0, 0, q, fe, Ie, n.NEAREST),
            l === !0 &&
              ((qe.length = 0),
              (H.length = 0),
              qe.push(n.COLOR_ATTACHMENT0 + pt),
              k.depthBuffer &&
                k.resolveDepthBuffer === !1 &&
                (qe.push(le),
                H.push(le),
                n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, H)),
              n.invalidateFramebuffer(n.READ_FRAMEBUFFER, qe)));
        }
        if (
          (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
          t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
          Ee)
        )
          for (let pt = 0; pt < B.length; pt++) {
            (t.bindFramebuffer(
              n.FRAMEBUFFER,
              Ke.__webglMultisampledFramebuffer,
            ),
              n.framebufferRenderbuffer(
                n.FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + pt,
                n.RENDERBUFFER,
                Ke.__webglColorRenderbuffer[pt],
              ));
            const ye = i.get(B[pt]).__webglTexture;
            (t.bindFramebuffer(n.FRAMEBUFFER, Ke.__webglFramebuffer),
              n.framebufferTexture2D(
                n.DRAW_FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + pt,
                n.TEXTURE_2D,
                ye,
                0,
              ));
          }
        t.bindFramebuffer(
          n.DRAW_FRAMEBUFFER,
          Ke.__webglMultisampledFramebuffer,
        );
      } else if (k.depthBuffer && k.resolveDepthBuffer === !1 && l) {
        const B = k.stencilBuffer
          ? n.DEPTH_STENCIL_ATTACHMENT
          : n.DEPTH_ATTACHMENT;
        n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [B]);
      }
    }
  }
  function Mt(k) {
    return Math.min(r.maxSamples, k.samples);
  }
  function ot(k) {
    const B = i.get(k);
    return (
      k.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      B.__useRenderToTexture !== !1
    );
  }
  function Ae(k) {
    const B = o.render.frame;
    u.get(k) !== B && (u.set(k, B), k.update());
  }
  function _n(k, B) {
    const q = k.colorSpace,
      fe = k.format,
      Ie = k.type;
    return (
      k.isCompressedTexture === !0 ||
        k.isVideoTexture === !0 ||
        (q !== Ir &&
          q !== dl &&
          (Kt.getTransfer(q) === mn
            ? (fe !== Sr || Ie !== Fo) &&
              console.warn(
                "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.",
              )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                q,
              ))),
      B
    );
  }
  function Ze(k) {
    return (
      typeof HTMLImageElement < "u" && k instanceof HTMLImageElement
        ? ((c.width = k.naturalWidth || k.width),
          (c.height = k.naturalHeight || k.height))
        : typeof VideoFrame < "u" && k instanceof VideoFrame
          ? ((c.width = k.displayWidth), (c.height = k.displayHeight))
          : ((c.width = k.width), (c.height = k.height)),
      c
    );
  }
  ((this.allocateTextureUnit = L),
    (this.resetTextureUnits = M),
    (this.setTexture2D = U),
    (this.setTexture2DArray = O),
    (this.setTexture3D = V),
    (this.setTextureCube = W),
    (this.rebindTextures = Te),
    (this.setupRenderTarget = it),
    (this.updateRenderTargetMipmap = ct),
    (this.updateMultisampleRenderTarget = tn),
    (this.setupDepthRenderbuffer = $e),
    (this.setupFrameBufferTexture = ce),
    (this.useMultisampledRTT = ot));
}
function tae(n, e) {
  function t(i, r = dl) {
    let s;
    const o = Kt.getTransfer(r);
    if (i === Fo) return n.UNSIGNED_BYTE;
    if (i === Rv) return n.UNSIGNED_SHORT_4_4_4_4;
    if (i === Bv) return n.UNSIGNED_SHORT_5_5_5_1;
    if (i === XL) return n.UNSIGNED_INT_5_9_9_9_REV;
    if (i === zL) return n.BYTE;
    if (i === YL) return n.SHORT;
    if (i === Lg) return n.UNSIGNED_SHORT;
    if (i === Lv) return n.INT;
    if (i === gu) return n.UNSIGNED_INT;
    if (i === Xr) return n.FLOAT;
    if (i === wp) return n.HALF_FLOAT;
    if (i === KL) return n.ALPHA;
    if (i === jL) return n.RGB;
    if (i === Sr) return n.RGBA;
    if (i === Bg) return n.DEPTH_COMPONENT;
    if (i === Pg) return n.DEPTH_STENCIL;
    if (i === Pv) return n.RED;
    if (i === Nv) return n.RED_INTEGER;
    if (i === $L) return n.RG;
    if (i === Dv) return n.RG_INTEGER;
    if (i === Gv) return n.RGBA_INTEGER;
    if (i === k0 || i === O0 || i === U0 || i === H0)
      if (o === mn)
        if (((s = e.get("WEBGL_compressed_texture_s3tc_srgb")), s !== null)) {
          if (i === k0) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (i === O0) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (i === U0) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (i === H0) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((s = e.get("WEBGL_compressed_texture_s3tc")), s !== null)) {
        if (i === k0) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (i === O0) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (i === U0) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (i === H0) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (i === __ || i === b_ || i === v_ || i === x_)
      if (((s = e.get("WEBGL_compressed_texture_pvrtc")), s !== null)) {
        if (i === __) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (i === b_) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (i === v_) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (i === x_) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (i === w_ || i === S_ || i === T_)
      if (((s = e.get("WEBGL_compressed_texture_etc")), s !== null)) {
        if (i === w_ || i === S_)
          return o === mn ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
        if (i === T_)
          return o === mn
            ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : s.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      i === E_ ||
      i === M_ ||
      i === L_ ||
      i === R_ ||
      i === B_ ||
      i === P_ ||
      i === N_ ||
      i === D_ ||
      i === G_ ||
      i === F_ ||
      i === k_ ||
      i === O_ ||
      i === U_ ||
      i === H_
    )
      if (((s = e.get("WEBGL_compressed_texture_astc")), s !== null)) {
        if (i === E_)
          return o === mn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (i === M_)
          return o === mn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (i === L_)
          return o === mn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (i === R_)
          return o === mn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (i === B_)
          return o === mn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (i === P_)
          return o === mn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (i === N_)
          return o === mn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (i === D_)
          return o === mn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (i === G_)
          return o === mn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (i === F_)
          return o === mn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (i === k_)
          return o === mn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (i === O_)
          return o === mn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (i === U_)
          return o === mn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (i === H_)
          return o === mn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (i === W0 || i === W_ || i === V_)
      if (((s = e.get("EXT_texture_compression_bptc")), s !== null)) {
        if (i === W0)
          return o === mn
            ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (i === W_) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (i === V_) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (i === JL || i === Z_ || i === z_ || i === Y_)
      if (((s = e.get("EXT_texture_compression_rgtc")), s !== null)) {
        if (i === W0) return s.COMPRESSED_RED_RGTC1_EXT;
        if (i === Z_) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (i === z_) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (i === Y_) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return i === Rg ? n.UNSIGNED_INT_24_8 : n[i] !== void 0 ? n[i] : null;
  }
  return { convert: t };
}
const nae = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
  iae = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class rae {
  constructor() {
    ((this.texture = null),
      (this.mesh = null),
      (this.depthNear = 0),
      (this.depthFar = 0));
  }
  init(e, t, i) {
    if (this.texture === null) {
      const r = new Oi(),
        s = e.properties.get(r);
      ((s.__webglTexture = t.texture),
        (t.depthNear !== i.depthNear || t.depthFar !== i.depthFar) &&
          ((this.depthNear = t.depthNear), (this.depthFar = t.depthFar)),
        (this.texture = r));
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const t = e.cameras[0].viewport,
        i = new Qi({
          vertexShader: nae,
          fragmentShader: iae,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: t.z },
            depthHeight: { value: t.w },
          },
        });
      this.mesh = new si(new Vd(20, 20), i);
    }
    return this.mesh;
  }
  reset() {
    ((this.texture = null), (this.mesh = null));
  }
  getDepthTexture() {
    return this.texture;
  }
}
class sae extends wu {
  constructor(e, t) {
    super();
    const i = this;
    let r = null,
      s = 1,
      o = null,
      a = "local-floor",
      l = 1,
      c = null,
      u = null,
      h = null,
      d = null,
      f = null,
      g = null;
    const p = new rae(),
      m = t.getContextAttributes();
    let C = null,
      A = null;
    const I = [],
      y = [],
      x = new Gt();
    let T = null;
    const S = new Ri();
    S.viewport = new ln();
    const E = new Ri();
    E.viewport = new ln();
    const _ = [S, E],
      b = new gne();
    let R = null,
      M = null;
    ((this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (J) {
        let se = I[J];
        return (
          se === void 0 && ((se = new k2()), (I[J] = se)),
          se.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (J) {
        let se = I[J];
        return (
          se === void 0 && ((se = new k2()), (I[J] = se)),
          se.getGripSpace()
        );
      }),
      (this.getHand = function (J) {
        let se = I[J];
        return (
          se === void 0 && ((se = new k2()), (I[J] = se)),
          se.getHandSpace()
        );
      }));
    function L(J) {
      const se = y.indexOf(J.inputSource);
      if (se === -1) return;
      const ce = I[se];
      ce !== void 0 &&
        (ce.update(J.inputSource, J.frame, c || o),
        ce.dispatchEvent({ type: J.type, data: J.inputSource }));
    }
    function P() {
      (r.removeEventListener("select", L),
        r.removeEventListener("selectstart", L),
        r.removeEventListener("selectend", L),
        r.removeEventListener("squeeze", L),
        r.removeEventListener("squeezestart", L),
        r.removeEventListener("squeezeend", L),
        r.removeEventListener("end", P),
        r.removeEventListener("inputsourceschange", U));
      for (let J = 0; J < I.length; J++) {
        const se = y[J];
        se !== null && ((y[J] = null), I[J].disconnect(se));
      }
      ((R = null),
        (M = null),
        p.reset(),
        e.setRenderTarget(C),
        (f = null),
        (d = null),
        (h = null),
        (r = null),
        (A = null),
        be.stop(),
        (i.isPresenting = !1),
        e.setPixelRatio(T),
        e.setSize(x.width, x.height, !1),
        i.dispatchEvent({ type: "sessionend" }));
    }
    ((this.setFramebufferScaleFactor = function (J) {
      ((s = J),
        i.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting.",
          ));
    }),
      (this.setReferenceSpaceType = function (J) {
        ((a = J),
          i.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting.",
            ));
      }),
      (this.getReferenceSpace = function () {
        return c || o;
      }),
      (this.setReferenceSpace = function (J) {
        c = J;
      }),
      (this.getBaseLayer = function () {
        return d !== null ? d : f;
      }),
      (this.getBinding = function () {
        return h;
      }),
      (this.getFrame = function () {
        return g;
      }),
      (this.getSession = function () {
        return r;
      }),
      (this.setSession = async function (J) {
        if (((r = J), r !== null)) {
          if (
            ((C = e.getRenderTarget()),
            r.addEventListener("select", L),
            r.addEventListener("selectstart", L),
            r.addEventListener("selectend", L),
            r.addEventListener("squeeze", L),
            r.addEventListener("squeezestart", L),
            r.addEventListener("squeezeend", L),
            r.addEventListener("end", P),
            r.addEventListener("inputsourceschange", U),
            m.xrCompatible !== !0 && (await t.makeXRCompatible()),
            (T = e.getPixelRatio()),
            e.getSize(x),
            typeof XRWebGLBinding < "u" &&
              "createProjectionLayer" in XRWebGLBinding.prototype)
          ) {
            let ce = null,
              ae = null,
              Ce = null;
            m.depth &&
              ((Ce = m.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (ce = m.stencil ? Pg : Bg),
              (ae = m.stencil ? Rg : gu));
            const $e = {
              colorFormat: t.RGBA8,
              depthFormat: Ce,
              scaleFactor: s,
            };
            ((h = new XRWebGLBinding(r, t)),
              (d = h.createProjectionLayer($e)),
              r.updateRenderState({ layers: [d] }),
              e.setPixelRatio(1),
              e.setSize(d.textureWidth, d.textureHeight, !1),
              (A = new ko(d.textureWidth, d.textureHeight, {
                format: Sr,
                type: Fo,
                depthTexture: new gR(
                  d.textureWidth,
                  d.textureHeight,
                  ae,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  ce,
                ),
                stencilBuffer: m.stencil,
                colorSpace: e.outputColorSpace,
                samples: m.antialias ? 4 : 0,
                resolveDepthBuffer: d.ignoreDepthValues === !1,
                resolveStencilBuffer: d.ignoreDepthValues === !1,
              })));
          } else {
            const ce = {
              antialias: m.antialias,
              alpha: !0,
              depth: m.depth,
              stencil: m.stencil,
              framebufferScaleFactor: s,
            };
            ((f = new XRWebGLLayer(r, t, ce)),
              r.updateRenderState({ baseLayer: f }),
              e.setPixelRatio(1),
              e.setSize(f.framebufferWidth, f.framebufferHeight, !1),
              (A = new ko(f.framebufferWidth, f.framebufferHeight, {
                format: Sr,
                type: Fo,
                colorSpace: e.outputColorSpace,
                stencilBuffer: m.stencil,
                resolveDepthBuffer: f.ignoreDepthValues === !1,
                resolveStencilBuffer: f.ignoreDepthValues === !1,
              })));
          }
          ((A.isXRRenderTarget = !0),
            this.setFoveation(l),
            (c = null),
            (o = await r.requestReferenceSpace(a)),
            be.setContext(r),
            be.start(),
            (i.isPresenting = !0),
            i.dispatchEvent({ type: "sessionstart" }));
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (r !== null) return r.environmentBlendMode;
      }),
      (this.getDepthTexture = function () {
        return p.getDepthTexture();
      }));
    function U(J) {
      for (let se = 0; se < J.removed.length; se++) {
        const ce = J.removed[se],
          ae = y.indexOf(ce);
        ae >= 0 && ((y[ae] = null), I[ae].disconnect(ce));
      }
      for (let se = 0; se < J.added.length; se++) {
        const ce = J.added[se];
        let ae = y.indexOf(ce);
        if (ae === -1) {
          for (let $e = 0; $e < I.length; $e++)
            if ($e >= y.length) {
              (y.push(ce), (ae = $e));
              break;
            } else if (y[$e] === null) {
              ((y[$e] = ce), (ae = $e));
              break;
            }
          if (ae === -1) break;
        }
        const Ce = I[ae];
        Ce && Ce.connect(ce);
      }
    }
    const O = new X(),
      V = new X();
    function W(J, se, ce) {
      (O.setFromMatrixPosition(se.matrixWorld),
        V.setFromMatrixPosition(ce.matrixWorld));
      const ae = O.distanceTo(V),
        Ce = se.projectionMatrix.elements,
        $e = ce.projectionMatrix.elements,
        Te = Ce[14] / (Ce[10] - 1),
        it = Ce[14] / (Ce[10] + 1),
        ct = (Ce[9] + 1) / Ce[5],
        qe = (Ce[9] - 1) / Ce[5],
        H = (Ce[8] - 1) / Ce[0],
        tn = ($e[8] + 1) / $e[0],
        Mt = Te * H,
        ot = Te * tn,
        Ae = ae / (-H + tn),
        _n = Ae * -H;
      if (
        (se.matrixWorld.decompose(J.position, J.quaternion, J.scale),
        J.translateX(_n),
        J.translateZ(Ae),
        J.matrixWorld.compose(J.position, J.quaternion, J.scale),
        J.matrixWorldInverse.copy(J.matrixWorld).invert(),
        Ce[10] === -1)
      )
        (J.projectionMatrix.copy(se.projectionMatrix),
          J.projectionMatrixInverse.copy(se.projectionMatrixInverse));
      else {
        const Ze = Te + Ae,
          k = it + Ae,
          B = Mt - _n,
          q = ot + (ae - _n),
          fe = ((ct * it) / k) * Ze,
          Ie = ((qe * it) / k) * Ze;
        (J.projectionMatrix.makePerspective(B, q, fe, Ie, Ze, k),
          J.projectionMatrixInverse.copy(J.projectionMatrix).invert());
      }
    }
    function re(J, se) {
      (se === null
        ? J.matrixWorld.copy(J.matrix)
        : J.matrixWorld.multiplyMatrices(se.matrixWorld, J.matrix),
        J.matrixWorldInverse.copy(J.matrixWorld).invert());
    }
    this.updateCamera = function (J) {
      if (r === null) return;
      let se = J.near,
        ce = J.far;
      (p.texture !== null &&
        (p.depthNear > 0 && (se = p.depthNear),
        p.depthFar > 0 && (ce = p.depthFar)),
        (b.near = E.near = S.near = se),
        (b.far = E.far = S.far = ce),
        (R !== b.near || M !== b.far) &&
          (r.updateRenderState({ depthNear: b.near, depthFar: b.far }),
          (R = b.near),
          (M = b.far)),
        (S.layers.mask = J.layers.mask | 2),
        (E.layers.mask = J.layers.mask | 4),
        (b.layers.mask = S.layers.mask | E.layers.mask));
      const ae = J.parent,
        Ce = b.cameras;
      re(b, ae);
      for (let $e = 0; $e < Ce.length; $e++) re(Ce[$e], ae);
      (Ce.length === 2
        ? W(b, S, E)
        : b.projectionMatrix.copy(S.projectionMatrix),
        Z(J, b, ae));
    };
    function Z(J, se, ce) {
      (ce === null
        ? J.matrix.copy(se.matrixWorld)
        : (J.matrix.copy(ce.matrixWorld),
          J.matrix.invert(),
          J.matrix.multiply(se.matrixWorld)),
        J.matrix.decompose(J.position, J.quaternion, J.scale),
        J.updateMatrixWorld(!0),
        J.projectionMatrix.copy(se.projectionMatrix),
        J.projectionMatrixInverse.copy(se.projectionMatrixInverse),
        J.isPerspectiveCamera &&
          ((J.fov = ld * 2 * Math.atan(1 / J.projectionMatrix.elements[5])),
          (J.zoom = 1)));
    }
    ((this.getCamera = function () {
      return b;
    }),
      (this.getFoveation = function () {
        if (!(d === null && f === null)) return l;
      }),
      (this.setFoveation = function (J) {
        ((l = J),
          d !== null && (d.fixedFoveation = J),
          f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = J));
      }),
      (this.hasDepthSensing = function () {
        return p.texture !== null;
      }),
      (this.getDepthSensingMesh = function () {
        return p.getMesh(b);
      }));
    let te = null;
    function ge(J, se) {
      if (((u = se.getViewerPose(c || o)), (g = se), u !== null)) {
        const ce = u.views;
        f !== null &&
          (e.setRenderTargetFramebuffer(A, f.framebuffer),
          e.setRenderTarget(A));
        let ae = !1;
        ce.length !== b.cameras.length && ((b.cameras.length = 0), (ae = !0));
        for (let Te = 0; Te < ce.length; Te++) {
          const it = ce[Te];
          let ct = null;
          if (f !== null) ct = f.getViewport(it);
          else {
            const H = h.getViewSubImage(d, it);
            ((ct = H.viewport),
              Te === 0 &&
                (e.setRenderTargetTextures(
                  A,
                  H.colorTexture,
                  H.depthStencilTexture,
                ),
                e.setRenderTarget(A)));
          }
          let qe = _[Te];
          (qe === void 0 &&
            ((qe = new Ri()),
            qe.layers.enable(Te),
            (qe.viewport = new ln()),
            (_[Te] = qe)),
            qe.matrix.fromArray(it.transform.matrix),
            qe.matrix.decompose(qe.position, qe.quaternion, qe.scale),
            qe.projectionMatrix.fromArray(it.projectionMatrix),
            qe.projectionMatrixInverse.copy(qe.projectionMatrix).invert(),
            qe.viewport.set(ct.x, ct.y, ct.width, ct.height),
            Te === 0 &&
              (b.matrix.copy(qe.matrix),
              b.matrix.decompose(b.position, b.quaternion, b.scale)),
            ae === !0 && b.cameras.push(qe));
        }
        const Ce = r.enabledFeatures;
        if (
          Ce &&
          Ce.includes("depth-sensing") &&
          r.depthUsage == "gpu-optimized" &&
          h
        ) {
          const Te = h.getDepthInformation(ce[0]);
          Te && Te.isValid && Te.texture && p.init(e, Te, r.renderState);
        }
      }
      for (let ce = 0; ce < I.length; ce++) {
        const ae = y[ce],
          Ce = I[ce];
        ae !== null && Ce !== void 0 && Ce.update(ae, se, c || o);
      }
      (te && te(J, se),
        se.detectedPlanes &&
          i.dispatchEvent({ type: "planesdetected", data: se }),
        (g = null));
    }
    const be = new xR();
    (be.setAnimationLoop(ge),
      (this.setAnimationLoop = function (J) {
        te = J;
      }),
      (this.dispose = function () {}));
  }
}
const lc = new Oo(),
  oae = new Et();
function aae(n, e) {
  function t(m, C) {
    (m.matrixAutoUpdate === !0 && m.updateMatrix(), C.value.copy(m.matrix));
  }
  function i(m, C) {
    (C.color.getRGB(m.fogColor.value, oR(n)),
      C.isFog
        ? ((m.fogNear.value = C.near), (m.fogFar.value = C.far))
        : C.isFogExp2 && (m.fogDensity.value = C.density));
  }
  function r(m, C, A, I, y) {
    C.isMeshBasicMaterial || C.isMeshLambertMaterial
      ? s(m, C)
      : C.isMeshToonMaterial
        ? (s(m, C), h(m, C))
        : C.isMeshPhongMaterial
          ? (s(m, C), u(m, C))
          : C.isMeshStandardMaterial
            ? (s(m, C), d(m, C), C.isMeshPhysicalMaterial && f(m, C, y))
            : C.isMeshMatcapMaterial
              ? (s(m, C), g(m, C))
              : C.isMeshDepthMaterial
                ? s(m, C)
                : C.isMeshDistanceMaterial
                  ? (s(m, C), p(m, C))
                  : C.isMeshNormalMaterial
                    ? s(m, C)
                    : C.isLineBasicMaterial
                      ? (o(m, C), C.isLineDashedMaterial && a(m, C))
                      : C.isPointsMaterial
                        ? l(m, C, A, I)
                        : C.isSpriteMaterial
                          ? c(m, C)
                          : C.isShadowMaterial
                            ? (m.color.value.copy(C.color),
                              (m.opacity.value = C.opacity))
                            : C.isShaderMaterial && (C.uniformsNeedUpdate = !1);
  }
  function s(m, C) {
    ((m.opacity.value = C.opacity),
      C.color && m.diffuse.value.copy(C.color),
      C.emissive &&
        m.emissive.value.copy(C.emissive).multiplyScalar(C.emissiveIntensity),
      C.map && ((m.map.value = C.map), t(C.map, m.mapTransform)),
      C.alphaMap &&
        ((m.alphaMap.value = C.alphaMap), t(C.alphaMap, m.alphaMapTransform)),
      C.bumpMap &&
        ((m.bumpMap.value = C.bumpMap),
        t(C.bumpMap, m.bumpMapTransform),
        (m.bumpScale.value = C.bumpScale),
        C.side === er && (m.bumpScale.value *= -1)),
      C.normalMap &&
        ((m.normalMap.value = C.normalMap),
        t(C.normalMap, m.normalMapTransform),
        m.normalScale.value.copy(C.normalScale),
        C.side === er && m.normalScale.value.negate()),
      C.displacementMap &&
        ((m.displacementMap.value = C.displacementMap),
        t(C.displacementMap, m.displacementMapTransform),
        (m.displacementScale.value = C.displacementScale),
        (m.displacementBias.value = C.displacementBias)),
      C.emissiveMap &&
        ((m.emissiveMap.value = C.emissiveMap),
        t(C.emissiveMap, m.emissiveMapTransform)),
      C.specularMap &&
        ((m.specularMap.value = C.specularMap),
        t(C.specularMap, m.specularMapTransform)),
      C.alphaTest > 0 && (m.alphaTest.value = C.alphaTest));
    const A = e.get(C),
      I = A.envMap,
      y = A.envMapRotation;
    (I &&
      ((m.envMap.value = I),
      lc.copy(y),
      (lc.x *= -1),
      (lc.y *= -1),
      (lc.z *= -1),
      I.isCubeTexture &&
        I.isRenderTargetTexture === !1 &&
        ((lc.y *= -1), (lc.z *= -1)),
      m.envMapRotation.value.setFromMatrix4(oae.makeRotationFromEuler(lc)),
      (m.flipEnvMap.value =
        I.isCubeTexture && I.isRenderTargetTexture === !1 ? -1 : 1),
      (m.reflectivity.value = C.reflectivity),
      (m.ior.value = C.ior),
      (m.refractionRatio.value = C.refractionRatio)),
      C.lightMap &&
        ((m.lightMap.value = C.lightMap),
        (m.lightMapIntensity.value = C.lightMapIntensity),
        t(C.lightMap, m.lightMapTransform)),
      C.aoMap &&
        ((m.aoMap.value = C.aoMap),
        (m.aoMapIntensity.value = C.aoMapIntensity),
        t(C.aoMap, m.aoMapTransform)));
  }
  function o(m, C) {
    (m.diffuse.value.copy(C.color),
      (m.opacity.value = C.opacity),
      C.map && ((m.map.value = C.map), t(C.map, m.mapTransform)));
  }
  function a(m, C) {
    ((m.dashSize.value = C.dashSize),
      (m.totalSize.value = C.dashSize + C.gapSize),
      (m.scale.value = C.scale));
  }
  function l(m, C, A, I) {
    (m.diffuse.value.copy(C.color),
      (m.opacity.value = C.opacity),
      (m.size.value = C.size * A),
      (m.scale.value = I * 0.5),
      C.map && ((m.map.value = C.map), t(C.map, m.uvTransform)),
      C.alphaMap &&
        ((m.alphaMap.value = C.alphaMap), t(C.alphaMap, m.alphaMapTransform)),
      C.alphaTest > 0 && (m.alphaTest.value = C.alphaTest));
  }
  function c(m, C) {
    (m.diffuse.value.copy(C.color),
      (m.opacity.value = C.opacity),
      (m.rotation.value = C.rotation),
      C.map && ((m.map.value = C.map), t(C.map, m.mapTransform)),
      C.alphaMap &&
        ((m.alphaMap.value = C.alphaMap), t(C.alphaMap, m.alphaMapTransform)),
      C.alphaTest > 0 && (m.alphaTest.value = C.alphaTest));
  }
  function u(m, C) {
    (m.specular.value.copy(C.specular),
      (m.shininess.value = Math.max(C.shininess, 1e-4)));
  }
  function h(m, C) {
    C.gradientMap && (m.gradientMap.value = C.gradientMap);
  }
  function d(m, C) {
    ((m.metalness.value = C.metalness),
      C.metalnessMap &&
        ((m.metalnessMap.value = C.metalnessMap),
        t(C.metalnessMap, m.metalnessMapTransform)),
      (m.roughness.value = C.roughness),
      C.roughnessMap &&
        ((m.roughnessMap.value = C.roughnessMap),
        t(C.roughnessMap, m.roughnessMapTransform)),
      C.envMap && (m.envMapIntensity.value = C.envMapIntensity));
  }
  function f(m, C, A) {
    ((m.ior.value = C.ior),
      C.sheen > 0 &&
        (m.sheenColor.value.copy(C.sheenColor).multiplyScalar(C.sheen),
        (m.sheenRoughness.value = C.sheenRoughness),
        C.sheenColorMap &&
          ((m.sheenColorMap.value = C.sheenColorMap),
          t(C.sheenColorMap, m.sheenColorMapTransform)),
        C.sheenRoughnessMap &&
          ((m.sheenRoughnessMap.value = C.sheenRoughnessMap),
          t(C.sheenRoughnessMap, m.sheenRoughnessMapTransform))),
      C.clearcoat > 0 &&
        ((m.clearcoat.value = C.clearcoat),
        (m.clearcoatRoughness.value = C.clearcoatRoughness),
        C.clearcoatMap &&
          ((m.clearcoatMap.value = C.clearcoatMap),
          t(C.clearcoatMap, m.clearcoatMapTransform)),
        C.clearcoatRoughnessMap &&
          ((m.clearcoatRoughnessMap.value = C.clearcoatRoughnessMap),
          t(C.clearcoatRoughnessMap, m.clearcoatRoughnessMapTransform)),
        C.clearcoatNormalMap &&
          ((m.clearcoatNormalMap.value = C.clearcoatNormalMap),
          t(C.clearcoatNormalMap, m.clearcoatNormalMapTransform),
          m.clearcoatNormalScale.value.copy(C.clearcoatNormalScale),
          C.side === er && m.clearcoatNormalScale.value.negate())),
      C.dispersion > 0 && (m.dispersion.value = C.dispersion),
      C.iridescence > 0 &&
        ((m.iridescence.value = C.iridescence),
        (m.iridescenceIOR.value = C.iridescenceIOR),
        (m.iridescenceThicknessMinimum.value = C.iridescenceThicknessRange[0]),
        (m.iridescenceThicknessMaximum.value = C.iridescenceThicknessRange[1]),
        C.iridescenceMap &&
          ((m.iridescenceMap.value = C.iridescenceMap),
          t(C.iridescenceMap, m.iridescenceMapTransform)),
        C.iridescenceThicknessMap &&
          ((m.iridescenceThicknessMap.value = C.iridescenceThicknessMap),
          t(C.iridescenceThicknessMap, m.iridescenceThicknessMapTransform))),
      C.transmission > 0 &&
        ((m.transmission.value = C.transmission),
        (m.transmissionSamplerMap.value = A.texture),
        m.transmissionSamplerSize.value.set(A.width, A.height),
        C.transmissionMap &&
          ((m.transmissionMap.value = C.transmissionMap),
          t(C.transmissionMap, m.transmissionMapTransform)),
        (m.thickness.value = C.thickness),
        C.thicknessMap &&
          ((m.thicknessMap.value = C.thicknessMap),
          t(C.thicknessMap, m.thicknessMapTransform)),
        (m.attenuationDistance.value = C.attenuationDistance),
        m.attenuationColor.value.copy(C.attenuationColor)),
      C.anisotropy > 0 &&
        (m.anisotropyVector.value.set(
          C.anisotropy * Math.cos(C.anisotropyRotation),
          C.anisotropy * Math.sin(C.anisotropyRotation),
        ),
        C.anisotropyMap &&
          ((m.anisotropyMap.value = C.anisotropyMap),
          t(C.anisotropyMap, m.anisotropyMapTransform))),
      (m.specularIntensity.value = C.specularIntensity),
      m.specularColor.value.copy(C.specularColor),
      C.specularColorMap &&
        ((m.specularColorMap.value = C.specularColorMap),
        t(C.specularColorMap, m.specularColorMapTransform)),
      C.specularIntensityMap &&
        ((m.specularIntensityMap.value = C.specularIntensityMap),
        t(C.specularIntensityMap, m.specularIntensityMapTransform)));
  }
  function g(m, C) {
    C.matcap && (m.matcap.value = C.matcap);
  }
  function p(m, C) {
    const A = e.get(C).light;
    (m.referencePosition.value.setFromMatrixPosition(A.matrixWorld),
      (m.nearDistance.value = A.shadow.camera.near),
      (m.farDistance.value = A.shadow.camera.far));
  }
  return { refreshFogUniforms: i, refreshMaterialUniforms: r };
}
function lae(n, e, t, i) {
  let r = {},
    s = {},
    o = [];
  const a = n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);
  function l(A, I) {
    const y = I.program;
    i.uniformBlockBinding(A, y);
  }
  function c(A, I) {
    let y = r[A.id];
    y === void 0 &&
      (g(A), (y = u(A)), (r[A.id] = y), A.addEventListener("dispose", m));
    const x = I.program;
    i.updateUBOMapping(A, x);
    const T = e.render.frame;
    s[A.id] !== T && (d(A), (s[A.id] = T));
  }
  function u(A) {
    const I = h();
    A.__bindingPointIndex = I;
    const y = n.createBuffer(),
      x = A.__size,
      T = A.usage;
    return (
      n.bindBuffer(n.UNIFORM_BUFFER, y),
      n.bufferData(n.UNIFORM_BUFFER, x, T),
      n.bindBuffer(n.UNIFORM_BUFFER, null),
      n.bindBufferBase(n.UNIFORM_BUFFER, I, y),
      y
    );
  }
  function h() {
    for (let A = 0; A < a; A++) if (o.indexOf(A) === -1) return (o.push(A), A);
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.",
      ),
      0
    );
  }
  function d(A) {
    const I = r[A.id],
      y = A.uniforms,
      x = A.__cache;
    n.bindBuffer(n.UNIFORM_BUFFER, I);
    for (let T = 0, S = y.length; T < S; T++) {
      const E = Array.isArray(y[T]) ? y[T] : [y[T]];
      for (let _ = 0, b = E.length; _ < b; _++) {
        const R = E[_];
        if (f(R, T, _, x) === !0) {
          const M = R.__offset,
            L = Array.isArray(R.value) ? R.value : [R.value];
          let P = 0;
          for (let U = 0; U < L.length; U++) {
            const O = L[U],
              V = p(O);
            typeof O == "number" || typeof O == "boolean"
              ? ((R.__data[0] = O),
                n.bufferSubData(n.UNIFORM_BUFFER, M + P, R.__data))
              : O.isMatrix3
                ? ((R.__data[0] = O.elements[0]),
                  (R.__data[1] = O.elements[1]),
                  (R.__data[2] = O.elements[2]),
                  (R.__data[3] = 0),
                  (R.__data[4] = O.elements[3]),
                  (R.__data[5] = O.elements[4]),
                  (R.__data[6] = O.elements[5]),
                  (R.__data[7] = 0),
                  (R.__data[8] = O.elements[6]),
                  (R.__data[9] = O.elements[7]),
                  (R.__data[10] = O.elements[8]),
                  (R.__data[11] = 0))
                : (O.toArray(R.__data, P),
                  (P += V.storage / Float32Array.BYTES_PER_ELEMENT));
          }
          n.bufferSubData(n.UNIFORM_BUFFER, M, R.__data);
        }
      }
    }
    n.bindBuffer(n.UNIFORM_BUFFER, null);
  }
  function f(A, I, y, x) {
    const T = A.value,
      S = I + "_" + y;
    if (x[S] === void 0)
      return (
        typeof T == "number" || typeof T == "boolean"
          ? (x[S] = T)
          : (x[S] = T.clone()),
        !0
      );
    {
      const E = x[S];
      if (typeof T == "number" || typeof T == "boolean") {
        if (E !== T) return ((x[S] = T), !0);
      } else if (E.equals(T) === !1) return (E.copy(T), !0);
    }
    return !1;
  }
  function g(A) {
    const I = A.uniforms;
    let y = 0;
    const x = 16;
    for (let S = 0, E = I.length; S < E; S++) {
      const _ = Array.isArray(I[S]) ? I[S] : [I[S]];
      for (let b = 0, R = _.length; b < R; b++) {
        const M = _[b],
          L = Array.isArray(M.value) ? M.value : [M.value];
        for (let P = 0, U = L.length; P < U; P++) {
          const O = L[P],
            V = p(O),
            W = y % x,
            re = W % V.boundary,
            Z = W + re;
          ((y += re),
            Z !== 0 && x - Z < V.storage && (y += x - Z),
            (M.__data = new Float32Array(
              V.storage / Float32Array.BYTES_PER_ELEMENT,
            )),
            (M.__offset = y),
            (y += V.storage));
        }
      }
    }
    const T = y % x;
    return (T > 0 && (y += x - T), (A.__size = y), (A.__cache = {}), this);
  }
  function p(A) {
    const I = { boundary: 0, storage: 0 };
    return (
      typeof A == "number" || typeof A == "boolean"
        ? ((I.boundary = 4), (I.storage = 4))
        : A.isVector2
          ? ((I.boundary = 8), (I.storage = 8))
          : A.isVector3 || A.isColor
            ? ((I.boundary = 16), (I.storage = 12))
            : A.isVector4
              ? ((I.boundary = 16), (I.storage = 16))
              : A.isMatrix3
                ? ((I.boundary = 48), (I.storage = 48))
                : A.isMatrix4
                  ? ((I.boundary = 64), (I.storage = 64))
                  : A.isTexture
                    ? console.warn(
                        "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.",
                      )
                    : console.warn(
                        "THREE.WebGLRenderer: Unsupported uniform value type.",
                        A,
                      ),
      I
    );
  }
  function m(A) {
    const I = A.target;
    I.removeEventListener("dispose", m);
    const y = o.indexOf(I.__bindingPointIndex);
    (o.splice(y, 1), n.deleteBuffer(r[I.id]), delete r[I.id], delete s[I.id]);
  }
  function C() {
    for (const A in r) n.deleteBuffer(r[A]);
    ((o = []), (r = {}), (s = {}));
  }
  return { bind: l, update: c, dispose: C };
}
class Jv {
  constructor(e = {}) {
    const {
      canvas: t = ute(),
      context: i = null,
      depth: r = !0,
      stencil: s = !1,
      alpha: o = !1,
      antialias: a = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: u = "default",
      failIfMajorPerformanceCaveat: h = !1,
      reverseDepthBuffer: d = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let f;
    if (i !== null) {
      if (
        typeof WebGLRenderingContext < "u" &&
        i instanceof WebGLRenderingContext
      )
        throw new Error(
          "THREE.WebGLRenderer: WebGL 1 is not supported since r163.",
        );
      f = i.getContextAttributes().alpha;
    } else f = o;
    const g = new Uint32Array(4),
      p = new Int32Array(4);
    let m = null,
      C = null;
    const A = [],
      I = [];
    ((this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this.toneMapping = Sl),
      (this.toneMappingExposure = 1),
      (this.transmissionResolutionScale = 1));
    const y = this;
    let x = !1;
    this._outputColorSpace = Gi;
    let T = 0,
      S = 0,
      E = null,
      _ = -1,
      b = null;
    const R = new ln(),
      M = new ln();
    let L = null;
    const P = new vt(0);
    let U = 0,
      O = t.width,
      V = t.height,
      W = 1,
      re = null,
      Z = null;
    const te = new ln(0, 0, O, V),
      ge = new ln(0, 0, O, V);
    let be = !1;
    const J = new zv();
    let se = !1,
      ce = !1;
    const ae = new Et(),
      Ce = new Et(),
      $e = new X(),
      Te = new ln(),
      it = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    let ct = !1;
    function qe() {
      return E === null ? W : 1;
    }
    let H = i;
    function tn(N, K) {
      return t.getContext(N, K);
    }
    try {
      const N = {
        alpha: !0,
        depth: r,
        stencil: s,
        antialias: a,
        premultipliedAlpha: l,
        preserveDrawingBuffer: c,
        powerPreference: u,
        failIfMajorPerformanceCaveat: h,
      };
      if (
        ("setAttribute" in t &&
          t.setAttribute("data-engine", `three.js r${Mv}`),
        t.addEventListener("webglcontextlost", me, !1),
        t.addEventListener("webglcontextrestored", Re, !1),
        t.addEventListener("webglcontextcreationerror", Ge, !1),
        H === null)
      ) {
        const K = "webgl2";
        if (((H = tn(K, N)), H === null))
          throw tn(K)
            ? new Error(
                "Error creating WebGL context with your selected attributes.",
              )
            : new Error("Error creating WebGL context.");
      }
    } catch (N) {
      throw (console.error("THREE.WebGLRenderer: " + N.message), N);
    }
    let Mt,
      ot,
      Ae,
      _n,
      Ze,
      k,
      B,
      q,
      fe,
      Ie,
      le,
      Ke,
      Ee,
      rt,
      pt,
      ye,
      Ue,
      ut,
      ht,
      ze,
      Ft,
      Lt,
      pn,
      Y;
    function Fe() {
      ((Mt = new Ase(H)),
        Mt.init(),
        (Lt = new tae(H, Mt)),
        (ot = new dse(H, Mt, e, Lt)),
        (Ae = new qoe(H, Mt)),
        ot.reverseDepthBuffer && d && Ae.buffers.depth.setReversed(!0),
        (_n = new bse(H)),
        (Ze = new Uoe()),
        (k = new eae(H, Mt, Ae, Ze, ot, Lt, _n)),
        (B = new gse(y)),
        (q = new Ise(y)),
        (fe = new Ene(H)),
        (pn = new use(H, fe)),
        (Ie = new yse(H, fe, _n, pn)),
        (le = new xse(H, Ie, fe, _n)),
        (ht = new vse(H, ot, k)),
        (ye = new fse(Ze)),
        (Ke = new Ooe(y, B, q, Mt, ot, pn, ye)),
        (Ee = new aae(y, Ze)),
        (rt = new Woe()),
        (pt = new Koe(Mt)),
        (ut = new cse(y, B, q, Ae, le, f, l)),
        (Ue = new Joe(y, le, ot)),
        (Y = new lae(H, _n, ot, Ae)),
        (ze = new hse(H, Mt, _n)),
        (Ft = new _se(H, Mt, _n)),
        (_n.programs = Ke.programs),
        (y.capabilities = ot),
        (y.extensions = Mt),
        (y.properties = Ze),
        (y.renderLists = rt),
        (y.shadowMap = Ue),
        (y.state = Ae),
        (y.info = _n));
    }
    Fe();
    const oe = new sae(y, H);
    ((this.xr = oe),
      (this.getContext = function () {
        return H;
      }),
      (this.getContextAttributes = function () {
        return H.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const N = Mt.get("WEBGL_lose_context");
        N && N.loseContext();
      }),
      (this.forceContextRestore = function () {
        const N = Mt.get("WEBGL_lose_context");
        N && N.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return W;
      }),
      (this.setPixelRatio = function (N) {
        N !== void 0 && ((W = N), this.setSize(O, V, !1));
      }),
      (this.getSize = function (N) {
        return N.set(O, V);
      }),
      (this.setSize = function (N, K, ee = !0) {
        if (oe.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting.",
          );
          return;
        }
        ((O = N),
          (V = K),
          (t.width = Math.floor(N * W)),
          (t.height = Math.floor(K * W)),
          ee === !0 &&
            ((t.style.width = N + "px"), (t.style.height = K + "px")),
          this.setViewport(0, 0, N, K));
      }),
      (this.getDrawingBufferSize = function (N) {
        return N.set(O * W, V * W).floor();
      }),
      (this.setDrawingBufferSize = function (N, K, ee) {
        ((O = N),
          (V = K),
          (W = ee),
          (t.width = Math.floor(N * ee)),
          (t.height = Math.floor(K * ee)),
          this.setViewport(0, 0, N, K));
      }),
      (this.getCurrentViewport = function (N) {
        return N.copy(R);
      }),
      (this.getViewport = function (N) {
        return N.copy(te);
      }),
      (this.setViewport = function (N, K, ee, ne) {
        (N.isVector4 ? te.set(N.x, N.y, N.z, N.w) : te.set(N, K, ee, ne),
          Ae.viewport(R.copy(te).multiplyScalar(W).round()));
      }),
      (this.getScissor = function (N) {
        return N.copy(ge);
      }),
      (this.setScissor = function (N, K, ee, ne) {
        (N.isVector4 ? ge.set(N.x, N.y, N.z, N.w) : ge.set(N, K, ee, ne),
          Ae.scissor(M.copy(ge).multiplyScalar(W).round()));
      }),
      (this.getScissorTest = function () {
        return be;
      }),
      (this.setScissorTest = function (N) {
        Ae.setScissorTest((be = N));
      }),
      (this.setOpaqueSort = function (N) {
        re = N;
      }),
      (this.setTransparentSort = function (N) {
        Z = N;
      }),
      (this.getClearColor = function (N) {
        return N.copy(ut.getClearColor());
      }),
      (this.setClearColor = function () {
        ut.setClearColor(...arguments);
      }),
      (this.getClearAlpha = function () {
        return ut.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        ut.setClearAlpha(...arguments);
      }),
      (this.clear = function (N = !0, K = !0, ee = !0) {
        let ne = 0;
        if (N) {
          let j = !1;
          if (E !== null) {
            const _e = E.texture.format;
            j = _e === Gv || _e === Dv || _e === Nv;
          }
          if (j) {
            const _e = E.texture.type,
              Le =
                _e === Fo ||
                _e === gu ||
                _e === Lg ||
                _e === Rg ||
                _e === Rv ||
                _e === Bv,
              He = ut.getClearColor(),
              Xe = ut.getClearAlpha(),
              It = He.r,
              gt = He.g,
              st = He.b;
            Le
              ? ((g[0] = It),
                (g[1] = gt),
                (g[2] = st),
                (g[3] = Xe),
                H.clearBufferuiv(H.COLOR, 0, g))
              : ((p[0] = It),
                (p[1] = gt),
                (p[2] = st),
                (p[3] = Xe),
                H.clearBufferiv(H.COLOR, 0, p));
          } else ne |= H.COLOR_BUFFER_BIT;
        }
        (K && (ne |= H.DEPTH_BUFFER_BIT),
          ee &&
            ((ne |= H.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          H.clear(ne));
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        (t.removeEventListener("webglcontextlost", me, !1),
          t.removeEventListener("webglcontextrestored", Re, !1),
          t.removeEventListener("webglcontextcreationerror", Ge, !1),
          ut.dispose(),
          rt.dispose(),
          pt.dispose(),
          Ze.dispose(),
          B.dispose(),
          q.dispose(),
          le.dispose(),
          pn.dispose(),
          Y.dispose(),
          Ke.dispose(),
          oe.dispose(),
          oe.removeEventListener("sessionstart", Kl),
          oe.removeEventListener("sessionend", Mu),
          Xo.stop());
      }));
    function me(N) {
      (N.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (x = !0));
    }
    function Re() {
      (console.log("THREE.WebGLRenderer: Context Restored."), (x = !1));
      const N = _n.autoReset,
        K = Ue.enabled,
        ee = Ue.autoUpdate,
        ne = Ue.needsUpdate,
        j = Ue.type;
      (Fe(),
        (_n.autoReset = N),
        (Ue.enabled = K),
        (Ue.autoUpdate = ee),
        (Ue.needsUpdate = ne),
        (Ue.type = j));
    }
    function Ge(N) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        N.statusMessage,
      );
    }
    function at(N) {
      const K = N.target;
      (K.removeEventListener("dispose", at), Bn(K));
    }
    function Bn(N) {
      (Ii(N), Ze.remove(N));
    }
    function Ii(N) {
      const K = Ze.get(N).programs;
      K !== void 0 &&
        (K.forEach(function (ee) {
          Ke.releaseProgram(ee);
        }),
        N.isShaderMaterial && Ke.releaseShaderCache(N));
    }
    this.renderBufferDirect = function (N, K, ee, ne, j, _e) {
      K === null && (K = it);
      const Le = j.isMesh && j.matrixWorld.determinant() < 0,
        He = bI(N, K, ee, ne, j);
      Ae.setMaterial(ne, Le);
      let Xe = ee.index,
        It = 1;
      if (ne.wireframe === !0) {
        if (((Xe = Ie.getWireframeAttribute(ee)), Xe === void 0)) return;
        It = 2;
      }
      const gt = ee.drawRange,
        st = ee.attributes.position;
      let Ot = gt.start * It,
        nn = (gt.start + gt.count) * It;
      (_e !== null &&
        ((Ot = Math.max(Ot, _e.start * It)),
        (nn = Math.min(nn, (_e.start + _e.count) * It))),
        Xe !== null
          ? ((Ot = Math.max(Ot, 0)), (nn = Math.min(nn, Xe.count)))
          : st != null &&
            ((Ot = Math.max(Ot, 0)), (nn = Math.min(nn, st.count))));
      const Vn = nn - Ot;
      if (Vn < 0 || Vn === 1 / 0) return;
      pn.setup(j, ne, He, ee, Xe);
      let Tn,
        Ut = ze;
      if (
        (Xe !== null && ((Tn = fe.get(Xe)), (Ut = Ft), Ut.setIndex(Tn)),
        j.isMesh)
      )
        ne.wireframe === !0
          ? (Ae.setLineWidth(ne.wireframeLinewidth * qe()), Ut.setMode(H.LINES))
          : Ut.setMode(H.TRIANGLES);
      else if (j.isLine) {
        let lt = ne.linewidth;
        (lt === void 0 && (lt = 1),
          Ae.setLineWidth(lt * qe()),
          j.isLineSegments
            ? Ut.setMode(H.LINES)
            : j.isLineLoop
              ? Ut.setMode(H.LINE_LOOP)
              : Ut.setMode(H.LINE_STRIP));
      } else
        j.isPoints
          ? Ut.setMode(H.POINTS)
          : j.isSprite && Ut.setMode(H.TRIANGLES);
      if (j.isBatchedMesh)
        if (j._multiDrawInstances !== null)
          (V0(
            "THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.",
          ),
            Ut.renderMultiDrawInstances(
              j._multiDrawStarts,
              j._multiDrawCounts,
              j._multiDrawCount,
              j._multiDrawInstances,
            ));
        else if (Mt.get("WEBGL_multi_draw"))
          Ut.renderMultiDraw(
            j._multiDrawStarts,
            j._multiDrawCounts,
            j._multiDrawCount,
          );
        else {
          const lt = j._multiDrawStarts,
            qn = j._multiDrawCounts,
            rn = j._multiDrawCount,
            Gr = Xe ? fe.get(Xe).bytesPerElement : 1,
            Ko = Ze.get(ne).currentProgram.getUniforms();
          for (let Ai = 0; Ai < rn; Ai++)
            (Ko.setValue(H, "_gl_DrawID", Ai), Ut.render(lt[Ai] / Gr, qn[Ai]));
        }
      else if (j.isInstancedMesh) Ut.renderInstances(Ot, Vn, j.count);
      else if (ee.isInstancedBufferGeometry) {
        const lt =
            ee._maxInstanceCount !== void 0 ? ee._maxInstanceCount : 1 / 0,
          qn = Math.min(ee.instanceCount, lt);
        Ut.renderInstances(Ot, Vn, qn);
      } else Ut.render(Ot, Vn);
    };
    function yt(N, K, ee) {
      N.transparent === !0 && N.side === Ao && N.forceSinglePass === !1
        ? ((N.side = er),
          (N.needsUpdate = !0),
          Oa(N, K, ee),
          (N.side = Go),
          (N.needsUpdate = !0),
          Oa(N, K, ee),
          (N.side = Ao))
        : Oa(N, K, ee);
    }
    ((this.compile = function (N, K, ee = null) {
      (ee === null && (ee = N),
        (C = pt.get(ee)),
        C.init(K),
        I.push(C),
        ee.traverseVisible(function (j) {
          j.isLight &&
            j.layers.test(K.layers) &&
            (C.pushLight(j), j.castShadow && C.pushShadow(j));
        }),
        N !== ee &&
          N.traverseVisible(function (j) {
            j.isLight &&
              j.layers.test(K.layers) &&
              (C.pushLight(j), j.castShadow && C.pushShadow(j));
          }),
        C.setupLights());
      const ne = new Set();
      return (
        N.traverse(function (j) {
          if (!(j.isMesh || j.isPoints || j.isLine || j.isSprite)) return;
          const _e = j.material;
          if (_e)
            if (Array.isArray(_e))
              for (let Le = 0; Le < _e.length; Le++) {
                const He = _e[Le];
                (yt(He, ee, j), ne.add(He));
              }
            else (yt(_e, ee, j), ne.add(_e));
        }),
        (C = I.pop()),
        ne
      );
    }),
      (this.compileAsync = function (N, K, ee = null) {
        const ne = this.compile(N, K, ee);
        return new Promise((j) => {
          function _e() {
            if (
              (ne.forEach(function (Le) {
                Ze.get(Le).currentProgram.isReady() && ne.delete(Le);
              }),
              ne.size === 0)
            ) {
              j(N);
              return;
            }
            setTimeout(_e, 10);
          }
          Mt.get("KHR_parallel_shader_compile") !== null
            ? _e()
            : setTimeout(_e, 10);
        });
      }));
    let Ar = null;
    function ss(N) {
      Ar && Ar(N);
    }
    function Kl() {
      Xo.stop();
    }
    function Mu() {
      Xo.start();
    }
    const Xo = new xR();
    (Xo.setAnimationLoop(ss),
      typeof self < "u" && Xo.setContext(self),
      (this.setAnimationLoop = function (N) {
        ((Ar = N), oe.setAnimationLoop(N), N === null ? Xo.stop() : Xo.start());
      }),
      oe.addEventListener("sessionstart", Kl),
      oe.addEventListener("sessionend", Mu),
      (this.render = function (N, K) {
        if (K !== void 0 && K.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.",
          );
          return;
        }
        if (x === !0) return;
        if (
          (N.matrixWorldAutoUpdate === !0 && N.updateMatrixWorld(),
          K.parent === null &&
            K.matrixWorldAutoUpdate === !0 &&
            K.updateMatrixWorld(),
          oe.enabled === !0 &&
            oe.isPresenting === !0 &&
            (oe.cameraAutoUpdate === !0 && oe.updateCamera(K),
            (K = oe.getCamera())),
          N.isScene === !0 && N.onBeforeRender(y, N, K, E),
          (C = pt.get(N, I.length)),
          C.init(K),
          I.push(C),
          Ce.multiplyMatrices(K.projectionMatrix, K.matrixWorldInverse),
          J.setFromProjectionMatrix(Ce),
          (ce = this.localClippingEnabled),
          (se = ye.init(this.clippingPlanes, ce)),
          (m = rt.get(N, A.length)),
          m.init(),
          A.push(m),
          oe.enabled === !0 && oe.isPresenting === !0)
        ) {
          const _e = y.xr.getDepthSensingMesh();
          _e !== null && jl(_e, K, -1 / 0, y.sortObjects);
        }
        (jl(N, K, 0, y.sortObjects),
          m.finish(),
          y.sortObjects === !0 && m.sort(re, Z),
          (ct =
            oe.enabled === !1 ||
            oe.isPresenting === !1 ||
            oe.hasDepthSensing() === !1),
          ct && ut.addToRenderList(m, N),
          this.info.render.frame++,
          se === !0 && ye.beginShadows());
        const ee = C.state.shadowsArray;
        (Ue.render(ee, N, K),
          se === !0 && ye.endShadows(),
          this.info.autoReset === !0 && this.info.reset());
        const ne = m.opaque,
          j = m.transmissive;
        if ((C.setupLights(), K.isArrayCamera)) {
          const _e = K.cameras;
          if (j.length > 0)
            for (let Le = 0, He = _e.length; Le < He; Le++) {
              const Xe = _e[Le];
              Lu(ne, j, N, Xe);
            }
          ct && ut.render(N);
          for (let Le = 0, He = _e.length; Le < He; Le++) {
            const Xe = _e[Le];
            Qd(m, N, Xe, Xe.viewport);
          }
        } else
          (j.length > 0 && Lu(ne, j, N, K), ct && ut.render(N), Qd(m, N, K));
        (E !== null &&
          S === 0 &&
          (k.updateMultisampleRenderTarget(E), k.updateRenderTargetMipmap(E)),
          N.isScene === !0 && N.onAfterRender(y, N, K),
          pn.resetDefaultState(),
          (_ = -1),
          (b = null),
          I.pop(),
          I.length > 0
            ? ((C = I[I.length - 1]),
              se === !0 && ye.setGlobalState(y.clippingPlanes, C.state.camera))
            : (C = null),
          A.pop(),
          A.length > 0 ? (m = A[A.length - 1]) : (m = null));
      }));
    function jl(N, K, ee, ne) {
      if (N.visible === !1) return;
      if (N.layers.test(K.layers)) {
        if (N.isGroup) ee = N.renderOrder;
        else if (N.isLOD) N.autoUpdate === !0 && N.update(K);
        else if (N.isLight) (C.pushLight(N), N.castShadow && C.pushShadow(N));
        else if (N.isSprite) {
          if (!N.frustumCulled || J.intersectsSprite(N)) {
            ne && Te.setFromMatrixPosition(N.matrixWorld).applyMatrix4(Ce);
            const Le = le.update(N),
              He = N.material;
            He.visible && m.push(N, Le, He, ee, Te.z, null);
          }
        } else if (
          (N.isMesh || N.isLine || N.isPoints) &&
          (!N.frustumCulled || J.intersectsObject(N))
        ) {
          const Le = le.update(N),
            He = N.material;
          if (
            (ne &&
              (N.boundingSphere !== void 0
                ? (N.boundingSphere === null && N.computeBoundingSphere(),
                  Te.copy(N.boundingSphere.center))
                : (Le.boundingSphere === null && Le.computeBoundingSphere(),
                  Te.copy(Le.boundingSphere.center)),
              Te.applyMatrix4(N.matrixWorld).applyMatrix4(Ce)),
            Array.isArray(He))
          ) {
            const Xe = Le.groups;
            for (let It = 0, gt = Xe.length; It < gt; It++) {
              const st = Xe[It],
                Ot = He[st.materialIndex];
              Ot && Ot.visible && m.push(N, Le, Ot, ee, Te.z, st);
            }
          } else He.visible && m.push(N, Le, He, ee, Te.z, null);
        }
      }
      const _e = N.children;
      for (let Le = 0, He = _e.length; Le < He; Le++) jl(_e[Le], K, ee, ne);
    }
    function Qd(N, K, ee, ne) {
      const j = N.opaque,
        _e = N.transmissive,
        Le = N.transparent;
      (C.setupLightsView(ee),
        se === !0 && ye.setGlobalState(y.clippingPlanes, ee),
        ne && Ae.viewport(R.copy(ne)),
        j.length > 0 && yr(j, K, ee),
        _e.length > 0 && yr(_e, K, ee),
        Le.length > 0 && yr(Le, K, ee),
        Ae.buffers.depth.setTest(!0),
        Ae.buffers.depth.setMask(!0),
        Ae.buffers.color.setMask(!0),
        Ae.setPolygonOffset(!1));
    }
    function Lu(N, K, ee, ne) {
      if ((ee.isScene === !0 ? ee.overrideMaterial : null) !== null) return;
      C.state.transmissionRenderTarget[ne.id] === void 0 &&
        (C.state.transmissionRenderTarget[ne.id] = new ko(1, 1, {
          generateMipmaps: !0,
          type:
            Mt.has("EXT_color_buffer_half_float") ||
            Mt.has("EXT_color_buffer_float")
              ? wp
              : Fo,
          minFilter: ga,
          samples: 4,
          stencilBuffer: s,
          resolveDepthBuffer: !1,
          resolveStencilBuffer: !1,
          colorSpace: Kt.workingColorSpace,
        }));
      const _e = C.state.transmissionRenderTarget[ne.id],
        Le = ne.viewport || R;
      _e.setSize(
        Le.z * y.transmissionResolutionScale,
        Le.w * y.transmissionResolutionScale,
      );
      const He = y.getRenderTarget();
      (y.setRenderTarget(_e),
        y.getClearColor(P),
        (U = y.getClearAlpha()),
        U < 1 && y.setClearColor(16777215, 0.5),
        y.clear(),
        ct && ut.render(ee));
      const Xe = y.toneMapping;
      y.toneMapping = Sl;
      const It = ne.viewport;
      if (
        (ne.viewport !== void 0 && (ne.viewport = void 0),
        C.setupLightsView(ne),
        se === !0 && ye.setGlobalState(y.clippingPlanes, ne),
        yr(N, ee, ne),
        k.updateMultisampleRenderTarget(_e),
        k.updateRenderTargetMipmap(_e),
        Mt.has("WEBGL_multisampled_render_to_texture") === !1)
      ) {
        let gt = !1;
        for (let st = 0, Ot = K.length; st < Ot; st++) {
          const nn = K[st],
            Vn = nn.object,
            Tn = nn.geometry,
            Ut = nn.material,
            lt = nn.group;
          if (Ut.side === Ao && Vn.layers.test(ne.layers)) {
            const qn = Ut.side;
            ((Ut.side = er),
              (Ut.needsUpdate = !0),
              Ru(Vn, ee, ne, Tn, Ut, lt),
              (Ut.side = qn),
              (Ut.needsUpdate = !0),
              (gt = !0));
          }
        }
        gt === !0 &&
          (k.updateMultisampleRenderTarget(_e), k.updateRenderTargetMipmap(_e));
      }
      (y.setRenderTarget(He),
        y.setClearColor(P, U),
        It !== void 0 && (ne.viewport = It),
        (y.toneMapping = Xe));
    }
    function yr(N, K, ee) {
      const ne = K.isScene === !0 ? K.overrideMaterial : null;
      for (let j = 0, _e = N.length; j < _e; j++) {
        const Le = N[j],
          He = Le.object,
          Xe = Le.geometry,
          It = Le.group;
        let gt = Le.material;
        (gt.allowOverride === !0 && ne !== null && (gt = ne),
          He.layers.test(ee.layers) && Ru(He, K, ee, Xe, gt, It));
      }
    }
    function Ru(N, K, ee, ne, j, _e) {
      (N.onBeforeRender(y, K, ee, ne, j, _e),
        N.modelViewMatrix.multiplyMatrices(
          ee.matrixWorldInverse,
          N.matrixWorld,
        ),
        N.normalMatrix.getNormalMatrix(N.modelViewMatrix),
        j.onBeforeRender(y, K, ee, ne, N, _e),
        j.transparent === !0 && j.side === Ao && j.forceSinglePass === !1
          ? ((j.side = er),
            (j.needsUpdate = !0),
            y.renderBufferDirect(ee, K, ne, j, N, _e),
            (j.side = Go),
            (j.needsUpdate = !0),
            y.renderBufferDirect(ee, K, ne, j, N, _e),
            (j.side = Ao))
          : y.renderBufferDirect(ee, K, ne, j, N, _e),
        N.onAfterRender(y, K, ee, ne, j, _e));
    }
    function Oa(N, K, ee) {
      K.isScene !== !0 && (K = it);
      const ne = Ze.get(N),
        j = C.state.lights,
        _e = C.state.shadowsArray,
        Le = j.state.version,
        He = Ke.getParameters(N, j.state, _e, K, ee),
        Xe = Ke.getProgramCacheKey(He);
      let It = ne.programs;
      ((ne.environment = N.isMeshStandardMaterial ? K.environment : null),
        (ne.fog = K.fog),
        (ne.envMap = (N.isMeshStandardMaterial ? q : B).get(
          N.envMap || ne.environment,
        )),
        (ne.envMapRotation =
          ne.environment !== null && N.envMap === null
            ? K.environmentRotation
            : N.envMapRotation),
        It === void 0 &&
          (N.addEventListener("dispose", at),
          (It = new Map()),
          (ne.programs = It)));
      let gt = It.get(Xe);
      if (gt !== void 0) {
        if (ne.currentProgram === gt && ne.lightsStateVersion === Le)
          return (qd(N, He), gt);
      } else
        ((He.uniforms = Ke.getUniforms(N)),
          N.onBeforeCompile(He, y),
          (gt = Ke.acquireProgram(He, Xe)),
          It.set(Xe, gt),
          (ne.uniforms = He.uniforms));
      const st = ne.uniforms;
      return (
        ((!N.isShaderMaterial && !N.isRawShaderMaterial) ||
          N.clipping === !0) &&
          (st.clippingPlanes = ye.uniform),
        qd(N, He),
        (ne.needsLights = tf(N)),
        (ne.lightsStateVersion = Le),
        ne.needsLights &&
          ((st.ambientLightColor.value = j.state.ambient),
          (st.lightProbe.value = j.state.probe),
          (st.directionalLights.value = j.state.directional),
          (st.directionalLightShadows.value = j.state.directionalShadow),
          (st.spotLights.value = j.state.spot),
          (st.spotLightShadows.value = j.state.spotShadow),
          (st.rectAreaLights.value = j.state.rectArea),
          (st.ltc_1.value = j.state.rectAreaLTC1),
          (st.ltc_2.value = j.state.rectAreaLTC2),
          (st.pointLights.value = j.state.point),
          (st.pointLightShadows.value = j.state.pointShadow),
          (st.hemisphereLights.value = j.state.hemi),
          (st.directionalShadowMap.value = j.state.directionalShadowMap),
          (st.directionalShadowMatrix.value = j.state.directionalShadowMatrix),
          (st.spotShadowMap.value = j.state.spotShadowMap),
          (st.spotLightMatrix.value = j.state.spotLightMatrix),
          (st.spotLightMap.value = j.state.spotLightMap),
          (st.pointShadowMap.value = j.state.pointShadowMap),
          (st.pointShadowMatrix.value = j.state.pointShadowMatrix)),
        (ne.currentProgram = gt),
        (ne.uniformsList = null),
        gt
      );
    }
    function $l(N) {
      if (N.uniformsList === null) {
        const K = N.currentProgram.getUniforms();
        N.uniformsList = z0.seqWithValue(K.seq, N.uniforms);
      }
      return N.uniformsList;
    }
    function qd(N, K) {
      const ee = Ze.get(N);
      ((ee.outputColorSpace = K.outputColorSpace),
        (ee.batching = K.batching),
        (ee.batchingColor = K.batchingColor),
        (ee.instancing = K.instancing),
        (ee.instancingColor = K.instancingColor),
        (ee.instancingMorph = K.instancingMorph),
        (ee.skinning = K.skinning),
        (ee.morphTargets = K.morphTargets),
        (ee.morphNormals = K.morphNormals),
        (ee.morphColors = K.morphColors),
        (ee.morphTargetsCount = K.morphTargetsCount),
        (ee.numClippingPlanes = K.numClippingPlanes),
        (ee.numIntersection = K.numClipIntersection),
        (ee.vertexAlphas = K.vertexAlphas),
        (ee.vertexTangents = K.vertexTangents),
        (ee.toneMapping = K.toneMapping));
    }
    function bI(N, K, ee, ne, j) {
      (K.isScene !== !0 && (K = it), k.resetTextureUnits());
      const _e = K.fog,
        Le = ne.isMeshStandardMaterial ? K.environment : null,
        He =
          E === null
            ? y.outputColorSpace
            : E.isXRRenderTarget === !0
              ? E.texture.colorSpace
              : Ir,
        Xe = (ne.isMeshStandardMaterial ? q : B).get(ne.envMap || Le),
        It =
          ne.vertexColors === !0 &&
          !!ee.attributes.color &&
          ee.attributes.color.itemSize === 4,
        gt = !!ee.attributes.tangent && (!!ne.normalMap || ne.anisotropy > 0),
        st = !!ee.morphAttributes.position,
        Ot = !!ee.morphAttributes.normal,
        nn = !!ee.morphAttributes.color;
      let Vn = Sl;
      ne.toneMapped &&
        (E === null || E.isXRRenderTarget === !0) &&
        (Vn = y.toneMapping);
      const Tn =
          ee.morphAttributes.position ||
          ee.morphAttributes.normal ||
          ee.morphAttributes.color,
        Ut = Tn !== void 0 ? Tn.length : 0,
        lt = Ze.get(ne),
        qn = C.state.lights;
      if (se === !0 && (ce === !0 || N !== b)) {
        const En = N === b && ne.id === _;
        ye.setState(ne, N, En);
      }
      let rn = !1;
      ne.version === lt.__version
        ? ((lt.needsLights && lt.lightsStateVersion !== qn.state.version) ||
            lt.outputColorSpace !== He ||
            (j.isBatchedMesh && lt.batching === !1) ||
            (!j.isBatchedMesh && lt.batching === !0) ||
            (j.isBatchedMesh &&
              lt.batchingColor === !0 &&
              j.colorTexture === null) ||
            (j.isBatchedMesh &&
              lt.batchingColor === !1 &&
              j.colorTexture !== null) ||
            (j.isInstancedMesh && lt.instancing === !1) ||
            (!j.isInstancedMesh && lt.instancing === !0) ||
            (j.isSkinnedMesh && lt.skinning === !1) ||
            (!j.isSkinnedMesh && lt.skinning === !0) ||
            (j.isInstancedMesh &&
              lt.instancingColor === !0 &&
              j.instanceColor === null) ||
            (j.isInstancedMesh &&
              lt.instancingColor === !1 &&
              j.instanceColor !== null) ||
            (j.isInstancedMesh &&
              lt.instancingMorph === !0 &&
              j.morphTexture === null) ||
            (j.isInstancedMesh &&
              lt.instancingMorph === !1 &&
              j.morphTexture !== null) ||
            lt.envMap !== Xe ||
            (ne.fog === !0 && lt.fog !== _e) ||
            (lt.numClippingPlanes !== void 0 &&
              (lt.numClippingPlanes !== ye.numPlanes ||
                lt.numIntersection !== ye.numIntersection)) ||
            lt.vertexAlphas !== It ||
            lt.vertexTangents !== gt ||
            lt.morphTargets !== st ||
            lt.morphNormals !== Ot ||
            lt.morphColors !== nn ||
            lt.toneMapping !== Vn ||
            lt.morphTargetsCount !== Ut) &&
          (rn = !0)
        : ((rn = !0), (lt.__version = ne.version));
      let Gr = lt.currentProgram;
      rn === !0 && (Gr = Oa(ne, K, j));
      let Ko = !1,
        Ai = !1,
        Jl = !1;
      const At = Gr.getUniforms(),
        Ui = lt.uniforms;
      if (
        (Ae.useProgram(Gr.program) && ((Ko = !0), (Ai = !0), (Jl = !0)),
        ne.id !== _ && ((_ = ne.id), (Ai = !0)),
        Ko || b !== N)
      ) {
        (Ae.buffers.depth.getReversed()
          ? (ae.copy(N.projectionMatrix),
            dte(ae),
            fte(ae),
            At.setValue(H, "projectionMatrix", ae))
          : At.setValue(H, "projectionMatrix", N.projectionMatrix),
          At.setValue(H, "viewMatrix", N.matrixWorldInverse));
        const Sn = At.map.cameraPosition;
        (Sn !== void 0 &&
          Sn.setValue(H, $e.setFromMatrixPosition(N.matrixWorld)),
          ot.logarithmicDepthBuffer &&
            At.setValue(
              H,
              "logDepthBufFC",
              2 / (Math.log(N.far + 1) / Math.LN2),
            ),
          (ne.isMeshPhongMaterial ||
            ne.isMeshToonMaterial ||
            ne.isMeshLambertMaterial ||
            ne.isMeshBasicMaterial ||
            ne.isMeshStandardMaterial ||
            ne.isShaderMaterial) &&
            At.setValue(H, "isOrthographic", N.isOrthographicCamera === !0),
          b !== N && ((b = N), (Ai = !0), (Jl = !0)));
      }
      if (j.isSkinnedMesh) {
        (At.setOptional(H, j, "bindMatrix"),
          At.setOptional(H, j, "bindMatrixInverse"));
        const En = j.skeleton;
        En &&
          (En.boneTexture === null && En.computeBoneTexture(),
          At.setValue(H, "boneTexture", En.boneTexture, k));
      }
      j.isBatchedMesh &&
        (At.setOptional(H, j, "batchingTexture"),
        At.setValue(H, "batchingTexture", j._matricesTexture, k),
        At.setOptional(H, j, "batchingIdTexture"),
        At.setValue(H, "batchingIdTexture", j._indirectTexture, k),
        At.setOptional(H, j, "batchingColorTexture"),
        j._colorsTexture !== null &&
          At.setValue(H, "batchingColorTexture", j._colorsTexture, k));
      const sr = ee.morphAttributes;
      if (
        ((sr.position !== void 0 ||
          sr.normal !== void 0 ||
          sr.color !== void 0) &&
          ht.update(j, ee, Gr),
        (Ai || lt.receiveShadow !== j.receiveShadow) &&
          ((lt.receiveShadow = j.receiveShadow),
          At.setValue(H, "receiveShadow", j.receiveShadow)),
        ne.isMeshGouraudMaterial &&
          ne.envMap !== null &&
          ((Ui.envMap.value = Xe),
          (Ui.flipEnvMap.value =
            Xe.isCubeTexture && Xe.isRenderTargetTexture === !1 ? -1 : 1)),
        ne.isMeshStandardMaterial &&
          ne.envMap === null &&
          K.environment !== null &&
          (Ui.envMapIntensity.value = K.environmentIntensity),
        Ai &&
          (At.setValue(H, "toneMappingExposure", y.toneMappingExposure),
          lt.needsLights && ef(Ui, Jl),
          _e && ne.fog === !0 && Ee.refreshFogUniforms(Ui, _e),
          Ee.refreshMaterialUniforms(
            Ui,
            ne,
            W,
            V,
            C.state.transmissionRenderTarget[N.id],
          ),
          z0.upload(H, $l(lt), Ui, k)),
        ne.isShaderMaterial &&
          ne.uniformsNeedUpdate === !0 &&
          (z0.upload(H, $l(lt), Ui, k), (ne.uniformsNeedUpdate = !1)),
        ne.isSpriteMaterial && At.setValue(H, "center", j.center),
        At.setValue(H, "modelViewMatrix", j.modelViewMatrix),
        At.setValue(H, "normalMatrix", j.normalMatrix),
        At.setValue(H, "modelMatrix", j.matrixWorld),
        ne.isShaderMaterial || ne.isRawShaderMaterial)
      ) {
        const En = ne.uniformsGroups;
        for (let Sn = 0, or = En.length; Sn < or; Sn++) {
          const li = En[Sn];
          (Y.update(li, Gr), Y.bind(li, Gr));
        }
      }
      return Gr;
    }
    function ef(N, K) {
      ((N.ambientLightColor.needsUpdate = K),
        (N.lightProbe.needsUpdate = K),
        (N.directionalLights.needsUpdate = K),
        (N.directionalLightShadows.needsUpdate = K),
        (N.pointLights.needsUpdate = K),
        (N.pointLightShadows.needsUpdate = K),
        (N.spotLights.needsUpdate = K),
        (N.spotLightShadows.needsUpdate = K),
        (N.rectAreaLights.needsUpdate = K),
        (N.hemisphereLights.needsUpdate = K));
    }
    function tf(N) {
      return (
        N.isMeshLambertMaterial ||
        N.isMeshToonMaterial ||
        N.isMeshPhongMaterial ||
        N.isMeshStandardMaterial ||
        N.isShadowMaterial ||
        (N.isShaderMaterial && N.lights === !0)
      );
    }
    ((this.getActiveCubeFace = function () {
      return T;
    }),
      (this.getActiveMipmapLevel = function () {
        return S;
      }),
      (this.getRenderTarget = function () {
        return E;
      }),
      (this.setRenderTargetTextures = function (N, K, ee) {
        const ne = Ze.get(N);
        ((ne.__autoAllocateDepthBuffer = N.resolveDepthBuffer === !1),
          ne.__autoAllocateDepthBuffer === !1 && (ne.__useRenderToTexture = !1),
          (Ze.get(N.texture).__webglTexture = K),
          (Ze.get(N.depthTexture).__webglTexture = ne.__autoAllocateDepthBuffer
            ? void 0
            : ee),
          (ne.__hasExternalTextures = !0));
      }),
      (this.setRenderTargetFramebuffer = function (N, K) {
        const ee = Ze.get(N);
        ((ee.__webglFramebuffer = K),
          (ee.__useDefaultFramebuffer = K === void 0));
      }));
    const vI = H.createFramebuffer();
    ((this.setRenderTarget = function (N, K = 0, ee = 0) {
      ((E = N), (T = K), (S = ee));
      let ne = !0,
        j = null,
        _e = !1,
        Le = !1;
      if (N) {
        const Xe = Ze.get(N);
        if (Xe.__useDefaultFramebuffer !== void 0)
          (Ae.bindFramebuffer(H.FRAMEBUFFER, null), (ne = !1));
        else if (Xe.__webglFramebuffer === void 0) k.setupRenderTarget(N);
        else if (Xe.__hasExternalTextures)
          k.rebindTextures(
            N,
            Ze.get(N.texture).__webglTexture,
            Ze.get(N.depthTexture).__webglTexture,
          );
        else if (N.depthBuffer) {
          const st = N.depthTexture;
          if (Xe.__boundDepthTexture !== st) {
            if (
              st !== null &&
              Ze.has(st) &&
              (N.width !== st.image.width || N.height !== st.image.height)
            )
              throw new Error(
                "WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.",
              );
            k.setupDepthRenderbuffer(N);
          }
        }
        const It = N.texture;
        (It.isData3DTexture ||
          It.isDataArrayTexture ||
          It.isCompressedArrayTexture) &&
          (Le = !0);
        const gt = Ze.get(N).__webglFramebuffer;
        (N.isWebGLCubeRenderTarget
          ? (Array.isArray(gt[K]) ? (j = gt[K][ee]) : (j = gt[K]), (_e = !0))
          : N.samples > 0 && k.useMultisampledRTT(N) === !1
            ? (j = Ze.get(N).__webglMultisampledFramebuffer)
            : Array.isArray(gt)
              ? (j = gt[ee])
              : (j = gt),
          R.copy(N.viewport),
          M.copy(N.scissor),
          (L = N.scissorTest));
      } else
        (R.copy(te).multiplyScalar(W).floor(),
          M.copy(ge).multiplyScalar(W).floor(),
          (L = be));
      if (
        (ee !== 0 && (j = vI),
        Ae.bindFramebuffer(H.FRAMEBUFFER, j) && ne && Ae.drawBuffers(N, j),
        Ae.viewport(R),
        Ae.scissor(M),
        Ae.setScissorTest(L),
        _e)
      ) {
        const Xe = Ze.get(N.texture);
        H.framebufferTexture2D(
          H.FRAMEBUFFER,
          H.COLOR_ATTACHMENT0,
          H.TEXTURE_CUBE_MAP_POSITIVE_X + K,
          Xe.__webglTexture,
          ee,
        );
      } else if (Le) {
        const Xe = Ze.get(N.texture),
          It = K;
        H.framebufferTextureLayer(
          H.FRAMEBUFFER,
          H.COLOR_ATTACHMENT0,
          Xe.__webglTexture,
          ee,
          It,
        );
      } else if (N !== null && ee !== 0) {
        const Xe = Ze.get(N.texture);
        H.framebufferTexture2D(
          H.FRAMEBUFFER,
          H.COLOR_ATTACHMENT0,
          H.TEXTURE_2D,
          Xe.__webglTexture,
          ee,
        );
      }
      _ = -1;
    }),
      (this.readRenderTargetPixels = function (N, K, ee, ne, j, _e, Le) {
        if (!(N && N.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.",
          );
          return;
        }
        let He = Ze.get(N).__webglFramebuffer;
        if ((N.isWebGLCubeRenderTarget && Le !== void 0 && (He = He[Le]), He)) {
          Ae.bindFramebuffer(H.FRAMEBUFFER, He);
          try {
            const Xe = N.texture,
              It = Xe.format,
              gt = Xe.type;
            if (!ot.textureFormatReadable(It)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.",
              );
              return;
            }
            if (!ot.textureTypeReadable(gt)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.",
              );
              return;
            }
            K >= 0 &&
              K <= N.width - ne &&
              ee >= 0 &&
              ee <= N.height - j &&
              H.readPixels(K, ee, ne, j, Lt.convert(It), Lt.convert(gt), _e);
          } finally {
            const Xe = E !== null ? Ze.get(E).__webglFramebuffer : null;
            Ae.bindFramebuffer(H.FRAMEBUFFER, Xe);
          }
        }
      }),
      (this.readRenderTargetPixelsAsync = async function (
        N,
        K,
        ee,
        ne,
        j,
        _e,
        Le,
      ) {
        if (!(N && N.isWebGLRenderTarget))
          throw new Error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.",
          );
        let He = Ze.get(N).__webglFramebuffer;
        if ((N.isWebGLCubeRenderTarget && Le !== void 0 && (He = He[Le]), He))
          if (K >= 0 && K <= N.width - ne && ee >= 0 && ee <= N.height - j) {
            Ae.bindFramebuffer(H.FRAMEBUFFER, He);
            const Xe = N.texture,
              It = Xe.format,
              gt = Xe.type;
            if (!ot.textureFormatReadable(It))
              throw new Error(
                "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.",
              );
            if (!ot.textureTypeReadable(gt))
              throw new Error(
                "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.",
              );
            const st = H.createBuffer();
            (H.bindBuffer(H.PIXEL_PACK_BUFFER, st),
              H.bufferData(H.PIXEL_PACK_BUFFER, _e.byteLength, H.STREAM_READ),
              H.readPixels(K, ee, ne, j, Lt.convert(It), Lt.convert(gt), 0));
            const Ot = E !== null ? Ze.get(E).__webglFramebuffer : null;
            Ae.bindFramebuffer(H.FRAMEBUFFER, Ot);
            const nn = H.fenceSync(H.SYNC_GPU_COMMANDS_COMPLETE, 0);
            return (
              H.flush(),
              await hte(H, nn, 4),
              H.bindBuffer(H.PIXEL_PACK_BUFFER, st),
              H.getBufferSubData(H.PIXEL_PACK_BUFFER, 0, _e),
              H.deleteBuffer(st),
              H.deleteSync(nn),
              _e
            );
          } else
            throw new Error(
              "THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.",
            );
      }),
      (this.copyFramebufferToTexture = function (N, K = null, ee = 0) {
        const ne = Math.pow(2, -ee),
          j = Math.floor(N.image.width * ne),
          _e = Math.floor(N.image.height * ne),
          Le = K !== null ? K.x : 0,
          He = K !== null ? K.y : 0;
        (k.setTexture2D(N, 0),
          H.copyTexSubImage2D(H.TEXTURE_2D, ee, 0, 0, Le, He, j, _e),
          Ae.unbindTexture());
      }));
    const xI = H.createFramebuffer(),
      Np = H.createFramebuffer();
    ((this.copyTextureToTexture = function (
      N,
      K,
      ee = null,
      ne = null,
      j = 0,
      _e = null,
    ) {
      _e === null &&
        (j !== 0
          ? (V0(
              "WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels.",
            ),
            (_e = j),
            (j = 0))
          : (_e = 0));
      let Le, He, Xe, It, gt, st, Ot, nn, Vn;
      const Tn = N.isCompressedTexture ? N.mipmaps[_e] : N.image;
      if (ee !== null)
        ((Le = ee.max.x - ee.min.x),
          (He = ee.max.y - ee.min.y),
          (Xe = ee.isBox3 ? ee.max.z - ee.min.z : 1),
          (It = ee.min.x),
          (gt = ee.min.y),
          (st = ee.isBox3 ? ee.min.z : 0));
      else {
        const sr = Math.pow(2, -j);
        ((Le = Math.floor(Tn.width * sr)),
          (He = Math.floor(Tn.height * sr)),
          N.isDataArrayTexture
            ? (Xe = Tn.depth)
            : N.isData3DTexture
              ? (Xe = Math.floor(Tn.depth * sr))
              : (Xe = 1),
          (It = 0),
          (gt = 0),
          (st = 0));
      }
      ne !== null
        ? ((Ot = ne.x), (nn = ne.y), (Vn = ne.z))
        : ((Ot = 0), (nn = 0), (Vn = 0));
      const Ut = Lt.convert(K.format),
        lt = Lt.convert(K.type);
      let qn;
      (K.isData3DTexture
        ? (k.setTexture3D(K, 0), (qn = H.TEXTURE_3D))
        : K.isDataArrayTexture || K.isCompressedArrayTexture
          ? (k.setTexture2DArray(K, 0), (qn = H.TEXTURE_2D_ARRAY))
          : (k.setTexture2D(K, 0), (qn = H.TEXTURE_2D)),
        H.pixelStorei(H.UNPACK_FLIP_Y_WEBGL, K.flipY),
        H.pixelStorei(H.UNPACK_PREMULTIPLY_ALPHA_WEBGL, K.premultiplyAlpha),
        H.pixelStorei(H.UNPACK_ALIGNMENT, K.unpackAlignment));
      const rn = H.getParameter(H.UNPACK_ROW_LENGTH),
        Gr = H.getParameter(H.UNPACK_IMAGE_HEIGHT),
        Ko = H.getParameter(H.UNPACK_SKIP_PIXELS),
        Ai = H.getParameter(H.UNPACK_SKIP_ROWS),
        Jl = H.getParameter(H.UNPACK_SKIP_IMAGES);
      (H.pixelStorei(H.UNPACK_ROW_LENGTH, Tn.width),
        H.pixelStorei(H.UNPACK_IMAGE_HEIGHT, Tn.height),
        H.pixelStorei(H.UNPACK_SKIP_PIXELS, It),
        H.pixelStorei(H.UNPACK_SKIP_ROWS, gt),
        H.pixelStorei(H.UNPACK_SKIP_IMAGES, st));
      const At = N.isDataArrayTexture || N.isData3DTexture,
        Ui = K.isDataArrayTexture || K.isData3DTexture;
      if (N.isDepthTexture) {
        const sr = Ze.get(N),
          En = Ze.get(K),
          Sn = Ze.get(sr.__renderTarget),
          or = Ze.get(En.__renderTarget);
        (Ae.bindFramebuffer(H.READ_FRAMEBUFFER, Sn.__webglFramebuffer),
          Ae.bindFramebuffer(H.DRAW_FRAMEBUFFER, or.__webglFramebuffer));
        for (let li = 0; li < Xe; li++)
          (At &&
            (H.framebufferTextureLayer(
              H.READ_FRAMEBUFFER,
              H.COLOR_ATTACHMENT0,
              Ze.get(N).__webglTexture,
              j,
              st + li,
            ),
            H.framebufferTextureLayer(
              H.DRAW_FRAMEBUFFER,
              H.COLOR_ATTACHMENT0,
              Ze.get(K).__webglTexture,
              _e,
              Vn + li,
            )),
            H.blitFramebuffer(
              It,
              gt,
              Le,
              He,
              Ot,
              nn,
              Le,
              He,
              H.DEPTH_BUFFER_BIT,
              H.NEAREST,
            ));
        (Ae.bindFramebuffer(H.READ_FRAMEBUFFER, null),
          Ae.bindFramebuffer(H.DRAW_FRAMEBUFFER, null));
      } else if (j !== 0 || N.isRenderTargetTexture || Ze.has(N)) {
        const sr = Ze.get(N),
          En = Ze.get(K);
        (Ae.bindFramebuffer(H.READ_FRAMEBUFFER, xI),
          Ae.bindFramebuffer(H.DRAW_FRAMEBUFFER, Np));
        for (let Sn = 0; Sn < Xe; Sn++)
          (At
            ? H.framebufferTextureLayer(
                H.READ_FRAMEBUFFER,
                H.COLOR_ATTACHMENT0,
                sr.__webglTexture,
                j,
                st + Sn,
              )
            : H.framebufferTexture2D(
                H.READ_FRAMEBUFFER,
                H.COLOR_ATTACHMENT0,
                H.TEXTURE_2D,
                sr.__webglTexture,
                j,
              ),
            Ui
              ? H.framebufferTextureLayer(
                  H.DRAW_FRAMEBUFFER,
                  H.COLOR_ATTACHMENT0,
                  En.__webglTexture,
                  _e,
                  Vn + Sn,
                )
              : H.framebufferTexture2D(
                  H.DRAW_FRAMEBUFFER,
                  H.COLOR_ATTACHMENT0,
                  H.TEXTURE_2D,
                  En.__webglTexture,
                  _e,
                ),
            j !== 0
              ? H.blitFramebuffer(
                  It,
                  gt,
                  Le,
                  He,
                  Ot,
                  nn,
                  Le,
                  He,
                  H.COLOR_BUFFER_BIT,
                  H.NEAREST,
                )
              : Ui
                ? H.copyTexSubImage3D(qn, _e, Ot, nn, Vn + Sn, It, gt, Le, He)
                : H.copyTexSubImage2D(qn, _e, Ot, nn, It, gt, Le, He));
        (Ae.bindFramebuffer(H.READ_FRAMEBUFFER, null),
          Ae.bindFramebuffer(H.DRAW_FRAMEBUFFER, null));
      } else
        Ui
          ? N.isDataTexture || N.isData3DTexture
            ? H.texSubImage3D(qn, _e, Ot, nn, Vn, Le, He, Xe, Ut, lt, Tn.data)
            : K.isCompressedArrayTexture
              ? H.compressedTexSubImage3D(
                  qn,
                  _e,
                  Ot,
                  nn,
                  Vn,
                  Le,
                  He,
                  Xe,
                  Ut,
                  Tn.data,
                )
              : H.texSubImage3D(qn, _e, Ot, nn, Vn, Le, He, Xe, Ut, lt, Tn)
          : N.isDataTexture
            ? H.texSubImage2D(H.TEXTURE_2D, _e, Ot, nn, Le, He, Ut, lt, Tn.data)
            : N.isCompressedTexture
              ? H.compressedTexSubImage2D(
                  H.TEXTURE_2D,
                  _e,
                  Ot,
                  nn,
                  Tn.width,
                  Tn.height,
                  Ut,
                  Tn.data,
                )
              : H.texSubImage2D(H.TEXTURE_2D, _e, Ot, nn, Le, He, Ut, lt, Tn);
      (H.pixelStorei(H.UNPACK_ROW_LENGTH, rn),
        H.pixelStorei(H.UNPACK_IMAGE_HEIGHT, Gr),
        H.pixelStorei(H.UNPACK_SKIP_PIXELS, Ko),
        H.pixelStorei(H.UNPACK_SKIP_ROWS, Ai),
        H.pixelStorei(H.UNPACK_SKIP_IMAGES, Jl),
        _e === 0 && K.generateMipmaps && H.generateMipmap(qn),
        Ae.unbindTexture());
    }),
      (this.copyTextureToTexture3D = function (
        N,
        K,
        ee = null,
        ne = null,
        j = 0,
      ) {
        return (
          V0(
            'WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.',
          ),
          this.copyTextureToTexture(N, K, ee, ne, j)
        );
      }),
      (this.initRenderTarget = function (N) {
        Ze.get(N).__webglFramebuffer === void 0 && k.setupRenderTarget(N);
      }),
      (this.initTexture = function (N) {
        (N.isCubeTexture
          ? k.setTextureCube(N, 0)
          : N.isData3DTexture
            ? k.setTexture3D(N, 0)
            : N.isDataArrayTexture || N.isCompressedArrayTexture
              ? k.setTexture2DArray(N, 0)
              : k.setTexture2D(N, 0),
          Ae.unbindTexture());
      }),
      (this.resetState = function () {
        ((T = 0), (S = 0), (E = null), Ae.reset(), pn.reset());
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this }),
        ));
  }
  get coordinateSystem() {
    return pa;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    ((t.drawingBufferColorSpace = Kt._getDrawingBufferColorSpace(e)),
      (t.unpackColorSpace = Kt._getUnpackColorSpace()));
  }
}
const cae = new aI(-1, 1, 1, -1, 0, 1);
class uae extends Pr {
  constructor() {
    (super(),
      this.setAttribute("position", new tr([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)),
      this.setAttribute("uv", new tr([0, 2, 0, 0, 2, 0], 2)));
  }
}
const hae = new uae();
class dae {
  constructor(e) {
    this._mesh = new si(hae, e);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(e) {
    e.render(this._mesh, cae);
  }
  get material() {
    return this._mesh.material;
  }
  set material(e) {
    this._mesh.material = e;
  }
}
function qw(n, e) {
  if (e === Fee)
    return (
      console.warn(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.",
      ),
      n
    );
  if (e === K_ || e === QL) {
    let t = n.getIndex();
    if (t === null) {
      const o = [],
        a = n.getAttribute("position");
      if (a !== void 0) {
        for (let l = 0; l < a.count; l++) o.push(l);
        (n.setIndex(o), (t = n.getIndex()));
      } else
        return (
          console.error(
            "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.",
          ),
          n
        );
    }
    const i = t.count - 2,
      r = [];
    if (e === K_)
      for (let o = 1; o <= i; o++)
        (r.push(t.getX(0)), r.push(t.getX(o)), r.push(t.getX(o + 1)));
    else
      for (let o = 0; o < i; o++)
        o % 2 === 0
          ? (r.push(t.getX(o)), r.push(t.getX(o + 1)), r.push(t.getX(o + 2)))
          : (r.push(t.getX(o + 2)), r.push(t.getX(o + 1)), r.push(t.getX(o)));
    r.length / 3 !== i &&
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.",
      );
    const s = n.clone();
    return (s.setIndex(r), s.clearGroups(), s);
  } else
    return (
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
        e,
      ),
      n
    );
}
class fae extends Yd {
  constructor(e) {
    (super(e),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (t) {
        return new Iae(t);
      }),
      this.register(function (t) {
        return new Aae(t);
      }),
      this.register(function (t) {
        return new Eae(t);
      }),
      this.register(function (t) {
        return new Mae(t);
      }),
      this.register(function (t) {
        return new Lae(t);
      }),
      this.register(function (t) {
        return new _ae(t);
      }),
      this.register(function (t) {
        return new bae(t);
      }),
      this.register(function (t) {
        return new vae(t);
      }),
      this.register(function (t) {
        return new xae(t);
      }),
      this.register(function (t) {
        return new Cae(t);
      }),
      this.register(function (t) {
        return new wae(t);
      }),
      this.register(function (t) {
        return new yae(t);
      }),
      this.register(function (t) {
        return new Tae(t);
      }),
      this.register(function (t) {
        return new Sae(t);
      }),
      this.register(function (t) {
        return new pae(t);
      }),
      this.register(function (t) {
        return new Rae(t);
      }),
      this.register(function (t) {
        return new Bae(t);
      }));
  }
  load(e, t, i, r) {
    const s = this;
    let o;
    if (this.resourcePath !== "") o = this.resourcePath;
    else if (this.path !== "") {
      const c = rg.extractUrlBase(e);
      o = rg.resolveURL(c, this.path);
    } else o = rg.extractUrlBase(e);
    this.manager.itemStart(e);
    const a = function (c) {
        (r ? r(c) : console.error(c),
          s.manager.itemError(e),
          s.manager.itemEnd(e));
      },
      l = new IR(this.manager);
    (l.setPath(this.path),
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(this.withCredentials),
      l.load(
        e,
        function (c) {
          try {
            s.parse(
              c,
              o,
              function (u) {
                (t(u), s.manager.itemEnd(e));
              },
              a,
            );
          } catch (u) {
            a(u);
          }
        },
        i,
        a,
      ));
  }
  setDRACOLoader(e) {
    return ((this.dracoLoader = e), this);
  }
  setKTX2Loader(e) {
    return ((this.ktx2Loader = e), this);
  }
  setMeshoptDecoder(e) {
    return ((this.meshoptDecoder = e), this);
  }
  register(e) {
    return (
      this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
      this
    );
  }
  unregister(e) {
    return (
      this.pluginCallbacks.indexOf(e) !== -1 &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    );
  }
  parse(e, t, i, r) {
    let s;
    const o = {},
      a = {},
      l = new TextDecoder();
    if (typeof e == "string") s = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (l.decode(new Uint8Array(e, 0, 4)) === MR) {
        try {
          o[Vt.KHR_BINARY_GLTF] = new Pae(e);
        } catch (h) {
          r && r(h);
          return;
        }
        s = JSON.parse(o[Vt.KHR_BINARY_GLTF].content);
      } else s = JSON.parse(l.decode(e));
    else s = e;
    if (s.asset === void 0 || s.asset.version[0] < 2) {
      r &&
        r(
          new Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.",
          ),
        );
      return;
    }
    const c = new Yae(s, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    c.fileLoader.setRequestHeader(this.requestHeader);
    for (let u = 0; u < this.pluginCallbacks.length; u++) {
      const h = this.pluginCallbacks[u](c);
      (h.name ||
        console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),
        (a[h.name] = h),
        (o[h.name] = !0));
    }
    if (s.extensionsUsed)
      for (let u = 0; u < s.extensionsUsed.length; ++u) {
        const h = s.extensionsUsed[u],
          d = s.extensionsRequired || [];
        switch (h) {
          case Vt.KHR_MATERIALS_UNLIT:
            o[h] = new mae();
            break;
          case Vt.KHR_DRACO_MESH_COMPRESSION:
            o[h] = new Nae(s, this.dracoLoader);
            break;
          case Vt.KHR_TEXTURE_TRANSFORM:
            o[h] = new Dae();
            break;
          case Vt.KHR_MESH_QUANTIZATION:
            o[h] = new Gae();
            break;
          default:
            d.indexOf(h) >= 0 &&
              a[h] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".');
        }
      }
    (c.setExtensions(o), c.setPlugins(a), c.parse(i, r));
  }
  parseAsync(e, t) {
    const i = this;
    return new Promise(function (r, s) {
      i.parse(e, t, r, s);
    });
  }
}
function gae() {
  let n = {};
  return {
    get: function (e) {
      return n[e];
    },
    add: function (e, t) {
      n[e] = t;
    },
    remove: function (e) {
      delete n[e];
    },
    removeAll: function () {
      n = {};
    },
  };
}
const Vt = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
};
class pae {
  constructor(e) {
    ((this.parser = e),
      (this.name = Vt.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} }));
  }
  _markDefs() {
    const e = this.parser,
      t = this.parser.json.nodes || [];
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      s.extensions &&
        s.extensions[this.name] &&
        s.extensions[this.name].light !== void 0 &&
        e._addNodeRef(this.cache, s.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser,
      i = "light:" + e;
    let r = t.cache.get(i);
    if (r) return r;
    const s = t.json,
      l = (((s.extensions && s.extensions[this.name]) || {}).lights || [])[e];
    let c;
    const u = new vt(16777215);
    l.color !== void 0 && u.setRGB(l.color[0], l.color[1], l.color[2], Ir);
    const h = l.range !== void 0 ? l.range : 0;
    switch (l.type) {
      case "directional":
        ((c = new dne(u)), c.target.position.set(0, 0, -1), c.add(c.target));
        break;
      case "point":
        ((c = new yR(u)), (c.distance = h));
        break;
      case "spot":
        ((c = new cne(u)),
          (c.distance = h),
          (l.spot = l.spot || {}),
          (l.spot.innerConeAngle =
            l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0),
          (l.spot.outerConeAngle =
            l.spot.outerConeAngle !== void 0
              ? l.spot.outerConeAngle
              : Math.PI / 4),
          (c.angle = l.spot.outerConeAngle),
          (c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle),
          c.target.position.set(0, 0, -1),
          c.add(c.target));
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
    }
    return (
      c.position.set(0, 0, 0),
      ca(c, l),
      l.intensity !== void 0 && (c.intensity = l.intensity),
      (c.name = t.createUniqueName(l.name || "light_" + e)),
      (r = Promise.resolve(c)),
      t.cache.add(i, r),
      r
    );
  }
  getDependency(e, t) {
    if (e === "light") return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this,
      i = this.parser,
      s = i.json.nodes[e],
      a = ((s.extensions && s.extensions[this.name]) || {}).light;
    return a === void 0
      ? null
      : this._loadLight(a).then(function (l) {
          return i._getNodeRef(t.cache, a, l);
        });
  }
}
class mae {
  constructor() {
    this.name = Vt.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return ma;
  }
  extendParams(e, t, i) {
    const r = [];
    ((e.color = new vt(1, 1, 1)), (e.opacity = 1));
    const s = t.pbrMetallicRoughness;
    if (s) {
      if (Array.isArray(s.baseColorFactor)) {
        const o = s.baseColorFactor;
        (e.color.setRGB(o[0], o[1], o[2], Ir), (e.opacity = o[3]));
      }
      s.baseColorTexture !== void 0 &&
        r.push(i.assignTexture(e, "map", s.baseColorTexture, Gi));
    }
    return Promise.all(r);
  }
}
class Cae {
  constructor(e) {
    ((this.parser = e), (this.name = Vt.KHR_MATERIALS_EMISSIVE_STRENGTH));
  }
  extendMaterialParams(e, t) {
    const r = this.parser.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = r.extensions[this.name].emissiveStrength;
    return (s !== void 0 && (t.emissiveIntensity = s), Promise.resolve());
  }
}
class Iae {
  constructor(e) {
    ((this.parser = e), (this.name = Vt.KHR_MATERIALS_CLEARCOAT));
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : zo;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    if (
      (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor),
      o.clearcoatTexture !== void 0 &&
        s.push(i.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
      o.clearcoatRoughnessFactor !== void 0 &&
        (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
      o.clearcoatRoughnessTexture !== void 0 &&
        s.push(
          i.assignTexture(
            t,
            "clearcoatRoughnessMap",
            o.clearcoatRoughnessTexture,
          ),
        ),
      o.clearcoatNormalTexture !== void 0 &&
        (s.push(
          i.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture),
        ),
        o.clearcoatNormalTexture.scale !== void 0))
    ) {
      const a = o.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new Gt(a, a);
    }
    return Promise.all(s);
  }
}
class Aae {
  constructor(e) {
    ((this.parser = e), (this.name = Vt.KHR_MATERIALS_DISPERSION));
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : zo;
  }
  extendMaterialParams(e, t) {
    const r = this.parser.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = r.extensions[this.name];
    return (
      (t.dispersion = s.dispersion !== void 0 ? s.dispersion : 0),
      Promise.resolve()
    );
  }
}
class yae {
  constructor(e) {
    ((this.parser = e), (this.name = Vt.KHR_MATERIALS_IRIDESCENCE));
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : zo;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    return (
      o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor),
      o.iridescenceTexture !== void 0 &&
        s.push(i.assignTexture(t, "iridescenceMap", o.iridescenceTexture)),
      o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor),
      t.iridescenceThicknessRange === void 0 &&
        (t.iridescenceThicknessRange = [100, 400]),
      o.iridescenceThicknessMinimum !== void 0 &&
        (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
      o.iridescenceThicknessMaximum !== void 0 &&
        (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
      o.iridescenceThicknessTexture !== void 0 &&
        s.push(
          i.assignTexture(
            t,
            "iridescenceThicknessMap",
            o.iridescenceThicknessTexture,
          ),
        ),
      Promise.all(s)
    );
  }
}
class _ae {
  constructor(e) {
    ((this.parser = e), (this.name = Vt.KHR_MATERIALS_SHEEN));
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : zo;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [];
    ((t.sheenColor = new vt(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1));
    const o = r.extensions[this.name];
    if (o.sheenColorFactor !== void 0) {
      const a = o.sheenColorFactor;
      t.sheenColor.setRGB(a[0], a[1], a[2], Ir);
    }
    return (
      o.sheenRoughnessFactor !== void 0 &&
        (t.sheenRoughness = o.sheenRoughnessFactor),
      o.sheenColorTexture !== void 0 &&
        s.push(i.assignTexture(t, "sheenColorMap", o.sheenColorTexture, Gi)),
      o.sheenRoughnessTexture !== void 0 &&
        s.push(
          i.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture),
        ),
      Promise.all(s)
    );
  }
}
class bae {
  constructor(e) {
    ((this.parser = e), (this.name = Vt.KHR_MATERIALS_TRANSMISSION));
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : zo;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    return (
      o.transmissionFactor !== void 0 &&
        (t.transmission = o.transmissionFactor),
      o.transmissionTexture !== void 0 &&
        s.push(i.assignTexture(t, "transmissionMap", o.transmissionTexture)),
      Promise.all(s)
    );
  }
}
class vae {
  constructor(e) {
    ((this.parser = e), (this.name = Vt.KHR_MATERIALS_VOLUME));
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : zo;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    ((t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0),
      o.thicknessTexture !== void 0 &&
        s.push(i.assignTexture(t, "thicknessMap", o.thicknessTexture)),
      (t.attenuationDistance = o.attenuationDistance || 1 / 0));
    const a = o.attenuationColor || [1, 1, 1];
    return (
      (t.attenuationColor = new vt().setRGB(a[0], a[1], a[2], Ir)),
      Promise.all(s)
    );
  }
}
class xae {
  constructor(e) {
    ((this.parser = e), (this.name = Vt.KHR_MATERIALS_IOR));
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : zo;
  }
  extendMaterialParams(e, t) {
    const r = this.parser.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = r.extensions[this.name];
    return ((t.ior = s.ior !== void 0 ? s.ior : 1.5), Promise.resolve());
  }
}
class wae {
  constructor(e) {
    ((this.parser = e), (this.name = Vt.KHR_MATERIALS_SPECULAR));
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : zo;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    ((t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1),
      o.specularTexture !== void 0 &&
        s.push(i.assignTexture(t, "specularIntensityMap", o.specularTexture)));
    const a = o.specularColorFactor || [1, 1, 1];
    return (
      (t.specularColor = new vt().setRGB(a[0], a[1], a[2], Ir)),
      o.specularColorTexture !== void 0 &&
        s.push(
          i.assignTexture(t, "specularColorMap", o.specularColorTexture, Gi),
        ),
      Promise.all(s)
    );
  }
}
class Sae {
  constructor(e) {
    ((this.parser = e), (this.name = Vt.EXT_MATERIALS_BUMP));
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : zo;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    return (
      (t.bumpScale = o.bumpFactor !== void 0 ? o.bumpFactor : 1),
      o.bumpTexture !== void 0 &&
        s.push(i.assignTexture(t, "bumpMap", o.bumpTexture)),
      Promise.all(s)
    );
  }
}
class Tae {
  constructor(e) {
    ((this.parser = e), (this.name = Vt.KHR_MATERIALS_ANISOTROPY));
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : zo;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    return (
      o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength),
      o.anisotropyRotation !== void 0 &&
        (t.anisotropyRotation = o.anisotropyRotation),
      o.anisotropyTexture !== void 0 &&
        s.push(i.assignTexture(t, "anisotropyMap", o.anisotropyTexture)),
      Promise.all(s)
    );
  }
}
class Eae {
  constructor(e) {
    ((this.parser = e), (this.name = Vt.KHR_TEXTURE_BASISU));
  }
  loadTexture(e) {
    const t = this.parser,
      i = t.json,
      r = i.textures[e];
    if (!r.extensions || !r.extensions[this.name]) return null;
    const s = r.extensions[this.name],
      o = t.options.ktx2Loader;
    if (!o) {
      if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures",
        );
      return null;
    }
    return t.loadTextureImage(e, s.source, o);
  }
}
class Mae {
  constructor(e) {
    ((this.parser = e), (this.name = Vt.EXT_TEXTURE_WEBP));
  }
  loadTexture(e) {
    const t = this.name,
      i = this.parser,
      r = i.json,
      s = r.textures[e];
    if (!s.extensions || !s.extensions[t]) return null;
    const o = s.extensions[t],
      a = r.images[o.source];
    let l = i.textureLoader;
    if (a.uri) {
      const c = i.options.manager.getHandler(a.uri);
      c !== null && (l = c);
    }
    return i.loadTextureImage(e, o.source, l);
  }
}
class Lae {
  constructor(e) {
    ((this.parser = e), (this.name = Vt.EXT_TEXTURE_AVIF));
  }
  loadTexture(e) {
    const t = this.name,
      i = this.parser,
      r = i.json,
      s = r.textures[e];
    if (!s.extensions || !s.extensions[t]) return null;
    const o = s.extensions[t],
      a = r.images[o.source];
    let l = i.textureLoader;
    if (a.uri) {
      const c = i.options.manager.getHandler(a.uri);
      c !== null && (l = c);
    }
    return i.loadTextureImage(e, o.source, l);
  }
}
class Rae {
  constructor(e) {
    ((this.name = Vt.EXT_MESHOPT_COMPRESSION), (this.parser = e));
  }
  loadBufferView(e) {
    const t = this.parser.json,
      i = t.bufferViews[e];
    if (i.extensions && i.extensions[this.name]) {
      const r = i.extensions[this.name],
        s = this.parser.getDependency("buffer", r.buffer),
        o = this.parser.options.meshoptDecoder;
      if (!o || !o.supported) {
        if (
          t.extensionsRequired &&
          t.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files",
          );
        return null;
      }
      return s.then(function (a) {
        const l = r.byteOffset || 0,
          c = r.byteLength || 0,
          u = r.count,
          h = r.byteStride,
          d = new Uint8Array(a, l, c);
        return o.decodeGltfBufferAsync
          ? o
              .decodeGltfBufferAsync(u, h, d, r.mode, r.filter)
              .then(function (f) {
                return f.buffer;
              })
          : o.ready.then(function () {
              const f = new ArrayBuffer(u * h);
              return (
                o.decodeGltfBuffer(
                  new Uint8Array(f),
                  u,
                  h,
                  d,
                  r.mode,
                  r.filter,
                ),
                f
              );
            });
      });
    } else return null;
  }
}
class Bae {
  constructor(e) {
    ((this.name = Vt.EXT_MESH_GPU_INSTANCING), (this.parser = e));
  }
  createNodeMesh(e) {
    const t = this.parser.json,
      i = t.nodes[e];
    if (!i.extensions || !i.extensions[this.name] || i.mesh === void 0)
      return null;
    const r = t.meshes[i.mesh];
    for (const c of r.primitives)
      if (
        c.mode !== fs.TRIANGLES &&
        c.mode !== fs.TRIANGLE_STRIP &&
        c.mode !== fs.TRIANGLE_FAN &&
        c.mode !== void 0
      )
        return null;
    const o = i.extensions[this.name].attributes,
      a = [],
      l = {};
    for (const c in o)
      a.push(
        this.parser
          .getDependency("accessor", o[c])
          .then((u) => ((l[c] = u), l[c])),
      );
    return a.length < 1
      ? null
      : (a.push(this.parser.createNodeMesh(e)),
        Promise.all(a).then((c) => {
          const u = c.pop(),
            h = u.isGroup ? u.children : [u],
            d = c[0].count,
            f = [];
          for (const g of h) {
            const p = new Et(),
              m = new X(),
              C = new Qs(),
              A = new X(1, 1, 1),
              I = new Vte(g.geometry, g.material, d);
            for (let y = 0; y < d; y++)
              (l.TRANSLATION && m.fromBufferAttribute(l.TRANSLATION, y),
                l.ROTATION && C.fromBufferAttribute(l.ROTATION, y),
                l.SCALE && A.fromBufferAttribute(l.SCALE, y),
                I.setMatrixAt(y, p.compose(m, C, A)));
            for (const y in l)
              if (y === "_COLOR_0") {
                const x = l[y];
                I.instanceColor = new $_(x.array, x.itemSize, x.normalized);
              } else
                y !== "TRANSLATION" &&
                  y !== "ROTATION" &&
                  y !== "SCALE" &&
                  g.geometry.setAttribute(y, l[y]);
            (Hn.prototype.copy.call(I, g),
              this.parser.assignFinalMaterial(I),
              f.push(I));
          }
          return u.isGroup ? (u.clear(), u.add(...f), u) : f[0];
        }));
  }
}
const MR = "glTF",
  If = 12,
  eS = { JSON: 1313821514, BIN: 5130562 };
class Pae {
  constructor(e) {
    ((this.name = Vt.KHR_BINARY_GLTF),
      (this.content = null),
      (this.body = null));
    const t = new DataView(e, 0, If),
      i = new TextDecoder();
    if (
      ((this.header = {
        magic: i.decode(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0),
      }),
      this.header.magic !== MR)
    )
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const r = this.header.length - If,
      s = new DataView(e, If);
    let o = 0;
    for (; o < r; ) {
      const a = s.getUint32(o, !0);
      o += 4;
      const l = s.getUint32(o, !0);
      if (((o += 4), l === eS.JSON)) {
        const c = new Uint8Array(e, If + o, a);
        this.content = i.decode(c);
      } else if (l === eS.BIN) {
        const c = If + o;
        this.body = e.slice(c, c + a);
      }
      o += a;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class Nae {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    ((this.name = Vt.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = t),
      this.dracoLoader.preload());
  }
  decodePrimitive(e, t) {
    const i = this.json,
      r = this.dracoLoader,
      s = e.extensions[this.name].bufferView,
      o = e.extensions[this.name].attributes,
      a = {},
      l = {},
      c = {};
    for (const u in o) {
      const h = t3[u] || u.toLowerCase();
      a[h] = o[u];
    }
    for (const u in e.attributes) {
      const h = t3[u] || u.toLowerCase();
      if (o[u] !== void 0) {
        const d = i.accessors[e.attributes[u]],
          f = Dh[d.componentType];
        ((c[h] = f.name), (l[h] = d.normalized === !0));
      }
    }
    return t.getDependency("bufferView", s).then(function (u) {
      return new Promise(function (h, d) {
        r.decodeDracoFile(
          u,
          function (f) {
            for (const g in f.attributes) {
              const p = f.attributes[g],
                m = l[g];
              m !== void 0 && (p.normalized = m);
            }
            h(f);
          },
          a,
          c,
          Ir,
          d,
        );
      });
    });
  }
}
class Dae {
  constructor() {
    this.name = Vt.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (
      ((t.texCoord === void 0 || t.texCoord === e.channel) &&
        t.offset === void 0 &&
        t.rotation === void 0 &&
        t.scale === void 0) ||
        ((e = e.clone()),
        t.texCoord !== void 0 && (e.channel = t.texCoord),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        (e.needsUpdate = !0)),
      e
    );
  }
}
class Gae {
  constructor() {
    this.name = Vt.KHR_MESH_QUANTIZATION;
  }
}
class LR extends Ep {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      i = this.sampleValues,
      r = this.valueSize,
      s = e * r * 3 + r;
    for (let o = 0; o !== r; o++) t[o] = i[s + o];
    return t;
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = a * 2,
      c = a * 3,
      u = r - t,
      h = (i - t) / u,
      d = h * h,
      f = d * h,
      g = e * c,
      p = g - c,
      m = -2 * f + 3 * d,
      C = f - d,
      A = 1 - m,
      I = C - d + h;
    for (let y = 0; y !== a; y++) {
      const x = o[p + y + a],
        T = o[p + y + l] * u,
        S = o[g + y + a],
        E = o[g + y] * u;
      s[y] = A * x + I * T + m * S + C * E;
    }
    return s;
  }
}
const Fae = new Qs();
class kae extends LR {
  interpolate_(e, t, i, r) {
    const s = super.interpolate_(e, t, i, r);
    return (Fae.fromArray(s).normalize().toArray(s), s);
  }
}
const fs = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
  },
  Dh = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  tS = { 9728: gi, 9729: Yr, 9984: ZL, 9985: F0, 9986: Ff, 9987: ga },
  nS = { 33071: xo, 33648: zm, 10497: ad },
  J2 = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  t3 = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  qa = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  Oae = { CUBICSPLINE: void 0, LINEAR: Dg, STEP: Ng },
  Q2 = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
function Uae(n) {
  return (
    n.DefaultMaterial === void 0 &&
      (n.DefaultMaterial = new sI({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: Go,
      })),
    n.DefaultMaterial
  );
}
function cc(n, e, t) {
  for (const i in t.extensions)
    n[i] === void 0 &&
      ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
      (e.userData.gltfExtensions[i] = t.extensions[i]));
}
function ca(n, e) {
  e.extras !== void 0 &&
    (typeof e.extras == "object"
      ? Object.assign(n.userData, e.extras)
      : console.warn(
          "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras,
        ));
}
function Hae(n, e, t) {
  let i = !1,
    r = !1,
    s = !1;
  for (let c = 0, u = e.length; c < u; c++) {
    const h = e[c];
    if (
      (h.POSITION !== void 0 && (i = !0),
      h.NORMAL !== void 0 && (r = !0),
      h.COLOR_0 !== void 0 && (s = !0),
      i && r && s)
    )
      break;
  }
  if (!i && !r && !s) return Promise.resolve(n);
  const o = [],
    a = [],
    l = [];
  for (let c = 0, u = e.length; c < u; c++) {
    const h = e[c];
    if (i) {
      const d =
        h.POSITION !== void 0
          ? t.getDependency("accessor", h.POSITION)
          : n.attributes.position;
      o.push(d);
    }
    if (r) {
      const d =
        h.NORMAL !== void 0
          ? t.getDependency("accessor", h.NORMAL)
          : n.attributes.normal;
      a.push(d);
    }
    if (s) {
      const d =
        h.COLOR_0 !== void 0
          ? t.getDependency("accessor", h.COLOR_0)
          : n.attributes.color;
      l.push(d);
    }
  }
  return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(
    function (c) {
      const u = c[0],
        h = c[1],
        d = c[2];
      return (
        i && (n.morphAttributes.position = u),
        r && (n.morphAttributes.normal = h),
        s && (n.morphAttributes.color = d),
        (n.morphTargetsRelative = !0),
        n
      );
    },
  );
}
function Wae(n, e) {
  if ((n.updateMorphTargets(), e.weights !== void 0))
    for (let t = 0, i = e.weights.length; t < i; t++)
      n.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (n.morphTargetInfluences.length === t.length) {
      n.morphTargetDictionary = {};
      for (let i = 0, r = t.length; i < r; i++)
        n.morphTargetDictionary[t[i]] = i;
    } else
      console.warn(
        "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.",
      );
  }
}
function Vae(n) {
  let e;
  const t = n.extensions && n.extensions[Vt.KHR_DRACO_MESH_COMPRESSION];
  if (
    (t
      ? (e = "draco:" + t.bufferView + ":" + t.indices + ":" + q2(t.attributes))
      : (e = n.indices + ":" + q2(n.attributes) + ":" + n.mode),
    n.targets !== void 0)
  )
    for (let i = 0, r = n.targets.length; i < r; i++)
      e += ":" + q2(n.targets[i]);
  return e;
}
function q2(n) {
  let e = "";
  const t = Object.keys(n).sort();
  for (let i = 0, r = t.length; i < r; i++) e += t[i] + ":" + n[t[i]] + ";";
  return e;
}
function n3(n) {
  switch (n) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type.",
      );
  }
}
function Zae(n) {
  return n.search(/\.jpe?g($|\?)/i) > 0 || n.search(/^data\:image\/jpeg/) === 0
    ? "image/jpeg"
    : n.search(/\.webp($|\?)/i) > 0 || n.search(/^data\:image\/webp/) === 0
      ? "image/webp"
      : n.search(/\.ktx2($|\?)/i) > 0 || n.search(/^data\:image\/ktx2/) === 0
        ? "image/ktx2"
        : "image/png";
}
const zae = new Et();
class Yae {
  constructor(e = {}, t = {}) {
    ((this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = t),
      (this.cache = new gae()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.nodeCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {}));
    let i = !1,
      r = -1,
      s = !1,
      o = -1;
    if (typeof navigator < "u") {
      const a = navigator.userAgent;
      i = /^((?!chrome|android).)*safari/i.test(a) === !0;
      const l = a.match(/Version\/(\d+)/);
      ((r = i && l ? parseInt(l[1], 10) : -1),
        (s = a.indexOf("Firefox") > -1),
        (o = s ? a.match(/Firefox\/([0-9]+)\./)[1] : -1));
    }
    (typeof createImageBitmap > "u" || (i && r < 17) || (s && o < 98)
      ? (this.textureLoader = new AR(this.options.manager))
      : (this.textureLoader = new fne(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new IR(this.options.manager)),
      this.fileLoader.setResponseType("arraybuffer"),
      this.options.crossOrigin === "use-credentials" &&
        this.fileLoader.setWithCredentials(!0));
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const i = this,
      r = this.json,
      s = this.extensions;
    (this.cache.removeAll(),
      (this.nodeCache = {}),
      this._invokeAll(function (o) {
        return o._markDefs && o._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (o) {
          return o.beforeRoot && o.beforeRoot();
        }),
      )
        .then(function () {
          return Promise.all([
            i.getDependencies("scene"),
            i.getDependencies("animation"),
            i.getDependencies("camera"),
          ]);
        })
        .then(function (o) {
          const a = {
            scene: o[0][r.scene || 0],
            scenes: o[0],
            animations: o[1],
            cameras: o[2],
            asset: r.asset,
            parser: i,
            userData: {},
          };
          return (
            cc(s, a, r),
            ca(a, r),
            Promise.all(
              i._invokeAll(function (l) {
                return l.afterRoot && l.afterRoot(a);
              }),
            ).then(function () {
              for (const l of a.scenes) l.updateMatrixWorld();
              e(a);
            })
          );
        })
        .catch(t));
  }
  _markDefs() {
    const e = this.json.nodes || [],
      t = this.json.skins || [],
      i = this.json.meshes || [];
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r].joints;
      for (let a = 0, l = o.length; a < l; a++) e[o[a]].isBone = !0;
    }
    for (let r = 0, s = e.length; r < s; r++) {
      const o = e[r];
      (o.mesh !== void 0 &&
        (this._addNodeRef(this.meshCache, o.mesh),
        o.skin !== void 0 && (i[o.mesh].isSkinnedMesh = !0)),
        o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera));
    }
  }
  _addNodeRef(e, t) {
    t !== void 0 &&
      (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  _getNodeRef(e, t, i) {
    if (e.refs[t] <= 1) return i;
    const r = i.clone(),
      s = (o, a) => {
        const l = this.associations.get(o);
        l != null && this.associations.set(a, l);
        for (const [c, u] of o.children.entries()) s(u, a.children[c]);
      };
    return (s(i, r), (r.name += "_instance_" + e.uses[t]++), r);
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let i = 0; i < t.length; i++) {
      const r = e(t[i]);
      if (r) return r;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const i = [];
    for (let r = 0; r < t.length; r++) {
      const s = e(t[r]);
      s && i.push(s);
    }
    return i;
  }
  getDependency(e, t) {
    const i = e + ":" + t;
    let r = this.cache.get(i);
    if (!r) {
      switch (e) {
        case "scene":
          r = this.loadScene(t);
          break;
        case "node":
          r = this._invokeOne(function (s) {
            return s.loadNode && s.loadNode(t);
          });
          break;
        case "mesh":
          r = this._invokeOne(function (s) {
            return s.loadMesh && s.loadMesh(t);
          });
          break;
        case "accessor":
          r = this.loadAccessor(t);
          break;
        case "bufferView":
          r = this._invokeOne(function (s) {
            return s.loadBufferView && s.loadBufferView(t);
          });
          break;
        case "buffer":
          r = this.loadBuffer(t);
          break;
        case "material":
          r = this._invokeOne(function (s) {
            return s.loadMaterial && s.loadMaterial(t);
          });
          break;
        case "texture":
          r = this._invokeOne(function (s) {
            return s.loadTexture && s.loadTexture(t);
          });
          break;
        case "skin":
          r = this.loadSkin(t);
          break;
        case "animation":
          r = this._invokeOne(function (s) {
            return s.loadAnimation && s.loadAnimation(t);
          });
          break;
        case "camera":
          r = this.loadCamera(t);
          break;
        default:
          if (
            ((r = this._invokeOne(function (s) {
              return s != this && s.getDependency && s.getDependency(e, t);
            })),
            !r)
          )
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(i, r);
    }
    return r;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const i = this,
        r = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      ((t = Promise.all(
        r.map(function (s, o) {
          return i.getDependency(e, o);
        }),
      )),
        this.cache.add(e, t));
    }
    return t;
  }
  loadBuffer(e) {
    const t = this.json.buffers[e],
      i = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error(
        "THREE.GLTFLoader: " + t.type + " buffer type is not supported.",
      );
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[Vt.KHR_BINARY_GLTF].body);
    const r = this.options;
    return new Promise(function (s, o) {
      i.load(rg.resolveURL(t.uri, r.path), s, void 0, function () {
        o(
          new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'),
        );
      });
    });
  }
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function (i) {
      const r = t.byteLength || 0,
        s = t.byteOffset || 0;
      return i.slice(s, s + r);
    });
  }
  loadAccessor(e) {
    const t = this,
      i = this.json,
      r = this.json.accessors[e];
    if (r.bufferView === void 0 && r.sparse === void 0) {
      const o = J2[r.type],
        a = Dh[r.componentType],
        l = r.normalized === !0,
        c = new a(r.count * o);
      return Promise.resolve(new Pi(c, o, l));
    }
    const s = [];
    return (
      r.bufferView !== void 0
        ? s.push(this.getDependency("bufferView", r.bufferView))
        : s.push(null),
      r.sparse !== void 0 &&
        (s.push(this.getDependency("bufferView", r.sparse.indices.bufferView)),
        s.push(this.getDependency("bufferView", r.sparse.values.bufferView))),
      Promise.all(s).then(function (o) {
        const a = o[0],
          l = J2[r.type],
          c = Dh[r.componentType],
          u = c.BYTES_PER_ELEMENT,
          h = u * l,
          d = r.byteOffset || 0,
          f =
            r.bufferView !== void 0
              ? i.bufferViews[r.bufferView].byteStride
              : void 0,
          g = r.normalized === !0;
        let p, m;
        if (f && f !== h) {
          const C = Math.floor(d / f),
            A =
              "InterleavedBuffer:" +
              r.bufferView +
              ":" +
              r.componentType +
              ":" +
              C +
              ":" +
              r.count;
          let I = t.cache.get(A);
          (I ||
            ((p = new c(a, C * f, (r.count * f) / u)),
            (I = new kte(p, f / u)),
            t.cache.add(A, I)),
            (m = new Wv(I, l, (d % f) / u, g)));
        } else
          (a === null
            ? (p = new c(r.count * l))
            : (p = new c(a, d, r.count * l)),
            (m = new Pi(p, l, g)));
        if (r.sparse !== void 0) {
          const C = J2.SCALAR,
            A = Dh[r.sparse.indices.componentType],
            I = r.sparse.indices.byteOffset || 0,
            y = r.sparse.values.byteOffset || 0,
            x = new A(o[1], I, r.sparse.count * C),
            T = new c(o[2], y, r.sparse.count * l);
          (a !== null &&
            (m = new Pi(m.array.slice(), m.itemSize, m.normalized)),
            (m.normalized = !1));
          for (let S = 0, E = x.length; S < E; S++) {
            const _ = x[S];
            if (
              (m.setX(_, T[S * l]),
              l >= 2 && m.setY(_, T[S * l + 1]),
              l >= 3 && m.setZ(_, T[S * l + 2]),
              l >= 4 && m.setW(_, T[S * l + 3]),
              l >= 5)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.",
              );
          }
          m.normalized = g;
        }
        return m;
      })
    );
  }
  loadTexture(e) {
    const t = this.json,
      i = this.options,
      s = t.textures[e].source,
      o = t.images[s];
    let a = this.textureLoader;
    if (o.uri) {
      const l = i.manager.getHandler(o.uri);
      l !== null && (a = l);
    }
    return this.loadTextureImage(e, s, a);
  }
  loadTextureImage(e, t, i) {
    const r = this,
      s = this.json,
      o = s.textures[e],
      a = s.images[t],
      l = (a.uri || a.bufferView) + ":" + o.sampler;
    if (this.textureCache[l]) return this.textureCache[l];
    const c = this.loadImageSource(t, i)
      .then(function (u) {
        ((u.flipY = !1),
          (u.name = o.name || a.name || ""),
          u.name === "" &&
            typeof a.uri == "string" &&
            a.uri.startsWith("data:image/") === !1 &&
            (u.name = a.uri));
        const d = (s.samplers || {})[o.sampler] || {};
        return (
          (u.magFilter = tS[d.magFilter] || Yr),
          (u.minFilter = tS[d.minFilter] || ga),
          (u.wrapS = nS[d.wrapS] || ad),
          (u.wrapT = nS[d.wrapT] || ad),
          (u.generateMipmaps =
            !u.isCompressedTexture && u.minFilter !== gi && u.minFilter !== Yr),
          r.associations.set(u, { textures: e }),
          u
        );
      })
      .catch(function () {
        return null;
      });
    return ((this.textureCache[l] = c), c);
  }
  loadImageSource(e, t) {
    const i = this,
      r = this.json,
      s = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((h) => h.clone());
    const o = r.images[e],
      a = self.URL || self.webkitURL;
    let l = o.uri || "",
      c = !1;
    if (o.bufferView !== void 0)
      l = i.getDependency("bufferView", o.bufferView).then(function (h) {
        c = !0;
        const d = new Blob([h], { type: o.mimeType });
        return ((l = a.createObjectURL(d)), l);
      });
    else if (o.uri === void 0)
      throw new Error(
        "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView",
      );
    const u = Promise.resolve(l)
      .then(function (h) {
        return new Promise(function (d, f) {
          let g = d;
          (t.isImageBitmapLoader === !0 &&
            (g = function (p) {
              const m = new Oi(p);
              ((m.needsUpdate = !0), d(m));
            }),
            t.load(rg.resolveURL(h, s.path), g, void 0, f));
        });
      })
      .then(function (h) {
        return (
          c === !0 && a.revokeObjectURL(l),
          ca(h, o),
          (h.userData.mimeType = o.mimeType || Zae(o.uri)),
          h
        );
      })
      .catch(function (h) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", l), h);
      });
    return ((this.sourceCache[e] = u), u);
  }
  assignTexture(e, t, i, r) {
    const s = this;
    return this.getDependency("texture", i.index).then(function (o) {
      if (!o) return null;
      if (
        (i.texCoord !== void 0 &&
          i.texCoord > 0 &&
          ((o = o.clone()), (o.channel = i.texCoord)),
        s.extensions[Vt.KHR_TEXTURE_TRANSFORM])
      ) {
        const a =
          i.extensions !== void 0
            ? i.extensions[Vt.KHR_TEXTURE_TRANSFORM]
            : void 0;
        if (a) {
          const l = s.associations.get(o);
          ((o = s.extensions[Vt.KHR_TEXTURE_TRANSFORM].extendTexture(o, a)),
            s.associations.set(o, l));
        }
      }
      return (r !== void 0 && (o.colorSpace = r), (e[t] = o), o);
    });
  }
  assignFinalMaterial(e) {
    const t = e.geometry;
    let i = e.material;
    const r = t.attributes.tangent === void 0,
      s = t.attributes.color !== void 0,
      o = t.attributes.normal === void 0;
    if (e.isPoints) {
      const a = "PointsMaterial:" + i.uuid;
      let l = this.cache.get(a);
      (l ||
        ((l = new hR()),
        Mo.prototype.copy.call(l, i),
        l.color.copy(i.color),
        (l.map = i.map),
        (l.sizeAttenuation = !1),
        this.cache.add(a, l)),
        (i = l));
    } else if (e.isLine) {
      const a = "LineBasicMaterial:" + i.uuid;
      let l = this.cache.get(a);
      (l ||
        ((l = new uR()),
        Mo.prototype.copy.call(l, i),
        l.color.copy(i.color),
        (l.map = i.map),
        this.cache.add(a, l)),
        (i = l));
    }
    if (r || s || o) {
      let a = "ClonedMaterial:" + i.uuid + ":";
      (r && (a += "derivative-tangents:"),
        s && (a += "vertex-colors:"),
        o && (a += "flat-shading:"));
      let l = this.cache.get(a);
      (l ||
        ((l = i.clone()),
        s && (l.vertexColors = !0),
        o && (l.flatShading = !0),
        r &&
          (l.normalScale && (l.normalScale.y *= -1),
          l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
        this.cache.add(a, l),
        this.associations.set(l, this.associations.get(i))),
        (i = l));
    }
    e.material = i;
  }
  getMaterialType() {
    return sI;
  }
  loadMaterial(e) {
    const t = this,
      i = this.json,
      r = this.extensions,
      s = i.materials[e];
    let o;
    const a = {},
      l = s.extensions || {},
      c = [];
    if (l[Vt.KHR_MATERIALS_UNLIT]) {
      const h = r[Vt.KHR_MATERIALS_UNLIT];
      ((o = h.getMaterialType()), c.push(h.extendParams(a, s, t)));
    } else {
      const h = s.pbrMetallicRoughness || {};
      if (
        ((a.color = new vt(1, 1, 1)),
        (a.opacity = 1),
        Array.isArray(h.baseColorFactor))
      ) {
        const d = h.baseColorFactor;
        (a.color.setRGB(d[0], d[1], d[2], Ir), (a.opacity = d[3]));
      }
      (h.baseColorTexture !== void 0 &&
        c.push(t.assignTexture(a, "map", h.baseColorTexture, Gi)),
        (a.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1),
        (a.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1),
        h.metallicRoughnessTexture !== void 0 &&
          (c.push(
            t.assignTexture(a, "metalnessMap", h.metallicRoughnessTexture),
          ),
          c.push(
            t.assignTexture(a, "roughnessMap", h.metallicRoughnessTexture),
          )),
        (o = this._invokeOne(function (d) {
          return d.getMaterialType && d.getMaterialType(e);
        })),
        c.push(
          Promise.all(
            this._invokeAll(function (d) {
              return d.extendMaterialParams && d.extendMaterialParams(e, a);
            }),
          ),
        ));
    }
    s.doubleSided === !0 && (a.side = Ao);
    const u = s.alphaMode || Q2.OPAQUE;
    if (
      (u === Q2.BLEND
        ? ((a.transparent = !0), (a.depthWrite = !1))
        : ((a.transparent = !1),
          u === Q2.MASK &&
            (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)),
      s.normalTexture !== void 0 &&
        o !== ma &&
        (c.push(t.assignTexture(a, "normalMap", s.normalTexture)),
        (a.normalScale = new Gt(1, 1)),
        s.normalTexture.scale !== void 0))
    ) {
      const h = s.normalTexture.scale;
      a.normalScale.set(h, h);
    }
    if (
      (s.occlusionTexture !== void 0 &&
        o !== ma &&
        (c.push(t.assignTexture(a, "aoMap", s.occlusionTexture)),
        s.occlusionTexture.strength !== void 0 &&
          (a.aoMapIntensity = s.occlusionTexture.strength)),
      s.emissiveFactor !== void 0 && o !== ma)
    ) {
      const h = s.emissiveFactor;
      a.emissive = new vt().setRGB(h[0], h[1], h[2], Ir);
    }
    return (
      s.emissiveTexture !== void 0 &&
        o !== ma &&
        c.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, Gi)),
      Promise.all(c).then(function () {
        const h = new o(a);
        return (
          s.name && (h.name = s.name),
          ca(h, s),
          t.associations.set(h, { materials: e }),
          s.extensions && cc(r, h, s),
          h
        );
      })
    );
  }
  createUniqueName(e) {
    const t = hn.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed
      ? t + "_" + ++this.nodeNamesUsed[t]
      : ((this.nodeNamesUsed[t] = 0), t);
  }
  loadGeometries(e) {
    const t = this,
      i = this.extensions,
      r = this.primitiveCache;
    function s(a) {
      return i[Vt.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(a, t)
        .then(function (l) {
          return iS(l, a, t);
        });
    }
    const o = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a],
        u = Vae(c),
        h = r[u];
      if (h) o.push(h.promise);
      else {
        let d;
        (c.extensions && c.extensions[Vt.KHR_DRACO_MESH_COMPRESSION]
          ? (d = s(c))
          : (d = iS(new Pr(), c, t)),
          (r[u] = { primitive: c, promise: d }),
          o.push(d));
      }
    }
    return Promise.all(o);
  }
  loadMesh(e) {
    const t = this,
      i = this.json,
      r = this.extensions,
      s = i.meshes[e],
      o = s.primitives,
      a = [];
    for (let l = 0, c = o.length; l < c; l++) {
      const u =
        o[l].material === void 0
          ? Uae(this.cache)
          : this.getDependency("material", o[l].material);
      a.push(u);
    }
    return (
      a.push(t.loadGeometries(o)),
      Promise.all(a).then(function (l) {
        const c = l.slice(0, l.length - 1),
          u = l[l.length - 1],
          h = [];
        for (let f = 0, g = u.length; f < g; f++) {
          const p = u[f],
            m = o[f];
          let C;
          const A = c[f];
          if (
            m.mode === fs.TRIANGLES ||
            m.mode === fs.TRIANGLE_STRIP ||
            m.mode === fs.TRIANGLE_FAN ||
            m.mode === void 0
          )
            ((C = s.isSkinnedMesh === !0 ? new Ute(p, A) : new si(p, A)),
              C.isSkinnedMesh === !0 && C.normalizeSkinWeights(),
              m.mode === fs.TRIANGLE_STRIP
                ? (C.geometry = qw(C.geometry, QL))
                : m.mode === fs.TRIANGLE_FAN &&
                  (C.geometry = qw(C.geometry, K_)));
          else if (m.mode === fs.LINES) C = new Yte(p, A);
          else if (m.mode === fs.LINE_STRIP) C = new Yv(p, A);
          else if (m.mode === fs.LINE_LOOP) C = new Xte(p, A);
          else if (m.mode === fs.POINTS) C = new dR(p, A);
          else
            throw new Error(
              "THREE.GLTFLoader: Primitive mode unsupported: " + m.mode,
            );
          (Object.keys(C.geometry.morphAttributes).length > 0 && Wae(C, s),
            (C.name = t.createUniqueName(s.name || "mesh_" + e)),
            ca(C, s),
            m.extensions && cc(r, C, m),
            t.assignFinalMaterial(C),
            h.push(C));
        }
        for (let f = 0, g = h.length; f < g; f++)
          t.associations.set(h[f], { meshes: e, primitives: f });
        if (h.length === 1) return (s.extensions && cc(r, h[0], s), h[0]);
        const d = new Is();
        (s.extensions && cc(r, d, s), t.associations.set(d, { meshes: e }));
        for (let f = 0, g = h.length; f < g; f++) d.add(h[f]);
        return d;
      })
    );
  }
  loadCamera(e) {
    let t;
    const i = this.json.cameras[e],
      r = i[i.type];
    if (!r) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return (
      i.type === "perspective"
        ? (t = new Ri(
            zc.radToDeg(r.yfov),
            r.aspectRatio || 1,
            r.znear || 1,
            r.zfar || 2e6,
          ))
        : i.type === "orthographic" &&
          (t = new aI(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)),
      i.name && (t.name = this.createUniqueName(i.name)),
      ca(t, i),
      Promise.resolve(t)
    );
  }
  loadSkin(e) {
    const t = this.json.skins[e],
      i = [];
    for (let r = 0, s = t.joints.length; r < s; r++)
      i.push(this._loadNodeShallow(t.joints[r]));
    return (
      t.inverseBindMatrices !== void 0
        ? i.push(this.getDependency("accessor", t.inverseBindMatrices))
        : i.push(null),
      Promise.all(i).then(function (r) {
        const s = r.pop(),
          o = r,
          a = [],
          l = [];
        for (let c = 0, u = o.length; c < u; c++) {
          const h = o[c];
          if (h) {
            a.push(h);
            const d = new Et();
            (s !== null && d.fromArray(s.array, c * 16), l.push(d));
          } else
            console.warn(
              'THREE.GLTFLoader: Joint "%s" could not be found.',
              t.joints[c],
            );
        }
        return new Zv(a, l);
      })
    );
  }
  loadAnimation(e) {
    const t = this.json,
      i = this,
      r = t.animations[e],
      s = r.name ? r.name : "animation_" + e,
      o = [],
      a = [],
      l = [],
      c = [],
      u = [];
    for (let h = 0, d = r.channels.length; h < d; h++) {
      const f = r.channels[h],
        g = r.samplers[f.sampler],
        p = f.target,
        m = p.node,
        C = r.parameters !== void 0 ? r.parameters[g.input] : g.input,
        A = r.parameters !== void 0 ? r.parameters[g.output] : g.output;
      p.node !== void 0 &&
        (o.push(this.getDependency("node", m)),
        a.push(this.getDependency("accessor", C)),
        l.push(this.getDependency("accessor", A)),
        c.push(g),
        u.push(p));
    }
    return Promise.all([
      Promise.all(o),
      Promise.all(a),
      Promise.all(l),
      Promise.all(c),
      Promise.all(u),
    ]).then(function (h) {
      const d = h[0],
        f = h[1],
        g = h[2],
        p = h[3],
        m = h[4],
        C = [];
      for (let A = 0, I = d.length; A < I; A++) {
        const y = d[A],
          x = f[A],
          T = g[A],
          S = p[A],
          E = m[A];
        if (y === void 0) continue;
        y.updateMatrix && y.updateMatrix();
        const _ = i._createAnimationTracks(y, x, T, S, E);
        if (_) for (let b = 0; b < _.length; b++) C.push(_[b]);
      }
      return new Q_(s, void 0, C);
    });
  }
  createNodeMesh(e) {
    const t = this.json,
      i = this,
      r = t.nodes[e];
    return r.mesh === void 0
      ? null
      : i.getDependency("mesh", r.mesh).then(function (s) {
          const o = i._getNodeRef(i.meshCache, r.mesh, s);
          return (
            r.weights !== void 0 &&
              o.traverse(function (a) {
                if (a.isMesh)
                  for (let l = 0, c = r.weights.length; l < c; l++)
                    a.morphTargetInfluences[l] = r.weights[l];
              }),
            o
          );
        });
  }
  loadNode(e) {
    const t = this.json,
      i = this,
      r = t.nodes[e],
      s = i._loadNodeShallow(e),
      o = [],
      a = r.children || [];
    for (let c = 0, u = a.length; c < u; c++)
      o.push(i.getDependency("node", a[c]));
    const l =
      r.skin === void 0
        ? Promise.resolve(null)
        : i.getDependency("skin", r.skin);
    return Promise.all([s, Promise.all(o), l]).then(function (c) {
      const u = c[0],
        h = c[1],
        d = c[2];
      d !== null &&
        u.traverse(function (f) {
          f.isSkinnedMesh && f.bind(d, zae);
        });
      for (let f = 0, g = h.length; f < g; f++) u.add(h[f]);
      return u;
    });
  }
  _loadNodeShallow(e) {
    const t = this.json,
      i = this.extensions,
      r = this;
    if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
    const s = t.nodes[e],
      o = s.name ? r.createUniqueName(s.name) : "",
      a = [],
      l = r._invokeOne(function (c) {
        return c.createNodeMesh && c.createNodeMesh(e);
      });
    return (
      l && a.push(l),
      s.camera !== void 0 &&
        a.push(
          r.getDependency("camera", s.camera).then(function (c) {
            return r._getNodeRef(r.cameraCache, s.camera, c);
          }),
        ),
      r
        ._invokeAll(function (c) {
          return c.createNodeAttachment && c.createNodeAttachment(e);
        })
        .forEach(function (c) {
          a.push(c);
        }),
      (this.nodeCache[e] = Promise.all(a).then(function (c) {
        let u;
        if (
          (s.isBone === !0
            ? (u = new cR())
            : c.length > 1
              ? (u = new Is())
              : c.length === 1
                ? (u = c[0])
                : (u = new Hn()),
          u !== c[0])
        )
          for (let h = 0, d = c.length; h < d; h++) u.add(c[h]);
        if (
          (s.name && ((u.userData.name = s.name), (u.name = o)),
          ca(u, s),
          s.extensions && cc(i, u, s),
          s.matrix !== void 0)
        ) {
          const h = new Et();
          (h.fromArray(s.matrix), u.applyMatrix4(h));
        } else
          (s.translation !== void 0 && u.position.fromArray(s.translation),
            s.rotation !== void 0 && u.quaternion.fromArray(s.rotation),
            s.scale !== void 0 && u.scale.fromArray(s.scale));
        return (
          r.associations.has(u) || r.associations.set(u, {}),
          (r.associations.get(u).nodes = e),
          u
        );
      })),
      this.nodeCache[e]
    );
  }
  loadScene(e) {
    const t = this.extensions,
      i = this.json.scenes[e],
      r = this,
      s = new Is();
    (i.name && (s.name = r.createUniqueName(i.name)),
      ca(s, i),
      i.extensions && cc(t, s, i));
    const o = i.nodes || [],
      a = [];
    for (let l = 0, c = o.length; l < c; l++)
      a.push(r.getDependency("node", o[l]));
    return Promise.all(a).then(function (l) {
      for (let u = 0, h = l.length; u < h; u++) s.add(l[u]);
      const c = (u) => {
        const h = new Map();
        for (const [d, f] of r.associations)
          (d instanceof Mo || d instanceof Oi) && h.set(d, f);
        return (
          u.traverse((d) => {
            const f = r.associations.get(d);
            f != null && h.set(d, f);
          }),
          h
        );
      };
      return ((r.associations = c(s)), s);
    });
  }
  _createAnimationTracks(e, t, i, r, s) {
    const o = [],
      a = e.name ? e.name : e.uuid,
      l = [];
    qa[s.path] === qa.weights
      ? e.traverse(function (d) {
          d.morphTargetInfluences && l.push(d.name ? d.name : d.uuid);
        })
      : l.push(a);
    let c;
    switch (qa[s.path]) {
      case qa.weights:
        c = ud;
        break;
      case qa.rotation:
        c = hd;
        break;
      case qa.translation:
      case qa.scale:
        c = dd;
        break;
      default:
        switch (i.itemSize) {
          case 1:
            c = ud;
            break;
          case 2:
          case 3:
          default:
            c = dd;
            break;
        }
        break;
    }
    const u = r.interpolation !== void 0 ? Oae[r.interpolation] : Dg,
      h = this._getArrayFromAccessor(i);
    for (let d = 0, f = l.length; d < f; d++) {
      const g = new c(l[d] + "." + qa[s.path], t.array, h, u);
      (r.interpolation === "CUBICSPLINE" &&
        this._createCubicSplineTrackInterpolant(g),
        o.push(g));
    }
    return o;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const i = n3(t.constructor),
        r = new Float32Array(t.length);
      for (let s = 0, o = t.length; s < o; s++) r[s] = t[s] * i;
      t = r;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    ((e.createInterpolant = function (i) {
      const r = this instanceof hd ? kae : LR;
      return new r(this.times, this.values, this.getValueSize() / 3, i);
    }),
      (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0));
  }
}
function Xae(n, e, t) {
  const i = e.attributes,
    r = new ka();
  if (i.POSITION !== void 0) {
    const a = t.json.accessors[i.POSITION],
      l = a.min,
      c = a.max;
    if (l !== void 0 && c !== void 0) {
      if (
        (r.set(new X(l[0], l[1], l[2]), new X(c[0], c[1], c[2])), a.normalized)
      ) {
        const u = n3(Dh[a.componentType]);
        (r.min.multiplyScalar(u), r.max.multiplyScalar(u));
      }
    } else {
      console.warn(
        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION.",
      );
      return;
    }
  } else return;
  const s = e.targets;
  if (s !== void 0) {
    const a = new X(),
      l = new X();
    for (let c = 0, u = s.length; c < u; c++) {
      const h = s[c];
      if (h.POSITION !== void 0) {
        const d = t.json.accessors[h.POSITION],
          f = d.min,
          g = d.max;
        if (f !== void 0 && g !== void 0) {
          if (
            (l.setX(Math.max(Math.abs(f[0]), Math.abs(g[0]))),
            l.setY(Math.max(Math.abs(f[1]), Math.abs(g[1]))),
            l.setZ(Math.max(Math.abs(f[2]), Math.abs(g[2]))),
            d.normalized)
          ) {
            const p = n3(Dh[d.componentType]);
            l.multiplyScalar(p);
          }
          a.max(l);
        } else
          console.warn(
            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION.",
          );
      }
    }
    r.expandByVector(a);
  }
  n.boundingBox = r;
  const o = new Zo();
  (r.getCenter(o.center),
    (o.radius = r.min.distanceTo(r.max) / 2),
    (n.boundingSphere = o));
}
function iS(n, e, t) {
  const i = e.attributes,
    r = [];
  function s(o, a) {
    return t.getDependency("accessor", o).then(function (l) {
      n.setAttribute(a, l);
    });
  }
  for (const o in i) {
    const a = t3[o] || o.toLowerCase();
    a in n.attributes || r.push(s(i[o], a));
  }
  if (e.indices !== void 0 && !n.index) {
    const o = t.getDependency("accessor", e.indices).then(function (a) {
      n.setIndex(a);
    });
    r.push(o);
  }
  return (
    Kt.workingColorSpace !== Ir &&
      "COLOR_0" in i &&
      console.warn(
        `THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Kt.workingColorSpace}" not supported.`,
      ),
    ca(n, e),
    Xae(n, e, t),
    Promise.all(r).then(function () {
      return e.targets !== void 0 ? Hae(n, e.targets, t) : n;
    })
  );
}
class Kae {
  constructor(e, t, i) {
    ((this.variables = []), (this.currentTextureIndex = 0));
    let r = Xr;
    const s = { passThruTexture: { value: null } },
      o = c(h(), s),
      a = new dae(o);
    ((this.setDataType = function (d) {
      return ((r = d), this);
    }),
      (this.addVariable = function (d, f, g) {
        const p = this.createShaderMaterial(f),
          m = {
            name: d,
            initialValueTexture: g,
            material: p,
            dependencies: null,
            renderTargets: [],
            wrapS: null,
            wrapT: null,
            minFilter: gi,
            magFilter: gi,
          };
        return (this.variables.push(m), m);
      }),
      (this.setVariableDependencies = function (d, f) {
        d.dependencies = f;
      }),
      (this.init = function () {
        if (i.capabilities.maxVertexTextures === 0)
          return "No support for vertex shader textures.";
        for (let d = 0; d < this.variables.length; d++) {
          const f = this.variables[d];
          ((f.renderTargets[0] = this.createRenderTarget(
            e,
            t,
            f.wrapS,
            f.wrapT,
            f.minFilter,
            f.magFilter,
          )),
            (f.renderTargets[1] = this.createRenderTarget(
              e,
              t,
              f.wrapS,
              f.wrapT,
              f.minFilter,
              f.magFilter,
            )),
            this.renderTexture(f.initialValueTexture, f.renderTargets[0]),
            this.renderTexture(f.initialValueTexture, f.renderTargets[1]));
          const g = f.material,
            p = g.uniforms;
          if (f.dependencies !== null)
            for (let m = 0; m < f.dependencies.length; m++) {
              const C = f.dependencies[m];
              if (C.name !== f.name) {
                let A = !1;
                for (let I = 0; I < this.variables.length; I++)
                  if (C.name === this.variables[I].name) {
                    A = !0;
                    break;
                  }
                if (!A)
                  return (
                    "Variable dependency not found. Variable=" +
                    f.name +
                    ", dependency=" +
                    C.name
                  );
              }
              ((p[C.name] = { value: null }),
                (g.fragmentShader =
                  `
uniform sampler2D ` +
                  C.name +
                  `;
` +
                  g.fragmentShader));
            }
        }
        return ((this.currentTextureIndex = 0), null);
      }),
      (this.compute = function () {
        const d = this.currentTextureIndex,
          f = this.currentTextureIndex === 0 ? 1 : 0;
        for (let g = 0, p = this.variables.length; g < p; g++) {
          const m = this.variables[g];
          if (m.dependencies !== null) {
            const C = m.material.uniforms;
            for (let A = 0, I = m.dependencies.length; A < I; A++) {
              const y = m.dependencies[A];
              C[y.name].value = y.renderTargets[d].texture;
            }
          }
          this.doRenderTarget(m.material, m.renderTargets[f]);
        }
        this.currentTextureIndex = f;
      }),
      (this.getCurrentRenderTarget = function (d) {
        return d.renderTargets[this.currentTextureIndex];
      }),
      (this.getAlternateRenderTarget = function (d) {
        return d.renderTargets[this.currentTextureIndex === 0 ? 1 : 0];
      }),
      (this.dispose = function () {
        a.dispose();
        const d = this.variables;
        for (let f = 0; f < d.length; f++) {
          const g = d[f];
          g.initialValueTexture && g.initialValueTexture.dispose();
          const p = g.renderTargets;
          for (let m = 0; m < p.length; m++) p[m].dispose();
        }
      }));
    function l(d) {
      d.defines.resolution =
        "vec2( " + e.toFixed(1) + ", " + t.toFixed(1) + " )";
    }
    this.addResolutionDefine = l;
    function c(d, f) {
      f = f || {};
      const g = new Qi({
        name: "GPUComputationShader",
        uniforms: f,
        vertexShader: u(),
        fragmentShader: d,
      });
      return (l(g), g);
    }
    ((this.createShaderMaterial = c),
      (this.createRenderTarget = function (d, f, g, p, m, C) {
        return (
          (d = d || e),
          (f = f || t),
          (g = g || xo),
          (p = p || xo),
          (m = m || gi),
          (C = C || gi),
          new ko(d, f, {
            wrapS: g,
            wrapT: p,
            minFilter: m,
            magFilter: C,
            format: Sr,
            type: r,
            depthBuffer: !1,
          })
        );
      }),
      (this.createTexture = function () {
        const d = new Float32Array(e * t * 4),
          f = new Vv(d, e, t, Sr, Xr);
        return ((f.needsUpdate = !0), f);
      }),
      (this.renderTexture = function (d, f) {
        ((s.passThruTexture.value = d),
          this.doRenderTarget(o, f),
          (s.passThruTexture.value = null));
      }),
      (this.doRenderTarget = function (d, f) {
        const g = i.getRenderTarget(),
          p = i.xr.enabled,
          m = i.shadowMap.autoUpdate;
        ((i.xr.enabled = !1),
          (i.shadowMap.autoUpdate = !1),
          (a.material = d),
          i.setRenderTarget(f),
          a.render(i),
          (a.material = o),
          (i.xr.enabled = p),
          (i.shadowMap.autoUpdate = m),
          i.setRenderTarget(g));
      }));
    function u() {
      return `void main()	{

	gl_Position = vec4( position, 1.0 );

}
`;
    }
    function h() {
      return `uniform sampler2D passThruTexture;

void main() {

	vec2 uv = gl_FragCoord.xy / resolution.xy;

	gl_FragColor = texture2D( passThruTexture, uv );

}
`;
    }
  }
}
var jae = `uniform vec2 uResolution;
uniform float uSize;
uniform sampler2D uParticlesTexture;

attribute vec2 aParticlesUv;
attribute float aSize;
attribute vec3 aColor;
attribute vec3 aColorv;

varying vec3 vColor;

void main()
{
    
    vec4 particle = texture(uParticlesTexture, aParticlesUv);
    
    
    vec4 modelPosition = modelMatrix * vec4(particle.xyz, 1.0);
    vec4 viewPosition = viewMatrix * modelPosition;
    vec4 projectedPosition = projectionMatrix * viewPosition;
    gl_Position = projectedPosition;

    
    float sizeIn = smoothstep(0.0, 1.0, particle.a);
    float sizeOut = 1.0 - smoothstep(0.7, 1.0, particle.a);
    float size = min(sizeIn, sizeOut);
    gl_PointSize = aSize * size * uSize * uResolution.y;
    gl_PointSize *= (1.0 / -viewPosition.z); 

    vColor = aColorv; 
}`,
  $ae = `varying vec3 vColor;

vec3 rgb2hsl(vec3 color) {
  float r = color.r, g = color.g, b = color.b;
  float max = max(max(r, g), b);
  float min = min(min(r, g), b);
  float h, s, l = (max + min) * 0.5;

  if (max == min) {
    h = s = 0.0;
  } else {
    float d = max - min;
    s = l > 0.5 ? d / (2.0 - max - min) : d / (max + min);
    if (max == r) {
      h = (g - b) / d + (g < b ? 6.0 : 0.0);
    } else if (max == g) {
      h = (b - r) / d + 2.0;
    } else {
      h = (r - g) / d + 4.0;
    }
    h /= 6.0;
  }

  return vec3(h, s, l);
}

float hue2rgb(float p, float q, float t) {
  if (t < 0.0) t += 1.0;
  if (t > 1.0) t -= 1.0;
  if (t < 1.0/6.0) return p + (q - p) * 6.0 * t;
  if (t < 1.0/2.0) return q;
  if (t < 2.0/3.0) return p + (q - p) * (2.0/3.0 - t) * 6.0;
  return p;
}

vec3 hsl2rgb(vec3 hsl) {
  float h = hsl.x, s = hsl.y, l = hsl.z;

  float r, g, b;

  if (s == 0.0) {
    r = g = b = l;
  } else {
    float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;
    float p = 2.0 * l - q;

    r = hue2rgb(p, q, h + 1.0/3.0);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1.0/3.0);
  }

  return vec3(r, g, b);
}

void main()
{
    float distanceToCenter = length(gl_PointCoord - 0.5);
    if(distanceToCenter > 0.4)
        discard;
    vec3 hsl = rgb2hsl(vColor);
    hsl.y *= 1.5; 
    vec3 saturatedColor = hsl2rgb(hsl);
    gl_FragColor = vec4(saturatedColor, 1.0);

    #include <tonemapping_fragment>
    #include <colorspace_fragment>
}`,
  Jae = `varying vec3 vNormal;
varying vec3 vPosition;

void main()
{
    
    vec4 modelPosition = modelMatrix * vec4(position, 1.0);
    gl_Position = projectionMatrix * viewMatrix * modelPosition;

    
    vec3 modelNormal = (modelMatrix * vec4(normal, 0.0)).xyz;

    
    vNormal = modelNormal;
    vPosition = modelPosition.xyz;
}`,
  Qae = `uniform vec3 uAtmosphereColor; 
varying vec3 vNormal;
varying vec3 vPosition;

void main()
{
    
    vec3 viewDirection = normalize(vPosition - cameraPosition);
    
    vec3 normal = normalize(vNormal);

    
    float fresnel = -abs(dot(viewDirection, normal)) + 1.0;
    
    

    
    float alpha = smoothstep(0.0, 1.0, fresnel);  
    alpha -= 0.7;
    gl_FragColor = vec4(uAtmosphereColor, alpha);

    #include <tonemapping_fragment>
    #include <colorspace_fragment>
}`,
  qae = `vec4 mod289(vec4 x)
{
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x)
{
  return mod289(((x*34.0)+10.0)*x);
}

vec4 taylorInvSqrt(vec4 r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

vec4 fade(vec4 t) {
  return t*t*t*(t*(t*6.0-15.0)+10.0);
}

float cnoise(vec4 P)
{
  vec4 Pi0 = floor(P); 
  vec4 Pi1 = Pi0 + 1.0; 
  Pi0 = mod289(Pi0);
  Pi1 = mod289(Pi1);
  vec4 Pf0 = fract(P); 
  vec4 Pf1 = Pf0 - 1.0; 
  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec4 iy = vec4(Pi0.yy, Pi1.yy);
  vec4 iz0 = vec4(Pi0.zzzz);
  vec4 iz1 = vec4(Pi1.zzzz);
  vec4 iw0 = vec4(Pi0.wwww);
  vec4 iw1 = vec4(Pi1.wwww);

  vec4 ixy = permute(permute(ix) + iy);
  vec4 ixy0 = permute(ixy + iz0);
  vec4 ixy1 = permute(ixy + iz1);
  vec4 ixy00 = permute(ixy0 + iw0);
  vec4 ixy01 = permute(ixy0 + iw1);
  vec4 ixy10 = permute(ixy1 + iw0);
  vec4 ixy11 = permute(ixy1 + iw1);

  vec4 gx00 = ixy00 * (1.0 / 7.0);
  vec4 gy00 = floor(gx00) * (1.0 / 7.0);
  vec4 gz00 = floor(gy00) * (1.0 / 6.0);
  gx00 = fract(gx00) - 0.5;
  gy00 = fract(gy00) - 0.5;
  gz00 = fract(gz00) - 0.5;
  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
  vec4 sw00 = step(gw00, vec4(0.0));
  gx00 -= sw00 * (step(0.0, gx00) - 0.5);
  gy00 -= sw00 * (step(0.0, gy00) - 0.5);

  vec4 gx01 = ixy01 * (1.0 / 7.0);
  vec4 gy01 = floor(gx01) * (1.0 / 7.0);
  vec4 gz01 = floor(gy01) * (1.0 / 6.0);
  gx01 = fract(gx01) - 0.5;
  gy01 = fract(gy01) - 0.5;
  gz01 = fract(gz01) - 0.5;
  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
  vec4 sw01 = step(gw01, vec4(0.0));
  gx01 -= sw01 * (step(0.0, gx01) - 0.5);
  gy01 -= sw01 * (step(0.0, gy01) - 0.5);

  vec4 gx10 = ixy10 * (1.0 / 7.0);
  vec4 gy10 = floor(gx10) * (1.0 / 7.0);
  vec4 gz10 = floor(gy10) * (1.0 / 6.0);
  gx10 = fract(gx10) - 0.5;
  gy10 = fract(gy10) - 0.5;
  gz10 = fract(gz10) - 0.5;
  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
  vec4 sw10 = step(gw10, vec4(0.0));
  gx10 -= sw10 * (step(0.0, gx10) - 0.5);
  gy10 -= sw10 * (step(0.0, gy10) - 0.5);

  vec4 gx11 = ixy11 * (1.0 / 7.0);
  vec4 gy11 = floor(gx11) * (1.0 / 7.0);
  vec4 gz11 = floor(gy11) * (1.0 / 6.0);
  gx11 = fract(gx11) - 0.5;
  gy11 = fract(gy11) - 0.5;
  gz11 = fract(gz11) - 0.5;
  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
  vec4 sw11 = step(gw11, vec4(0.0));
  gx11 -= sw11 * (step(0.0, gx11) - 0.5);
  gy11 -= sw11 * (step(0.0, gy11) - 0.5);

  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);
  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);
  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);
  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);
  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);
  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);
  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);
  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);
  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);
  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);
  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);
  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);
  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);
  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);
  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);
  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);

  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));

  float n0000 = norm00.x * dot(g0000, Pf0);
  float n0100 = norm00.y * dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));
  float n1000 = norm00.z * dot(g1000, vec4(Pf1.x, Pf0.yzw));
  float n1100 = norm00.w * dot(g1100, vec4(Pf1.xy, Pf0.zw));
  float n0010 = norm10.x * dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));
  float n0110 = norm10.y * dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));
  float n1010 = norm10.z * dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
  float n1110 = norm10.w * dot(g1110, vec4(Pf1.xyz, Pf0.w));
  float n0001 = norm01.x * dot(g0001, vec4(Pf0.xyz, Pf1.w));
  float n0101 = norm01.y * dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
  float n1001 = norm01.z * dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));
  float n1101 = norm01.w * dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));
  float n0011 = norm11.x * dot(g0011, vec4(Pf0.xy, Pf1.zw));
  float n0111 = norm11.y * dot(g0111, vec4(Pf0.x, Pf1.yzw));
  float n1011 = norm11.z * dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));
  float n1111 = norm11.w * dot(g1111, Pf1);

  vec4 fade_xyzw = fade(Pf0);
  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);
  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);
  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);
  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);
  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
  return 2.2 * n_xyzw;
}

float pnoise(vec4 P, vec4 rep)
{
  vec4 Pi0 = mod(floor(P), rep); 
  vec4 Pi1 = mod(Pi0 + 1.0, rep); 
  Pi0 = mod289(Pi0);
  Pi1 = mod289(Pi1);
  vec4 Pf0 = fract(P); 
  vec4 Pf1 = Pf0 - 1.0; 
  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec4 iy = vec4(Pi0.yy, Pi1.yy);
  vec4 iz0 = vec4(Pi0.zzzz);
  vec4 iz1 = vec4(Pi1.zzzz);
  vec4 iw0 = vec4(Pi0.wwww);
  vec4 iw1 = vec4(Pi1.wwww);

  vec4 ixy = permute(permute(ix) + iy);
  vec4 ixy0 = permute(ixy + iz0);
  vec4 ixy1 = permute(ixy + iz1);
  vec4 ixy00 = permute(ixy0 + iw0);
  vec4 ixy01 = permute(ixy0 + iw1);
  vec4 ixy10 = permute(ixy1 + iw0);
  vec4 ixy11 = permute(ixy1 + iw1);

  vec4 gx00 = ixy00 * (1.0 / 7.0);
  vec4 gy00 = floor(gx00) * (1.0 / 7.0);
  vec4 gz00 = floor(gy00) * (1.0 / 6.0);
  gx00 = fract(gx00) - 0.5;
  gy00 = fract(gy00) - 0.5;
  gz00 = fract(gz00) - 0.5;
  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);
  vec4 sw00 = step(gw00, vec4(0.0));
  gx00 -= sw00 * (step(0.0, gx00) - 0.5);
  gy00 -= sw00 * (step(0.0, gy00) - 0.5);

  vec4 gx01 = ixy01 * (1.0 / 7.0);
  vec4 gy01 = floor(gx01) * (1.0 / 7.0);
  vec4 gz01 = floor(gy01) * (1.0 / 6.0);
  gx01 = fract(gx01) - 0.5;
  gy01 = fract(gy01) - 0.5;
  gz01 = fract(gz01) - 0.5;
  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);
  vec4 sw01 = step(gw01, vec4(0.0));
  gx01 -= sw01 * (step(0.0, gx01) - 0.5);
  gy01 -= sw01 * (step(0.0, gy01) - 0.5);

  vec4 gx10 = ixy10 * (1.0 / 7.0);
  vec4 gy10 = floor(gx10) * (1.0 / 7.0);
  vec4 gz10 = floor(gy10) * (1.0 / 6.0);
  gx10 = fract(gx10) - 0.5;
  gy10 = fract(gy10) - 0.5;
  gz10 = fract(gz10) - 0.5;
  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);
  vec4 sw10 = step(gw10, vec4(0.0));
  gx10 -= sw10 * (step(0.0, gx10) - 0.5);
  gy10 -= sw10 * (step(0.0, gy10) - 0.5);

  vec4 gx11 = ixy11 * (1.0 / 7.0);
  vec4 gy11 = floor(gx11) * (1.0 / 7.0);
  vec4 gz11 = floor(gy11) * (1.0 / 6.0);
  gx11 = fract(gx11) - 0.5;
  gy11 = fract(gy11) - 0.5;
  gz11 = fract(gz11) - 0.5;
  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);
  vec4 sw11 = step(gw11, vec4(0.0));
  gx11 -= sw11 * (step(0.0, gx11) - 0.5);
  gy11 -= sw11 * (step(0.0, gy11) - 0.5);

  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);
  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);
  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);
  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);
  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);
  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);
  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);
  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);
  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);
  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);
  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);
  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);
  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);
  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);
  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);
  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);

  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));
  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));
  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));
  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));

  float n0000 = norm00.x * dot(g0000, Pf0);
  float n0100 = norm00.y * dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));
  float n1000 = norm00.z * dot(g1000, vec4(Pf1.x, Pf0.yzw));
  float n1100 = norm00.w * dot(g1100, vec4(Pf1.xy, Pf0.zw));
  float n0010 = norm10.x * dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));
  float n0110 = norm10.y * dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));
  float n1010 = norm10.z * dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));
  float n1110 = norm10.w * dot(g1110, vec4(Pf1.xyz, Pf0.w));
  float n0001 = norm01.x * dot(g0001, vec4(Pf0.xyz, Pf1.w));
  float n0101 = norm01.y * dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));
  float n1001 = norm01.z * dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));
  float n1101 = norm01.w * dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));
  float n0011 = norm11.x * dot(g0011, vec4(Pf0.xy, Pf1.zw));
  float n0111 = norm11.y * dot(g0111, vec4(Pf0.x, Pf1.yzw));
  float n1011 = norm11.z * dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));
  float n1111 = norm11.w * dot(g1111, Pf1);

  vec4 fade_xyzw = fade(Pf0);
  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);
  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);
  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);
  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);
  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);
  return 2.2 * n_xyzw;
}

uniform sampler2D uDisplacementTexture;
uniform mat4 uRotationMatrix;
uniform vec3 uCoord;
uniform float uTime;
uniform float uDeltaTime;
uniform sampler2D uBase;
uniform float uRadius;

void main()
{
  vec2 uv = gl_FragCoord.xy / resolution.xy;
  vec4 particle = texture(uParticles, uv);
  vec4 base = texture(uBase, uv);
  float time = uTime * 0.01;
  float displacementIntensity = texture(uDisplacementTexture, uv).r;

  
  if (particle.a >= 1.0) {
    particle.a = mod(particle.a, 1.0);
    particle.xyz = base.xyz;
  } else {
    float strength = cnoise(vec4(base.xyz, time + 1.0));
    
    vec3 localCoord = (inverse(uRotationMatrix) * vec4(uCoord, 1.0)).xyz;
    float distanceFromHovered = distance(base.xyz, localCoord);

    
    float falloffFactor = uRadius; 
    strength = smoothstep(falloffFactor, 0.0, abs(distanceFromHovered));
    

    
    vec3 flowField = vec3(
      cnoise(vec4(particle.xyz + 0.0, time)),
      cnoise(vec4(particle.xyz + 1.0, time)),
      cnoise(vec4(particle.xyz + 2.0, time))
    );
    
    
    flowField = normalize(flowField);
    particle.xyz += flowField * uDeltaTime * strength * 2.0; 
    
    particle.a += uDeltaTime * (0.8 + strength * 0.01); 
  }
  
  vec3 displacement = vec3(0.0, 0.0, 1.0) * displacementIntensity;
  
  gl_FragColor = particle;
}`;
function ua(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called",
    );
  return n;
}
function RR(n, e) {
  ((n.prototype = Object.create(e.prototype)),
    (n.prototype.constructor = n),
    (n.__proto__ = e));
}
/*!
 * GSAP 3.12.7
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var Jr = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: { lineHeight: "" },
  },
  fd = { duration: 0.5, overwrite: !1, delay: 0 },
  Qv,
  ki,
  Nn,
  As = 1e8,
  xn = 1 / As,
  i3 = Math.PI * 2,
  ele = i3 / 4,
  tle = 0,
  BR = Math.sqrt,
  nle = Math.cos,
  ile = Math.sin,
  Ni = function (e) {
    return typeof e == "string";
  },
  Xn = function (e) {
    return typeof e == "function";
  },
  Na = function (e) {
    return typeof e == "number";
  },
  qv = function (e) {
    return typeof e > "u";
  },
  Uo = function (e) {
    return typeof e == "object";
  },
  Mr = function (e) {
    return e !== !1;
  },
  e5 = function () {
    return typeof window < "u";
  },
  T1 = function (e) {
    return Xn(e) || Ni(e);
  },
  PR =
    (typeof ArrayBuffer == "function" && ArrayBuffer.isView) || function () {},
  nr = Array.isArray,
  r3 = /(?:-?\.?\d|\.)+/gi,
  NR = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
  _h = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
  eA = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
  DR = /[+-]=-?[.\d]+/,
  GR = /[^,'"\[\]\s]+/gi,
  rle = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
  kn,
  po,
  s3,
  t5,
  qr = {},
  Jm = {},
  FR,
  kR = function (e) {
    return (Jm = gd(e, qr)) && Nr;
  },
  n5 = function (e, t) {
    return console.warn(
      "Invalid property",
      e,
      "set to",
      t,
      "Missing plugin? gsap.registerPlugin()",
    );
  },
  Fg = function (e, t) {
    return !t && console.warn(e);
  },
  OR = function (e, t) {
    return (e && (qr[e] = t) && Jm && (Jm[e] = t)) || qr;
  },
  kg = function () {
    return 0;
  },
  sle = { suppressEvents: !0, isStart: !0, kill: !1 },
  Y0 = { suppressEvents: !0, kill: !1 },
  ole = { suppressEvents: !0 },
  i5 = {},
  Tl = [],
  o3 = {},
  UR,
  Wr = {},
  tA = {},
  rS = 30,
  X0 = [],
  r5 = "",
  s5 = function (e) {
    var t = e[0],
      i,
      r;
    if ((Uo(t) || Xn(t) || (e = [e]), !(i = (t._gsap || {}).harness))) {
      for (r = X0.length; r-- && !X0[r].targetTest(t); );
      i = X0[r];
    }
    for (r = e.length; r--; )
      (e[r] && (e[r]._gsap || (e[r]._gsap = new uB(e[r], i)))) ||
        e.splice(r, 1);
    return e;
  },
  tu = function (e) {
    return e._gsap || s5(ys(e))[0]._gsap;
  },
  HR = function (e, t, i) {
    return (i = e[t]) && Xn(i)
      ? e[t]()
      : (qv(i) && e.getAttribute && e.getAttribute(t)) || i;
  },
  Lr = function (e, t) {
    return (e = e.split(",")).forEach(t) || e;
  },
  Jn = function (e) {
    return Math.round(e * 1e5) / 1e5 || 0;
  },
  ii = function (e) {
    return Math.round(e * 1e7) / 1e7 || 0;
  },
  Gh = function (e, t) {
    var i = t.charAt(0),
      r = parseFloat(t.substr(2));
    return (
      (e = parseFloat(e)),
      i === "+" ? e + r : i === "-" ? e - r : i === "*" ? e * r : e / r
    );
  },
  ale = function (e, t) {
    for (var i = t.length, r = 0; e.indexOf(t[r]) < 0 && ++r < i; );
    return r < i;
  },
  Qm = function () {
    var e = Tl.length,
      t = Tl.slice(0),
      i,
      r;
    for (o3 = {}, Tl.length = 0, i = 0; i < e; i++)
      ((r = t[i]),
        r && r._lazy && (r.render(r._lazy[0], r._lazy[1], !0)._lazy = 0));
  },
  WR = function (e, t, i, r) {
    (Tl.length && !ki && Qm(),
      e.render(t, i, r || (ki && t < 0 && (e._initted || e._startAt))),
      Tl.length && !ki && Qm());
  },
  VR = function (e) {
    var t = parseFloat(e);
    return (t || t === 0) && (e + "").match(GR).length < 2
      ? t
      : Ni(e)
        ? e.trim()
        : e;
  },
  ZR = function (e) {
    return e;
  },
  es = function (e, t) {
    for (var i in t) i in e || (e[i] = t[i]);
    return e;
  },
  lle = function (e) {
    return function (t, i) {
      for (var r in i)
        r in t || (r === "duration" && e) || r === "ease" || (t[r] = i[r]);
    };
  },
  gd = function (e, t) {
    for (var i in t) e[i] = t[i];
    return e;
  },
  sS = function n(e, t) {
    for (var i in t)
      i !== "__proto__" &&
        i !== "constructor" &&
        i !== "prototype" &&
        (e[i] = Uo(t[i]) ? n(e[i] || (e[i] = {}), t[i]) : t[i]);
    return e;
  },
  qm = function (e, t) {
    var i = {},
      r;
    for (r in e) r in t || (i[r] = e[r]);
    return i;
  },
  sg = function (e) {
    var t = e.parent || kn,
      i = e.keyframes ? lle(nr(e.keyframes)) : es;
    if (Mr(e.inherit))
      for (; t; ) (i(e, t.vars.defaults), (t = t.parent || t._dp));
    return e;
  },
  cle = function (e, t) {
    for (var i = e.length, r = i === t.length; r && i-- && e[i] === t[i]; );
    return i < 0;
  },
  zR = function (e, t, i, r, s) {
    (i === void 0 && (i = "_first"), r === void 0 && (r = "_last"));
    var o = e[r],
      a;
    if (s) for (a = t[s]; o && o[s] > a; ) o = o._prev;
    return (
      o ? ((t._next = o._next), (o._next = t)) : ((t._next = e[i]), (e[i] = t)),
      t._next ? (t._next._prev = t) : (e[r] = t),
      (t._prev = o),
      (t.parent = t._dp = e),
      t
    );
  },
  cI = function (e, t, i, r) {
    (i === void 0 && (i = "_first"), r === void 0 && (r = "_last"));
    var s = t._prev,
      o = t._next;
    (s ? (s._next = o) : e[i] === t && (e[i] = o),
      o ? (o._prev = s) : e[r] === t && (e[r] = s),
      (t._next = t._prev = t.parent = null));
  },
  Gl = function (e, t) {
    (e.parent &&
      (!t || e.parent.autoRemoveChildren) &&
      e.parent.remove &&
      e.parent.remove(e),
      (e._act = 0));
  },
  nu = function (e, t) {
    if (e && (!t || t._end > e._dur || t._start < 0))
      for (var i = e; i; ) ((i._dirty = 1), (i = i.parent));
    return e;
  },
  ule = function (e) {
    for (var t = e.parent; t && t.parent; )
      ((t._dirty = 1), t.totalDuration(), (t = t.parent));
    return e;
  },
  a3 = function (e, t, i, r) {
    return (
      e._startAt &&
      (ki
        ? e._startAt.revert(Y0)
        : (e.vars.immediateRender && !e.vars.autoRevert) ||
          e._startAt.render(t, !0, r))
    );
  },
  hle = function n(e) {
    return !e || (e._ts && n(e.parent));
  },
  oS = function (e) {
    return e._repeat ? pd(e._tTime, (e = e.duration() + e._rDelay)) * e : 0;
  },
  pd = function (e, t) {
    var i = Math.floor((e = ii(e / t)));
    return e && i === e ? i - 1 : i;
  },
  eC = function (e, t) {
    return (
      (e - t._start) * t._ts +
      (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
    );
  },
  uI = function (e) {
    return (e._end = ii(
      e._start + (e._tDur / Math.abs(e._ts || e._rts || xn) || 0),
    ));
  },
  hI = function (e, t) {
    var i = e._dp;
    return (
      i &&
        i.smoothChildTiming &&
        e._ts &&
        ((e._start = ii(
          i._time -
            (e._ts > 0
              ? t / e._ts
              : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts),
        )),
        uI(e),
        i._dirty || nu(i, e)),
      e
    );
  },
  YR = function (e, t) {
    var i;
    if (
      ((t._time ||
        (!t._dur && t._initted) ||
        (t._start < e._time && (t._dur || !t.add))) &&
        ((i = eC(e.rawTime(), t)),
        (!t._dur || Mp(0, t.totalDuration(), i) - t._tTime > xn) &&
          t.render(i, !0)),
      nu(e, t)._dp && e._initted && e._time >= e._dur && e._ts)
    ) {
      if (e._dur < e.duration())
        for (i = e; i._dp; )
          (i.rawTime() >= 0 && i.totalTime(i._tTime), (i = i._dp));
      e._zTime = -xn;
    }
  },
  yo = function (e, t, i, r) {
    return (
      t.parent && Gl(t),
      (t._start = ii(
        (Na(i) ? i : i || e !== kn ? ds(e, i, t) : e._time) + t._delay,
      )),
      (t._end = ii(
        t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0),
      )),
      zR(e, t, "_first", "_last", e._sort ? "_start" : 0),
      l3(t) || (e._recent = t),
      r || YR(e, t),
      e._ts < 0 && hI(e, e._tTime),
      e
    );
  },
  XR = function (e, t) {
    return (
      (qr.ScrollTrigger || n5("scrollTrigger", t)) &&
      qr.ScrollTrigger.create(t, e)
    );
  },
  KR = function (e, t, i, r, s) {
    if ((a5(e, t, s), !e._initted)) return 1;
    if (
      !i &&
      e._pt &&
      !ki &&
      ((e._dur && e.vars.lazy !== !1) || (!e._dur && e.vars.lazy)) &&
      UR !== Vr.frame
    )
      return (Tl.push(e), (e._lazy = [s, r]), 1);
  },
  dle = function n(e) {
    var t = e.parent;
    return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || n(t));
  },
  l3 = function (e) {
    var t = e.data;
    return t === "isFromStart" || t === "isStart";
  },
  fle = function (e, t, i, r) {
    var s = e.ratio,
      o =
        t < 0 ||
        (!t &&
          ((!e._start && dle(e) && !(!e._initted && l3(e))) ||
            ((e._ts < 0 || e._dp._ts < 0) && !l3(e))))
          ? 0
          : 1,
      a = e._rDelay,
      l = 0,
      c,
      u,
      h;
    if (
      (a &&
        e._repeat &&
        ((l = Mp(0, e._tDur, t)),
        (u = pd(l, a)),
        e._yoyo && u & 1 && (o = 1 - o),
        u !== pd(e._tTime, a) &&
          ((s = 1 - o), e.vars.repeatRefresh && e._initted && e.invalidate())),
      o !== s || ki || r || e._zTime === xn || (!t && e._zTime))
    ) {
      if (!e._initted && KR(e, t, r, i, l)) return;
      for (
        h = e._zTime,
          e._zTime = t || (i ? xn : 0),
          i || (i = t && !h),
          e.ratio = o,
          e._from && (o = 1 - o),
          e._time = 0,
          e._tTime = l,
          c = e._pt;
        c;
      )
        (c.r(o, c.d), (c = c._next));
      (t < 0 && a3(e, t, i, !0),
        e._onUpdate && !i && Kr(e, "onUpdate"),
        l && e._repeat && !i && e.parent && Kr(e, "onRepeat"),
        (t >= e._tDur || t < 0) &&
          e.ratio === o &&
          (o && Gl(e, 1),
          !i &&
            !ki &&
            (Kr(e, o ? "onComplete" : "onReverseComplete", !0),
            e._prom && e._prom())));
    } else e._zTime || (e._zTime = t);
  },
  gle = function (e, t, i) {
    var r;
    if (i > t)
      for (r = e._first; r && r._start <= i; ) {
        if (r.data === "isPause" && r._start > t) return r;
        r = r._next;
      }
    else
      for (r = e._last; r && r._start >= i; ) {
        if (r.data === "isPause" && r._start < t) return r;
        r = r._prev;
      }
  },
  md = function (e, t, i, r) {
    var s = e._repeat,
      o = ii(t) || 0,
      a = e._tTime / e._tDur;
    return (
      a && !r && (e._time *= o / e._dur),
      (e._dur = o),
      (e._tDur = s ? (s < 0 ? 1e10 : ii(o * (s + 1) + e._rDelay * s)) : o),
      a > 0 && !r && hI(e, (e._tTime = e._tDur * a)),
      e.parent && uI(e),
      i || nu(e.parent, e),
      e
    );
  },
  aS = function (e) {
    return e instanceof hr ? nu(e) : md(e, e._dur);
  },
  ple = { _start: 0, endTime: kg, totalDuration: kg },
  ds = function n(e, t, i) {
    var r = e.labels,
      s = e._recent || ple,
      o = e.duration() >= As ? s.endTime(!1) : e._dur,
      a,
      l,
      c;
    return Ni(t) && (isNaN(t) || t in r)
      ? ((l = t.charAt(0)),
        (c = t.substr(-1) === "%"),
        (a = t.indexOf("=")),
        l === "<" || l === ">"
          ? (a >= 0 && (t = t.replace(/=/, "")),
            (l === "<" ? s._start : s.endTime(s._repeat >= 0)) +
              (parseFloat(t.substr(1)) || 0) *
                (c ? (a < 0 ? s : i).totalDuration() / 100 : 1))
          : a < 0
            ? (t in r || (r[t] = o), r[t])
            : ((l = parseFloat(t.charAt(a - 1) + t.substr(a + 1))),
              c && i && (l = (l / 100) * (nr(i) ? i[0] : i).totalDuration()),
              a > 1 ? n(e, t.substr(0, a - 1), i) + l : o + l))
      : t == null
        ? o
        : +t;
  },
  og = function (e, t, i) {
    var r = Na(t[1]),
      s = (r ? 2 : 1) + (e < 2 ? 0 : 1),
      o = t[s],
      a,
      l;
    if ((r && (o.duration = t[1]), (o.parent = i), e)) {
      for (a = o, l = i; l && !("immediateRender" in a); )
        ((a = l.vars.defaults || {}), (l = Mr(l.vars.inherit) && l.parent));
      ((o.immediateRender = Mr(a.immediateRender)),
        e < 2 ? (o.runBackwards = 1) : (o.startAt = t[s - 1]));
    }
    return new ni(t[0], o, t[s + 1]);
  },
  zl = function (e, t) {
    return e || e === 0 ? t(e) : t;
  },
  Mp = function (e, t, i) {
    return i < e ? e : i > t ? t : i;
  },
  ji = function (e, t) {
    return !Ni(e) || !(t = rle.exec(e)) ? "" : t[1];
  },
  mle = function (e, t, i) {
    return zl(i, function (r) {
      return Mp(e, t, r);
    });
  },
  c3 = [].slice,
  jR = function (e, t) {
    return (
      e &&
      Uo(e) &&
      "length" in e &&
      ((!t && !e.length) || (e.length - 1 in e && Uo(e[0]))) &&
      !e.nodeType &&
      e !== po
    );
  },
  Cle = function (e, t, i) {
    return (
      i === void 0 && (i = []),
      e.forEach(function (r) {
        var s;
        return (Ni(r) && !t) || jR(r, 1)
          ? (s = i).push.apply(s, ys(r))
          : i.push(r);
      }) || i
    );
  },
  ys = function (e, t, i) {
    return Nn && !t && Nn.selector
      ? Nn.selector(e)
      : Ni(e) && !i && (s3 || !Cd())
        ? c3.call((t || t5).querySelectorAll(e), 0)
        : nr(e)
          ? Cle(e, i)
          : jR(e)
            ? c3.call(e, 0)
            : e
              ? [e]
              : [];
  },
  u3 = function (e) {
    return (
      (e = ys(e)[0] || Fg("Invalid scope") || {}),
      function (t) {
        var i = e.current || e.nativeElement || e;
        return ys(
          t,
          i.querySelectorAll
            ? i
            : i === e
              ? Fg("Invalid scope") || t5.createElement("div")
              : e,
        );
      }
    );
  },
  $R = function (e) {
    return e.sort(function () {
      return 0.5 - Math.random();
    });
  },
  JR = function (e) {
    if (Xn(e)) return e;
    var t = Uo(e) ? e : { each: e },
      i = iu(t.ease),
      r = t.from || 0,
      s = parseFloat(t.base) || 0,
      o = {},
      a = r > 0 && r < 1,
      l = isNaN(r) || a,
      c = t.axis,
      u = r,
      h = r;
    return (
      Ni(r)
        ? (u = h = { center: 0.5, edges: 0.5, end: 1 }[r] || 0)
        : !a && l && ((u = r[0]), (h = r[1])),
      function (d, f, g) {
        var p = (g || t).length,
          m = o[p],
          C,
          A,
          I,
          y,
          x,
          T,
          S,
          E,
          _;
        if (!m) {
          if (((_ = t.grid === "auto" ? 0 : (t.grid || [1, As])[1]), !_)) {
            for (
              S = -As;
              S < (S = g[_++].getBoundingClientRect().left) && _ < p;
            );
            _ < p && _--;
          }
          for (
            m = o[p] = [],
              C = l ? Math.min(_, p) * u - 0.5 : r % _,
              A = _ === As ? 0 : l ? (p * h) / _ - 0.5 : (r / _) | 0,
              S = 0,
              E = As,
              T = 0;
            T < p;
            T++
          )
            ((I = (T % _) - C),
              (y = A - ((T / _) | 0)),
              (m[T] = x = c ? Math.abs(c === "y" ? y : I) : BR(I * I + y * y)),
              x > S && (S = x),
              x < E && (E = x));
          (r === "random" && $R(m),
            (m.max = S - E),
            (m.min = E),
            (m.v = p =
              (parseFloat(t.amount) ||
                parseFloat(t.each) *
                  (_ > p
                    ? p - 1
                    : c
                      ? c === "y"
                        ? p / _
                        : _
                      : Math.max(_, p / _)) ||
                0) * (r === "edges" ? -1 : 1)),
            (m.b = p < 0 ? s - p : s),
            (m.u = ji(t.amount || t.each) || 0),
            (i = i && p < 0 ? aB(i) : i));
        }
        return (
          (p = (m[d] - m.min) / m.max || 0),
          ii(m.b + (i ? i(p) : p) * m.v) + m.u
        );
      }
    );
  },
  h3 = function (e) {
    var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
    return function (i) {
      var r = ii(Math.round(parseFloat(i) / e) * e * t);
      return (r - (r % 1)) / t + (Na(i) ? 0 : ji(i));
    };
  },
  QR = function (e, t) {
    var i = nr(e),
      r,
      s;
    return (
      !i &&
        Uo(e) &&
        ((r = i = e.radius || As),
        e.values
          ? ((e = ys(e.values)), (s = !Na(e[0])) && (r *= r))
          : (e = h3(e.increment))),
      zl(
        t,
        i
          ? Xn(e)
            ? function (o) {
                return ((s = e(o)), Math.abs(s - o) <= r ? s : o);
              }
            : function (o) {
                for (
                  var a = parseFloat(s ? o.x : o),
                    l = parseFloat(s ? o.y : 0),
                    c = As,
                    u = 0,
                    h = e.length,
                    d,
                    f;
                  h--;
                )
                  (s
                    ? ((d = e[h].x - a), (f = e[h].y - l), (d = d * d + f * f))
                    : (d = Math.abs(e[h] - a)),
                    d < c && ((c = d), (u = h)));
                return (
                  (u = !r || c <= r ? e[u] : o),
                  s || u === o || Na(o) ? u : u + ji(o)
                );
              }
          : h3(e),
      )
    );
  },
  qR = function (e, t, i, r) {
    return zl(nr(e) ? !t : i === !0 ? !!(i = 0) : !r, function () {
      return nr(e)
        ? e[~~(Math.random() * e.length)]
        : (i = i || 1e-5) &&
            (r = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) &&
            Math.floor(
              Math.round((e - i / 2 + Math.random() * (t - e + i * 0.99)) / i) *
                i *
                r,
            ) / r;
    });
  },
  Ile = function () {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return function (r) {
      return t.reduce(function (s, o) {
        return o(s);
      }, r);
    };
  },
  Ale = function (e, t) {
    return function (i) {
      return e(parseFloat(i)) + (t || ji(i));
    };
  },
  yle = function (e, t, i) {
    return tB(e, t, 0, 1, i);
  },
  eB = function (e, t, i) {
    return zl(i, function (r) {
      return e[~~t(r)];
    });
  },
  _le = function n(e, t, i) {
    var r = t - e;
    return nr(e)
      ? eB(e, n(0, e.length), t)
      : zl(i, function (s) {
          return ((r + ((s - e) % r)) % r) + e;
        });
  },
  ble = function n(e, t, i) {
    var r = t - e,
      s = r * 2;
    return nr(e)
      ? eB(e, n(0, e.length - 1), t)
      : zl(i, function (o) {
          return ((o = (s + ((o - e) % s)) % s || 0), e + (o > r ? s - o : o));
        });
  },
  Og = function (e) {
    for (var t = 0, i = "", r, s, o, a; ~(r = e.indexOf("random(", t)); )
      ((o = e.indexOf(")", r)),
        (a = e.charAt(r + 7) === "["),
        (s = e.substr(r + 7, o - r - 7).match(a ? GR : r3)),
        (i +=
          e.substr(t, r - t) + qR(a ? s : +s[0], a ? 0 : +s[1], +s[2] || 1e-5)),
        (t = o + 1));
    return i + e.substr(t, e.length - t);
  },
  tB = function (e, t, i, r, s) {
    var o = t - e,
      a = r - i;
    return zl(s, function (l) {
      return i + (((l - e) / o) * a || 0);
    });
  },
  vle = function n(e, t, i, r) {
    var s = isNaN(e + t)
      ? 0
      : function (f) {
          return (1 - f) * e + f * t;
        };
    if (!s) {
      var o = Ni(e),
        a = {},
        l,
        c,
        u,
        h,
        d;
      if ((i === !0 && (r = 1) && (i = null), o))
        ((e = { p: e }), (t = { p: t }));
      else if (nr(e) && !nr(t)) {
        for (u = [], h = e.length, d = h - 2, c = 1; c < h; c++)
          u.push(n(e[c - 1], e[c]));
        (h--,
          (s = function (g) {
            g *= h;
            var p = Math.min(d, ~~g);
            return u[p](g - p);
          }),
          (i = t));
      } else r || (e = gd(nr(e) ? [] : {}, e));
      if (!u) {
        for (l in t) o5.call(a, e, l, "get", t[l]);
        s = function (g) {
          return u5(g, a) || (o ? e.p : e);
        };
      }
    }
    return zl(i, s);
  },
  lS = function (e, t, i) {
    var r = e.labels,
      s = As,
      o,
      a,
      l;
    for (o in r)
      ((a = r[o] - t),
        a < 0 == !!i && a && s > (a = Math.abs(a)) && ((l = o), (s = a)));
    return l;
  },
  Kr = function (e, t, i) {
    var r = e.vars,
      s = r[t],
      o = Nn,
      a = e._ctx,
      l,
      c,
      u;
    if (s)
      return (
        (l = r[t + "Params"]),
        (c = r.callbackScope || e),
        i && Tl.length && Qm(),
        a && (Nn = a),
        (u = l ? s.apply(c, l) : s.call(c)),
        (Nn = o),
        u
      );
  },
  Of = function (e) {
    return (
      Gl(e),
      e.scrollTrigger && e.scrollTrigger.kill(!!ki),
      e.progress() < 1 && Kr(e, "onInterrupt"),
      e
    );
  },
  bh,
  nB = [],
  iB = function (e) {
    if (e)
      if (((e = (!e.name && e.default) || e), e5() || e.headless)) {
        var t = e.name,
          i = Xn(e),
          r =
            t && !i && e.init
              ? function () {
                  this._props = [];
                }
              : e,
          s = {
            init: kg,
            render: u5,
            add: o5,
            kill: Ole,
            modifier: kle,
            rawVars: 0,
          },
          o = {
            targetTest: 0,
            get: 0,
            getSetter: c5,
            aliases: {},
            register: 0,
          };
        if ((Cd(), e !== r)) {
          if (Wr[t]) return;
          (es(r, es(qm(e, s), o)),
            gd(r.prototype, gd(s, qm(e, o))),
            (Wr[(r.prop = t)] = r),
            e.targetTest && (X0.push(r), (i5[t] = 1)),
            (t =
              (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) +
              "Plugin"));
        }
        (OR(t, r), e.register && e.register(Nr, r, Rr));
      } else nB.push(e);
  },
  vn = 255,
  Uf = {
    aqua: [0, vn, vn],
    lime: [0, vn, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, vn],
    navy: [0, 0, 128],
    white: [vn, vn, vn],
    olive: [128, 128, 0],
    yellow: [vn, vn, 0],
    orange: [vn, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [vn, 0, 0],
    pink: [vn, 192, 203],
    cyan: [0, vn, vn],
    transparent: [vn, vn, vn, 0],
  },
  nA = function (e, t, i) {
    return (
      (e += e < 0 ? 1 : e > 1 ? -1 : 0),
      ((e * 6 < 1
        ? t + (i - t) * e * 6
        : e < 0.5
          ? i
          : e * 3 < 2
            ? t + (i - t) * (2 / 3 - e) * 6
            : t) *
        vn +
        0.5) |
        0
    );
  },
  rB = function (e, t, i) {
    var r = e ? (Na(e) ? [e >> 16, (e >> 8) & vn, e & vn] : 0) : Uf.black,
      s,
      o,
      a,
      l,
      c,
      u,
      h,
      d,
      f,
      g;
    if (!r) {
      if ((e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), Uf[e]))
        r = Uf[e];
      else if (e.charAt(0) === "#") {
        if (
          (e.length < 6 &&
            ((s = e.charAt(1)),
            (o = e.charAt(2)),
            (a = e.charAt(3)),
            (e =
              "#" +
              s +
              s +
              o +
              o +
              a +
              a +
              (e.length === 5 ? e.charAt(4) + e.charAt(4) : ""))),
          e.length === 9)
        )
          return (
            (r = parseInt(e.substr(1, 6), 16)),
            [r >> 16, (r >> 8) & vn, r & vn, parseInt(e.substr(7), 16) / 255]
          );
        ((e = parseInt(e.substr(1), 16)),
          (r = [e >> 16, (e >> 8) & vn, e & vn]));
      } else if (e.substr(0, 3) === "hsl") {
        if (((r = g = e.match(r3)), !t))
          ((l = (+r[0] % 360) / 360),
            (c = +r[1] / 100),
            (u = +r[2] / 100),
            (o = u <= 0.5 ? u * (c + 1) : u + c - u * c),
            (s = u * 2 - o),
            r.length > 3 && (r[3] *= 1),
            (r[0] = nA(l + 1 / 3, s, o)),
            (r[1] = nA(l, s, o)),
            (r[2] = nA(l - 1 / 3, s, o)));
        else if (~e.indexOf("="))
          return ((r = e.match(NR)), i && r.length < 4 && (r[3] = 1), r);
      } else r = e.match(r3) || Uf.transparent;
      r = r.map(Number);
    }
    return (
      t &&
        !g &&
        ((s = r[0] / vn),
        (o = r[1] / vn),
        (a = r[2] / vn),
        (h = Math.max(s, o, a)),
        (d = Math.min(s, o, a)),
        (u = (h + d) / 2),
        h === d
          ? (l = c = 0)
          : ((f = h - d),
            (c = u > 0.5 ? f / (2 - h - d) : f / (h + d)),
            (l =
              h === s
                ? (o - a) / f + (o < a ? 6 : 0)
                : h === o
                  ? (a - s) / f + 2
                  : (s - o) / f + 4),
            (l *= 60)),
        (r[0] = ~~(l + 0.5)),
        (r[1] = ~~(c * 100 + 0.5)),
        (r[2] = ~~(u * 100 + 0.5))),
      i && r.length < 4 && (r[3] = 1),
      r
    );
  },
  sB = function (e) {
    var t = [],
      i = [],
      r = -1;
    return (
      e.split(El).forEach(function (s) {
        var o = s.match(_h) || [];
        (t.push.apply(t, o), i.push((r += o.length + 1)));
      }),
      (t.c = i),
      t
    );
  },
  cS = function (e, t, i) {
    var r = "",
      s = (e + r).match(El),
      o = t ? "hsla(" : "rgba(",
      a = 0,
      l,
      c,
      u,
      h;
    if (!s) return e;
    if (
      ((s = s.map(function (d) {
        return (
          (d = rB(d, t, 1)) &&
          o +
            (t ? d[0] + "," + d[1] + "%," + d[2] + "%," + d[3] : d.join(",")) +
            ")"
        );
      })),
      i && ((u = sB(e)), (l = i.c), l.join(r) !== u.c.join(r)))
    )
      for (c = e.replace(El, "1").split(_h), h = c.length - 1; a < h; a++)
        r +=
          c[a] +
          (~l.indexOf(a)
            ? s.shift() || o + "0,0,0,0)"
            : (u.length ? u : s.length ? s : i).shift());
    if (!c)
      for (c = e.split(El), h = c.length - 1; a < h; a++) r += c[a] + s[a];
    return r + c[h];
  },
  El = (function () {
    var n =
        "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
      e;
    for (e in Uf) n += "|" + e + "\\b";
    return new RegExp(n + ")", "gi");
  })(),
  xle = /hsl[a]?\(/,
  oB = function (e) {
    var t = e.join(" "),
      i;
    if (((El.lastIndex = 0), El.test(t)))
      return (
        (i = xle.test(t)),
        (e[1] = cS(e[1], i)),
        (e[0] = cS(e[0], i, sB(e[1]))),
        !0
      );
  },
  Ug,
  Vr = (function () {
    var n = Date.now,
      e = 500,
      t = 33,
      i = n(),
      r = i,
      s = 1e3 / 240,
      o = s,
      a = [],
      l,
      c,
      u,
      h,
      d,
      f,
      g = function p(m) {
        var C = n() - r,
          A = m === !0,
          I,
          y,
          x,
          T;
        if (
          ((C > e || C < 0) && (i += C - t),
          (r += C),
          (x = r - i),
          (I = x - o),
          (I > 0 || A) &&
            ((T = ++h.frame),
            (d = x - h.time * 1e3),
            (h.time = x = x / 1e3),
            (o += I + (I >= s ? 4 : s - I)),
            (y = 1)),
          A || (l = c(p)),
          y)
        )
          for (f = 0; f < a.length; f++) a[f](x, d, T, m);
      };
    return (
      (h = {
        time: 0,
        frame: 0,
        tick: function () {
          g(!0);
        },
        deltaRatio: function (m) {
          return d / (1e3 / (m || 60));
        },
        wake: function () {
          FR &&
            (!s3 &&
              e5() &&
              ((po = s3 = window),
              (t5 = po.document || {}),
              (qr.gsap = Nr),
              (po.gsapVersions || (po.gsapVersions = [])).push(Nr.version),
              kR(Jm || po.GreenSockGlobals || (!po.gsap && po) || {}),
              nB.forEach(iB)),
            (u = typeof requestAnimationFrame < "u" && requestAnimationFrame),
            l && h.sleep(),
            (c =
              u ||
              function (m) {
                return setTimeout(m, (o - h.time * 1e3 + 1) | 0);
              }),
            (Ug = 1),
            g(2));
        },
        sleep: function () {
          ((u ? cancelAnimationFrame : clearTimeout)(l), (Ug = 0), (c = kg));
        },
        lagSmoothing: function (m, C) {
          ((e = m || 1 / 0), (t = Math.min(C || 33, e)));
        },
        fps: function (m) {
          ((s = 1e3 / (m || 240)), (o = h.time * 1e3 + s));
        },
        add: function (m, C, A) {
          var I = C
            ? function (y, x, T, S) {
                (m(y, x, T, S), h.remove(I));
              }
            : m;
          return (h.remove(m), a[A ? "unshift" : "push"](I), Cd(), I);
        },
        remove: function (m, C) {
          ~(C = a.indexOf(m)) && a.splice(C, 1) && f >= C && f--;
        },
        _listeners: a,
      }),
      h
    );
  })(),
  Cd = function () {
    return !Ug && Vr.wake();
  },
  Xt = {},
  wle = /^[\d.\-M][\d.\-,\s]/,
  Sle = /["']/g,
  Tle = function (e) {
    for (
      var t = {},
        i = e.substr(1, e.length - 3).split(":"),
        r = i[0],
        s = 1,
        o = i.length,
        a,
        l,
        c;
      s < o;
      s++
    )
      ((l = i[s]),
        (a = s !== o - 1 ? l.lastIndexOf(",") : l.length),
        (c = l.substr(0, a)),
        (t[r] = isNaN(c) ? c.replace(Sle, "").trim() : +c),
        (r = l.substr(a + 1).trim()));
    return t;
  },
  Ele = function (e) {
    var t = e.indexOf("(") + 1,
      i = e.indexOf(")"),
      r = e.indexOf("(", t);
    return e.substring(t, ~r && r < i ? e.indexOf(")", i + 1) : i);
  },
  Mle = function (e) {
    var t = (e + "").split("("),
      i = Xt[t[0]];
    return i && t.length > 1 && i.config
      ? i.config.apply(
          null,
          ~e.indexOf("{") ? [Tle(t[1])] : Ele(e).split(",").map(VR),
        )
      : Xt._CE && wle.test(e)
        ? Xt._CE("", e)
        : i;
  },
  aB = function (e) {
    return function (t) {
      return 1 - e(1 - t);
    };
  },
  lB = function n(e, t) {
    for (var i = e._first, r; i; )
      (i instanceof hr
        ? n(i, t)
        : i.vars.yoyoEase &&
          (!i._yoyo || !i._repeat) &&
          i._yoyo !== t &&
          (i.timeline
            ? n(i.timeline, t)
            : ((r = i._ease),
              (i._ease = i._yEase),
              (i._yEase = r),
              (i._yoyo = t))),
        (i = i._next));
  },
  iu = function (e, t) {
    return (e && (Xn(e) ? e : Xt[e] || Mle(e))) || t;
  },
  Su = function (e, t, i, r) {
    (i === void 0 &&
      (i = function (l) {
        return 1 - t(1 - l);
      }),
      r === void 0 &&
        (r = function (l) {
          return l < 0.5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2;
        }));
    var s = { easeIn: t, easeOut: i, easeInOut: r },
      o;
    return (
      Lr(e, function (a) {
        ((Xt[a] = qr[a] = s), (Xt[(o = a.toLowerCase())] = i));
        for (var l in s)
          Xt[
            o + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")
          ] = Xt[a + "." + l] = s[l];
      }),
      s
    );
  },
  cB = function (e) {
    return function (t) {
      return t < 0.5 ? (1 - e(1 - t * 2)) / 2 : 0.5 + e((t - 0.5) * 2) / 2;
    };
  },
  iA = function n(e, t, i) {
    var r = t >= 1 ? t : 1,
      s = (i || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1),
      o = (s / i3) * (Math.asin(1 / r) || 0),
      a = function (u) {
        return u === 1 ? 1 : r * Math.pow(2, -10 * u) * ile((u - o) * s) + 1;
      },
      l =
        e === "out"
          ? a
          : e === "in"
            ? function (c) {
                return 1 - a(1 - c);
              }
            : cB(a);
    return (
      (s = i3 / s),
      (l.config = function (c, u) {
        return n(e, c, u);
      }),
      l
    );
  },
  rA = function n(e, t) {
    t === void 0 && (t = 1.70158);
    var i = function (o) {
        return o ? --o * o * ((t + 1) * o + t) + 1 : 0;
      },
      r =
        e === "out"
          ? i
          : e === "in"
            ? function (s) {
                return 1 - i(1 - s);
              }
            : cB(i);
    return (
      (r.config = function (s) {
        return n(e, s);
      }),
      r
    );
  };
Lr("Linear,Quad,Cubic,Quart,Quint,Strong", function (n, e) {
  var t = e < 5 ? e + 1 : e;
  Su(
    n + ",Power" + (t - 1),
    e
      ? function (i) {
          return Math.pow(i, t);
        }
      : function (i) {
          return i;
        },
    function (i) {
      return 1 - Math.pow(1 - i, t);
    },
    function (i) {
      return i < 0.5
        ? Math.pow(i * 2, t) / 2
        : 1 - Math.pow((1 - i) * 2, t) / 2;
    },
  );
});
Xt.Linear.easeNone = Xt.none = Xt.Linear.easeIn;
Su("Elastic", iA("in"), iA("out"), iA());
(function (n, e) {
  var t = 1 / e,
    i = 2 * t,
    r = 2.5 * t,
    s = function (a) {
      return a < t
        ? n * a * a
        : a < i
          ? n * Math.pow(a - 1.5 / e, 2) + 0.75
          : a < r
            ? n * (a -= 2.25 / e) * a + 0.9375
            : n * Math.pow(a - 2.625 / e, 2) + 0.984375;
    };
  Su(
    "Bounce",
    function (o) {
      return 1 - s(1 - o);
    },
    s,
  );
})(7.5625, 2.75);
Su("Expo", function (n) {
  return Math.pow(2, 10 * (n - 1)) * n + n * n * n * n * n * n * (1 - n);
});
Su("Circ", function (n) {
  return -(BR(1 - n * n) - 1);
});
Su("Sine", function (n) {
  return n === 1 ? 1 : -nle(n * ele) + 1;
});
Su("Back", rA("in"), rA("out"), rA());
Xt.SteppedEase =
  Xt.steps =
  qr.SteppedEase =
    {
      config: function (e, t) {
        e === void 0 && (e = 1);
        var i = 1 / e,
          r = e + (t ? 0 : 1),
          s = t ? 1 : 0,
          o = 1 - xn;
        return function (a) {
          return (((r * Mp(0, o, a)) | 0) + s) * i;
        };
      },
    };
fd.ease = Xt["quad.out"];
Lr(
  "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
  function (n) {
    return (r5 += n + "," + n + "Params,");
  },
);
var uB = function (e, t) {
    ((this.id = tle++),
      (e._gsap = this),
      (this.target = e),
      (this.harness = t),
      (this.get = t ? t.get : HR),
      (this.set = t ? t.getSetter : c5));
  },
  Hg = (function () {
    function n(t) {
      ((this.vars = t),
        (this._delay = +t.delay || 0),
        (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) &&
          ((this._rDelay = t.repeatDelay || 0),
          (this._yoyo = !!t.yoyo || !!t.yoyoEase)),
        (this._ts = 1),
        md(this, +t.duration, 1, 1),
        (this.data = t.data),
        Nn && ((this._ctx = Nn), Nn.data.push(this)),
        Ug || Vr.wake());
    }
    var e = n.prototype;
    return (
      (e.delay = function (i) {
        return i || i === 0
          ? (this.parent &&
              this.parent.smoothChildTiming &&
              this.startTime(this._start + i - this._delay),
            (this._delay = i),
            this)
          : this._delay;
      }),
      (e.duration = function (i) {
        return arguments.length
          ? this.totalDuration(
              this._repeat > 0 ? i + (i + this._rDelay) * this._repeat : i,
            )
          : this.totalDuration() && this._dur;
      }),
      (e.totalDuration = function (i) {
        return arguments.length
          ? ((this._dirty = 0),
            md(
              this,
              this._repeat < 0
                ? i
                : (i - this._repeat * this._rDelay) / (this._repeat + 1),
            ))
          : this._tDur;
      }),
      (e.totalTime = function (i, r) {
        if ((Cd(), !arguments.length)) return this._tTime;
        var s = this._dp;
        if (s && s.smoothChildTiming && this._ts) {
          for (hI(this, i), !s._dp || s.parent || YR(s, this); s && s.parent; )
            (s.parent._time !==
              s._start +
                (s._ts >= 0
                  ? s._tTime / s._ts
                  : (s.totalDuration() - s._tTime) / -s._ts) &&
              s.totalTime(s._tTime, !0),
              (s = s.parent));
          !this.parent &&
            this._dp.autoRemoveChildren &&
            ((this._ts > 0 && i < this._tDur) ||
              (this._ts < 0 && i > 0) ||
              (!this._tDur && !i)) &&
            yo(this._dp, this, this._start - this._delay);
        }
        return (
          (this._tTime !== i ||
            (!this._dur && !r) ||
            (this._initted && Math.abs(this._zTime) === xn) ||
            (!i && !this._initted && (this.add || this._ptLookup))) &&
            (this._ts || (this._pTime = i), WR(this, i, r)),
          this
        );
      }),
      (e.time = function (i, r) {
        return arguments.length
          ? this.totalTime(
              Math.min(this.totalDuration(), i + oS(this)) %
                (this._dur + this._rDelay) || (i ? this._dur : 0),
              r,
            )
          : this._time;
      }),
      (e.totalProgress = function (i, r) {
        return arguments.length
          ? this.totalTime(this.totalDuration() * i, r)
          : this.totalDuration()
            ? Math.min(1, this._tTime / this._tDur)
            : this.rawTime() >= 0 && this._initted
              ? 1
              : 0;
      }),
      (e.progress = function (i, r) {
        return arguments.length
          ? this.totalTime(
              this.duration() *
                (this._yoyo && !(this.iteration() & 1) ? 1 - i : i) +
                oS(this),
              r,
            )
          : this.duration()
            ? Math.min(1, this._time / this._dur)
            : this.rawTime() > 0
              ? 1
              : 0;
      }),
      (e.iteration = function (i, r) {
        var s = this.duration() + this._rDelay;
        return arguments.length
          ? this.totalTime(this._time + (i - 1) * s, r)
          : this._repeat
            ? pd(this._tTime, s) + 1
            : 1;
      }),
      (e.timeScale = function (i, r) {
        if (!arguments.length) return this._rts === -xn ? 0 : this._rts;
        if (this._rts === i) return this;
        var s =
          this.parent && this._ts ? eC(this.parent._time, this) : this._tTime;
        return (
          (this._rts = +i || 0),
          (this._ts = this._ps || i === -xn ? 0 : this._rts),
          this.totalTime(Mp(-Math.abs(this._delay), this._tDur, s), r !== !1),
          uI(this),
          ule(this)
        );
      }),
      (e.paused = function (i) {
        return arguments.length
          ? (this._ps !== i &&
              ((this._ps = i),
              i
                ? ((this._pTime =
                    this._tTime || Math.max(-this._delay, this.rawTime())),
                  (this._ts = this._act = 0))
                : (Cd(),
                  (this._ts = this._rts),
                  this.totalTime(
                    this.parent && !this.parent.smoothChildTiming
                      ? this.rawTime()
                      : this._tTime || this._pTime,
                    this.progress() === 1 &&
                      Math.abs(this._zTime) !== xn &&
                      (this._tTime -= xn),
                  ))),
            this)
          : this._ps;
      }),
      (e.startTime = function (i) {
        if (arguments.length) {
          this._start = i;
          var r = this.parent || this._dp;
          return (
            r && (r._sort || !this.parent) && yo(r, this, i - this._delay),
            this
          );
        }
        return this._start;
      }),
      (e.endTime = function (i) {
        return (
          this._start +
          (Mr(i) ? this.totalDuration() : this.duration()) /
            Math.abs(this._ts || 1)
        );
      }),
      (e.rawTime = function (i) {
        var r = this.parent || this._dp;
        return r
          ? i &&
            (!this._ts ||
              (this._repeat && this._time && this.totalProgress() < 1))
            ? this._tTime % (this._dur + this._rDelay)
            : this._ts
              ? eC(r.rawTime(i), this)
              : this._tTime
          : this._tTime;
      }),
      (e.revert = function (i) {
        i === void 0 && (i = ole);
        var r = ki;
        return (
          (ki = i),
          (this._initted || this._startAt) &&
            (this.timeline && this.timeline.revert(i),
            this.totalTime(-0.01, i.suppressEvents)),
          this.data !== "nested" && i.kill !== !1 && this.kill(),
          (ki = r),
          this
        );
      }),
      (e.globalTime = function (i) {
        for (var r = this, s = arguments.length ? i : r.rawTime(); r; )
          ((s = r._start + s / (Math.abs(r._ts) || 1)), (r = r._dp));
        return !this.parent && this._sat ? this._sat.globalTime(i) : s;
      }),
      (e.repeat = function (i) {
        return arguments.length
          ? ((this._repeat = i === 1 / 0 ? -2 : i), aS(this))
          : this._repeat === -2
            ? 1 / 0
            : this._repeat;
      }),
      (e.repeatDelay = function (i) {
        if (arguments.length) {
          var r = this._time;
          return ((this._rDelay = i), aS(this), r ? this.time(r) : this);
        }
        return this._rDelay;
      }),
      (e.yoyo = function (i) {
        return arguments.length ? ((this._yoyo = i), this) : this._yoyo;
      }),
      (e.seek = function (i, r) {
        return this.totalTime(ds(this, i), Mr(r));
      }),
      (e.restart = function (i, r) {
        return (
          this.play().totalTime(i ? -this._delay : 0, Mr(r)),
          this._dur || (this._zTime = -xn),
          this
        );
      }),
      (e.play = function (i, r) {
        return (i != null && this.seek(i, r), this.reversed(!1).paused(!1));
      }),
      (e.reverse = function (i, r) {
        return (
          i != null && this.seek(i || this.totalDuration(), r),
          this.reversed(!0).paused(!1)
        );
      }),
      (e.pause = function (i, r) {
        return (i != null && this.seek(i, r), this.paused(!0));
      }),
      (e.resume = function () {
        return this.paused(!1);
      }),
      (e.reversed = function (i) {
        return arguments.length
          ? (!!i !== this.reversed() &&
              this.timeScale(-this._rts || (i ? -xn : 0)),
            this)
          : this._rts < 0;
      }),
      (e.invalidate = function () {
        return ((this._initted = this._act = 0), (this._zTime = -xn), this);
      }),
      (e.isActive = function () {
        var i = this.parent || this._dp,
          r = this._start,
          s;
        return !!(
          !i ||
          (this._ts &&
            this._initted &&
            i.isActive() &&
            (s = i.rawTime(!0)) >= r &&
            s < this.endTime(!0) - xn)
        );
      }),
      (e.eventCallback = function (i, r, s) {
        var o = this.vars;
        return arguments.length > 1
          ? (r
              ? ((o[i] = r),
                s && (o[i + "Params"] = s),
                i === "onUpdate" && (this._onUpdate = r))
              : delete o[i],
            this)
          : o[i];
      }),
      (e.then = function (i) {
        var r = this;
        return new Promise(function (s) {
          var o = Xn(i) ? i : ZR,
            a = function () {
              var c = r.then;
              ((r.then = null),
                Xn(o) && (o = o(r)) && (o.then || o === r) && (r.then = c),
                s(o),
                (r.then = c));
            };
          (r._initted && r.totalProgress() === 1 && r._ts >= 0) ||
          (!r._tTime && r._ts < 0)
            ? a()
            : (r._prom = a);
        });
      }),
      (e.kill = function () {
        Of(this);
      }),
      n
    );
  })();
es(Hg.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -xn,
  _prom: 0,
  _ps: !1,
  _rts: 1,
});
var hr = (function (n) {
  RR(e, n);
  function e(i, r) {
    var s;
    return (
      i === void 0 && (i = {}),
      (s = n.call(this, i) || this),
      (s.labels = {}),
      (s.smoothChildTiming = !!i.smoothChildTiming),
      (s.autoRemoveChildren = !!i.autoRemoveChildren),
      (s._sort = Mr(i.sortChildren)),
      kn && yo(i.parent || kn, ua(s), r),
      i.reversed && s.reverse(),
      i.paused && s.paused(!0),
      i.scrollTrigger && XR(ua(s), i.scrollTrigger),
      s
    );
  }
  var t = e.prototype;
  return (
    (t.to = function (r, s, o) {
      return (og(0, arguments, this), this);
    }),
    (t.from = function (r, s, o) {
      return (og(1, arguments, this), this);
    }),
    (t.fromTo = function (r, s, o, a) {
      return (og(2, arguments, this), this);
    }),
    (t.set = function (r, s, o) {
      return (
        (s.duration = 0),
        (s.parent = this),
        sg(s).repeatDelay || (s.repeat = 0),
        (s.immediateRender = !!s.immediateRender),
        new ni(r, s, ds(this, o), 1),
        this
      );
    }),
    (t.call = function (r, s, o) {
      return yo(this, ni.delayedCall(0, r, s), o);
    }),
    (t.staggerTo = function (r, s, o, a, l, c, u) {
      return (
        (o.duration = s),
        (o.stagger = o.stagger || a),
        (o.onComplete = c),
        (o.onCompleteParams = u),
        (o.parent = this),
        new ni(r, o, ds(this, l)),
        this
      );
    }),
    (t.staggerFrom = function (r, s, o, a, l, c, u) {
      return (
        (o.runBackwards = 1),
        (sg(o).immediateRender = Mr(o.immediateRender)),
        this.staggerTo(r, s, o, a, l, c, u)
      );
    }),
    (t.staggerFromTo = function (r, s, o, a, l, c, u, h) {
      return (
        (a.startAt = o),
        (sg(a).immediateRender = Mr(a.immediateRender)),
        this.staggerTo(r, s, a, l, c, u, h)
      );
    }),
    (t.render = function (r, s, o) {
      var a = this._time,
        l = this._dirty ? this.totalDuration() : this._tDur,
        c = this._dur,
        u = r <= 0 ? 0 : ii(r),
        h = this._zTime < 0 != r < 0 && (this._initted || !c),
        d,
        f,
        g,
        p,
        m,
        C,
        A,
        I,
        y,
        x,
        T,
        S;
      if (
        (this !== kn && u > l && r >= 0 && (u = l), u !== this._tTime || o || h)
      ) {
        if (
          (a !== this._time &&
            c &&
            ((u += this._time - a), (r += this._time - a)),
          (d = u),
          (y = this._start),
          (I = this._ts),
          (C = !I),
          h && (c || (a = this._zTime), (r || !s) && (this._zTime = r)),
          this._repeat)
        ) {
          if (
            ((T = this._yoyo),
            (m = c + this._rDelay),
            this._repeat < -1 && r < 0)
          )
            return this.totalTime(m * 100 + r, s, o);
          if (
            ((d = ii(u % m)),
            u === l
              ? ((p = this._repeat), (d = c))
              : ((x = ii(u / m)),
                (p = ~~x),
                p && p === x && ((d = c), p--),
                d > c && (d = c)),
            (x = pd(this._tTime, m)),
            !a &&
              this._tTime &&
              x !== p &&
              this._tTime - x * m - this._dur <= 0 &&
              (x = p),
            T && p & 1 && ((d = c - d), (S = 1)),
            p !== x && !this._lock)
          ) {
            var E = T && x & 1,
              _ = E === (T && p & 1);
            if (
              (p < x && (E = !E),
              (a = E ? 0 : u % c ? c : u),
              (this._lock = 1),
              (this.render(a || (S ? 0 : ii(p * m)), s, !c)._lock = 0),
              (this._tTime = u),
              !s && this.parent && Kr(this, "onRepeat"),
              this.vars.repeatRefresh && !S && (this.invalidate()._lock = 1),
              (a && a !== this._time) ||
                C !== !this._ts ||
                (this.vars.onRepeat && !this.parent && !this._act))
            )
              return this;
            if (
              ((c = this._dur),
              (l = this._tDur),
              _ &&
                ((this._lock = 2),
                (a = E ? c : -1e-4),
                this.render(a, !0),
                this.vars.repeatRefresh && !S && this.invalidate()),
              (this._lock = 0),
              !this._ts && !C)
            )
              return this;
            lB(this, S);
          }
        }
        if (
          (this._hasPause &&
            !this._forcing &&
            this._lock < 2 &&
            ((A = gle(this, ii(a), ii(d))), A && (u -= d - (d = A._start))),
          (this._tTime = u),
          (this._time = d),
          (this._act = !I),
          this._initted ||
            ((this._onUpdate = this.vars.onUpdate),
            (this._initted = 1),
            (this._zTime = r),
            (a = 0)),
          !a && d && !s && !p && (Kr(this, "onStart"), this._tTime !== u))
        )
          return this;
        if (d >= a && r >= 0)
          for (f = this._first; f; ) {
            if (
              ((g = f._next), (f._act || d >= f._start) && f._ts && A !== f)
            ) {
              if (f.parent !== this) return this.render(r, s, o);
              if (
                (f.render(
                  f._ts > 0
                    ? (d - f._start) * f._ts
                    : (f._dirty ? f.totalDuration() : f._tDur) +
                        (d - f._start) * f._ts,
                  s,
                  o,
                ),
                d !== this._time || (!this._ts && !C))
              ) {
                ((A = 0), g && (u += this._zTime = -xn));
                break;
              }
            }
            f = g;
          }
        else {
          f = this._last;
          for (var b = r < 0 ? r : d; f; ) {
            if (((g = f._prev), (f._act || b <= f._end) && f._ts && A !== f)) {
              if (f.parent !== this) return this.render(r, s, o);
              if (
                (f.render(
                  f._ts > 0
                    ? (b - f._start) * f._ts
                    : (f._dirty ? f.totalDuration() : f._tDur) +
                        (b - f._start) * f._ts,
                  s,
                  o || (ki && (f._initted || f._startAt)),
                ),
                d !== this._time || (!this._ts && !C))
              ) {
                ((A = 0), g && (u += this._zTime = b ? -xn : xn));
                break;
              }
            }
            f = g;
          }
        }
        if (
          A &&
          !s &&
          (this.pause(),
          (A.render(d >= a ? 0 : -xn)._zTime = d >= a ? 1 : -1),
          this._ts)
        )
          return ((this._start = y), uI(this), this.render(r, s, o));
        (this._onUpdate && !s && Kr(this, "onUpdate", !0),
          ((u === l && this._tTime >= this.totalDuration()) || (!u && a)) &&
            (y === this._start || Math.abs(I) !== Math.abs(this._ts)) &&
            (this._lock ||
              ((r || !c) &&
                ((u === l && this._ts > 0) || (!u && this._ts < 0)) &&
                Gl(this, 1),
              !s &&
                !(r < 0 && !a) &&
                (u || a || !l) &&
                (Kr(
                  this,
                  u === l && r >= 0 ? "onComplete" : "onReverseComplete",
                  !0,
                ),
                this._prom &&
                  !(u < l && this.timeScale() > 0) &&
                  this._prom()))));
      }
      return this;
    }),
    (t.add = function (r, s) {
      var o = this;
      if ((Na(s) || (s = ds(this, s, r)), !(r instanceof Hg))) {
        if (nr(r))
          return (
            r.forEach(function (a) {
              return o.add(a, s);
            }),
            this
          );
        if (Ni(r)) return this.addLabel(r, s);
        if (Xn(r)) r = ni.delayedCall(0, r);
        else return this;
      }
      return this !== r ? yo(this, r, s) : this;
    }),
    (t.getChildren = function (r, s, o, a) {
      (r === void 0 && (r = !0),
        s === void 0 && (s = !0),
        o === void 0 && (o = !0),
        a === void 0 && (a = -As));
      for (var l = [], c = this._first; c; )
        (c._start >= a &&
          (c instanceof ni
            ? s && l.push(c)
            : (o && l.push(c), r && l.push.apply(l, c.getChildren(!0, s, o)))),
          (c = c._next));
      return l;
    }),
    (t.getById = function (r) {
      for (var s = this.getChildren(1, 1, 1), o = s.length; o--; )
        if (s[o].vars.id === r) return s[o];
    }),
    (t.remove = function (r) {
      return Ni(r)
        ? this.removeLabel(r)
        : Xn(r)
          ? this.killTweensOf(r)
          : (r.parent === this && cI(this, r),
            r === this._recent && (this._recent = this._last),
            nu(this));
    }),
    (t.totalTime = function (r, s) {
      return arguments.length
        ? ((this._forcing = 1),
          !this._dp &&
            this._ts &&
            (this._start = ii(
              Vr.time -
                (this._ts > 0
                  ? r / this._ts
                  : (this.totalDuration() - r) / -this._ts),
            )),
          n.prototype.totalTime.call(this, r, s),
          (this._forcing = 0),
          this)
        : this._tTime;
    }),
    (t.addLabel = function (r, s) {
      return ((this.labels[r] = ds(this, s)), this);
    }),
    (t.removeLabel = function (r) {
      return (delete this.labels[r], this);
    }),
    (t.addPause = function (r, s, o) {
      var a = ni.delayedCall(0, s || kg, o);
      return (
        (a.data = "isPause"),
        (this._hasPause = 1),
        yo(this, a, ds(this, r))
      );
    }),
    (t.removePause = function (r) {
      var s = this._first;
      for (r = ds(this, r); s; )
        (s._start === r && s.data === "isPause" && Gl(s), (s = s._next));
    }),
    (t.killTweensOf = function (r, s, o) {
      for (var a = this.getTweensOf(r, o), l = a.length; l--; )
        Il !== a[l] && a[l].kill(r, s);
      return this;
    }),
    (t.getTweensOf = function (r, s) {
      for (var o = [], a = ys(r), l = this._first, c = Na(s), u; l; )
        (l instanceof ni
          ? ale(l._targets, a) &&
            (c
              ? (!Il || (l._initted && l._ts)) &&
                l.globalTime(0) <= s &&
                l.globalTime(l.totalDuration()) > s
              : !s || l.isActive()) &&
            o.push(l)
          : (u = l.getTweensOf(a, s)).length && o.push.apply(o, u),
          (l = l._next));
      return o;
    }),
    (t.tweenTo = function (r, s) {
      s = s || {};
      var o = this,
        a = ds(o, r),
        l = s,
        c = l.startAt,
        u = l.onStart,
        h = l.onStartParams,
        d = l.immediateRender,
        f,
        g = ni.to(
          o,
          es(
            {
              ease: s.ease || "none",
              lazy: !1,
              immediateRender: !1,
              time: a,
              overwrite: "auto",
              duration:
                s.duration ||
                Math.abs(
                  (a - (c && "time" in c ? c.time : o._time)) / o.timeScale(),
                ) ||
                xn,
              onStart: function () {
                if ((o.pause(), !f)) {
                  var m =
                    s.duration ||
                    Math.abs(
                      (a - (c && "time" in c ? c.time : o._time)) /
                        o.timeScale(),
                    );
                  (g._dur !== m && md(g, m, 0, 1).render(g._time, !0, !0),
                    (f = 1));
                }
                u && u.apply(g, h || []);
              },
            },
            s,
          ),
        );
      return d ? g.render(0) : g;
    }),
    (t.tweenFromTo = function (r, s, o) {
      return this.tweenTo(s, es({ startAt: { time: ds(this, r) } }, o));
    }),
    (t.recent = function () {
      return this._recent;
    }),
    (t.nextLabel = function (r) {
      return (r === void 0 && (r = this._time), lS(this, ds(this, r)));
    }),
    (t.previousLabel = function (r) {
      return (r === void 0 && (r = this._time), lS(this, ds(this, r), 1));
    }),
    (t.currentLabel = function (r) {
      return arguments.length
        ? this.seek(r, !0)
        : this.previousLabel(this._time + xn);
    }),
    (t.shiftChildren = function (r, s, o) {
      o === void 0 && (o = 0);
      for (var a = this._first, l = this.labels, c; a; )
        (a._start >= o && ((a._start += r), (a._end += r)), (a = a._next));
      if (s) for (c in l) l[c] >= o && (l[c] += r);
      return nu(this);
    }),
    (t.invalidate = function (r) {
      var s = this._first;
      for (this._lock = 0; s; ) (s.invalidate(r), (s = s._next));
      return n.prototype.invalidate.call(this, r);
    }),
    (t.clear = function (r) {
      r === void 0 && (r = !0);
      for (var s = this._first, o; s; )
        ((o = s._next), this.remove(s), (s = o));
      return (
        this._dp && (this._time = this._tTime = this._pTime = 0),
        r && (this.labels = {}),
        nu(this)
      );
    }),
    (t.totalDuration = function (r) {
      var s = 0,
        o = this,
        a = o._last,
        l = As,
        c,
        u,
        h;
      if (arguments.length)
        return o.timeScale(
          (o._repeat < 0 ? o.duration() : o.totalDuration()) /
            (o.reversed() ? -r : r),
        );
      if (o._dirty) {
        for (h = o.parent; a; )
          ((c = a._prev),
            a._dirty && a.totalDuration(),
            (u = a._start),
            u > l && o._sort && a._ts && !o._lock
              ? ((o._lock = 1), (yo(o, a, u - a._delay, 1)._lock = 0))
              : (l = u),
            u < 0 &&
              a._ts &&
              ((s -= u),
              ((!h && !o._dp) || (h && h.smoothChildTiming)) &&
                ((o._start += u / o._ts), (o._time -= u), (o._tTime -= u)),
              o.shiftChildren(-u, !1, -1 / 0),
              (l = 0)),
            a._end > s && a._ts && (s = a._end),
            (a = c));
        (md(o, o === kn && o._time > s ? o._time : s, 1, 1), (o._dirty = 0));
      }
      return o._tDur;
    }),
    (e.updateRoot = function (r) {
      if ((kn._ts && (WR(kn, eC(r, kn)), (UR = Vr.frame)), Vr.frame >= rS)) {
        rS += Jr.autoSleep || 120;
        var s = kn._first;
        if ((!s || !s._ts) && Jr.autoSleep && Vr._listeners.length < 2) {
          for (; s && !s._ts; ) s = s._next;
          s || Vr.sleep();
        }
      }
    }),
    e
  );
})(Hg);
es(hr.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
var Lle = function (e, t, i, r, s, o, a) {
    var l = new Rr(this._pt, e, t, 0, 1, mB, null, s),
      c = 0,
      u = 0,
      h,
      d,
      f,
      g,
      p,
      m,
      C,
      A;
    for (
      l.b = i,
        l.e = r,
        i += "",
        r += "",
        (C = ~r.indexOf("random(")) && (r = Og(r)),
        o && ((A = [i, r]), o(A, e, t), (i = A[0]), (r = A[1])),
        d = i.match(eA) || [];
      (h = eA.exec(r));
    )
      ((g = h[0]),
        (p = r.substring(c, h.index)),
        f ? (f = (f + 1) % 5) : p.substr(-5) === "rgba(" && (f = 1),
        g !== d[u++] &&
          ((m = parseFloat(d[u - 1]) || 0),
          (l._pt = {
            _next: l._pt,
            p: p || u === 1 ? p : ",",
            s: m,
            c: g.charAt(1) === "=" ? Gh(m, g) - m : parseFloat(g) - m,
            m: f && f < 4 ? Math.round : 0,
          }),
          (c = eA.lastIndex)));
    return (
      (l.c = c < r.length ? r.substring(c, r.length) : ""),
      (l.fp = a),
      (DR.test(r) || C) && (l.e = 0),
      (this._pt = l),
      l
    );
  },
  o5 = function (e, t, i, r, s, o, a, l, c, u) {
    Xn(r) && (r = r(s || 0, e, o));
    var h = e[t],
      d =
        i !== "get"
          ? i
          : Xn(h)
            ? c
              ? e[
                  t.indexOf("set") || !Xn(e["get" + t.substr(3)])
                    ? t
                    : "get" + t.substr(3)
                ](c)
              : e[t]()
            : h,
      f = Xn(h) ? (c ? Dle : gB) : l5,
      g;
    if (
      (Ni(r) &&
        (~r.indexOf("random(") && (r = Og(r)),
        r.charAt(1) === "=" &&
          ((g = Gh(d, r) + (ji(d) || 0)), (g || g === 0) && (r = g))),
      !u || d !== r || d3)
    )
      return !isNaN(d * r) && r !== ""
        ? ((g = new Rr(
            this._pt,
            e,
            t,
            +d || 0,
            r - (d || 0),
            typeof h == "boolean" ? Fle : pB,
            0,
            f,
          )),
          c && (g.fp = c),
          a && g.modifier(a, this, e),
          (this._pt = g))
        : (!h && !(t in e) && n5(t, r),
          Lle.call(this, e, t, d, r, f, l || Jr.stringFilter, c));
  },
  Rle = function (e, t, i, r, s) {
    if (
      (Xn(e) && (e = ag(e, s, t, i, r)),
      !Uo(e) || (e.style && e.nodeType) || nr(e) || PR(e))
    )
      return Ni(e) ? ag(e, s, t, i, r) : e;
    var o = {},
      a;
    for (a in e) o[a] = ag(e[a], s, t, i, r);
    return o;
  },
  hB = function (e, t, i, r, s, o) {
    var a, l, c, u;
    if (
      Wr[e] &&
      (a = new Wr[e]()).init(
        s,
        a.rawVars ? t[e] : Rle(t[e], r, s, o, i),
        i,
        r,
        o,
      ) !== !1 &&
      ((i._pt = l = new Rr(i._pt, s, e, 0, 1, a.render, a, 0, a.priority)),
      i !== bh)
    )
      for (c = i._ptLookup[i._targets.indexOf(s)], u = a._props.length; u--; )
        c[a._props[u]] = l;
    return a;
  },
  Il,
  d3,
  a5 = function n(e, t, i) {
    var r = e.vars,
      s = r.ease,
      o = r.startAt,
      a = r.immediateRender,
      l = r.lazy,
      c = r.onUpdate,
      u = r.runBackwards,
      h = r.yoyoEase,
      d = r.keyframes,
      f = r.autoRevert,
      g = e._dur,
      p = e._startAt,
      m = e._targets,
      C = e.parent,
      A = C && C.data === "nested" ? C.vars.targets : m,
      I = e._overwrite === "auto" && !Qv,
      y = e.timeline,
      x,
      T,
      S,
      E,
      _,
      b,
      R,
      M,
      L,
      P,
      U,
      O,
      V;
    if (
      (y && (!d || !s) && (s = "none"),
      (e._ease = iu(s, fd.ease)),
      (e._yEase = h ? aB(iu(h === !0 ? s : h, fd.ease)) : 0),
      h &&
        e._yoyo &&
        !e._repeat &&
        ((h = e._yEase), (e._yEase = e._ease), (e._ease = h)),
      (e._from = !y && !!r.runBackwards),
      !y || (d && !r.stagger))
    ) {
      if (
        ((M = m[0] ? tu(m[0]).harness : 0),
        (O = M && r[M.prop]),
        (x = qm(r, i5)),
        p &&
          (p._zTime < 0 && p.progress(1),
          t < 0 && u && a && !f
            ? p.render(-1, !0)
            : p.revert(u && g ? Y0 : sle),
          (p._lazy = 0)),
        o)
      ) {
        if (
          (Gl(
            (e._startAt = ni.set(
              m,
              es(
                {
                  data: "isStart",
                  overwrite: !1,
                  parent: C,
                  immediateRender: !0,
                  lazy: !p && Mr(l),
                  startAt: null,
                  delay: 0,
                  onUpdate:
                    c &&
                    function () {
                      return Kr(e, "onUpdate");
                    },
                  stagger: 0,
                },
                o,
              ),
            )),
          ),
          (e._startAt._dp = 0),
          (e._startAt._sat = e),
          t < 0 && (ki || (!a && !f)) && e._startAt.revert(Y0),
          a && g && t <= 0 && i <= 0)
        ) {
          t && (e._zTime = t);
          return;
        }
      } else if (u && g && !p) {
        if (
          (t && (a = !1),
          (S = es(
            {
              overwrite: !1,
              data: "isFromStart",
              lazy: a && !p && Mr(l),
              immediateRender: a,
              stagger: 0,
              parent: C,
            },
            x,
          )),
          O && (S[M.prop] = O),
          Gl((e._startAt = ni.set(m, S))),
          (e._startAt._dp = 0),
          (e._startAt._sat = e),
          t < 0 && (ki ? e._startAt.revert(Y0) : e._startAt.render(-1, !0)),
          (e._zTime = t),
          !a)
        )
          n(e._startAt, xn, xn);
        else if (!t) return;
      }
      for (
        e._pt = e._ptCache = 0, l = (g && Mr(l)) || (l && !g), T = 0;
        T < m.length;
        T++
      ) {
        if (
          ((_ = m[T]),
          (R = _._gsap || s5(m)[T]._gsap),
          (e._ptLookup[T] = P = {}),
          o3[R.id] && Tl.length && Qm(),
          (U = A === m ? T : A.indexOf(_)),
          M &&
            (L = new M()).init(_, O || x, e, U, A) !== !1 &&
            ((e._pt = E =
              new Rr(e._pt, _, L.name, 0, 1, L.render, L, 0, L.priority)),
            L._props.forEach(function (W) {
              P[W] = E;
            }),
            L.priority && (b = 1)),
          !M || O)
        )
          for (S in x)
            Wr[S] && (L = hB(S, x, e, U, _, A))
              ? L.priority && (b = 1)
              : (P[S] = E =
                  o5.call(e, _, S, "get", x[S], U, A, 0, r.stringFilter));
        (e._op && e._op[T] && e.kill(_, e._op[T]),
          I &&
            e._pt &&
            ((Il = e),
            kn.killTweensOf(_, P, e.globalTime(t)),
            (V = !e.parent),
            (Il = 0)),
          e._pt && l && (o3[R.id] = 1));
      }
      (b && CB(e), e._onInit && e._onInit(e));
    }
    ((e._onUpdate = c),
      (e._initted = (!e._op || e._pt) && !V),
      d && t <= 0 && y.render(As, !0, !0));
  },
  Ble = function (e, t, i, r, s, o, a, l) {
    var c = ((e._pt && e._ptCache) || (e._ptCache = {}))[t],
      u,
      h,
      d,
      f;
    if (!c)
      for (
        c = e._ptCache[t] = [], d = e._ptLookup, f = e._targets.length;
        f--;
      ) {
        if (((u = d[f][t]), u && u.d && u.d._pt))
          for (u = u.d._pt; u && u.p !== t && u.fp !== t; ) u = u._next;
        if (!u)
          return (
            (d3 = 1),
            (e.vars[t] = "+=0"),
            a5(e, a),
            (d3 = 0),
            l ? Fg(t + " not eligible for reset") : 1
          );
        c.push(u);
      }
    for (f = c.length; f--; )
      ((h = c[f]),
        (u = h._pt || h),
        (u.s = (r || r === 0) && !s ? r : u.s + (r || 0) + o * u.c),
        (u.c = i - u.s),
        h.e && (h.e = Jn(i) + ji(h.e)),
        h.b && (h.b = u.s + ji(h.b)));
  },
  Ple = function (e, t) {
    var i = e[0] ? tu(e[0]).harness : 0,
      r = i && i.aliases,
      s,
      o,
      a,
      l;
    if (!r) return t;
    s = gd({}, t);
    for (o in r)
      if (o in s) for (l = r[o].split(","), a = l.length; a--; ) s[l[a]] = s[o];
    return s;
  },
  Nle = function (e, t, i, r) {
    var s = t.ease || r || "power1.inOut",
      o,
      a;
    if (nr(t))
      ((a = i[e] || (i[e] = [])),
        t.forEach(function (l, c) {
          return a.push({ t: (c / (t.length - 1)) * 100, v: l, e: s });
        }));
    else
      for (o in t)
        ((a = i[o] || (i[o] = [])),
          o === "ease" || a.push({ t: parseFloat(e), v: t[o], e: s }));
  },
  ag = function (e, t, i, r, s) {
    return Xn(e)
      ? e.call(t, i, r, s)
      : Ni(e) && ~e.indexOf("random(")
        ? Og(e)
        : e;
  },
  dB = r5 + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
  fB = {};
Lr(dB + ",id,stagger,delay,duration,paused,scrollTrigger", function (n) {
  return (fB[n] = 1);
});
var ni = (function (n) {
  RR(e, n);
  function e(i, r, s, o) {
    var a;
    (typeof r == "number" && ((s.duration = r), (r = s), (s = null)),
      (a = n.call(this, o ? r : sg(r)) || this));
    var l = a.vars,
      c = l.duration,
      u = l.delay,
      h = l.immediateRender,
      d = l.stagger,
      f = l.overwrite,
      g = l.keyframes,
      p = l.defaults,
      m = l.scrollTrigger,
      C = l.yoyoEase,
      A = r.parent || kn,
      I = (nr(i) || PR(i) ? Na(i[0]) : "length" in r) ? [i] : ys(i),
      y,
      x,
      T,
      S,
      E,
      _,
      b,
      R;
    if (
      ((a._targets = I.length
        ? s5(I)
        : Fg(
            "GSAP target " + i + " not found. https://gsap.com",
            !Jr.nullTargetWarn,
          ) || []),
      (a._ptLookup = []),
      (a._overwrite = f),
      g || d || T1(c) || T1(u))
    ) {
      if (
        ((r = a.vars),
        (y = a.timeline =
          new hr({
            data: "nested",
            defaults: p || {},
            targets: A && A.data === "nested" ? A.vars.targets : I,
          })),
        y.kill(),
        (y.parent = y._dp = ua(a)),
        (y._start = 0),
        d || T1(c) || T1(u))
      ) {
        if (((S = I.length), (b = d && JR(d)), Uo(d)))
          for (E in d) ~dB.indexOf(E) && (R || (R = {}), (R[E] = d[E]));
        for (x = 0; x < S; x++)
          ((T = qm(r, fB)),
            (T.stagger = 0),
            C && (T.yoyoEase = C),
            R && gd(T, R),
            (_ = I[x]),
            (T.duration = +ag(c, ua(a), x, _, I)),
            (T.delay = (+ag(u, ua(a), x, _, I) || 0) - a._delay),
            !d &&
              S === 1 &&
              T.delay &&
              ((a._delay = u = T.delay), (a._start += u), (T.delay = 0)),
            y.to(_, T, b ? b(x, _, I) : 0),
            (y._ease = Xt.none));
        y.duration() ? (c = u = 0) : (a.timeline = 0);
      } else if (g) {
        (sg(es(y.vars.defaults, { ease: "none" })),
          (y._ease = iu(g.ease || r.ease || "none")));
        var M = 0,
          L,
          P,
          U;
        if (nr(g))
          (g.forEach(function (O) {
            return y.to(I, O, ">");
          }),
            y.duration());
        else {
          T = {};
          for (E in g)
            E === "ease" || E === "easeEach" || Nle(E, g[E], T, g.easeEach);
          for (E in T)
            for (
              L = T[E].sort(function (O, V) {
                return O.t - V.t;
              }),
                M = 0,
                x = 0;
              x < L.length;
              x++
            )
              ((P = L[x]),
                (U = {
                  ease: P.e,
                  duration: ((P.t - (x ? L[x - 1].t : 0)) / 100) * c,
                }),
                (U[E] = P.v),
                y.to(I, U, M),
                (M += U.duration));
          y.duration() < c && y.to({}, { duration: c - y.duration() });
        }
      }
      c || a.duration((c = y.duration()));
    } else a.timeline = 0;
    return (
      f === !0 && !Qv && ((Il = ua(a)), kn.killTweensOf(I), (Il = 0)),
      yo(A, ua(a), s),
      r.reversed && a.reverse(),
      r.paused && a.paused(!0),
      (h ||
        (!c &&
          !g &&
          a._start === ii(A._time) &&
          Mr(h) &&
          hle(ua(a)) &&
          A.data !== "nested")) &&
        ((a._tTime = -xn), a.render(Math.max(0, -u) || 0)),
      m && XR(ua(a), m),
      a
    );
  }
  var t = e.prototype;
  return (
    (t.render = function (r, s, o) {
      var a = this._time,
        l = this._tDur,
        c = this._dur,
        u = r < 0,
        h = r > l - xn && !u ? l : r < xn ? 0 : r,
        d,
        f,
        g,
        p,
        m,
        C,
        A,
        I,
        y;
      if (!c) fle(this, r, s, o);
      else if (
        h !== this._tTime ||
        !r ||
        o ||
        (!this._initted && this._tTime) ||
        (this._startAt && this._zTime < 0 !== u) ||
        this._lazy
      ) {
        if (((d = h), (I = this.timeline), this._repeat)) {
          if (((p = c + this._rDelay), this._repeat < -1 && u))
            return this.totalTime(p * 100 + r, s, o);
          if (
            ((d = ii(h % p)),
            h === l
              ? ((g = this._repeat), (d = c))
              : ((m = ii(h / p)),
                (g = ~~m),
                g && g === m ? ((d = c), g--) : d > c && (d = c)),
            (C = this._yoyo && g & 1),
            C && ((y = this._yEase), (d = c - d)),
            (m = pd(this._tTime, p)),
            d === a && !o && this._initted && g === m)
          )
            return ((this._tTime = h), this);
          g !== m &&
            (I && this._yEase && lB(I, C),
            this.vars.repeatRefresh &&
              !C &&
              !this._lock &&
              d !== p &&
              this._initted &&
              ((this._lock = o = 1),
              (this.render(ii(p * g), !0).invalidate()._lock = 0)));
        }
        if (!this._initted) {
          if (KR(this, u ? r : d, o, s, h)) return ((this._tTime = 0), this);
          if (a !== this._time && !(o && this.vars.repeatRefresh && g !== m))
            return this;
          if (c !== this._dur) return this.render(r, s, o);
        }
        if (
          ((this._tTime = h),
          (this._time = d),
          !this._act && this._ts && ((this._act = 1), (this._lazy = 0)),
          (this.ratio = A = (y || this._ease)(d / c)),
          this._from && (this.ratio = A = 1 - A),
          d && !a && !s && !g && (Kr(this, "onStart"), this._tTime !== h))
        )
          return this;
        for (f = this._pt; f; ) (f.r(A, f.d), (f = f._next));
        ((I && I.render(r < 0 ? r : I._dur * I._ease(d / this._dur), s, o)) ||
          (this._startAt && (this._zTime = r)),
          this._onUpdate &&
            !s &&
            (u && a3(this, r, s, o), Kr(this, "onUpdate")),
          this._repeat &&
            g !== m &&
            this.vars.onRepeat &&
            !s &&
            this.parent &&
            Kr(this, "onRepeat"),
          (h === this._tDur || !h) &&
            this._tTime === h &&
            (u && !this._onUpdate && a3(this, r, !0, !0),
            (r || !c) &&
              ((h === this._tDur && this._ts > 0) || (!h && this._ts < 0)) &&
              Gl(this, 1),
            !s &&
              !(u && !a) &&
              (h || a || C) &&
              (Kr(this, h === l ? "onComplete" : "onReverseComplete", !0),
              this._prom && !(h < l && this.timeScale() > 0) && this._prom())));
      }
      return this;
    }),
    (t.targets = function () {
      return this._targets;
    }),
    (t.invalidate = function (r) {
      return (
        (!r || !this.vars.runBackwards) && (this._startAt = 0),
        (this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0),
        (this._ptLookup = []),
        this.timeline && this.timeline.invalidate(r),
        n.prototype.invalidate.call(this, r)
      );
    }),
    (t.resetTo = function (r, s, o, a, l) {
      (Ug || Vr.wake(), this._ts || this.play());
      var c = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
        u;
      return (
        this._initted || a5(this, c),
        (u = this._ease(c / this._dur)),
        Ble(this, r, s, o, a, u, c, l)
          ? this.resetTo(r, s, o, a, 1)
          : (hI(this, 0),
            this.parent ||
              zR(
                this._dp,
                this,
                "_first",
                "_last",
                this._dp._sort ? "_start" : 0,
              ),
            this.render(0))
      );
    }),
    (t.kill = function (r, s) {
      if ((s === void 0 && (s = "all"), !r && (!s || s === "all")))
        return (
          (this._lazy = this._pt = 0),
          this.parent
            ? Of(this)
            : this.scrollTrigger && this.scrollTrigger.kill(!!ki),
          this
        );
      if (this.timeline) {
        var o = this.timeline.totalDuration();
        return (
          this.timeline.killTweensOf(r, s, Il && Il.vars.overwrite !== !0)
            ._first || Of(this),
          this.parent &&
            o !== this.timeline.totalDuration() &&
            md(this, (this._dur * this.timeline._tDur) / o, 0, 1),
          this
        );
      }
      var a = this._targets,
        l = r ? ys(r) : a,
        c = this._ptLookup,
        u = this._pt,
        h,
        d,
        f,
        g,
        p,
        m,
        C;
      if ((!s || s === "all") && cle(a, l))
        return (s === "all" && (this._pt = 0), Of(this));
      for (
        h = this._op = this._op || [],
          s !== "all" &&
            (Ni(s) &&
              ((p = {}),
              Lr(s, function (A) {
                return (p[A] = 1);
              }),
              (s = p)),
            (s = Ple(a, s))),
          C = a.length;
        C--;
      )
        if (~l.indexOf(a[C])) {
          ((d = c[C]),
            s === "all"
              ? ((h[C] = s), (g = d), (f = {}))
              : ((f = h[C] = h[C] || {}), (g = s)));
          for (p in g)
            ((m = d && d[p]),
              m &&
                ((!("kill" in m.d) || m.d.kill(p) === !0) && cI(this, m, "_pt"),
                delete d[p]),
              f !== "all" && (f[p] = 1));
        }
      return (this._initted && !this._pt && u && Of(this), this);
    }),
    (e.to = function (r, s) {
      return new e(r, s, arguments[2]);
    }),
    (e.from = function (r, s) {
      return og(1, arguments);
    }),
    (e.delayedCall = function (r, s, o, a) {
      return new e(s, 0, {
        immediateRender: !1,
        lazy: !1,
        overwrite: !1,
        delay: r,
        onComplete: s,
        onReverseComplete: s,
        onCompleteParams: o,
        onReverseCompleteParams: o,
        callbackScope: a,
      });
    }),
    (e.fromTo = function (r, s, o) {
      return og(2, arguments);
    }),
    (e.set = function (r, s) {
      return ((s.duration = 0), s.repeatDelay || (s.repeat = 0), new e(r, s));
    }),
    (e.killTweensOf = function (r, s, o) {
      return kn.killTweensOf(r, s, o);
    }),
    e
  );
})(Hg);
es(ni.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 });
Lr("staggerTo,staggerFrom,staggerFromTo", function (n) {
  ni[n] = function () {
    var e = new hr(),
      t = c3.call(arguments, 0);
    return (t.splice(n === "staggerFromTo" ? 5 : 4, 0, 0), e[n].apply(e, t));
  };
});
var l5 = function (e, t, i) {
    return (e[t] = i);
  },
  gB = function (e, t, i) {
    return e[t](i);
  },
  Dle = function (e, t, i, r) {
    return e[t](r.fp, i);
  },
  Gle = function (e, t, i) {
    return e.setAttribute(t, i);
  },
  c5 = function (e, t) {
    return Xn(e[t]) ? gB : qv(e[t]) && e.setAttribute ? Gle : l5;
  },
  pB = function (e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t);
  },
  Fle = function (e, t) {
    return t.set(t.t, t.p, !!(t.s + t.c * e), t);
  },
  mB = function (e, t) {
    var i = t._pt,
      r = "";
    if (!e && t.b) r = t.b;
    else if (e === 1 && t.e) r = t.e;
    else {
      for (; i; )
        ((r =
          i.p +
          (i.m ? i.m(i.s + i.c * e) : Math.round((i.s + i.c * e) * 1e4) / 1e4) +
          r),
          (i = i._next));
      r += t.c;
    }
    t.set(t.t, t.p, r, t);
  },
  u5 = function (e, t) {
    for (var i = t._pt; i; ) (i.r(e, i.d), (i = i._next));
  },
  kle = function (e, t, i, r) {
    for (var s = this._pt, o; s; )
      ((o = s._next), s.p === r && s.modifier(e, t, i), (s = o));
  },
  Ole = function (e) {
    for (var t = this._pt, i, r; t; )
      ((r = t._next),
        (t.p === e && !t.op) || t.op === e
          ? cI(this, t, "_pt")
          : t.dep || (i = 1),
        (t = r));
    return !i;
  },
  Ule = function (e, t, i, r) {
    r.mSet(e, t, r.m.call(r.tween, i, r.mt), r);
  },
  CB = function (e) {
    for (var t = e._pt, i, r, s, o; t; ) {
      for (i = t._next, r = s; r && r.pr > t.pr; ) r = r._next;
      ((t._prev = r ? r._prev : o) ? (t._prev._next = t) : (s = t),
        (t._next = r) ? (r._prev = t) : (o = t),
        (t = i));
    }
    e._pt = s;
  },
  Rr = (function () {
    function n(t, i, r, s, o, a, l, c, u) {
      ((this.t = i),
        (this.s = s),
        (this.c = o),
        (this.p = r),
        (this.r = a || pB),
        (this.d = l || this),
        (this.set = c || l5),
        (this.pr = u || 0),
        (this._next = t),
        t && (t._prev = this));
    }
    var e = n.prototype;
    return (
      (e.modifier = function (i, r, s) {
        ((this.mSet = this.mSet || this.set),
          (this.set = Ule),
          (this.m = i),
          (this.mt = s),
          (this.tween = r));
      }),
      n
    );
  })();
Lr(
  r5 +
    "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
  function (n) {
    return (i5[n] = 1);
  },
);
qr.TweenMax = qr.TweenLite = ni;
qr.TimelineLite = qr.TimelineMax = hr;
kn = new hr({
  sortChildren: !1,
  defaults: fd,
  autoRemoveChildren: !0,
  id: "root",
  smoothChildTiming: !0,
});
Jr.stringFilter = oB;
var ru = [],
  K0 = {},
  Hle = [],
  uS = 0,
  Wle = 0,
  sA = function (e) {
    return (K0[e] || Hle).map(function (t) {
      return t();
    });
  },
  f3 = function () {
    var e = Date.now(),
      t = [];
    e - uS > 2 &&
      (sA("matchMediaInit"),
      ru.forEach(function (i) {
        var r = i.queries,
          s = i.conditions,
          o,
          a,
          l,
          c;
        for (a in r)
          ((o = po.matchMedia(r[a]).matches),
            o && (l = 1),
            o !== s[a] && ((s[a] = o), (c = 1)));
        c && (i.revert(), l && t.push(i));
      }),
      sA("matchMediaRevert"),
      t.forEach(function (i) {
        return i.onMatch(i, function (r) {
          return i.add(null, r);
        });
      }),
      (uS = e),
      sA("matchMedia"));
  },
  IB = (function () {
    function n(t, i) {
      ((this.selector = i && u3(i)),
        (this.data = []),
        (this._r = []),
        (this.isReverted = !1),
        (this.id = Wle++),
        t && this.add(t));
    }
    var e = n.prototype;
    return (
      (e.add = function (i, r, s) {
        Xn(i) && ((s = r), (r = i), (i = Xn));
        var o = this,
          a = function () {
            var c = Nn,
              u = o.selector,
              h;
            return (
              c && c !== o && c.data.push(o),
              s && (o.selector = u3(s)),
              (Nn = o),
              (h = r.apply(o, arguments)),
              Xn(h) && o._r.push(h),
              (Nn = c),
              (o.selector = u),
              (o.isReverted = !1),
              h
            );
          };
        return (
          (o.last = a),
          i === Xn
            ? a(o, function (l) {
                return o.add(null, l);
              })
            : i
              ? (o[i] = a)
              : a
        );
      }),
      (e.ignore = function (i) {
        var r = Nn;
        ((Nn = null), i(this), (Nn = r));
      }),
      (e.getTweens = function () {
        var i = [];
        return (
          this.data.forEach(function (r) {
            return r instanceof n
              ? i.push.apply(i, r.getTweens())
              : r instanceof ni &&
                  !(r.parent && r.parent.data === "nested") &&
                  i.push(r);
          }),
          i
        );
      }),
      (e.clear = function () {
        this._r.length = this.data.length = 0;
      }),
      (e.kill = function (i, r) {
        var s = this;
        if (
          (i
            ? (function () {
                for (var a = s.getTweens(), l = s.data.length, c; l--; )
                  ((c = s.data[l]),
                    c.data === "isFlip" &&
                      (c.revert(),
                      c.getChildren(!0, !0, !1).forEach(function (u) {
                        return a.splice(a.indexOf(u), 1);
                      })));
                for (
                  a
                    .map(function (u) {
                      return {
                        g:
                          u._dur ||
                          u._delay ||
                          (u._sat && !u._sat.vars.immediateRender)
                            ? u.globalTime(0)
                            : -1 / 0,
                        t: u,
                      };
                    })
                    .sort(function (u, h) {
                      return h.g - u.g || -1 / 0;
                    })
                    .forEach(function (u) {
                      return u.t.revert(i);
                    }),
                    l = s.data.length;
                  l--;
                )
                  ((c = s.data[l]),
                    c instanceof hr
                      ? c.data !== "nested" &&
                        (c.scrollTrigger && c.scrollTrigger.revert(), c.kill())
                      : !(c instanceof ni) && c.revert && c.revert(i));
                (s._r.forEach(function (u) {
                  return u(i, s);
                }),
                  (s.isReverted = !0));
              })()
            : this.data.forEach(function (a) {
                return a.kill && a.kill();
              }),
          this.clear(),
          r)
        )
          for (var o = ru.length; o--; )
            ru[o].id === this.id && ru.splice(o, 1);
      }),
      (e.revert = function (i) {
        this.kill(i || {});
      }),
      n
    );
  })(),
  Vle = (function () {
    function n(t) {
      ((this.contexts = []), (this.scope = t), Nn && Nn.data.push(this));
    }
    var e = n.prototype;
    return (
      (e.add = function (i, r, s) {
        Uo(i) || (i = { matches: i });
        var o = new IB(0, s || this.scope),
          a = (o.conditions = {}),
          l,
          c,
          u;
        (Nn && !o.selector && (o.selector = Nn.selector),
          this.contexts.push(o),
          (r = o.add("onMatch", r)),
          (o.queries = i));
        for (c in i)
          c === "all"
            ? (u = 1)
            : ((l = po.matchMedia(i[c])),
              l &&
                (ru.indexOf(o) < 0 && ru.push(o),
                (a[c] = l.matches) && (u = 1),
                l.addListener
                  ? l.addListener(f3)
                  : l.addEventListener("change", f3)));
        return (
          u &&
            r(o, function (h) {
              return o.add(null, h);
            }),
          this
        );
      }),
      (e.revert = function (i) {
        this.kill(i || {});
      }),
      (e.kill = function (i) {
        this.contexts.forEach(function (r) {
          return r.kill(i, !0);
        });
      }),
      n
    );
  })(),
  tC = {
    registerPlugin: function () {
      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
        t[i] = arguments[i];
      t.forEach(function (r) {
        return iB(r);
      });
    },
    timeline: function (e) {
      return new hr(e);
    },
    getTweensOf: function (e, t) {
      return kn.getTweensOf(e, t);
    },
    getProperty: function (e, t, i, r) {
      Ni(e) && (e = ys(e)[0]);
      var s = tu(e || {}).get,
        o = i ? ZR : VR;
      return (
        i === "native" && (i = ""),
        e &&
          (t
            ? o(((Wr[t] && Wr[t].get) || s)(e, t, i, r))
            : function (a, l, c) {
                return o(((Wr[a] && Wr[a].get) || s)(e, a, l, c));
              })
      );
    },
    quickSetter: function (e, t, i) {
      if (((e = ys(e)), e.length > 1)) {
        var r = e.map(function (u) {
            return Nr.quickSetter(u, t, i);
          }),
          s = r.length;
        return function (u) {
          for (var h = s; h--; ) r[h](u);
        };
      }
      e = e[0] || {};
      var o = Wr[t],
        a = tu(e),
        l = (a.harness && (a.harness.aliases || {})[t]) || t,
        c = o
          ? function (u) {
              var h = new o();
              ((bh._pt = 0),
                h.init(e, i ? u + i : u, bh, 0, [e]),
                h.render(1, h),
                bh._pt && u5(1, bh));
            }
          : a.set(e, l);
      return o
        ? c
        : function (u) {
            return c(e, l, i ? u + i : u, a, 1);
          };
    },
    quickTo: function (e, t, i) {
      var r,
        s = Nr.to(
          e,
          es(
            ((r = {}), (r[t] = "+=0.1"), (r.paused = !0), (r.stagger = 0), r),
            i || {},
          ),
        ),
        o = function (l, c, u) {
          return s.resetTo(t, l, c, u);
        };
      return ((o.tween = s), o);
    },
    isTweening: function (e) {
      return kn.getTweensOf(e, !0).length > 0;
    },
    defaults: function (e) {
      return (e && e.ease && (e.ease = iu(e.ease, fd.ease)), sS(fd, e || {}));
    },
    config: function (e) {
      return sS(Jr, e || {});
    },
    registerEffect: function (e) {
      var t = e.name,
        i = e.effect,
        r = e.plugins,
        s = e.defaults,
        o = e.extendTimeline;
      ((r || "").split(",").forEach(function (a) {
        return (
          a && !Wr[a] && !qr[a] && Fg(t + " effect requires " + a + " plugin.")
        );
      }),
        (tA[t] = function (a, l, c) {
          return i(ys(a), es(l || {}, s), c);
        }),
        o &&
          (hr.prototype[t] = function (a, l, c) {
            return this.add(tA[t](a, Uo(l) ? l : (c = l) && {}, this), c);
          }));
    },
    registerEase: function (e, t) {
      Xt[e] = iu(t);
    },
    parseEase: function (e, t) {
      return arguments.length ? iu(e, t) : Xt;
    },
    getById: function (e) {
      return kn.getById(e);
    },
    exportRoot: function (e, t) {
      e === void 0 && (e = {});
      var i = new hr(e),
        r,
        s;
      for (
        i.smoothChildTiming = Mr(e.smoothChildTiming),
          kn.remove(i),
          i._dp = 0,
          i._time = i._tTime = kn._time,
          r = kn._first;
        r;
      )
        ((s = r._next),
          (t ||
            !(
              !r._dur &&
              r instanceof ni &&
              r.vars.onComplete === r._targets[0]
            )) &&
            yo(i, r, r._start - r._delay),
          (r = s));
      return (yo(kn, i, 0), i);
    },
    context: function (e, t) {
      return e ? new IB(e, t) : Nn;
    },
    matchMedia: function (e) {
      return new Vle(e);
    },
    matchMediaRefresh: function () {
      return (
        ru.forEach(function (e) {
          var t = e.conditions,
            i,
            r;
          for (r in t) t[r] && ((t[r] = !1), (i = 1));
          i && e.revert();
        }) || f3()
      );
    },
    addEventListener: function (e, t) {
      var i = K0[e] || (K0[e] = []);
      ~i.indexOf(t) || i.push(t);
    },
    removeEventListener: function (e, t) {
      var i = K0[e],
        r = i && i.indexOf(t);
      r >= 0 && i.splice(r, 1);
    },
    utils: {
      wrap: _le,
      wrapYoyo: ble,
      distribute: JR,
      random: qR,
      snap: QR,
      normalize: yle,
      getUnit: ji,
      clamp: mle,
      splitColor: rB,
      toArray: ys,
      selector: u3,
      mapRange: tB,
      pipe: Ile,
      unitize: Ale,
      interpolate: vle,
      shuffle: $R,
    },
    install: kR,
    effects: tA,
    ticker: Vr,
    updateRoot: hr.updateRoot,
    plugins: Wr,
    globalTimeline: kn,
    core: {
      PropTween: Rr,
      globals: OR,
      Tween: ni,
      Timeline: hr,
      Animation: Hg,
      getCache: tu,
      _removeLinkedListItem: cI,
      reverting: function () {
        return ki;
      },
      context: function (e) {
        return (e && Nn && (Nn.data.push(e), (e._ctx = Nn)), Nn);
      },
      suppressOverwrites: function (e) {
        return (Qv = e);
      },
    },
  };
Lr("to,from,fromTo,delayedCall,set,killTweensOf", function (n) {
  return (tC[n] = ni[n]);
});
Vr.add(hr.updateRoot);
bh = tC.to({}, { duration: 0 });
var Zle = function (e, t) {
    for (var i = e._pt; i && i.p !== t && i.op !== t && i.fp !== t; )
      i = i._next;
    return i;
  },
  zle = function (e, t) {
    var i = e._targets,
      r,
      s,
      o;
    for (r in t)
      for (s = i.length; s--; )
        ((o = e._ptLookup[s][r]),
          o &&
            (o = o.d) &&
            (o._pt && (o = Zle(o, r)),
            o && o.modifier && o.modifier(t[r], e, i[s], r)));
  },
  oA = function (e, t) {
    return {
      name: e,
      rawVars: 1,
      init: function (r, s, o) {
        o._onInit = function (a) {
          var l, c;
          if (
            (Ni(s) &&
              ((l = {}),
              Lr(s, function (u) {
                return (l[u] = 1);
              }),
              (s = l)),
            t)
          ) {
            l = {};
            for (c in s) l[c] = t(s[c]);
            s = l;
          }
          zle(a, s);
        };
      },
    };
  },
  Nr =
    tC.registerPlugin(
      {
        name: "attr",
        init: function (e, t, i, r, s) {
          var o, a, l;
          this.tween = i;
          for (o in t)
            ((l = e.getAttribute(o) || ""),
              (a = this.add(
                e,
                "setAttribute",
                (l || 0) + "",
                t[o],
                r,
                s,
                0,
                0,
                o,
              )),
              (a.op = o),
              (a.b = l),
              this._props.push(o));
        },
        render: function (e, t) {
          for (var i = t._pt; i; )
            (ki ? i.set(i.t, i.p, i.b, i) : i.r(e, i.d), (i = i._next));
        },
      },
      {
        name: "endArray",
        init: function (e, t) {
          for (var i = t.length; i--; )
            this.add(e, i, e[i] || 0, t[i], 0, 0, 0, 0, 0, 1);
        },
      },
      oA("roundProps", h3),
      oA("modifiers"),
      oA("snap", QR),
    ) || tC;
ni.version = hr.version = Nr.version = "3.12.7";
FR = 1;
e5() && Cd();
Xt.Power0;
Xt.Power1;
Xt.Power2;
Xt.Power3;
Xt.Power4;
Xt.Linear;
Xt.Quad;
Xt.Cubic;
Xt.Quart;
Xt.Quint;
Xt.Strong;
Xt.Elastic;
Xt.Back;
Xt.SteppedEase;
Xt.Bounce;
Xt.Sine;
Xt.Expo;
Xt.Circ;
/*!
 * CSSPlugin 3.12.7
 * https://gsap.com
 *
 * Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var hS,
  Al,
  Fh,
  h5,
  Yc,
  dS,
  d5,
  Yle = function () {
    return typeof window < "u";
  },
  Da = {},
  Ec = 180 / Math.PI,
  kh = Math.PI / 180,
  Ju = Math.atan2,
  fS = 1e8,
  f5 = /([A-Z])/g,
  Xle = /(left|right|width|margin|padding|x)/i,
  Kle = /[\s,\(]\S/,
  wo = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity",
  },
  g3 = function (e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
  },
  jle = function (e, t) {
    return t.set(
      t.t,
      t.p,
      e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u,
      t,
    );
  },
  $le = function (e, t) {
    return t.set(
      t.t,
      t.p,
      e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b,
      t,
    );
  },
  Jle = function (e, t) {
    var i = t.s + t.c * e;
    t.set(t.t, t.p, ~~(i + (i < 0 ? -0.5 : 0.5)) + t.u, t);
  },
  AB = function (e, t) {
    return t.set(t.t, t.p, e ? t.e : t.b, t);
  },
  yB = function (e, t) {
    return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t);
  },
  Qle = function (e, t, i) {
    return (e.style[t] = i);
  },
  qle = function (e, t, i) {
    return e.style.setProperty(t, i);
  },
  ece = function (e, t, i) {
    return (e._gsap[t] = i);
  },
  tce = function (e, t, i) {
    return (e._gsap.scaleX = e._gsap.scaleY = i);
  },
  nce = function (e, t, i, r, s) {
    var o = e._gsap;
    ((o.scaleX = o.scaleY = i), o.renderTransform(s, o));
  },
  ice = function (e, t, i, r, s) {
    var o = e._gsap;
    ((o[t] = i), o.renderTransform(s, o));
  },
  On = "transform",
  Br = On + "Origin",
  rce = function n(e, t) {
    var i = this,
      r = this.target,
      s = r.style,
      o = r._gsap;
    if (e in Da && s) {
      if (((this.tfm = this.tfm || {}), e !== "transform"))
        ((e = wo[e] || e),
          ~e.indexOf(",")
            ? e.split(",").forEach(function (a) {
                return (i.tfm[a] = da(r, a));
              })
            : (this.tfm[e] = o.x ? o[e] : da(r, e)),
          e === Br && (this.tfm.zOrigin = o.zOrigin));
      else
        return wo.transform.split(",").forEach(function (a) {
          return n.call(i, a, t);
        });
      if (this.props.indexOf(On) >= 0) return;
      (o.svg &&
        ((this.svgo = r.getAttribute("data-svg-origin")),
        this.props.push(Br, t, "")),
        (e = On));
    }
    (s || t) && this.props.push(e, t, s[e]);
  },
  _B = function (e) {
    e.translate &&
      (e.removeProperty("translate"),
      e.removeProperty("scale"),
      e.removeProperty("rotate"));
  },
  sce = function () {
    var e = this.props,
      t = this.target,
      i = t.style,
      r = t._gsap,
      s,
      o;
    for (s = 0; s < e.length; s += 3)
      e[s + 1]
        ? e[s + 1] === 2
          ? t[e[s]](e[s + 2])
          : (t[e[s]] = e[s + 2])
        : e[s + 2]
          ? (i[e[s]] = e[s + 2])
          : i.removeProperty(
              e[s].substr(0, 2) === "--"
                ? e[s]
                : e[s].replace(f5, "-$1").toLowerCase(),
            );
    if (this.tfm) {
      for (o in this.tfm) r[o] = this.tfm[o];
      (r.svg &&
        (r.renderTransform(),
        t.setAttribute("data-svg-origin", this.svgo || "")),
        (s = d5()),
        (!s || !s.isStart) &&
          !i[On] &&
          (_B(i),
          r.zOrigin &&
            i[Br] &&
            ((i[Br] += " " + r.zOrigin + "px"),
            (r.zOrigin = 0),
            r.renderTransform()),
          (r.uncache = 1)));
    }
  },
  bB = function (e, t) {
    var i = { target: e, props: [], revert: sce, save: rce };
    return (
      e._gsap || Nr.core.getCache(e),
      t &&
        e.style &&
        e.nodeType &&
        t.split(",").forEach(function (r) {
          return i.save(r);
        }),
      i
    );
  },
  vB,
  p3 = function (e, t) {
    var i = Al.createElementNS
      ? Al.createElementNS(
          (t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"),
          e,
        )
      : Al.createElement(e);
    return i && i.style ? i : Al.createElement(e);
  },
  Lo = function n(e, t, i) {
    var r = getComputedStyle(e);
    return (
      r[t] ||
      r.getPropertyValue(t.replace(f5, "-$1").toLowerCase()) ||
      r.getPropertyValue(t) ||
      (!i && n(e, Id(t) || t, 1)) ||
      ""
    );
  },
  gS = "O,Moz,ms,Ms,Webkit".split(","),
  Id = function (e, t, i) {
    var r = t || Yc,
      s = r.style,
      o = 5;
    if (e in s && !i) return e;
    for (
      e = e.charAt(0).toUpperCase() + e.substr(1);
      o-- && !(gS[o] + e in s);
    );
    return o < 0 ? null : (o === 3 ? "ms" : o >= 0 ? gS[o] : "") + e;
  },
  m3 = function () {
    Yle() &&
      window.document &&
      ((hS = window),
      (Al = hS.document),
      (Fh = Al.documentElement),
      (Yc = p3("div") || { style: {} }),
      p3("div"),
      (On = Id(On)),
      (Br = On + "Origin"),
      (Yc.style.cssText =
        "border-width:0;line-height:0;position:absolute;padding:0"),
      (vB = !!Id("perspective")),
      (d5 = Nr.core.reverting),
      (h5 = 1));
  },
  pS = function (e) {
    var t = e.ownerSVGElement,
      i = p3(
        "svg",
        (t && t.getAttribute("xmlns")) || "http://www.w3.org/2000/svg",
      ),
      r = e.cloneNode(!0),
      s;
    ((r.style.display = "block"), i.appendChild(r), Fh.appendChild(i));
    try {
      s = r.getBBox();
    } catch {}
    return (i.removeChild(r), Fh.removeChild(i), s);
  },
  mS = function (e, t) {
    for (var i = t.length; i--; )
      if (e.hasAttribute(t[i])) return e.getAttribute(t[i]);
  },
  xB = function (e) {
    var t, i;
    try {
      t = e.getBBox();
    } catch {
      ((t = pS(e)), (i = 1));
    }
    return (
      (t && (t.width || t.height)) || i || (t = pS(e)),
      t && !t.width && !t.x && !t.y
        ? {
            x: +mS(e, ["x", "cx", "x1"]) || 0,
            y: +mS(e, ["y", "cy", "y1"]) || 0,
            width: 0,
            height: 0,
          }
        : t
    );
  },
  wB = function (e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && xB(e));
  },
  pu = function (e, t) {
    if (t) {
      var i = e.style,
        r;
      (t in Da && t !== Br && (t = On),
        i.removeProperty
          ? ((r = t.substr(0, 2)),
            (r === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t),
            i.removeProperty(
              r === "--" ? t : t.replace(f5, "-$1").toLowerCase(),
            ))
          : i.removeAttribute(t));
    }
  },
  yl = function (e, t, i, r, s, o) {
    var a = new Rr(e._pt, t, i, 0, 1, o ? yB : AB);
    return ((e._pt = a), (a.b = r), (a.e = s), e._props.push(i), a);
  },
  CS = { deg: 1, rad: 1, turn: 1 },
  oce = { grid: 1, flex: 1 },
  Fl = function n(e, t, i, r) {
    var s = parseFloat(i) || 0,
      o = (i + "").trim().substr((s + "").length) || "px",
      a = Yc.style,
      l = Xle.test(t),
      c = e.tagName.toLowerCase() === "svg",
      u = (c ? "client" : "offset") + (l ? "Width" : "Height"),
      h = 100,
      d = r === "px",
      f = r === "%",
      g,
      p,
      m,
      C;
    if (r === o || !s || CS[r] || CS[o]) return s;
    if (
      (o !== "px" && !d && (s = n(e, t, i, "px")),
      (C = e.getCTM && wB(e)),
      (f || o === "%") && (Da[t] || ~t.indexOf("adius")))
    )
      return (
        (g = C ? e.getBBox()[l ? "width" : "height"] : e[u]),
        Jn(f ? (s / g) * h : (s / 100) * g)
      );
    if (
      ((a[l ? "width" : "height"] = h + (d ? o : r)),
      (p =
        (r !== "rem" && ~t.indexOf("adius")) ||
        (r === "em" && e.appendChild && !c)
          ? e
          : e.parentNode),
      C && (p = (e.ownerSVGElement || {}).parentNode),
      (!p || p === Al || !p.appendChild) && (p = Al.body),
      (m = p._gsap),
      m && f && m.width && l && m.time === Vr.time && !m.uncache)
    )
      return Jn((s / m.width) * h);
    if (f && (t === "height" || t === "width")) {
      var A = e.style[t];
      ((e.style[t] = h + r), (g = e[u]), A ? (e.style[t] = A) : pu(e, t));
    } else
      ((f || o === "%") &&
        !oce[Lo(p, "display")] &&
        (a.position = Lo(e, "position")),
        p === e && (a.position = "static"),
        p.appendChild(Yc),
        (g = Yc[u]),
        p.removeChild(Yc),
        (a.position = "absolute"));
    return (
      l && f && ((m = tu(p)), (m.time = Vr.time), (m.width = p[u])),
      Jn(d ? (g * s) / h : g && s ? (h / g) * s : 0)
    );
  },
  da = function (e, t, i, r) {
    var s;
    return (
      h5 || m3(),
      t in wo &&
        t !== "transform" &&
        ((t = wo[t]), ~t.indexOf(",") && (t = t.split(",")[0])),
      Da[t] && t !== "transform"
        ? ((s = Vg(e, r)),
          (s =
            t !== "transformOrigin"
              ? s[t]
              : s.svg
                ? s.origin
                : iC(Lo(e, Br)) + " " + s.zOrigin + "px"))
        : ((s = e.style[t]),
          (!s || s === "auto" || r || ~(s + "").indexOf("calc(")) &&
            (s =
              (nC[t] && nC[t](e, t, i)) ||
              Lo(e, t) ||
              HR(e, t) ||
              (t === "opacity" ? 1 : 0))),
      i && !~(s + "").trim().indexOf(" ") ? Fl(e, t, s, i) + i : s
    );
  },
  ace = function (e, t, i, r) {
    if (!i || i === "none") {
      var s = Id(t, e, 1),
        o = s && Lo(e, s, 1);
      o && o !== i
        ? ((t = s), (i = o))
        : t === "borderColor" && (i = Lo(e, "borderTopColor"));
    }
    var a = new Rr(this._pt, e.style, t, 0, 1, mB),
      l = 0,
      c = 0,
      u,
      h,
      d,
      f,
      g,
      p,
      m,
      C,
      A,
      I,
      y,
      x;
    if (
      ((a.b = i),
      (a.e = r),
      (i += ""),
      (r += ""),
      r === "auto" &&
        ((p = e.style[t]),
        (e.style[t] = r),
        (r = Lo(e, t) || r),
        p ? (e.style[t] = p) : pu(e, t)),
      (u = [i, r]),
      oB(u),
      (i = u[0]),
      (r = u[1]),
      (d = i.match(_h) || []),
      (x = r.match(_h) || []),
      x.length)
    ) {
      for (; (h = _h.exec(r)); )
        ((m = h[0]),
          (A = r.substring(l, h.index)),
          g
            ? (g = (g + 1) % 5)
            : (A.substr(-5) === "rgba(" || A.substr(-5) === "hsla(") && (g = 1),
          m !== (p = d[c++] || "") &&
            ((f = parseFloat(p) || 0),
            (y = p.substr((f + "").length)),
            m.charAt(1) === "=" && (m = Gh(f, m) + y),
            (C = parseFloat(m)),
            (I = m.substr((C + "").length)),
            (l = _h.lastIndex - I.length),
            I ||
              ((I = I || Jr.units[t] || y),
              l === r.length && ((r += I), (a.e += I))),
            y !== I && (f = Fl(e, t, p, I) || 0),
            (a._pt = {
              _next: a._pt,
              p: A || c === 1 ? A : ",",
              s: f,
              c: C - f,
              m: (g && g < 4) || t === "zIndex" ? Math.round : 0,
            })));
      a.c = l < r.length ? r.substring(l, r.length) : "";
    } else a.r = t === "display" && r === "none" ? yB : AB;
    return (DR.test(r) && (a.e = 0), (this._pt = a), a);
  },
  IS = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" },
  lce = function (e) {
    var t = e.split(" "),
      i = t[0],
      r = t[1] || "50%";
    return (
      (i === "top" || i === "bottom" || r === "left" || r === "right") &&
        ((e = i), (i = r), (r = e)),
      (t[0] = IS[i] || i),
      (t[1] = IS[r] || r),
      t.join(" ")
    );
  },
  cce = function (e, t) {
    if (t.tween && t.tween._time === t.tween._dur) {
      var i = t.t,
        r = i.style,
        s = t.u,
        o = i._gsap,
        a,
        l,
        c;
      if (s === "all" || s === !0) ((r.cssText = ""), (l = 1));
      else
        for (s = s.split(","), c = s.length; --c > -1; )
          ((a = s[c]),
            Da[a] && ((l = 1), (a = a === "transformOrigin" ? Br : On)),
            pu(i, a));
      l &&
        (pu(i, On),
        o &&
          (o.svg && i.removeAttribute("transform"),
          (r.scale = r.rotate = r.translate = "none"),
          Vg(i, 1),
          (o.uncache = 1),
          _B(r)));
    }
  },
  nC = {
    clearProps: function (e, t, i, r, s) {
      if (s.data !== "isFromStart") {
        var o = (e._pt = new Rr(e._pt, t, i, 0, 0, cce));
        return ((o.u = r), (o.pr = -10), (o.tween = s), e._props.push(i), 1);
      }
    },
  },
  Wg = [1, 0, 0, 1, 0, 0],
  SB = {},
  TB = function (e) {
    return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e;
  },
  AS = function (e) {
    var t = Lo(e, On);
    return TB(t) ? Wg : t.substr(7).match(NR).map(Jn);
  },
  g5 = function (e, t) {
    var i = e._gsap || tu(e),
      r = e.style,
      s = AS(e),
      o,
      a,
      l,
      c;
    return i.svg && e.getAttribute("transform")
      ? ((l = e.transform.baseVal.consolidate().matrix),
        (s = [l.a, l.b, l.c, l.d, l.e, l.f]),
        s.join(",") === "1,0,0,1,0,0" ? Wg : s)
      : (s === Wg &&
          !e.offsetParent &&
          e !== Fh &&
          !i.svg &&
          ((l = r.display),
          (r.display = "block"),
          (o = e.parentNode),
          (!o || (!e.offsetParent && !e.getBoundingClientRect().width)) &&
            ((c = 1), (a = e.nextElementSibling), Fh.appendChild(e)),
          (s = AS(e)),
          l ? (r.display = l) : pu(e, "display"),
          c &&
            (a
              ? o.insertBefore(e, a)
              : o
                ? o.appendChild(e)
                : Fh.removeChild(e))),
        t && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s);
  },
  C3 = function (e, t, i, r, s, o) {
    var a = e._gsap,
      l = s || g5(e, !0),
      c = a.xOrigin || 0,
      u = a.yOrigin || 0,
      h = a.xOffset || 0,
      d = a.yOffset || 0,
      f = l[0],
      g = l[1],
      p = l[2],
      m = l[3],
      C = l[4],
      A = l[5],
      I = t.split(" "),
      y = parseFloat(I[0]) || 0,
      x = parseFloat(I[1]) || 0,
      T,
      S,
      E,
      _;
    (i
      ? l !== Wg &&
        (S = f * m - g * p) &&
        ((E = y * (m / S) + x * (-p / S) + (p * A - m * C) / S),
        (_ = y * (-g / S) + x * (f / S) - (f * A - g * C) / S),
        (y = E),
        (x = _))
      : ((T = xB(e)),
        (y = T.x + (~I[0].indexOf("%") ? (y / 100) * T.width : y)),
        (x = T.y + (~(I[1] || I[0]).indexOf("%") ? (x / 100) * T.height : x))),
      r || (r !== !1 && a.smooth)
        ? ((C = y - c),
          (A = x - u),
          (a.xOffset = h + (C * f + A * p) - C),
          (a.yOffset = d + (C * g + A * m) - A))
        : (a.xOffset = a.yOffset = 0),
      (a.xOrigin = y),
      (a.yOrigin = x),
      (a.smooth = !!r),
      (a.origin = t),
      (a.originIsAbsolute = !!i),
      (e.style[Br] = "0px 0px"),
      o &&
        (yl(o, a, "xOrigin", c, y),
        yl(o, a, "yOrigin", u, x),
        yl(o, a, "xOffset", h, a.xOffset),
        yl(o, a, "yOffset", d, a.yOffset)),
      e.setAttribute("data-svg-origin", y + " " + x));
  },
  Vg = function (e, t) {
    var i = e._gsap || new uB(e);
    if ("x" in i && !t && !i.uncache) return i;
    var r = e.style,
      s = i.scaleX < 0,
      o = "px",
      a = "deg",
      l = getComputedStyle(e),
      c = Lo(e, Br) || "0",
      u,
      h,
      d,
      f,
      g,
      p,
      m,
      C,
      A,
      I,
      y,
      x,
      T,
      S,
      E,
      _,
      b,
      R,
      M,
      L,
      P,
      U,
      O,
      V,
      W,
      re,
      Z,
      te,
      ge,
      be,
      J,
      se;
    return (
      (u = h = d = p = m = C = A = I = y = 0),
      (f = g = 1),
      (i.svg = !!(e.getCTM && wB(e))),
      l.translate &&
        ((l.translate !== "none" ||
          l.scale !== "none" ||
          l.rotate !== "none") &&
          (r[On] =
            (l.translate !== "none"
              ? "translate3d(" +
                (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") +
                ") "
              : "") +
            (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") +
            (l.scale !== "none"
              ? "scale(" + l.scale.split(" ").join(",") + ") "
              : "") +
            (l[On] !== "none" ? l[On] : "")),
        (r.scale = r.rotate = r.translate = "none")),
      (S = g5(e, i.svg)),
      i.svg &&
        (i.uncache
          ? ((W = e.getBBox()),
            (c = i.xOrigin - W.x + "px " + (i.yOrigin - W.y) + "px"),
            (V = ""))
          : (V = !t && e.getAttribute("data-svg-origin")),
        C3(e, V || c, !!V || i.originIsAbsolute, i.smooth !== !1, S)),
      (x = i.xOrigin || 0),
      (T = i.yOrigin || 0),
      S !== Wg &&
        ((R = S[0]),
        (M = S[1]),
        (L = S[2]),
        (P = S[3]),
        (u = U = S[4]),
        (h = O = S[5]),
        S.length === 6
          ? ((f = Math.sqrt(R * R + M * M)),
            (g = Math.sqrt(P * P + L * L)),
            (p = R || M ? Ju(M, R) * Ec : 0),
            (A = L || P ? Ju(L, P) * Ec + p : 0),
            A && (g *= Math.abs(Math.cos(A * kh))),
            i.svg && ((u -= x - (x * R + T * L)), (h -= T - (x * M + T * P))))
          : ((se = S[6]),
            (be = S[7]),
            (Z = S[8]),
            (te = S[9]),
            (ge = S[10]),
            (J = S[11]),
            (u = S[12]),
            (h = S[13]),
            (d = S[14]),
            (E = Ju(se, ge)),
            (m = E * Ec),
            E &&
              ((_ = Math.cos(-E)),
              (b = Math.sin(-E)),
              (V = U * _ + Z * b),
              (W = O * _ + te * b),
              (re = se * _ + ge * b),
              (Z = U * -b + Z * _),
              (te = O * -b + te * _),
              (ge = se * -b + ge * _),
              (J = be * -b + J * _),
              (U = V),
              (O = W),
              (se = re)),
            (E = Ju(-L, ge)),
            (C = E * Ec),
            E &&
              ((_ = Math.cos(-E)),
              (b = Math.sin(-E)),
              (V = R * _ - Z * b),
              (W = M * _ - te * b),
              (re = L * _ - ge * b),
              (J = P * b + J * _),
              (R = V),
              (M = W),
              (L = re)),
            (E = Ju(M, R)),
            (p = E * Ec),
            E &&
              ((_ = Math.cos(E)),
              (b = Math.sin(E)),
              (V = R * _ + M * b),
              (W = U * _ + O * b),
              (M = M * _ - R * b),
              (O = O * _ - U * b),
              (R = V),
              (U = W)),
            m &&
              Math.abs(m) + Math.abs(p) > 359.9 &&
              ((m = p = 0), (C = 180 - C)),
            (f = Jn(Math.sqrt(R * R + M * M + L * L))),
            (g = Jn(Math.sqrt(O * O + se * se))),
            (E = Ju(U, O)),
            (A = Math.abs(E) > 2e-4 ? E * Ec : 0),
            (y = J ? 1 / (J < 0 ? -J : J) : 0)),
        i.svg &&
          ((V = e.getAttribute("transform")),
          (i.forceCSS = e.setAttribute("transform", "") || !TB(Lo(e, On))),
          V && e.setAttribute("transform", V))),
      Math.abs(A) > 90 &&
        Math.abs(A) < 270 &&
        (s
          ? ((f *= -1), (A += p <= 0 ? 180 : -180), (p += p <= 0 ? 180 : -180))
          : ((g *= -1), (A += A <= 0 ? 180 : -180))),
      (t = t || i.uncache),
      (i.x =
        u -
        ((i.xPercent =
          u &&
          ((!t && i.xPercent) ||
            (Math.round(e.offsetWidth / 2) === Math.round(-u) ? -50 : 0)))
          ? (e.offsetWidth * i.xPercent) / 100
          : 0) +
        o),
      (i.y =
        h -
        ((i.yPercent =
          h &&
          ((!t && i.yPercent) ||
            (Math.round(e.offsetHeight / 2) === Math.round(-h) ? -50 : 0)))
          ? (e.offsetHeight * i.yPercent) / 100
          : 0) +
        o),
      (i.z = d + o),
      (i.scaleX = Jn(f)),
      (i.scaleY = Jn(g)),
      (i.rotation = Jn(p) + a),
      (i.rotationX = Jn(m) + a),
      (i.rotationY = Jn(C) + a),
      (i.skewX = A + a),
      (i.skewY = I + a),
      (i.transformPerspective = y + o),
      (i.zOrigin = parseFloat(c.split(" ")[2]) || (!t && i.zOrigin) || 0) &&
        (r[Br] = iC(c)),
      (i.xOffset = i.yOffset = 0),
      (i.force3D = Jr.force3D),
      (i.renderTransform = i.svg ? hce : vB ? EB : uce),
      (i.uncache = 0),
      i
    );
  },
  iC = function (e) {
    return (e = e.split(" "))[0] + " " + e[1];
  },
  aA = function (e, t, i) {
    var r = ji(t);
    return Jn(parseFloat(t) + parseFloat(Fl(e, "x", i + "px", r))) + r;
  },
  uce = function (e, t) {
    ((t.z = "0px"),
      (t.rotationY = t.rotationX = "0deg"),
      (t.force3D = 0),
      EB(e, t));
  },
  uc = "0deg",
  Af = "0px",
  hc = ") ",
  EB = function (e, t) {
    var i = t || this,
      r = i.xPercent,
      s = i.yPercent,
      o = i.x,
      a = i.y,
      l = i.z,
      c = i.rotation,
      u = i.rotationY,
      h = i.rotationX,
      d = i.skewX,
      f = i.skewY,
      g = i.scaleX,
      p = i.scaleY,
      m = i.transformPerspective,
      C = i.force3D,
      A = i.target,
      I = i.zOrigin,
      y = "",
      x = (C === "auto" && e && e !== 1) || C === !0;
    if (I && (h !== uc || u !== uc)) {
      var T = parseFloat(u) * kh,
        S = Math.sin(T),
        E = Math.cos(T),
        _;
      ((T = parseFloat(h) * kh),
        (_ = Math.cos(T)),
        (o = aA(A, o, S * _ * -I)),
        (a = aA(A, a, -Math.sin(T) * -I)),
        (l = aA(A, l, E * _ * -I + I)));
    }
    (m !== Af && (y += "perspective(" + m + hc),
      (r || s) && (y += "translate(" + r + "%, " + s + "%) "),
      (x || o !== Af || a !== Af || l !== Af) &&
        (y +=
          l !== Af || x
            ? "translate3d(" + o + ", " + a + ", " + l + ") "
            : "translate(" + o + ", " + a + hc),
      c !== uc && (y += "rotate(" + c + hc),
      u !== uc && (y += "rotateY(" + u + hc),
      h !== uc && (y += "rotateX(" + h + hc),
      (d !== uc || f !== uc) && (y += "skew(" + d + ", " + f + hc),
      (g !== 1 || p !== 1) && (y += "scale(" + g + ", " + p + hc),
      (A.style[On] = y || "translate(0, 0)"));
  },
  hce = function (e, t) {
    var i = t || this,
      r = i.xPercent,
      s = i.yPercent,
      o = i.x,
      a = i.y,
      l = i.rotation,
      c = i.skewX,
      u = i.skewY,
      h = i.scaleX,
      d = i.scaleY,
      f = i.target,
      g = i.xOrigin,
      p = i.yOrigin,
      m = i.xOffset,
      C = i.yOffset,
      A = i.forceCSS,
      I = parseFloat(o),
      y = parseFloat(a),
      x,
      T,
      S,
      E,
      _;
    ((l = parseFloat(l)),
      (c = parseFloat(c)),
      (u = parseFloat(u)),
      u && ((u = parseFloat(u)), (c += u), (l += u)),
      l || c
        ? ((l *= kh),
          (c *= kh),
          (x = Math.cos(l) * h),
          (T = Math.sin(l) * h),
          (S = Math.sin(l - c) * -d),
          (E = Math.cos(l - c) * d),
          c &&
            ((u *= kh),
            (_ = Math.tan(c - u)),
            (_ = Math.sqrt(1 + _ * _)),
            (S *= _),
            (E *= _),
            u &&
              ((_ = Math.tan(u)),
              (_ = Math.sqrt(1 + _ * _)),
              (x *= _),
              (T *= _))),
          (x = Jn(x)),
          (T = Jn(T)),
          (S = Jn(S)),
          (E = Jn(E)))
        : ((x = h), (E = d), (T = S = 0)),
      ((I && !~(o + "").indexOf("px")) || (y && !~(a + "").indexOf("px"))) &&
        ((I = Fl(f, "x", o, "px")), (y = Fl(f, "y", a, "px"))),
      (g || p || m || C) &&
        ((I = Jn(I + g - (g * x + p * S) + m)),
        (y = Jn(y + p - (g * T + p * E) + C))),
      (r || s) &&
        ((_ = f.getBBox()),
        (I = Jn(I + (r / 100) * _.width)),
        (y = Jn(y + (s / 100) * _.height))),
      (_ =
        "matrix(" + x + "," + T + "," + S + "," + E + "," + I + "," + y + ")"),
      f.setAttribute("transform", _),
      A && (f.style[On] = _));
  },
  dce = function (e, t, i, r, s) {
    var o = 360,
      a = Ni(s),
      l = parseFloat(s) * (a && ~s.indexOf("rad") ? Ec : 1),
      c = l - r,
      u = r + c + "deg",
      h,
      d;
    return (
      a &&
        ((h = s.split("_")[1]),
        h === "short" && ((c %= o), c !== c % (o / 2) && (c += c < 0 ? o : -o)),
        h === "cw" && c < 0
          ? (c = ((c + o * fS) % o) - ~~(c / o) * o)
          : h === "ccw" && c > 0 && (c = ((c - o * fS) % o) - ~~(c / o) * o)),
      (e._pt = d = new Rr(e._pt, t, i, r, c, jle)),
      (d.e = u),
      (d.u = "deg"),
      e._props.push(i),
      d
    );
  },
  yS = function (e, t) {
    for (var i in t) e[i] = t[i];
    return e;
  },
  fce = function (e, t, i) {
    var r = yS({}, i._gsap),
      s = "perspective,force3D,transformOrigin,svgOrigin",
      o = i.style,
      a,
      l,
      c,
      u,
      h,
      d,
      f,
      g;
    r.svg
      ? ((c = i.getAttribute("transform")),
        i.setAttribute("transform", ""),
        (o[On] = t),
        (a = Vg(i, 1)),
        pu(i, On),
        i.setAttribute("transform", c))
      : ((c = getComputedStyle(i)[On]),
        (o[On] = t),
        (a = Vg(i, 1)),
        (o[On] = c));
    for (l in Da)
      ((c = r[l]),
        (u = a[l]),
        c !== u &&
          s.indexOf(l) < 0 &&
          ((f = ji(c)),
          (g = ji(u)),
          (h = f !== g ? Fl(i, l, c, g) : parseFloat(c)),
          (d = parseFloat(u)),
          (e._pt = new Rr(e._pt, a, l, h, d - h, g3)),
          (e._pt.u = g || 0),
          e._props.push(l)));
    yS(a, r);
  };
Lr("padding,margin,Width,Radius", function (n, e) {
  var t = "Top",
    i = "Right",
    r = "Bottom",
    s = "Left",
    o = (e < 3 ? [t, i, r, s] : [t + s, t + i, r + i, r + s]).map(function (a) {
      return e < 2 ? n + a : "border" + a + n;
    });
  nC[e > 1 ? "border" + n : n] = function (a, l, c, u, h) {
    var d, f;
    if (arguments.length < 4)
      return (
        (d = o.map(function (g) {
          return da(a, g, c);
        })),
        (f = d.join(" ")),
        f.split(d[0]).length === 5 ? d[0] : f
      );
    ((d = (u + "").split(" ")),
      (f = {}),
      o.forEach(function (g, p) {
        return (f[g] = d[p] = d[p] || d[((p - 1) / 2) | 0]);
      }),
      a.init(l, f, h));
  };
});
var MB = {
  name: "css",
  register: m3,
  targetTest: function (e) {
    return e.style && e.nodeType;
  },
  init: function (e, t, i, r, s) {
    var o = this._props,
      a = e.style,
      l = i.vars.startAt,
      c,
      u,
      h,
      d,
      f,
      g,
      p,
      m,
      C,
      A,
      I,
      y,
      x,
      T,
      S,
      E;
    (h5 || m3(),
      (this.styles = this.styles || bB(e)),
      (E = this.styles.props),
      (this.tween = i));
    for (p in t)
      if (p !== "autoRound" && ((u = t[p]), !(Wr[p] && hB(p, t, i, r, e, s)))) {
        if (
          ((f = typeof u),
          (g = nC[p]),
          f === "function" && ((u = u.call(i, r, e, s)), (f = typeof u)),
          f === "string" && ~u.indexOf("random(") && (u = Og(u)),
          g)
        )
          g(this, e, p, u, i) && (S = 1);
        else if (p.substr(0, 2) === "--")
          ((c = (getComputedStyle(e).getPropertyValue(p) + "").trim()),
            (u += ""),
            (El.lastIndex = 0),
            El.test(c) || ((m = ji(c)), (C = ji(u))),
            C ? m !== C && (c = Fl(e, p, c, C) + C) : m && (u += m),
            this.add(a, "setProperty", c, u, r, s, 0, 0, p),
            o.push(p),
            E.push(p, 0, a[p]));
        else if (f !== "undefined") {
          if (
            (l && p in l
              ? ((c = typeof l[p] == "function" ? l[p].call(i, r, e, s) : l[p]),
                Ni(c) && ~c.indexOf("random(") && (c = Og(c)),
                ji(c + "") ||
                  c === "auto" ||
                  (c += Jr.units[p] || ji(da(e, p)) || ""),
                (c + "").charAt(1) === "=" && (c = da(e, p)))
              : (c = da(e, p)),
            (d = parseFloat(c)),
            (A = f === "string" && u.charAt(1) === "=" && u.substr(0, 2)),
            A && (u = u.substr(2)),
            (h = parseFloat(u)),
            p in wo &&
              (p === "autoAlpha" &&
                (d === 1 && da(e, "visibility") === "hidden" && h && (d = 0),
                E.push("visibility", 0, a.visibility),
                yl(
                  this,
                  a,
                  "visibility",
                  d ? "inherit" : "hidden",
                  h ? "inherit" : "hidden",
                  !h,
                )),
              p !== "scale" &&
                p !== "transform" &&
                ((p = wo[p]), ~p.indexOf(",") && (p = p.split(",")[0]))),
            (I = p in Da),
            I)
          ) {
            if (
              (this.styles.save(p),
              y ||
                ((x = e._gsap),
                (x.renderTransform && !t.parseTransform) ||
                  Vg(e, t.parseTransform),
                (T = t.smoothOrigin !== !1 && x.smooth),
                (y = this._pt =
                  new Rr(this._pt, a, On, 0, 1, x.renderTransform, x, 0, -1)),
                (y.dep = 1)),
              p === "scale")
            )
              ((this._pt = new Rr(
                this._pt,
                x,
                "scaleY",
                x.scaleY,
                (A ? Gh(x.scaleY, A + h) : h) - x.scaleY || 0,
                g3,
              )),
                (this._pt.u = 0),
                o.push("scaleY", p),
                (p += "X"));
            else if (p === "transformOrigin") {
              (E.push(Br, 0, a[Br]),
                (u = lce(u)),
                x.svg
                  ? C3(e, u, 0, T, 0, this)
                  : ((C = parseFloat(u.split(" ")[2]) || 0),
                    C !== x.zOrigin && yl(this, x, "zOrigin", x.zOrigin, C),
                    yl(this, a, p, iC(c), iC(u))));
              continue;
            } else if (p === "svgOrigin") {
              C3(e, u, 1, T, 0, this);
              continue;
            } else if (p in SB) {
              dce(this, x, p, d, A ? Gh(d, A + u) : u);
              continue;
            } else if (p === "smoothOrigin") {
              yl(this, x, "smooth", x.smooth, u);
              continue;
            } else if (p === "force3D") {
              x[p] = u;
              continue;
            } else if (p === "transform") {
              fce(this, u, e);
              continue;
            }
          } else p in a || (p = Id(p) || p);
          if (I || ((h || h === 0) && (d || d === 0) && !Kle.test(u) && p in a))
            ((m = (c + "").substr((d + "").length)),
              h || (h = 0),
              (C = ji(u) || (p in Jr.units ? Jr.units[p] : m)),
              m !== C && (d = Fl(e, p, c, C)),
              (this._pt = new Rr(
                this._pt,
                I ? x : a,
                p,
                d,
                (A ? Gh(d, A + h) : h) - d,
                !I && (C === "px" || p === "zIndex") && t.autoRound !== !1
                  ? Jle
                  : g3,
              )),
              (this._pt.u = C || 0),
              m !== C && C !== "%" && ((this._pt.b = c), (this._pt.r = $le)));
          else if (p in a) ace.call(this, e, p, c, A ? A + u : u);
          else if (p in e) this.add(e, p, c || e[p], A ? A + u : u, r, s);
          else if (p !== "parseTransform") {
            n5(p, u);
            continue;
          }
          (I ||
            (p in a
              ? E.push(p, 0, a[p])
              : typeof e[p] == "function"
                ? E.push(p, 2, e[p]())
                : E.push(p, 1, c || e[p])),
            o.push(p));
        }
      }
    S && CB(this);
  },
  render: function (e, t) {
    if (t.tween._time || !d5())
      for (var i = t._pt; i; ) (i.r(e, i.d), (i = i._next));
    else t.styles.revert();
  },
  get: da,
  aliases: wo,
  getSetter: function (e, t, i) {
    var r = wo[t];
    return (
      r && r.indexOf(",") < 0 && (t = r),
      t in Da && t !== Br && (e._gsap.x || da(e, "x"))
        ? i && dS === i
          ? t === "scale"
            ? tce
            : ece
          : (dS = i || {}) && (t === "scale" ? nce : ice)
        : e.style && !qv(e.style[t])
          ? Qle
          : ~t.indexOf("-")
            ? qle
            : c5(e, t)
    );
  },
  core: { _removeProperty: pu, _getMatrix: g5 },
};
Nr.utils.checkPrefix = Id;
Nr.core.getStyleSaver = bB;
(function (n, e, t, i) {
  var r = Lr(n + "," + e + "," + t, function (s) {
    Da[s] = 1;
  });
  (Lr(e, function (s) {
    ((Jr.units[s] = "deg"), (SB[s] = 1));
  }),
    (wo[r[13]] = n + "," + e),
    Lr(i, function (s) {
      var o = s.split(":");
      wo[o[1]] = r[o[0]];
    }));
})(
  "x,y,z,scale,scaleX,scaleY,xPercent,yPercent",
  "rotation,rotationX,rotationY,skewX,skewY",
  "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
  "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY",
);
Lr(
  "x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
  function (n) {
    Jr.units[n] = "px";
  },
);
Nr.registerPlugin(MB);
var lg = Nr.registerPlugin(MB) || Nr;
lg.core.Tween;
const Gn = { width: 0, height: 0, pixelRatio: 0 };
let us = null;
const hs = {},
  dc = new Hv();
let ks = new Ri(75, Gn.width / Gn.height, 0.1, 1e3),
  na,
  br = { x: void 0, y: void 0 },
  _S = 0,
  bS = 0;
const gce = new bR(),
  vr = new Is(),
  lA = new Is(),
  pce = new Is();
let yf = [],
  cA = [];
const E1 = [],
  M1 = [],
  mce = (n) => {
    let e,
      t = null;
    function i() {
      return n.coords
        ? cA.filter(
            ({ lat: f, lon: g }) =>
              f >= n.coords.minLat &&
              f <= n.coords.maxLat &&
              g >= n.coords.minLon &&
              g <= n.coords.maxLon,
          )
        : [];
    }
    function r(f) {
      if (!n.coords) return null;
      const g = (n.coords.minLat + n.coords.maxLat) / 2,
        p = (n.coords.minLon + n.coords.maxLon) / 2;
      return f
        .filter(
          ({ lat: C, lon: A }) =>
            C >= n.coords.minLat &&
            C <= n.coords.maxLat &&
            A >= n.coords.minLon &&
            A <= n.coords.maxLon,
        )
        .reduce((C, A) => {
          const I = Math.hypot(A.lat - g, A.lon - p);
          return !C || I < C.distance ? { ...A, distance: I } : C;
        }, null);
    }
    function s() {
      const f = i();
      if (f.length === 0) return;
      const g = r(f),
        p = l(Array.of(g), 10.1);
      o(p);
    }
    function o(f) {
      if (!f || f.length !== 3) return;
      const g = new X(...f).normalize();
      let p = -Math.asin(g.y),
        m = -Math.atan2(-g.x, g.z),
        C = Math.PI;
      const A = (I, y) => {
        for (; I - y > Math.PI; ) I -= 2 * Math.PI;
        for (; I - y < -Math.PI; ) I += 2 * Math.PI;
        return I;
      };
      ((p = A(p, vr.rotation.x)),
        (m = A(m, vr.rotation.y)),
        (C = A(C, vr.rotation.z)),
        lg.to(vr.rotation, {
          x: p,
          y: m,
          z: C,
          duration: 2,
          ease: "power2.inOut",
        }));
    }
    function a() {
      (vr.position.set(n.groupPosition.x, n.groupPosition.y, n.groupPosition.z),
        (ks = new Ri(75, Gn.width / Gn.height, 0.1, 1e3)),
        ks.position.set(0, 0, 18),
        dc.add(ks),
        (na = new Jv({ canvas: e })),
        u(),
        na.setSize(Gn.width, Gn.height),
        na.setPixelRatio(Math.min(window.devicePixelRatio, 2)));
      const f = {};
      ((f.interactivePlane = new si(
        new ig(10, 64, 64),
        new ma({ color: "red" }),
      )),
        f.interactivePlane.position.set(0, 0, 0),
        (f.interactivePlane.visible = !1),
        (f.raycaster = new vR()),
        (f.canvasCursor = []),
        (f.texture = new fR(f.canvas)),
        vr.add(f.interactivePlane),
        (!yf || yf.length % 3 !== 0) &&
          console.error("Invalid positions array. Must be a multiple of 3."));
      const g = new Float32Array(yf.length / 3).fill(6),
        p = new Pr();
      (p.setAttribute("position", new tr(yf, 3)),
        p.setAttribute("size", new Pi(g, 1)));
      const m = {};
      ((m.instance = p), (m.count = m.instance.attributes.position.count));
      const C = {};
      ((C.size = Math.ceil(Math.sqrt(m.count))),
        (C.computation = new Kae(C.size, C.size, na)));
      const A = C.computation.createTexture();
      for (let ce = 0; ce < m.count; ce++) {
        const ae = ce * 3,
          Ce = ce * 4;
        ((A.image.data[Ce + 0] = m.instance.attributes.position.array[ae + 0]),
          (A.image.data[Ce + 1] = m.instance.attributes.position.array[ae + 1]),
          (A.image.data[Ce + 2] = m.instance.attributes.position.array[ae + 2]),
          (A.image.data[Ce + 3] = Math.random()));
      }
      ((C.particlesVariable = C.computation.addVariable("uParticles", qae, A)),
        C.computation.setVariableDependencies(C.particlesVariable, [
          C.particlesVariable,
        ]),
        (C.particlesVariable.material.uniforms.uDisplacementTexture = new ur(
          f.texture,
        )),
        (C.particlesVariable.material.uniforms.uCoord = new ur(
          new X(-1, -1, -1),
        )),
        (C.particlesVariable.material.uniforms.uTime = new ur(0)),
        (C.particlesVariable.material.uniforms.uDeltaTime = new ur(0)),
        (C.particlesVariable.material.uniforms.uBase = new ur(A)),
        (C.particlesVariable.material.uniforms.uRotationMatrix = new ur(
          new Et(),
        )),
        (C.particlesVariable.material.uniforms.isHovered = new ur(0)),
        (C.particlesVariable.material.uniforms.uRadius = new ur(0)),
        C.computation.init(),
        (C.debug = new si(
          new Vd(6, 6),
          new ma({
            map: C.computation.getCurrentRenderTarget(C.particlesVariable)
              .texture,
          }),
        )),
        (C.debug.position.x += 5));
      const I = new Float32Array(m.count * 2),
        y = new Float32Array(m.count * 1);
      for (let ce = 0; ce < C.size; ce++)
        for (let ae = 0; ae < C.size; ae++) {
          const Ce = ce * C.size + ae,
            $e = Ce * 2,
            Te = (ae + 0.5) / C.size,
            it = (ce + 0.5) / C.size;
          ((I[$e + 0] = Te),
            (I[$e + 1] = it),
            (y[Ce] = Math.random()),
            (M1[Ce * 3 + 0] = E1[Ce * 3 + 0]),
            (M1[Ce * 3 + 1] = E1[Ce * 3 + 1]),
            (M1[Ce * 3 + 2] = E1[Ce * 3 + 2]));
        }
      ((hs.geometry = new Pr()),
        hs.geometry.setDrawRange(0, m.count),
        hs.geometry.setAttribute("aParticlesUv", new Pi(I, 2)),
        hs.geometry.setAttribute("aSize", new Pi(y, 1)),
        hs.geometry.setAttribute("aColorv", new tr(M1, 3)),
        (hs.material = new Qi({
          vertexShader: jae,
          fragmentShader: $ae,
          uniforms: {
            uSize: new ur(0.03),
            uResolution: new ur(
              new Gt(Gn.width * Gn.pixelRatio, Gn.height * Gn.pixelRatio),
            ),
            uParticlesTexture: new ur(),
            highlightedUvs: new ur(),
          },
        })),
        (hs.points = new dR(hs.geometry, hs.material)),
        vr.add(hs.points));
      const x = new ig(9.99, 64, 64),
        T = new sI({ color: 0 }),
        S = new si(x, T);
      vr.add(S);
      const E = new _R();
      dc.add(E);
      const _ = new ig(10.05, 64, 64),
        b = new Qi({
          vertexShader: Jae,
          fragmentShader: Qae,
          uniforms: { uAtmosphereColor: new ur(new vt(10066162)) },
          transparent: !0,
          depthWrite: !1,
          blending: c_,
          side: Go,
        }),
        R = new si(_, b);
      (vr.add(R),
        lg.to(vr.rotation, {
          x: 0.5590292412159591,
          y: 1.3959225169759335,
          z: 3.14159265358979,
          duration: 2,
          ease: "power2.inOut",
        }),
        lA.add(vr),
        dc.add(lA),
        na.render(dc, ks));
      const M = () => {
          if (
            !f.raycaster ||
            !ks ||
            !f.interactivePlane ||
            br.x === void 0 ||
            br.y === void 0 ||
            No()
          )
            return;
          f.raycaster.setFromCamera(new Gt(br.x, br.y), ks);
          const ce = f.raycaster.intersectObject(f.interactivePlane);
          if (ce && ce.length && n.globeInView) {
            const { point: ae } = ce[0],
              Ce = vr.worldToLocal(ae.clone());
            ((C.particlesVariable.material.uniforms.uCoord.value = Ce),
              (C.particlesVariable.material.uniforms.isHovered.value = 1));
          } else
            ((C.particlesVariable.material.uniforms.uCoord.value = new X(
              -1,
              -1,
              -1,
            )),
              (C.particlesVariable.material.uniforms.isHovered.value = 0));
        },
        L = () => {
          t = requestAnimationFrame(L);
          const ce = gce.getElapsedTime(),
            ae = ce - bS;
          ((bS = ce),
            M(),
            (C.particlesVariable.material.uniforms.uDisplacementTexture.value =
              f.texture),
            (C.particlesVariable.material.uniforms.uTime.value = ce),
            (C.particlesVariable.material.uniforms.uDeltaTime.value = ae),
            (C.particlesVariable.material.needsUpdate = !0),
            C.computation.compute(),
            (hs.material.uniforms.uParticlesTexture.value =
              C.computation.getCurrentRenderTarget(
                C.particlesVariable,
              ).texture),
            (hs.material.needsUpdate = !0),
            J(),
            na.render(dc, ks));
        };
      let P = { x: 0, y: 0 },
        U = 0,
        O = 1;
      const V = 1.5,
        W = 6,
        re = 0.5,
        Z = 3;
      let te = Date.now();
      const ge = 200,
        be = (ce) => {
          ((br.x = (ce.clientX / Gn.width) * 2 - 1),
            (br.y = -(ce.clientY / Gn.height) * 2 + 1),
            ce.clientX / Gn.width - 0.5,
            ce.clientY / Gn.height - 0.5);
          const ae = br.x - P.x,
            Ce = br.y - P.y,
            $e = Math.sqrt(ae * ae + Ce * Ce);
          U = Math.max($e * Z, U * 0.95);
          const Te = Math.min(V + (W - V) * U, W);
          ((O = zc.lerp(O, Te, re)),
            (P = { x: br.x, y: br.y }),
            (te = Date.now()),
            (C.particlesVariable.material.uniforms.uDisplacementTexture.value =
              f.texture),
            (C.particlesVariable.material.uniforms.uRadius.value = O),
            !(No() || !n.globeInView) &&
              lA.lookAt(new X(br.x * 4, br.y * 4, 18)));
        };
      function J() {
        Date.now() - te > ge &&
          ((O = zc.lerp(O, V, re)),
          (C.particlesVariable.material.uniforms.uRadius.value = O));
      }
      const se = () => {
        ((C.particlesVariable.material.uniforms.uRadius.value = 0),
          (br.x = -1),
          (br.y = -1));
      };
      (e.addEventListener("pointermove", be),
        e.addEventListener("pointerleave", se),
        L());
    }
    function l(f, g) {
      const p = [];
      return (
        f.forEach(({ x: m, y: C }) => {
          const A = m / us.width,
            I = C / us.height,
            y = A * 360 - 180,
            T = (90 - (I * 180 - 90)) * (Math.PI / 180),
            S = y * (Math.PI / 180),
            E = g * Math.sin(T) * Math.cos(S),
            _ = g * Math.cos(T),
            b = g * Math.sin(T) * Math.sin(S);
          p.push(E, _, b);
        }),
        p
      );
    }
    function c() {
      ((yf = l(cA, 10)), a());
    }
    const u = () => {
      window.innerWidth !== _S &&
        ((_S = window.innerWidth),
        (Gn.width = e.parentElement.getBoundingClientRect().width),
        (Gn.height = e.parentElement.getBoundingClientRect().height),
        (Gn.pixelRatio = window.devicePixelRatio),
        (ks.aspect = Gn.width / Gn.height),
        window.innerWidth < 769
          ? ks.position.set(0, 0, 19)
          : ks.position.set(0, 0, 18),
        s(),
        na.setPixelRatio(Math.min(window.devicePixelRatio, 2)),
        na.setSize(Gn.width, Gn.height),
        ks.updateProjectionMatrix());
    };
    function h() {
      (dc?.traverse((f) => {
        f.isMesh &&
          (f.geometry && f.geometry.dispose(),
          f.material &&
            (Array.isArray(f.material)
              ? f.material.forEach((g) => {
                  (g.dispose(), g.map && g.map.dispose());
                })
              : (f.material.dispose(),
                f.material.map && f.material.map.dispose())));
      }),
        vr.clear(),
        pce.clear(),
        dc.clear(),
        na.dispose(),
        t !== null && (cancelAnimationFrame(t), (t = null)));
    }
    function d(f, g, p) {
      return f.map(({ x: m, y: C }) => {
        const A = (m / g) * 360 - 180,
          I = ((p - C) / p) * 180 - 90;
        return { x: m, y: C, lat: I, lon: A };
      });
    }
    return (
      Ct(() => {
        n.coords && s();
      }),
      Ct(() => {
        (({ x: g, y: p, z: m }) => g !== 0 || p !== 0 || m !== 0)(
          n.groupPosition,
        ) ||
          lg.to(vr.position, {
            duration: 3,
            x: n.groupPosition.x,
            y: n.groupPosition.y,
            z: n.groupPosition.z,
            ease: "power4.inOut",
            onComplete: () => {
              ((document.body.style.overflow = "auto"), n.setGlobeVisible(!0));
            },
          });
      }),
      rr(() => {
        ((Gn.width = e.parentElement.getBoundingClientRect().width),
          (Gn.height = e.parentElement.getBoundingClientRect().height),
          (us = document.createElement("canvas")));
        const f = us.getContext("2d"),
          g = new Image();
        ((g.src = "/earth_specular_map_simplified2.jpg"),
          (g.onload = () => {
            ((us.width = g.width),
              (us.height = g.height),
              f?.drawImage(g, 0, 0));
            const p = f?.getImageData(0, 0, us.width, us.height);
            if (!p) return;
            const m = [];
            for (let C = 0; C < p.data.length; C += 400) {
              const A = p.data[C],
                I = p.data[C + 1],
                y = p.data[C + 2];
              if (A < 254 && I < 254 && y <= 255) {
                const x = (C / 4) % us.width,
                  T = Math.floor(C / 4 / us.width);
                (m.push({ x, y: T }), E1.push(A / 255, I / 255, y / 255));
              }
            }
            ((cA = d(m, us.width, us.height)), c());
          }),
          window.addEventListener("resize", u),
          dn(() => {
            (h(), window.removeEventListener("resize", u));
          }));
      }),
      G($.Generic, {
        ref(f) {
          const g = e;
          typeof g == "function" ? g(f) : (e = f);
        },
        css: {
          position: "absolute",
          inset: "0px",
          height: "100%",
          width: "100%",
        },
        as: "canvas",
      })
    );
  },
  Cce = ({ str: n, callback: e }) => {
    const [t, i] = Jt(!1);
    let r = null;
    return (
      Ct(() => {
        if (!r) return;
        new IntersectionObserver(
          (o) => {
            o.forEach((a) => {
              a.isIntersecting && (i(!0), e && typeof e == "function" && e());
            });
          },
          { threshold: 0.5, rootMargin: "-50% 0px 0px 0px" },
        ).observe(r);
      }),
      G($.Generic, {
        css: {
          maxWidth: "900rem",
          paddingLeft: "40rem",
          paddingRight: "40rem",
        },
        as: "div",
        ref(s) {
          const o = r;
          typeof o == "function" ? o(s) : (r = s);
        },
        get children() {
          return [
            G($.Generic, {
              get css() {
                return [
                  {
                    marginLeft: "auto",
                    marginRight: "auto",
                    textAlign: "center",
                    textTransform: "uppercase",
                    "@media (max-width: 767px)": { maxWidth: "300rem" },
                  },
                  nt.breit.h4,
                  nt.m.breit.h3,
                ];
              },
              as: "h1",
              get children() {
                return G(Yn, {
                  get each() {
                    return n.split(" ");
                  },
                  children: (s, o) =>
                    G($.Generic, {
                      get style() {
                        return {
                          "transition-duration": "1000ms",
                          "transition-delay": `${o() * 500}ms`,
                          "transition-property": "top, opacity, filter",
                        };
                      },
                      get css() {
                        return [
                          { position: "relative" },
                          {
                            top: t() ? "0" : "40px",
                            opacity: t() ? 1 : 0,
                            filter: t() ? "blur(0)" : "blur(10px)",
                          },
                        ];
                      },
                      as: "span",
                      get children() {
                        return s + (o() === n.split(" ").length - 1 ? "" : " ");
                      },
                    }),
                });
              },
            }),
            G($.Generic, {
              get css() {
                return [
                  {
                    position: "relative",
                    marginTop: "32rem",
                    textAlign: "center",
                    color: "rgb(255 255 255 / 0.5)",
                  },
                  nt.sohne.body2,
                  nt.m.sohne.body2,
                ];
              },
              as: "p",
              get style() {
                return {
                  "transition-duration": "1000ms",
                  "transition-delay": "800ms",
                  "transition-property": "top, opacity, filter",
                  top: t() ? "0" : "40px",
                  opacity: t() ? 1 : 0,
                  filter: t() ? "blur(0)" : "blur(10px)",
                };
              },
              children:
                "Our globally distributed team is composed of industry-leading talent, bringing diverse perspectives and expertise to every project.",
            }),
          ];
        },
      })
    );
  };
/*!
 * ScrollToPlugin 3.12.7
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var $i,
  LB,
  Ta,
  So,
  Ml,
  RB,
  Oh,
  L1,
  BB = function () {
    return typeof window < "u";
  },
  PB = function () {
    return $i || (BB() && ($i = window.gsap) && $i.registerPlugin && $i);
  },
  NB = function (e) {
    return typeof e == "string";
  },
  vS = function (e) {
    return typeof e == "function";
  },
  Zg = function (e, t) {
    var i = t === "x" ? "Width" : "Height",
      r = "scroll" + i,
      s = "client" + i;
    return e === Ta || e === So || e === Ml
      ? Math.max(So[r], Ml[r]) - (Ta["inner" + i] || So[s] || Ml[s])
      : e[r] - e["offset" + i];
  },
  zg = function (e, t) {
    var i = "scroll" + (t === "x" ? "Left" : "Top");
    return (
      e === Ta &&
        (e.pageXOffset != null
          ? (i = "page" + t.toUpperCase() + "Offset")
          : (e = So[i] != null ? So : Ml)),
      function () {
        return e[i];
      }
    );
  },
  Ice = function (e, t, i, r) {
    if ((vS(e) && (e = e(t, i, r)), typeof e != "object"))
      return NB(e) && e !== "max" && e.charAt(1) !== "="
        ? { x: e, y: e }
        : { y: e };
    if (e.nodeType) return { y: e, x: e };
    var s = {},
      o;
    for (o in e) s[o] = o !== "onAutoKill" && vS(e[o]) ? e[o](t, i, r) : e[o];
    return s;
  },
  DB = function (e, t) {
    if (((e = RB(e)[0]), !e || !e.getBoundingClientRect))
      return (
        console.warn("scrollTo target doesn't exist. Using 0") || { x: 0, y: 0 }
      );
    var i = e.getBoundingClientRect(),
      r = !t || t === Ta || t === Ml,
      s = r
        ? {
            top:
              So.clientTop -
              (Ta.pageYOffset || So.scrollTop || Ml.scrollTop || 0),
            left:
              So.clientLeft -
              (Ta.pageXOffset || So.scrollLeft || Ml.scrollLeft || 0),
          }
        : t.getBoundingClientRect(),
      o = { x: i.left - s.left, y: i.top - s.top };
    return (!r && t && ((o.x += zg(t, "x")()), (o.y += zg(t, "y")())), o);
  },
  xS = function (e, t, i, r, s) {
    return !isNaN(e) && typeof e != "object"
      ? parseFloat(e) - s
      : NB(e) && e.charAt(1) === "="
        ? parseFloat(e.substr(2)) * (e.charAt(0) === "-" ? -1 : 1) + r - s
        : e === "max"
          ? Zg(t, i) - s
          : Math.min(Zg(t, i), DB(e, t)[i] - s);
  },
  I3 = function () {
    (($i = PB()),
      BB() &&
        $i &&
        typeof document < "u" &&
        document.body &&
        ((Ta = window),
        (Ml = document.body),
        (So = document.documentElement),
        (RB = $i.utils.toArray),
        $i.config({ autoKillThreshold: 7 }),
        (Oh = $i.config()),
        (LB = 1)));
  },
  Kd = {
    version: "3.12.7",
    name: "scrollTo",
    rawVars: 1,
    register: function (e) {
      (($i = e), I3());
    },
    init: function (e, t, i, r, s) {
      LB || I3();
      var o = this,
        a = $i.getProperty(e, "scrollSnapType");
      ((o.isWin = e === Ta),
        (o.target = e),
        (o.tween = i),
        (t = Ice(t, r, e, s)),
        (o.vars = t),
        (o.autoKill = !!("autoKill" in t ? t : Oh).autoKill),
        (o.getX = zg(e, "x")),
        (o.getY = zg(e, "y")),
        (o.x = o.xPrev = o.getX()),
        (o.y = o.yPrev = o.getY()),
        L1 || (L1 = $i.core.globals().ScrollTrigger),
        $i.getProperty(e, "scrollBehavior") === "smooth" &&
          $i.set(e, { scrollBehavior: "auto" }),
        a &&
          a !== "none" &&
          ((o.snap = 1),
          (o.snapInline = e.style.scrollSnapType),
          (e.style.scrollSnapType = "none")),
        t.x != null
          ? (o.add(o, "x", o.x, xS(t.x, e, "x", o.x, t.offsetX || 0), r, s),
            o._props.push("scrollTo_x"))
          : (o.skipX = 1),
        t.y != null
          ? (o.add(o, "y", o.y, xS(t.y, e, "y", o.y, t.offsetY || 0), r, s),
            o._props.push("scrollTo_y"))
          : (o.skipY = 1));
    },
    render: function (e, t) {
      for (
        var i = t._pt,
          r = t.target,
          s = t.tween,
          o = t.autoKill,
          a = t.xPrev,
          l = t.yPrev,
          c = t.isWin,
          u = t.snap,
          h = t.snapInline,
          d,
          f,
          g,
          p,
          m;
        i;
      )
        (i.r(e, i.d), (i = i._next));
      ((d = c || !t.skipX ? t.getX() : a),
        (f = c || !t.skipY ? t.getY() : l),
        (g = f - l),
        (p = d - a),
        (m = Oh.autoKillThreshold),
        t.x < 0 && (t.x = 0),
        t.y < 0 && (t.y = 0),
        o &&
          (!t.skipX && (p > m || p < -m) && d < Zg(r, "x") && (t.skipX = 1),
          !t.skipY && (g > m || g < -m) && f < Zg(r, "y") && (t.skipY = 1),
          t.skipX &&
            t.skipY &&
            (s.kill(),
            t.vars.onAutoKill &&
              t.vars.onAutoKill.apply(s, t.vars.onAutoKillParams || []))),
        c
          ? Ta.scrollTo(t.skipX ? d : t.x, t.skipY ? f : t.y)
          : (t.skipY || (r.scrollTop = t.y), t.skipX || (r.scrollLeft = t.x)),
        u &&
          (e === 1 || e === 0) &&
          ((f = r.scrollTop),
          (d = r.scrollLeft),
          h
            ? (r.style.scrollSnapType = h)
            : r.style.removeProperty("scroll-snap-type"),
          (r.scrollTop = f + 1),
          (r.scrollLeft = d + 1),
          (r.scrollTop = f),
          (r.scrollLeft = d)),
        (t.xPrev = t.x),
        (t.yPrev = t.y),
        L1 && L1.update());
    },
    kill: function (e) {
      var t = e === "scrollTo",
        i = this._props.indexOf(e);
      return (
        (t || e === "scrollTo_x") && (this.skipX = 1),
        (t || e === "scrollTo_y") && (this.skipY = 1),
        i > -1 && this._props.splice(i, 1),
        !this._props.length
      );
    },
  };
Kd.max = Zg;
Kd.getOffset = DB;
Kd.buildGetter = zg;
Kd.config = function (n) {
  Oh || I3() || (Oh = $i.config());
  for (var e in n) Oh[e] = n[e];
};
PB() && $i.registerPlugin(Kd);
lg.registerPlugin(Kd);
const uA = {
    europe: "Europe",
    "north america": "North America",
    "south america": "South America",
  },
  Ace = {
    europe: { minLat: 37, maxLat: 70, minLon: -10, maxLon: 35 },
    "north america": {
      minLat: 26,
      maxLat: 49.384358,
      minLon: -125,
      maxLon: -66.93457,
    },
    "south america": {
      minLat: -55.98,
      maxLat: 12.45,
      minLon: -81.33,
      maxLon: -34.79,
    },
  },
  ume = (n) => {
    const e = xT,
      [t, i] = Jt(""),
      [r, s] = Jt(""),
      [o, a] = Jt(null),
      [l, c] = Jt(!0),
      [u, h] = Jt(!1),
      [d, f] = Jt({ x: 0, y: -5, z: 5 });
    let g = !1,
      p = null,
      m = null,
      C = null,
      A = null,
      I = null,
      y = 850;
    const x = pe(() => (e() <= Si.MD ? 400 : 500)),
      T = Ki(() => C),
      S = Ki(() => m);
    Ki(() => I);
    const E = Ki(() => A),
      _ = Ki(() => p);
    let b = pe(() => S().width - _().width + Wc(x()) + In().height * 1.5);
    const R = pe(
      () => -Cr(Qn() - _().y - In().height * 0.5, 0, b() - In().height * 1.5),
    );
    Ct(() => {
      if (r() === "" || u() === !1) return;
      (c(!1), a(Ace[r()]));
      const L = setTimeout(() => {
        (i(uA[r()]), c(!0));
      }, t().length * 100);
      dn(() => clearTimeout(L));
    });
    const M = pe(() => {
      if (g) return 1;
      const P =
        ((Qn() + (E().height + y) - T().y + In().height - In().height) /
          (In().height * 1.5 - In().height)) *
        0.4;
      return Cr(P, 0.5, 1);
    });
    return (
      Ct(() => {
        M() >= 1 && d().z === 5 && ((g = !0), f({ x: 0, y: 0, z: 0 }));
      }),
      rr(() => {
        setTimeout(() => {
          xg(xg() + 1);
        });
      }),
      G($.Generic, {
        css: { position: "relative", width: "100%" },
        as: "section",
        ref(L) {
          const P = C;
          typeof P == "function" ? P(L) : (C = L);
        },
        get children() {
          return [
            G($.Generic, {
              css: {
                inset: "0px",
                display: "flex",
                width: "100%",
                justifyContent: "center",
                paddingBottom: "20rem",
                paddingTop: "200rem",
                "@media (max-width: 767px)": {
                  paddingBottom: "0",
                  paddingTop: "100rem",
                },
              },
              as: "div",
              ref(L) {
                const P = A;
                typeof P == "function" ? P(L) : (A = L);
              },
              get children() {
                return G(Cce, { str: "Global Disruption" });
              },
            }),
            G($.Generic, {
              get css() {
                return { height: `${b()}px` };
              },
              as: "div",
              ref(L) {
                const P = p;
                typeof P == "function" ? P(L) : (p = L);
              },
              get children() {
                return G(iI, {
                  get type() {
                    return xi.Regions;
                  },
                  children: (L) =>
                    G(
                      $.Generic,
                      jn(
                        {
                          css: [
                            {
                              position: "sticky",
                              top: "0px",
                              height: "100vh",
                              overflow: "hidden",
                            },
                            va,
                          ],
                          as: "div",
                        },
                        L,
                        {
                          get children() {
                            return [
                              G($.Generic, {
                                css: {
                                  pointerEvents: "none",
                                  position: "absolute",
                                  inset: "0px",
                                  zIndex: "2",
                                  display: "flex",
                                  height: "100%",
                                  width: "300vw",
                                  flexWrap: "nowrap",
                                  "@media (max-width: 767px)": {
                                    width: "400vw",
                                  },
                                },
                                as: "div",
                                class: "hide-scrollbars",
                                get style() {
                                  return {
                                    "will-change": "transform",
                                    transform: `translateX(${R()}px)`,
                                  };
                                },
                                ref(P) {
                                  const U = m;
                                  typeof U == "function" ? U(P) : (m = P);
                                },
                                get children() {
                                  return Object.entries(uA).map(([, P], U) =>
                                    G(yce, {
                                      setKey: s,
                                      setCoords: a,
                                      text: P,
                                      countries: uA,
                                    }),
                                  );
                                },
                              }),
                              G($.Generic, {
                                css: {
                                  pointerEvents: "none",
                                  position: "absolute",
                                  inset: "0px",
                                  zIndex: "2",
                                  display: "flex",
                                  height: "100%",
                                  width: "100%",
                                  alignItems: "center",
                                  justifyContent: "center",
                                },
                                as: "div",
                                get children() {
                                  return G($.Generic, {
                                    get css() {
                                      return [
                                        {
                                          textAlign: "center",
                                          textTransform: "uppercase",
                                        },
                                        nt.breit.h1,
                                        nt.m.breit.h05,
                                      ];
                                    },
                                    as: "h2",
                                    get children() {
                                      return G(Yn, {
                                        get each() {
                                          return t()
                                            .split(" ")
                                            .flatMap((P, U, O) =>
                                              P.split("").map((V, W) => ({
                                                char: V,
                                                isLastInWord:
                                                  W === P.length - 1,
                                                isLastWord: U === O.length - 1,
                                              })),
                                            );
                                        },
                                        children: (P, U) => [
                                          G($.Generic, {
                                            css: {
                                              position: "relative",
                                              paddingLeft: "8px",
                                              paddingRight: "8px",
                                              "@media (max-width: 767px)": {
                                                paddingLeft: "3px",
                                                paddingRight: "3px",
                                              },
                                            },
                                            as: "span",
                                            get style() {
                                              return {
                                                "animation-delay": `${U() * 100}ms`,
                                              };
                                            },
                                            get class() {
                                              return l()
                                                ? "fade-in-blur"
                                                : "fade-out-blur";
                                            },
                                            get children() {
                                              return P.char;
                                            },
                                          }),
                                          pe(
                                            (() => {
                                              const O = pe(
                                                () =>
                                                  !P.isLastInWord &&
                                                  !P.isLastWord,
                                              );
                                              return () =>
                                                O() &&
                                                G($.Generic, {
                                                  css: {
                                                    display: "inline-block",
                                                    "--tw-content": "' '",
                                                    content:
                                                      "var(--tw-content)",
                                                  },
                                                  as: "span",
                                                });
                                            })(),
                                          ),
                                          pe(
                                            (() => {
                                              const O = pe(
                                                () =>
                                                  !!(
                                                    P.isLastInWord &&
                                                    !P.isLastWord
                                                  ),
                                              );
                                              return () =>
                                                O() &&
                                                G($.Generic, {
                                                  css: {
                                                    display: "block",
                                                    width: "100%",
                                                  },
                                                  as: "span",
                                                });
                                            })(),
                                          ),
                                        ],
                                      });
                                    },
                                  });
                                },
                              }),
                              G($.Generic, {
                                css: {
                                  position: "absolute",
                                  inset: "0px",
                                  zIndex: "1",
                                  height: "100%",
                                  width: "100%",
                                  willChange: "transform, opacity",
                                },
                                as: "div",
                                get style() {
                                  return {
                                    opacity: M(),
                                    transform: `translate3d(0, ${100 - M() * 100}%, 0)`,
                                  };
                                },
                                ref(P) {
                                  const U = I;
                                  typeof U == "function" ? U(P) : (I = P);
                                },
                                get children() {
                                  return G(mce, {
                                    get groupPosition() {
                                      return d();
                                    },
                                    get coords() {
                                      return o();
                                    },
                                    setGlobeVisible: h,
                                    get globeInView() {
                                      return I.getBoundingClientRect().top <= 0;
                                    },
                                  });
                                },
                              }),
                            ];
                          },
                        },
                      ),
                    ),
                });
              },
            }),
          ];
        },
      })
    );
  },
  yce = (n) => {
    let e = null;
    return (
      Ct(() => {
        if (!e) return;
        const t = new IntersectionObserver(
          (i) => {
            i.forEach((r) => {
              r.isIntersecting && n.setKey(n.text.toLowerCase());
            });
          },
          { threshold: 0.5, rootMargin: "0px" },
        );
        (t.observe(e), dn(() => t.disconnect()));
      }),
      G($.Generic, {
        css: {
          display: "flex",
          height: "100%",
          flex: "1 1 0%",
          flexShrink: "0",
          alignItems: "center",
          justifyContent: "center",
        },
        as: "div",
        ref(t) {
          const i = e;
          typeof i == "function" ? i(t) : (e = t);
        },
      })
    );
  },
  _ce = xt('<svg stroke-width="0">');
function bce(n, e) {
  const t = jn(n.a, e),
    [i, r] = Dr(t, ["src"]),
    [s, o] = Jt(""),
    a = pe(() => (e.title ? `${n.c}<title>${e.title}</title>` : n.c));
  return (
    Ct(() => o(a())),
    dn(() => {
      o("");
    }),
    (() => {
      const l = ft(_ce);
      return (
        fn(
          l,
          jn(
            {
              get stroke() {
                return n.a?.stroke;
              },
              get color() {
                return e.color || "currentColor";
              },
              get fill() {
                return e.color || "currentColor";
              },
              get style() {
                return { ...e.style, overflow: "visible" };
              },
            },
            r,
            {
              get height() {
                return e.size || "1em";
              },
              get width() {
                return e.size || "1em";
              },
              xmlns: "http://www.w3.org/2000/svg",
              get innerHTML() {
                return s();
              },
            },
          ),
          !0,
          !0,
        ),
        Mn(l, () => pg),
        An(),
        l
      );
    })()
  );
}
function vce(n) {
  return bce(
    {
      a: { viewBox: "0 0 24 24" },
      c: '<path fill="currentColor" d="m16.172 11-5.364-5.364 1.414-1.414L20 12l-7.778 7.778-1.414-1.414L16.172 13H4v-2h12.172Z"/>',
    },
    n,
  );
}
var Tu = ((n) => (
    (n[(n.WEBGL_LEGACY = 0)] = "WEBGL_LEGACY"),
    (n[(n.WEBGL = 1)] = "WEBGL"),
    (n[(n.WEBGL2 = 2)] = "WEBGL2"),
    n
  ))(Tu || {}),
  GB = ((n) => (
    (n[(n.UNKNOWN = 0)] = "UNKNOWN"),
    (n[(n.WEBGL = 1)] = "WEBGL"),
    (n[(n.CANVAS = 2)] = "CANVAS"),
    n
  ))(GB || {}),
  A3 = ((n) => (
    (n[(n.COLOR = 16384)] = "COLOR"),
    (n[(n.DEPTH = 256)] = "DEPTH"),
    (n[(n.STENCIL = 1024)] = "STENCIL"),
    n
  ))(A3 || {}),
  dt = ((n) => (
    (n[(n.NORMAL = 0)] = "NORMAL"),
    (n[(n.ADD = 1)] = "ADD"),
    (n[(n.MULTIPLY = 2)] = "MULTIPLY"),
    (n[(n.SCREEN = 3)] = "SCREEN"),
    (n[(n.OVERLAY = 4)] = "OVERLAY"),
    (n[(n.DARKEN = 5)] = "DARKEN"),
    (n[(n.LIGHTEN = 6)] = "LIGHTEN"),
    (n[(n.COLOR_DODGE = 7)] = "COLOR_DODGE"),
    (n[(n.COLOR_BURN = 8)] = "COLOR_BURN"),
    (n[(n.HARD_LIGHT = 9)] = "HARD_LIGHT"),
    (n[(n.SOFT_LIGHT = 10)] = "SOFT_LIGHT"),
    (n[(n.DIFFERENCE = 11)] = "DIFFERENCE"),
    (n[(n.EXCLUSION = 12)] = "EXCLUSION"),
    (n[(n.HUE = 13)] = "HUE"),
    (n[(n.SATURATION = 14)] = "SATURATION"),
    (n[(n.COLOR = 15)] = "COLOR"),
    (n[(n.LUMINOSITY = 16)] = "LUMINOSITY"),
    (n[(n.NORMAL_NPM = 17)] = "NORMAL_NPM"),
    (n[(n.ADD_NPM = 18)] = "ADD_NPM"),
    (n[(n.SCREEN_NPM = 19)] = "SCREEN_NPM"),
    (n[(n.NONE = 20)] = "NONE"),
    (n[(n.SRC_OVER = 0)] = "SRC_OVER"),
    (n[(n.SRC_IN = 21)] = "SRC_IN"),
    (n[(n.SRC_OUT = 22)] = "SRC_OUT"),
    (n[(n.SRC_ATOP = 23)] = "SRC_ATOP"),
    (n[(n.DST_OVER = 24)] = "DST_OVER"),
    (n[(n.DST_IN = 25)] = "DST_IN"),
    (n[(n.DST_OUT = 26)] = "DST_OUT"),
    (n[(n.DST_ATOP = 27)] = "DST_ATOP"),
    (n[(n.ERASE = 26)] = "ERASE"),
    (n[(n.SUBTRACT = 28)] = "SUBTRACT"),
    (n[(n.XOR = 29)] = "XOR"),
    n
  ))(dt || {}),
  To = ((n) => (
    (n[(n.POINTS = 0)] = "POINTS"),
    (n[(n.LINES = 1)] = "LINES"),
    (n[(n.LINE_LOOP = 2)] = "LINE_LOOP"),
    (n[(n.LINE_STRIP = 3)] = "LINE_STRIP"),
    (n[(n.TRIANGLES = 4)] = "TRIANGLES"),
    (n[(n.TRIANGLE_STRIP = 5)] = "TRIANGLE_STRIP"),
    (n[(n.TRIANGLE_FAN = 6)] = "TRIANGLE_FAN"),
    n
  ))(To || {}),
  ve = ((n) => (
    (n[(n.RGBA = 6408)] = "RGBA"),
    (n[(n.RGB = 6407)] = "RGB"),
    (n[(n.RG = 33319)] = "RG"),
    (n[(n.RED = 6403)] = "RED"),
    (n[(n.RGBA_INTEGER = 36249)] = "RGBA_INTEGER"),
    (n[(n.RGB_INTEGER = 36248)] = "RGB_INTEGER"),
    (n[(n.RG_INTEGER = 33320)] = "RG_INTEGER"),
    (n[(n.RED_INTEGER = 36244)] = "RED_INTEGER"),
    (n[(n.ALPHA = 6406)] = "ALPHA"),
    (n[(n.LUMINANCE = 6409)] = "LUMINANCE"),
    (n[(n.LUMINANCE_ALPHA = 6410)] = "LUMINANCE_ALPHA"),
    (n[(n.DEPTH_COMPONENT = 6402)] = "DEPTH_COMPONENT"),
    (n[(n.DEPTH_STENCIL = 34041)] = "DEPTH_STENCIL"),
    n
  ))(ve || {}),
  Uh = ((n) => (
    (n[(n.TEXTURE_2D = 3553)] = "TEXTURE_2D"),
    (n[(n.TEXTURE_CUBE_MAP = 34067)] = "TEXTURE_CUBE_MAP"),
    (n[(n.TEXTURE_2D_ARRAY = 35866)] = "TEXTURE_2D_ARRAY"),
    (n[(n.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] =
      "TEXTURE_CUBE_MAP_POSITIVE_X"),
    (n[(n.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] =
      "TEXTURE_CUBE_MAP_NEGATIVE_X"),
    (n[(n.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] =
      "TEXTURE_CUBE_MAP_POSITIVE_Y"),
    (n[(n.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] =
      "TEXTURE_CUBE_MAP_NEGATIVE_Y"),
    (n[(n.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] =
      "TEXTURE_CUBE_MAP_POSITIVE_Z"),
    (n[(n.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] =
      "TEXTURE_CUBE_MAP_NEGATIVE_Z"),
    n
  ))(Uh || {}),
  et = ((n) => (
    (n[(n.UNSIGNED_BYTE = 5121)] = "UNSIGNED_BYTE"),
    (n[(n.UNSIGNED_SHORT = 5123)] = "UNSIGNED_SHORT"),
    (n[(n.UNSIGNED_SHORT_5_6_5 = 33635)] = "UNSIGNED_SHORT_5_6_5"),
    (n[(n.UNSIGNED_SHORT_4_4_4_4 = 32819)] = "UNSIGNED_SHORT_4_4_4_4"),
    (n[(n.UNSIGNED_SHORT_5_5_5_1 = 32820)] = "UNSIGNED_SHORT_5_5_5_1"),
    (n[(n.UNSIGNED_INT = 5125)] = "UNSIGNED_INT"),
    (n[(n.UNSIGNED_INT_10F_11F_11F_REV = 35899)] =
      "UNSIGNED_INT_10F_11F_11F_REV"),
    (n[(n.UNSIGNED_INT_2_10_10_10_REV = 33640)] =
      "UNSIGNED_INT_2_10_10_10_REV"),
    (n[(n.UNSIGNED_INT_24_8 = 34042)] = "UNSIGNED_INT_24_8"),
    (n[(n.UNSIGNED_INT_5_9_9_9_REV = 35902)] = "UNSIGNED_INT_5_9_9_9_REV"),
    (n[(n.BYTE = 5120)] = "BYTE"),
    (n[(n.SHORT = 5122)] = "SHORT"),
    (n[(n.INT = 5124)] = "INT"),
    (n[(n.FLOAT = 5126)] = "FLOAT"),
    (n[(n.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] =
      "FLOAT_32_UNSIGNED_INT_24_8_REV"),
    (n[(n.HALF_FLOAT = 36193)] = "HALF_FLOAT"),
    n
  ))(et || {}),
  ke = ((n) => (
    (n[(n.FLOAT = 0)] = "FLOAT"),
    (n[(n.INT = 1)] = "INT"),
    (n[(n.UINT = 2)] = "UINT"),
    n
  ))(ke || {}),
  Ca = ((n) => (
    (n[(n.NEAREST = 0)] = "NEAREST"),
    (n[(n.LINEAR = 1)] = "LINEAR"),
    n
  ))(Ca || {}),
  Ll = ((n) => (
    (n[(n.CLAMP = 33071)] = "CLAMP"),
    (n[(n.REPEAT = 10497)] = "REPEAT"),
    (n[(n.MIRRORED_REPEAT = 33648)] = "MIRRORED_REPEAT"),
    n
  ))(Ll || {}),
  Ho = ((n) => (
    (n[(n.OFF = 0)] = "OFF"),
    (n[(n.POW2 = 1)] = "POW2"),
    (n[(n.ON = 2)] = "ON"),
    (n[(n.ON_MANUAL = 3)] = "ON_MANUAL"),
    n
  ))(Ho || {}),
  Tr = ((n) => (
    (n[(n.NPM = 0)] = "NPM"),
    (n[(n.UNPACK = 1)] = "UNPACK"),
    (n[(n.PMA = 2)] = "PMA"),
    (n[(n.NO_PREMULTIPLIED_ALPHA = 0)] = "NO_PREMULTIPLIED_ALPHA"),
    (n[(n.PREMULTIPLY_ON_UPLOAD = 1)] = "PREMULTIPLY_ON_UPLOAD"),
    (n[(n.PREMULTIPLIED_ALPHA = 2)] = "PREMULTIPLIED_ALPHA"),
    n
  ))(Tr || {}),
  Co = ((n) => (
    (n[(n.NO = 0)] = "NO"),
    (n[(n.YES = 1)] = "YES"),
    (n[(n.AUTO = 2)] = "AUTO"),
    (n[(n.BLEND = 0)] = "BLEND"),
    (n[(n.CLEAR = 1)] = "CLEAR"),
    (n[(n.BLIT = 2)] = "BLIT"),
    n
  ))(Co || {}),
  p5 = ((n) => ((n[(n.AUTO = 0)] = "AUTO"), (n[(n.MANUAL = 1)] = "MANUAL"), n))(
    p5 || {},
  ),
  _s = ((n) => (
    (n.LOW = "lowp"),
    (n.MEDIUM = "mediump"),
    (n.HIGH = "highp"),
    n
  ))(_s || {}),
  hi = ((n) => (
    (n[(n.NONE = 0)] = "NONE"),
    (n[(n.SCISSOR = 1)] = "SCISSOR"),
    (n[(n.STENCIL = 2)] = "STENCIL"),
    (n[(n.SPRITE = 3)] = "SPRITE"),
    (n[(n.COLOR = 4)] = "COLOR"),
    n
  ))(hi || {}),
  ri = ((n) => (
    (n[(n.NONE = 0)] = "NONE"),
    (n[(n.LOW = 2)] = "LOW"),
    (n[(n.MEDIUM = 4)] = "MEDIUM"),
    (n[(n.HIGH = 8)] = "HIGH"),
    n
  ))(ri || {}),
  Ro = ((n) => (
    (n[(n.ELEMENT_ARRAY_BUFFER = 34963)] = "ELEMENT_ARRAY_BUFFER"),
    (n[(n.ARRAY_BUFFER = 34962)] = "ARRAY_BUFFER"),
    (n[(n.UNIFORM_BUFFER = 35345)] = "UNIFORM_BUFFER"),
    n
  ))(Ro || {});
const xce = {
    createCanvas: (n, e) => {
      const t = document.createElement("canvas");
      return ((t.width = n), (t.height = e), t);
    },
    getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
    getWebGLRenderingContext: () => WebGLRenderingContext,
    getNavigator: () => navigator,
    getBaseUrl: () => document.baseURI ?? window.location.href,
    getFontFaceSet: () => document.fonts,
    fetch: (n, e) => fetch(n, e),
    parseXML: (n) => new DOMParser().parseFromString(n, "text/xml"),
  },
  Oe = {
    ADAPTER: xce,
    RESOLUTION: 1,
    CREATE_IMAGE_BITMAP: !1,
    ROUND_PIXELS: !1,
  };
var hA = /iPhone/i,
  wS = /iPod/i,
  SS = /iPad/i,
  TS = /\biOS-universal(?:.+)Mac\b/i,
  dA = /\bAndroid(?:.+)Mobile\b/i,
  ES = /Android/i,
  Qu = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,
  R1 = /Silk/i,
  ia = /Windows Phone/i,
  MS = /\bWindows(?:.+)ARM\b/i,
  LS = /BlackBerry/i,
  RS = /BB10/i,
  BS = /Opera Mini/i,
  PS = /\b(CriOS|Chrome)(?:.+)Mobile/i,
  NS = /Mobile(?:.+)Firefox\b/i,
  DS = function (n) {
    return (
      typeof n < "u" &&
      n.platform === "MacIntel" &&
      typeof n.maxTouchPoints == "number" &&
      n.maxTouchPoints > 1 &&
      typeof MSStream > "u"
    );
  };
function wce(n) {
  return function (e) {
    return e.test(n);
  };
}
function GS(n) {
  var e = { userAgent: "", platform: "", maxTouchPoints: 0 };
  !n && typeof navigator < "u"
    ? (e = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        maxTouchPoints: navigator.maxTouchPoints || 0,
      })
    : typeof n == "string"
      ? (e.userAgent = n)
      : n &&
        n.userAgent &&
        (e = {
          userAgent: n.userAgent,
          platform: n.platform,
          maxTouchPoints: n.maxTouchPoints || 0,
        });
  var t = e.userAgent,
    i = t.split("[FBAN");
  (typeof i[1] < "u" && (t = i[0]),
    (i = t.split("Twitter")),
    typeof i[1] < "u" && (t = i[0]));
  var r = wce(t),
    s = {
      apple: {
        phone: r(hA) && !r(ia),
        ipod: r(wS),
        tablet: !r(hA) && (r(SS) || DS(e)) && !r(ia),
        universal: r(TS),
        device: (r(hA) || r(wS) || r(SS) || r(TS) || DS(e)) && !r(ia),
      },
      amazon: { phone: r(Qu), tablet: !r(Qu) && r(R1), device: r(Qu) || r(R1) },
      android: {
        phone: (!r(ia) && r(Qu)) || (!r(ia) && r(dA)),
        tablet: !r(ia) && !r(Qu) && !r(dA) && (r(R1) || r(ES)),
        device:
          (!r(ia) && (r(Qu) || r(R1) || r(dA) || r(ES))) || r(/\bokhttp\b/i),
      },
      windows: { phone: r(ia), tablet: r(MS), device: r(ia) || r(MS) },
      other: {
        blackberry: r(LS),
        blackberry10: r(RS),
        opera: r(BS),
        firefox: r(NS),
        chrome: r(PS),
        device: r(LS) || r(RS) || r(BS) || r(NS) || r(PS),
      },
      any: !1,
      phone: !1,
      tablet: !1,
    };
  return (
    (s.any =
      s.apple.device || s.android.device || s.windows.device || s.other.device),
    (s.phone = s.apple.phone || s.android.phone || s.windows.phone),
    (s.tablet = s.apple.tablet || s.android.tablet || s.windows.tablet),
    s
  );
}
const Sce = GS.default ?? GS,
  Ia = Sce(globalThis.navigator);
Oe.RETINA_PREFIX = /@([0-9\.]+)x/;
Oe.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
var FB = { exports: {} };
(function (n) {
  var e = Object.prototype.hasOwnProperty,
    t = "~";
  function i() {}
  Object.create &&
    ((i.prototype = Object.create(null)), new i().__proto__ || (t = !1));
  function r(l, c, u) {
    ((this.fn = l), (this.context = c), (this.once = u || !1));
  }
  function s(l, c, u, h, d) {
    if (typeof u != "function")
      throw new TypeError("The listener must be a function");
    var f = new r(u, h || l, d),
      g = t ? t + c : c;
    return (
      l._events[g]
        ? l._events[g].fn
          ? (l._events[g] = [l._events[g], f])
          : l._events[g].push(f)
        : ((l._events[g] = f), l._eventsCount++),
      l
    );
  }
  function o(l, c) {
    --l._eventsCount === 0 ? (l._events = new i()) : delete l._events[c];
  }
  function a() {
    ((this._events = new i()), (this._eventsCount = 0));
  }
  ((a.prototype.eventNames = function () {
    var c = [],
      u,
      h;
    if (this._eventsCount === 0) return c;
    for (h in (u = this._events)) e.call(u, h) && c.push(t ? h.slice(1) : h);
    return Object.getOwnPropertySymbols
      ? c.concat(Object.getOwnPropertySymbols(u))
      : c;
  }),
    (a.prototype.listeners = function (c) {
      var u = t ? t + c : c,
        h = this._events[u];
      if (!h) return [];
      if (h.fn) return [h.fn];
      for (var d = 0, f = h.length, g = new Array(f); d < f; d++)
        g[d] = h[d].fn;
      return g;
    }),
    (a.prototype.listenerCount = function (c) {
      var u = t ? t + c : c,
        h = this._events[u];
      return h ? (h.fn ? 1 : h.length) : 0;
    }),
    (a.prototype.emit = function (c, u, h, d, f, g) {
      var p = t ? t + c : c;
      if (!this._events[p]) return !1;
      var m = this._events[p],
        C = arguments.length,
        A,
        I;
      if (m.fn) {
        switch ((m.once && this.removeListener(c, m.fn, void 0, !0), C)) {
          case 1:
            return (m.fn.call(m.context), !0);
          case 2:
            return (m.fn.call(m.context, u), !0);
          case 3:
            return (m.fn.call(m.context, u, h), !0);
          case 4:
            return (m.fn.call(m.context, u, h, d), !0);
          case 5:
            return (m.fn.call(m.context, u, h, d, f), !0);
          case 6:
            return (m.fn.call(m.context, u, h, d, f, g), !0);
        }
        for (I = 1, A = new Array(C - 1); I < C; I++) A[I - 1] = arguments[I];
        m.fn.apply(m.context, A);
      } else {
        var y = m.length,
          x;
        for (I = 0; I < y; I++)
          switch (
            (m[I].once && this.removeListener(c, m[I].fn, void 0, !0), C)
          ) {
            case 1:
              m[I].fn.call(m[I].context);
              break;
            case 2:
              m[I].fn.call(m[I].context, u);
              break;
            case 3:
              m[I].fn.call(m[I].context, u, h);
              break;
            case 4:
              m[I].fn.call(m[I].context, u, h, d);
              break;
            default:
              if (!A)
                for (x = 1, A = new Array(C - 1); x < C; x++)
                  A[x - 1] = arguments[x];
              m[I].fn.apply(m[I].context, A);
          }
      }
      return !0;
    }),
    (a.prototype.on = function (c, u, h) {
      return s(this, c, u, h, !1);
    }),
    (a.prototype.once = function (c, u, h) {
      return s(this, c, u, h, !0);
    }),
    (a.prototype.removeListener = function (c, u, h, d) {
      var f = t ? t + c : c;
      if (!this._events[f]) return this;
      if (!u) return (o(this, f), this);
      var g = this._events[f];
      if (g.fn)
        g.fn === u && (!d || g.once) && (!h || g.context === h) && o(this, f);
      else {
        for (var p = 0, m = [], C = g.length; p < C; p++)
          (g[p].fn !== u || (d && !g[p].once) || (h && g[p].context !== h)) &&
            m.push(g[p]);
        m.length ? (this._events[f] = m.length === 1 ? m[0] : m) : o(this, f);
      }
      return this;
    }),
    (a.prototype.removeAllListeners = function (c) {
      var u;
      return (
        c
          ? ((u = t ? t + c : c), this._events[u] && o(this, u))
          : ((this._events = new i()), (this._eventsCount = 0)),
        this
      );
    }),
    (a.prototype.off = a.prototype.removeListener),
    (a.prototype.addListener = a.prototype.on),
    (a.prefixed = t),
    (a.EventEmitter = a),
    (n.exports = a));
})(FB);
var Tce = FB.exports;
const Lp = pp(Tce);
var m5 = { exports: {} };
m5.exports = dI;
m5.exports.default = dI;
function dI(n, e, t) {
  t = t || 2;
  var i = e && e.length,
    r = i ? e[0] * t : n.length,
    s = kB(n, 0, r, t, !0),
    o = [];
  if (!s || s.next === s.prev) return o;
  var a, l, c, u, h, d, f;
  if ((i && (s = Bce(n, e, s, t)), n.length > 80 * t)) {
    ((a = c = n[0]), (l = u = n[1]));
    for (var g = t; g < r; g += t)
      ((h = n[g]),
        (d = n[g + 1]),
        h < a && (a = h),
        d < l && (l = d),
        h > c && (c = h),
        d > u && (u = d));
    ((f = Math.max(c - a, u - l)), (f = f !== 0 ? 32767 / f : 0));
  }
  return (Yg(s, o, t, a, l, f, 0), o);
}
function kB(n, e, t, i, r) {
  var s, o;
  if (r === b3(n, e, t, i) > 0)
    for (s = e; s < t; s += i) o = FS(s, n[s], n[s + 1], o);
  else for (s = t - i; s >= e; s -= i) o = FS(s, n[s], n[s + 1], o);
  return (o && fI(o, o.next) && (Kg(o), (o = o.next)), o);
}
function mu(n, e) {
  if (!n) return n;
  e || (e = n);
  var t = n,
    i;
  do
    if (
      ((i = !1), !t.steiner && (fI(t, t.next) || Un(t.prev, t, t.next) === 0))
    ) {
      if ((Kg(t), (t = e = t.prev), t === t.next)) break;
      i = !0;
    } else t = t.next;
  while (i || t !== e);
  return e;
}
function Yg(n, e, t, i, r, s, o) {
  if (n) {
    !o && s && Fce(n, i, r, s);
    for (var a = n, l, c; n.prev !== n.next; ) {
      if (((l = n.prev), (c = n.next), s ? Mce(n, i, r, s) : Ece(n))) {
        (e.push((l.i / t) | 0),
          e.push((n.i / t) | 0),
          e.push((c.i / t) | 0),
          Kg(n),
          (n = c.next),
          (a = c.next));
        continue;
      }
      if (((n = c), n === a)) {
        o
          ? o === 1
            ? ((n = Lce(mu(n), e, t)), Yg(n, e, t, i, r, s, 2))
            : o === 2 && Rce(n, e, t, i, r, s)
          : Yg(mu(n), e, t, i, r, s, 1);
        break;
      }
    }
  }
}
function Ece(n) {
  var e = n.prev,
    t = n,
    i = n.next;
  if (Un(e, t, i) >= 0) return !1;
  for (
    var r = e.x,
      s = t.x,
      o = i.x,
      a = e.y,
      l = t.y,
      c = i.y,
      u = r < s ? (r < o ? r : o) : s < o ? s : o,
      h = a < l ? (a < c ? a : c) : l < c ? l : c,
      d = r > s ? (r > o ? r : o) : s > o ? s : o,
      f = a > l ? (a > c ? a : c) : l > c ? l : c,
      g = i.next;
    g !== e;
  ) {
    if (
      g.x >= u &&
      g.x <= d &&
      g.y >= h &&
      g.y <= f &&
      vh(r, a, s, l, o, c, g.x, g.y) &&
      Un(g.prev, g, g.next) >= 0
    )
      return !1;
    g = g.next;
  }
  return !0;
}
function Mce(n, e, t, i) {
  var r = n.prev,
    s = n,
    o = n.next;
  if (Un(r, s, o) >= 0) return !1;
  for (
    var a = r.x,
      l = s.x,
      c = o.x,
      u = r.y,
      h = s.y,
      d = o.y,
      f = a < l ? (a < c ? a : c) : l < c ? l : c,
      g = u < h ? (u < d ? u : d) : h < d ? h : d,
      p = a > l ? (a > c ? a : c) : l > c ? l : c,
      m = u > h ? (u > d ? u : d) : h > d ? h : d,
      C = y3(f, g, e, t, i),
      A = y3(p, m, e, t, i),
      I = n.prevZ,
      y = n.nextZ;
    I && I.z >= C && y && y.z <= A;
  ) {
    if (
      (I.x >= f &&
        I.x <= p &&
        I.y >= g &&
        I.y <= m &&
        I !== r &&
        I !== o &&
        vh(a, u, l, h, c, d, I.x, I.y) &&
        Un(I.prev, I, I.next) >= 0) ||
      ((I = I.prevZ),
      y.x >= f &&
        y.x <= p &&
        y.y >= g &&
        y.y <= m &&
        y !== r &&
        y !== o &&
        vh(a, u, l, h, c, d, y.x, y.y) &&
        Un(y.prev, y, y.next) >= 0)
    )
      return !1;
    y = y.nextZ;
  }
  for (; I && I.z >= C; ) {
    if (
      I.x >= f &&
      I.x <= p &&
      I.y >= g &&
      I.y <= m &&
      I !== r &&
      I !== o &&
      vh(a, u, l, h, c, d, I.x, I.y) &&
      Un(I.prev, I, I.next) >= 0
    )
      return !1;
    I = I.prevZ;
  }
  for (; y && y.z <= A; ) {
    if (
      y.x >= f &&
      y.x <= p &&
      y.y >= g &&
      y.y <= m &&
      y !== r &&
      y !== o &&
      vh(a, u, l, h, c, d, y.x, y.y) &&
      Un(y.prev, y, y.next) >= 0
    )
      return !1;
    y = y.nextZ;
  }
  return !0;
}
function Lce(n, e, t) {
  var i = n;
  do {
    var r = i.prev,
      s = i.next.next;
    (!fI(r, s) &&
      OB(r, i, i.next, s) &&
      Xg(r, s) &&
      Xg(s, r) &&
      (e.push((r.i / t) | 0),
      e.push((i.i / t) | 0),
      e.push((s.i / t) | 0),
      Kg(i),
      Kg(i.next),
      (i = n = s)),
      (i = i.next));
  } while (i !== n);
  return mu(i);
}
function Rce(n, e, t, i, r, s) {
  var o = n;
  do {
    for (var a = o.next.next; a !== o.prev; ) {
      if (o.i !== a.i && Uce(o, a)) {
        var l = UB(o, a);
        ((o = mu(o, o.next)),
          (l = mu(l, l.next)),
          Yg(o, e, t, i, r, s, 0),
          Yg(l, e, t, i, r, s, 0));
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== n);
}
function Bce(n, e, t, i) {
  var r = [],
    s,
    o,
    a,
    l,
    c;
  for (s = 0, o = e.length; s < o; s++)
    ((a = e[s] * i),
      (l = s < o - 1 ? e[s + 1] * i : n.length),
      (c = kB(n, a, l, i, !1)),
      c === c.next && (c.steiner = !0),
      r.push(Oce(c)));
  for (r.sort(Pce), s = 0; s < r.length; s++) t = Nce(r[s], t);
  return t;
}
function Pce(n, e) {
  return n.x - e.x;
}
function Nce(n, e) {
  var t = Dce(n, e);
  if (!t) return e;
  var i = UB(t, n);
  return (mu(i, i.next), mu(t, t.next));
}
function Dce(n, e) {
  var t = e,
    i = n.x,
    r = n.y,
    s = -1 / 0,
    o;
  do {
    if (r <= t.y && r >= t.next.y && t.next.y !== t.y) {
      var a = t.x + ((r - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
      if (
        a <= i &&
        a > s &&
        ((s = a), (o = t.x < t.next.x ? t : t.next), a === i)
      )
        return o;
    }
    t = t.next;
  } while (t !== e);
  if (!o) return null;
  var l = o,
    c = o.x,
    u = o.y,
    h = 1 / 0,
    d;
  t = o;
  do
    (i >= t.x &&
      t.x >= c &&
      i !== t.x &&
      vh(r < u ? i : s, r, c, u, r < u ? s : i, r, t.x, t.y) &&
      ((d = Math.abs(r - t.y) / (i - t.x)),
      Xg(t, n) &&
        (d < h || (d === h && (t.x > o.x || (t.x === o.x && Gce(o, t))))) &&
        ((o = t), (h = d))),
      (t = t.next));
  while (t !== l);
  return o;
}
function Gce(n, e) {
  return Un(n.prev, n, e.prev) < 0 && Un(e.next, n, n.next) < 0;
}
function Fce(n, e, t, i) {
  var r = n;
  do
    (r.z === 0 && (r.z = y3(r.x, r.y, e, t, i)),
      (r.prevZ = r.prev),
      (r.nextZ = r.next),
      (r = r.next));
  while (r !== n);
  ((r.prevZ.nextZ = null), (r.prevZ = null), kce(r));
}
function kce(n) {
  var e,
    t,
    i,
    r,
    s,
    o,
    a,
    l,
    c = 1;
  do {
    for (t = n, n = null, s = null, o = 0; t; ) {
      for (o++, i = t, a = 0, e = 0; e < c && (a++, (i = i.nextZ), !!i); e++);
      for (l = c; a > 0 || (l > 0 && i); )
        (a !== 0 && (l === 0 || !i || t.z <= i.z)
          ? ((r = t), (t = t.nextZ), a--)
          : ((r = i), (i = i.nextZ), l--),
          s ? (s.nextZ = r) : (n = r),
          (r.prevZ = s),
          (s = r));
      t = i;
    }
    ((s.nextZ = null), (c *= 2));
  } while (o > 1);
  return n;
}
function y3(n, e, t, i, r) {
  return (
    (n = ((n - t) * r) | 0),
    (e = ((e - i) * r) | 0),
    (n = (n | (n << 8)) & 16711935),
    (n = (n | (n << 4)) & 252645135),
    (n = (n | (n << 2)) & 858993459),
    (n = (n | (n << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    n | (e << 1)
  );
}
function Oce(n) {
  var e = n,
    t = n;
  do ((e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next));
  while (e !== n);
  return t;
}
function vh(n, e, t, i, r, s, o, a) {
  return (
    (r - o) * (e - a) >= (n - o) * (s - a) &&
    (n - o) * (i - a) >= (t - o) * (e - a) &&
    (t - o) * (s - a) >= (r - o) * (i - a)
  );
}
function Uce(n, e) {
  return (
    n.next.i !== e.i &&
    n.prev.i !== e.i &&
    !Hce(n, e) &&
    ((Xg(n, e) &&
      Xg(e, n) &&
      Wce(n, e) &&
      (Un(n.prev, n, e.prev) || Un(n, e.prev, e))) ||
      (fI(n, e) && Un(n.prev, n, n.next) > 0 && Un(e.prev, e, e.next) > 0))
  );
}
function Un(n, e, t) {
  return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y);
}
function fI(n, e) {
  return n.x === e.x && n.y === e.y;
}
function OB(n, e, t, i) {
  var r = P1(Un(n, e, t)),
    s = P1(Un(n, e, i)),
    o = P1(Un(t, i, n)),
    a = P1(Un(t, i, e));
  return !!(
    (r !== s && o !== a) ||
    (r === 0 && B1(n, t, e)) ||
    (s === 0 && B1(n, i, e)) ||
    (o === 0 && B1(t, n, i)) ||
    (a === 0 && B1(t, e, i))
  );
}
function B1(n, e, t) {
  return (
    e.x <= Math.max(n.x, t.x) &&
    e.x >= Math.min(n.x, t.x) &&
    e.y <= Math.max(n.y, t.y) &&
    e.y >= Math.min(n.y, t.y)
  );
}
function P1(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function Hce(n, e) {
  var t = n;
  do {
    if (
      t.i !== n.i &&
      t.next.i !== n.i &&
      t.i !== e.i &&
      t.next.i !== e.i &&
      OB(t, t.next, n, e)
    )
      return !0;
    t = t.next;
  } while (t !== n);
  return !1;
}
function Xg(n, e) {
  return Un(n.prev, n, n.next) < 0
    ? Un(n, e, n.next) >= 0 && Un(n, n.prev, e) >= 0
    : Un(n, e, n.prev) < 0 || Un(n, n.next, e) < 0;
}
function Wce(n, e) {
  var t = n,
    i = !1,
    r = (n.x + e.x) / 2,
    s = (n.y + e.y) / 2;
  do
    (t.y > s != t.next.y > s &&
      t.next.y !== t.y &&
      r < ((t.next.x - t.x) * (s - t.y)) / (t.next.y - t.y) + t.x &&
      (i = !i),
      (t = t.next));
  while (t !== n);
  return i;
}
function UB(n, e) {
  var t = new _3(n.i, n.x, n.y),
    i = new _3(e.i, e.x, e.y),
    r = n.next,
    s = e.prev;
  return (
    (n.next = e),
    (e.prev = n),
    (t.next = r),
    (r.prev = t),
    (i.next = t),
    (t.prev = i),
    (s.next = i),
    (i.prev = s),
    i
  );
}
function FS(n, e, t, i) {
  var r = new _3(n, e, t);
  return (
    i
      ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
      : ((r.prev = r), (r.next = r)),
    r
  );
}
function Kg(n) {
  ((n.next.prev = n.prev),
    (n.prev.next = n.next),
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ));
}
function _3(n, e, t) {
  ((this.i = n),
    (this.x = e),
    (this.y = t),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1));
}
dI.deviation = function (n, e, t, i) {
  var r = e && e.length,
    s = r ? e[0] * t : n.length,
    o = Math.abs(b3(n, 0, s, t));
  if (r)
    for (var a = 0, l = e.length; a < l; a++) {
      var c = e[a] * t,
        u = a < l - 1 ? e[a + 1] * t : n.length;
      o -= Math.abs(b3(n, c, u, t));
    }
  var h = 0;
  for (a = 0; a < i.length; a += 3) {
    var d = i[a] * t,
      f = i[a + 1] * t,
      g = i[a + 2] * t;
    h += Math.abs(
      (n[d] - n[g]) * (n[f + 1] - n[d + 1]) -
        (n[d] - n[f]) * (n[g + 1] - n[d + 1]),
    );
  }
  return o === 0 && h === 0 ? 0 : Math.abs((h - o) / o);
};
function b3(n, e, t, i) {
  for (var r = 0, s = e, o = t - i; s < t; s += i)
    ((r += (n[o] - n[s]) * (n[s + 1] + n[o + 1])), (o = s));
  return r;
}
dI.flatten = function (n) {
  for (
    var e = n[0][0].length,
      t = { vertices: [], holes: [], dimensions: e },
      i = 0,
      r = 0;
    r < n.length;
    r++
  ) {
    for (var s = 0; s < n[r].length; s++)
      for (var o = 0; o < e; o++) t.vertices.push(n[r][s][o]);
    r > 0 && ((i += n[r - 1].length), t.holes.push(i));
  }
  return t;
};
var Vce = m5.exports;
const Zce = pp(Vce);
var rC = { exports: {} };
/*! https://mths.be/punycode v1.4.1 by @mathias */ rC.exports;
(function (n, e) {
  (function (t) {
    var i = e && !e.nodeType && e,
      r = n && !n.nodeType && n,
      s = typeof C0 == "object" && C0;
    (s.global === s || s.window === s || s.self === s) && (t = s);
    var o,
      a = 2147483647,
      l = 36,
      c = 1,
      u = 26,
      h = 38,
      d = 700,
      f = 72,
      g = 128,
      p = "-",
      m = /^xn--/,
      C = /[^\x20-\x7E]/,
      A = /[\x2E\u3002\uFF0E\uFF61]/g,
      I = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input",
      },
      y = l - c,
      x = Math.floor,
      T = String.fromCharCode,
      S;
    function E(Z) {
      throw new RangeError(I[Z]);
    }
    function _(Z, te) {
      for (var ge = Z.length, be = []; ge--; ) be[ge] = te(Z[ge]);
      return be;
    }
    function b(Z, te) {
      var ge = Z.split("@"),
        be = "";
      (ge.length > 1 && ((be = ge[0] + "@"), (Z = ge[1])),
        (Z = Z.replace(A, ".")));
      var J = Z.split("."),
        se = _(J, te).join(".");
      return be + se;
    }
    function R(Z) {
      for (var te = [], ge = 0, be = Z.length, J, se; ge < be; )
        ((J = Z.charCodeAt(ge++)),
          J >= 55296 && J <= 56319 && ge < be
            ? ((se = Z.charCodeAt(ge++)),
              (se & 64512) == 56320
                ? te.push(((J & 1023) << 10) + (se & 1023) + 65536)
                : (te.push(J), ge--))
            : te.push(J));
      return te;
    }
    function M(Z) {
      return _(Z, function (te) {
        var ge = "";
        return (
          te > 65535 &&
            ((te -= 65536),
            (ge += T(((te >>> 10) & 1023) | 55296)),
            (te = 56320 | (te & 1023))),
          (ge += T(te)),
          ge
        );
      }).join("");
    }
    function L(Z) {
      return Z - 48 < 10
        ? Z - 22
        : Z - 65 < 26
          ? Z - 65
          : Z - 97 < 26
            ? Z - 97
            : l;
    }
    function P(Z, te) {
      return Z + 22 + 75 * (Z < 26) - ((te != 0) << 5);
    }
    function U(Z, te, ge) {
      var be = 0;
      for (
        Z = ge ? x(Z / d) : Z >> 1, Z += x(Z / te);
        Z > (y * u) >> 1;
        be += l
      )
        Z = x(Z / y);
      return x(be + ((y + 1) * Z) / (Z + h));
    }
    function O(Z) {
      var te = [],
        ge = Z.length,
        be,
        J = 0,
        se = g,
        ce = f,
        ae,
        Ce,
        $e,
        Te,
        it,
        ct,
        qe,
        H,
        tn;
      for (ae = Z.lastIndexOf(p), ae < 0 && (ae = 0), Ce = 0; Ce < ae; ++Ce)
        (Z.charCodeAt(Ce) >= 128 && E("not-basic"), te.push(Z.charCodeAt(Ce)));
      for ($e = ae > 0 ? ae + 1 : 0; $e < ge; ) {
        for (
          Te = J, it = 1, ct = l;
          $e >= ge && E("invalid-input"),
            (qe = L(Z.charCodeAt($e++))),
            (qe >= l || qe > x((a - J) / it)) && E("overflow"),
            (J += qe * it),
            (H = ct <= ce ? c : ct >= ce + u ? u : ct - ce),
            !(qe < H);
          ct += l
        )
          ((tn = l - H), it > x(a / tn) && E("overflow"), (it *= tn));
        ((be = te.length + 1),
          (ce = U(J - Te, be, Te == 0)),
          x(J / be) > a - se && E("overflow"),
          (se += x(J / be)),
          (J %= be),
          te.splice(J++, 0, se));
      }
      return M(te);
    }
    function V(Z) {
      var te,
        ge,
        be,
        J,
        se,
        ce,
        ae,
        Ce,
        $e,
        Te,
        it,
        ct = [],
        qe,
        H,
        tn,
        Mt;
      for (
        Z = R(Z), qe = Z.length, te = g, ge = 0, se = f, ce = 0;
        ce < qe;
        ++ce
      )
        ((it = Z[ce]), it < 128 && ct.push(T(it)));
      for (be = J = ct.length, J && ct.push(p); be < qe; ) {
        for (ae = a, ce = 0; ce < qe; ++ce)
          ((it = Z[ce]), it >= te && it < ae && (ae = it));
        for (
          H = be + 1,
            ae - te > x((a - ge) / H) && E("overflow"),
            ge += (ae - te) * H,
            te = ae,
            ce = 0;
          ce < qe;
          ++ce
        )
          if (((it = Z[ce]), it < te && ++ge > a && E("overflow"), it == te)) {
            for (
              Ce = ge, $e = l;
              (Te = $e <= se ? c : $e >= se + u ? u : $e - se), !(Ce < Te);
              $e += l
            )
              ((Mt = Ce - Te),
                (tn = l - Te),
                ct.push(T(P(Te + (Mt % tn), 0))),
                (Ce = x(Mt / tn)));
            (ct.push(T(P(Ce, 0))), (se = U(ge, H, be == J)), (ge = 0), ++be);
          }
        (++ge, ++te);
      }
      return ct.join("");
    }
    function W(Z) {
      return b(Z, function (te) {
        return m.test(te) ? O(te.slice(4).toLowerCase()) : te;
      });
    }
    function re(Z) {
      return b(Z, function (te) {
        return C.test(te) ? "xn--" + V(te) : te;
      });
    }
    if (
      ((o = {
        version: "1.4.1",
        ucs2: { decode: R, encode: M },
        decode: O,
        encode: V,
        toASCII: re,
        toUnicode: W,
      }),
      i && r)
    )
      if (n.exports == i) r.exports = o;
      else for (S in o) o.hasOwnProperty(S) && (i[S] = o[S]);
    else t.punycode = o;
  })(C0);
})(rC, rC.exports);
var zce = rC.exports,
  Yce = function () {
    if (
      typeof Symbol != "function" ||
      typeof Object.getOwnPropertySymbols != "function"
    )
      return !1;
    if (typeof Symbol.iterator == "symbol") return !0;
    var e = {},
      t = Symbol("test"),
      i = Object(t);
    if (
      typeof t == "string" ||
      Object.prototype.toString.call(t) !== "[object Symbol]" ||
      Object.prototype.toString.call(i) !== "[object Symbol]"
    )
      return !1;
    var r = 42;
    e[t] = r;
    for (t in e) return !1;
    if (
      (typeof Object.keys == "function" && Object.keys(e).length !== 0) ||
      (typeof Object.getOwnPropertyNames == "function" &&
        Object.getOwnPropertyNames(e).length !== 0)
    )
      return !1;
    var s = Object.getOwnPropertySymbols(e);
    if (
      s.length !== 1 ||
      s[0] !== t ||
      !Object.prototype.propertyIsEnumerable.call(e, t)
    )
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var o = Object.getOwnPropertyDescriptor(e, t);
      if (o.value !== r || o.enumerable !== !0) return !1;
    }
    return !0;
  },
  kS = typeof Symbol < "u" && Symbol,
  Xce = Yce,
  Kce = function () {
    return typeof kS != "function" ||
      typeof Symbol != "function" ||
      typeof kS("foo") != "symbol" ||
      typeof Symbol("bar") != "symbol"
      ? !1
      : Xce();
  },
  OS = { foo: {} },
  jce = Object,
  $ce = function () {
    return (
      { __proto__: OS }.foo === OS.foo && !({ __proto__: null } instanceof jce)
    );
  },
  Jce = "Function.prototype.bind called on incompatible ",
  fA = Array.prototype.slice,
  Qce = Object.prototype.toString,
  qce = "[object Function]",
  eue = function (e) {
    var t = this;
    if (typeof t != "function" || Qce.call(t) !== qce)
      throw new TypeError(Jce + t);
    for (
      var i = fA.call(arguments, 1),
        r,
        s = function () {
          if (this instanceof r) {
            var u = t.apply(this, i.concat(fA.call(arguments)));
            return Object(u) === u ? u : this;
          } else return t.apply(e, i.concat(fA.call(arguments)));
        },
        o = Math.max(0, t.length - i.length),
        a = [],
        l = 0;
      l < o;
      l++
    )
      a.push("$" + l);
    if (
      ((r = Function(
        "binder",
        "return function (" +
          a.join(",") +
          "){ return binder.apply(this,arguments); }",
      )(s)),
      t.prototype)
    ) {
      var c = function () {};
      ((c.prototype = t.prototype),
        (r.prototype = new c()),
        (c.prototype = null));
    }
    return r;
  },
  tue = eue,
  HB = Function.prototype.bind || tue,
  US = {}.hasOwnProperty,
  gA = Function.prototype.call,
  nue = gA.bind
    ? gA.bind(US)
    : function (n, e) {
        return gA.call(US, n, e);
      },
  Zt,
  Ad = SyntaxError,
  WB = Function,
  Hh = TypeError,
  pA = function (n) {
    try {
      return WB('"use strict"; return (' + n + ").constructor;")();
    } catch {}
  },
  su = Object.getOwnPropertyDescriptor;
if (su)
  try {
    su({}, "");
  } catch {
    su = null;
  }
var mA = function () {
    throw new Hh();
  },
  iue = su
    ? (function () {
        try {
          return (arguments.callee, mA);
        } catch {
          try {
            return su(arguments, "callee").get;
          } catch {
            return mA;
          }
        }
      })()
    : mA,
  qu = Kce(),
  rue = $ce(),
  wi =
    Object.getPrototypeOf ||
    (rue
      ? function (n) {
          return n.__proto__;
        }
      : null),
  oh = {},
  sue = typeof Uint8Array > "u" || !wi ? Zt : wi(Uint8Array),
  ou = {
    "%AggregateError%": typeof AggregateError > "u" ? Zt : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Zt : ArrayBuffer,
    "%ArrayIteratorPrototype%": qu && wi ? wi([][Symbol.iterator]()) : Zt,
    "%AsyncFromSyncIteratorPrototype%": Zt,
    "%AsyncFunction%": oh,
    "%AsyncGenerator%": oh,
    "%AsyncGeneratorFunction%": oh,
    "%AsyncIteratorPrototype%": oh,
    "%Atomics%": typeof Atomics > "u" ? Zt : Atomics,
    "%BigInt%": typeof BigInt > "u" ? Zt : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? Zt : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? Zt : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? Zt : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%eval%": eval,
    "%EvalError%": EvalError,
    "%Float32Array%": typeof Float32Array > "u" ? Zt : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? Zt : Float64Array,
    "%FinalizationRegistry%":
      typeof FinalizationRegistry > "u" ? Zt : FinalizationRegistry,
    "%Function%": WB,
    "%GeneratorFunction%": oh,
    "%Int8Array%": typeof Int8Array > "u" ? Zt : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? Zt : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? Zt : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": qu && wi ? wi(wi([][Symbol.iterator]())) : Zt,
    "%JSON%": typeof JSON == "object" ? JSON : Zt,
    "%Map%": typeof Map > "u" ? Zt : Map,
    "%MapIteratorPrototype%":
      typeof Map > "u" || !qu || !wi ? Zt : wi(new Map()[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? Zt : Promise,
    "%Proxy%": typeof Proxy > "u" ? Zt : Proxy,
    "%RangeError%": RangeError,
    "%ReferenceError%": ReferenceError,
    "%Reflect%": typeof Reflect > "u" ? Zt : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? Zt : Set,
    "%SetIteratorPrototype%":
      typeof Set > "u" || !qu || !wi ? Zt : wi(new Set()[Symbol.iterator]()),
    "%SharedArrayBuffer%":
      typeof SharedArrayBuffer > "u" ? Zt : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": qu && wi ? wi(""[Symbol.iterator]()) : Zt,
    "%Symbol%": qu ? Symbol : Zt,
    "%SyntaxError%": Ad,
    "%ThrowTypeError%": iue,
    "%TypedArray%": sue,
    "%TypeError%": Hh,
    "%Uint8Array%": typeof Uint8Array > "u" ? Zt : Uint8Array,
    "%Uint8ClampedArray%":
      typeof Uint8ClampedArray > "u" ? Zt : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? Zt : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? Zt : Uint32Array,
    "%URIError%": URIError,
    "%WeakMap%": typeof WeakMap > "u" ? Zt : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? Zt : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? Zt : WeakSet,
  };
if (wi)
  try {
    null.error;
  } catch (n) {
    var oue = wi(wi(n));
    ou["%Error.prototype%"] = oue;
  }
var aue = function n(e) {
    var t;
    if (e === "%AsyncFunction%") t = pA("async function () {}");
    else if (e === "%GeneratorFunction%") t = pA("function* () {}");
    else if (e === "%AsyncGeneratorFunction%") t = pA("async function* () {}");
    else if (e === "%AsyncGenerator%") {
      var i = n("%AsyncGeneratorFunction%");
      i && (t = i.prototype);
    } else if (e === "%AsyncIteratorPrototype%") {
      var r = n("%AsyncGenerator%");
      r && wi && (t = wi(r.prototype));
    }
    return ((ou[e] = t), t);
  },
  HS = {
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": [
      "AsyncGeneratorFunction",
      "prototype",
      "prototype",
    ],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"],
  },
  Rp = HB,
  sC = nue,
  lue = Rp.call(Function.call, Array.prototype.concat),
  cue = Rp.call(Function.apply, Array.prototype.splice),
  WS = Rp.call(Function.call, String.prototype.replace),
  oC = Rp.call(Function.call, String.prototype.slice),
  uue = Rp.call(Function.call, RegExp.prototype.exec),
  hue =
    /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
  due = /\\(\\)?/g,
  fue = function (e) {
    var t = oC(e, 0, 1),
      i = oC(e, -1);
    if (t === "%" && i !== "%")
      throw new Ad("invalid intrinsic syntax, expected closing `%`");
    if (i === "%" && t !== "%")
      throw new Ad("invalid intrinsic syntax, expected opening `%`");
    var r = [];
    return (
      WS(e, hue, function (s, o, a, l) {
        r[r.length] = a ? WS(l, due, "$1") : o || s;
      }),
      r
    );
  },
  gue = function (e, t) {
    var i = e,
      r;
    if ((sC(HS, i) && ((r = HS[i]), (i = "%" + r[0] + "%")), sC(ou, i))) {
      var s = ou[i];
      if ((s === oh && (s = aue(i)), typeof s > "u" && !t))
        throw new Hh(
          "intrinsic " +
            e +
            " exists, but is not available. Please file an issue!",
        );
      return { alias: r, name: i, value: s };
    }
    throw new Ad("intrinsic " + e + " does not exist!");
  },
  C5 = function (e, t) {
    if (typeof e != "string" || e.length === 0)
      throw new Hh("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof t != "boolean")
      throw new Hh('"allowMissing" argument must be a boolean');
    if (uue(/^%?[^%]*%?$/, e) === null)
      throw new Ad(
        "`%` may not be present anywhere but at the beginning and end of the intrinsic name",
      );
    var i = fue(e),
      r = i.length > 0 ? i[0] : "",
      s = gue("%" + r + "%", t),
      o = s.name,
      a = s.value,
      l = !1,
      c = s.alias;
    c && ((r = c[0]), cue(i, lue([0, 1], c)));
    for (var u = 1, h = !0; u < i.length; u += 1) {
      var d = i[u],
        f = oC(d, 0, 1),
        g = oC(d, -1);
      if (
        (f === '"' ||
          f === "'" ||
          f === "`" ||
          g === '"' ||
          g === "'" ||
          g === "`") &&
        f !== g
      )
        throw new Ad("property names with quotes must have matching quotes");
      if (
        ((d === "constructor" || !h) && (l = !0),
        (r += "." + d),
        (o = "%" + r + "%"),
        sC(ou, o))
      )
        a = ou[o];
      else if (a != null) {
        if (!(d in a)) {
          if (!t)
            throw new Hh(
              "base intrinsic for " +
                e +
                " exists, but the property is not available.",
            );
          return;
        }
        if (su && u + 1 >= i.length) {
          var p = su(a, d);
          ((h = !!p),
            h && "get" in p && !("originalValue" in p.get)
              ? (a = p.get)
              : (a = a[d]));
        } else ((h = sC(a, d)), (a = a[d]));
        h && !l && (ou[o] = a);
      }
    }
    return a;
  },
  VB = { exports: {} };
(function (n) {
  var e = HB,
    t = C5,
    i = t("%Function.prototype.apply%"),
    r = t("%Function.prototype.call%"),
    s = t("%Reflect.apply%", !0) || e.call(r, i),
    o = t("%Object.getOwnPropertyDescriptor%", !0),
    a = t("%Object.defineProperty%", !0),
    l = t("%Math.max%");
  if (a)
    try {
      a({}, "a", { value: 1 });
    } catch {
      a = null;
    }
  n.exports = function (h) {
    var d = s(e, r, arguments);
    if (o && a) {
      var f = o(d, "length");
      f.configurable &&
        a(d, "length", { value: 1 + l(0, h.length - (arguments.length - 1)) });
    }
    return d;
  };
  var c = function () {
    return s(e, i, arguments);
  };
  a ? a(n.exports, "apply", { value: c }) : (n.exports.apply = c);
})(VB);
var pue = VB.exports,
  ZB = C5,
  zB = pue,
  mue = zB(ZB("String.prototype.indexOf")),
  Cue = function (e, t) {
    var i = ZB(e, !!t);
    return typeof i == "function" && mue(e, ".prototype.") > -1 ? zB(i) : i;
  },
  I5 = typeof Map == "function" && Map.prototype,
  CA =
    Object.getOwnPropertyDescriptor && I5
      ? Object.getOwnPropertyDescriptor(Map.prototype, "size")
      : null,
  aC = I5 && CA && typeof CA.get == "function" ? CA.get : null,
  VS = I5 && Map.prototype.forEach,
  A5 = typeof Set == "function" && Set.prototype,
  IA =
    Object.getOwnPropertyDescriptor && A5
      ? Object.getOwnPropertyDescriptor(Set.prototype, "size")
      : null,
  lC = A5 && IA && typeof IA.get == "function" ? IA.get : null,
  ZS = A5 && Set.prototype.forEach,
  Iue = typeof WeakMap == "function" && WeakMap.prototype,
  cg = Iue ? WeakMap.prototype.has : null,
  Aue = typeof WeakSet == "function" && WeakSet.prototype,
  ug = Aue ? WeakSet.prototype.has : null,
  yue = typeof WeakRef == "function" && WeakRef.prototype,
  zS = yue ? WeakRef.prototype.deref : null,
  _ue = Boolean.prototype.valueOf,
  bue = Object.prototype.toString,
  vue = Function.prototype.toString,
  xue = String.prototype.match,
  y5 = String.prototype.slice,
  _l = String.prototype.replace,
  wue = String.prototype.toUpperCase,
  YS = String.prototype.toLowerCase,
  YB = RegExp.prototype.test,
  XS = Array.prototype.concat,
  Io = Array.prototype.join,
  Sue = Array.prototype.slice,
  KS = Math.floor,
  v3 = typeof BigInt == "function" ? BigInt.prototype.valueOf : null,
  AA = Object.getOwnPropertySymbols,
  x3 =
    typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
      ? Symbol.prototype.toString
      : null,
  yd = typeof Symbol == "function" && typeof Symbol.iterator == "object",
  ir =
    typeof Symbol == "function" &&
    Symbol.toStringTag &&
    (typeof Symbol.toStringTag === yd || "symbol")
      ? Symbol.toStringTag
      : null,
  XB = Object.prototype.propertyIsEnumerable,
  jS =
    (typeof Reflect == "function"
      ? Reflect.getPrototypeOf
      : Object.getPrototypeOf) ||
    ([].__proto__ === Array.prototype
      ? function (n) {
          return n.__proto__;
        }
      : null);
function $S(n, e) {
  if (
    n === 1 / 0 ||
    n === -1 / 0 ||
    n !== n ||
    (n && n > -1e3 && n < 1e3) ||
    YB.call(/e/, e)
  )
    return e;
  var t = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof n == "number") {
    var i = n < 0 ? -KS(-n) : KS(n);
    if (i !== n) {
      var r = String(i),
        s = y5.call(e, r.length + 1);
      return (
        _l.call(r, t, "$&_") +
        "." +
        _l.call(_l.call(s, /([0-9]{3})/g, "$&_"), /_$/, "")
      );
    }
  }
  return _l.call(e, t, "$&_");
}
var w3 = Sv,
  JS = w3.custom,
  QS = jB(JS) ? JS : null,
  Tue = function n(e, t, i, r) {
    var s = t || {};
    if (
      cl(s, "quoteStyle") &&
      s.quoteStyle !== "single" &&
      s.quoteStyle !== "double"
    )
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    if (
      cl(s, "maxStringLength") &&
      (typeof s.maxStringLength == "number"
        ? s.maxStringLength < 0 && s.maxStringLength !== 1 / 0
        : s.maxStringLength !== null)
    )
      throw new TypeError(
        'option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`',
      );
    var o = cl(s, "customInspect") ? s.customInspect : !0;
    if (typeof o != "boolean" && o !== "symbol")
      throw new TypeError(
        "option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`",
      );
    if (
      cl(s, "indent") &&
      s.indent !== null &&
      s.indent !== "	" &&
      !(parseInt(s.indent, 10) === s.indent && s.indent > 0)
    )
      throw new TypeError(
        'option "indent" must be "\\t", an integer > 0, or `null`',
      );
    if (cl(s, "numericSeparator") && typeof s.numericSeparator != "boolean")
      throw new TypeError(
        'option "numericSeparator", if provided, must be `true` or `false`',
      );
    var a = s.numericSeparator;
    if (typeof e > "u") return "undefined";
    if (e === null) return "null";
    if (typeof e == "boolean") return e ? "true" : "false";
    if (typeof e == "string") return JB(e, s);
    if (typeof e == "number") {
      if (e === 0) return 1 / 0 / e > 0 ? "0" : "-0";
      var l = String(e);
      return a ? $S(e, l) : l;
    }
    if (typeof e == "bigint") {
      var c = String(e) + "n";
      return a ? $S(e, c) : c;
    }
    var u = typeof s.depth > "u" ? 5 : s.depth;
    if ((typeof i > "u" && (i = 0), i >= u && u > 0 && typeof e == "object"))
      return S3(e) ? "[Array]" : "[Object]";
    var h = zue(s, i);
    if (typeof r > "u") r = [];
    else if ($B(r, e) >= 0) return "[Circular]";
    function d(L, P, U) {
      if ((P && ((r = Sue.call(r)), r.push(P)), U)) {
        var O = { depth: s.depth };
        return (
          cl(s, "quoteStyle") && (O.quoteStyle = s.quoteStyle),
          n(L, O, i + 1, r)
        );
      }
      return n(L, s, i + 1, r);
    }
    if (typeof e == "function" && !qS(e)) {
      var f = Gue(e),
        g = N1(e, d);
      return (
        "[Function" +
        (f ? ": " + f : " (anonymous)") +
        "]" +
        (g.length > 0 ? " { " + Io.call(g, ", ") + " }" : "")
      );
    }
    if (jB(e)) {
      var p = yd
        ? _l.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1")
        : x3.call(e);
      return typeof e == "object" && !yd ? _f(p) : p;
    }
    if (Wue(e)) {
      for (
        var m = "<" + YS.call(String(e.nodeName)),
          C = e.attributes || [],
          A = 0;
        A < C.length;
        A++
      )
        m += " " + C[A].name + "=" + KB(Eue(C[A].value), "double", s);
      return (
        (m += ">"),
        e.childNodes && e.childNodes.length && (m += "..."),
        (m += "</" + YS.call(String(e.nodeName)) + ">"),
        m
      );
    }
    if (S3(e)) {
      if (e.length === 0) return "[]";
      var I = N1(e, d);
      return h && !Zue(I)
        ? "[" + T3(I, h) + "]"
        : "[ " + Io.call(I, ", ") + " ]";
    }
    if (Lue(e)) {
      var y = N1(e, d);
      return !("cause" in Error.prototype) &&
        "cause" in e &&
        !XB.call(e, "cause")
        ? "{ [" +
            String(e) +
            "] " +
            Io.call(XS.call("[cause]: " + d(e.cause), y), ", ") +
            " }"
        : y.length === 0
          ? "[" + String(e) + "]"
          : "{ [" + String(e) + "] " + Io.call(y, ", ") + " }";
    }
    if (typeof e == "object" && o) {
      if (QS && typeof e[QS] == "function" && w3)
        return w3(e, { depth: u - i });
      if (o !== "symbol" && typeof e.inspect == "function") return e.inspect();
    }
    if (Fue(e)) {
      var x = [];
      return (
        VS &&
          VS.call(e, function (L, P) {
            x.push(d(P, e, !0) + " => " + d(L, e));
          }),
        e6("Map", aC.call(e), x, h)
      );
    }
    if (Uue(e)) {
      var T = [];
      return (
        ZS &&
          ZS.call(e, function (L) {
            T.push(d(L, e));
          }),
        e6("Set", lC.call(e), T, h)
      );
    }
    if (kue(e)) return yA("WeakMap");
    if (Hue(e)) return yA("WeakSet");
    if (Oue(e)) return yA("WeakRef");
    if (Bue(e)) return _f(d(Number(e)));
    if (Nue(e)) return _f(d(v3.call(e)));
    if (Pue(e)) return _f(_ue.call(e));
    if (Rue(e)) return _f(d(String(e)));
    if (!Mue(e) && !qS(e)) {
      var S = N1(e, d),
        E = jS
          ? jS(e) === Object.prototype
          : e instanceof Object || e.constructor === Object,
        _ = e instanceof Object ? "" : "null prototype",
        b =
          !E && ir && Object(e) === e && ir in e
            ? y5.call(Yl(e), 8, -1)
            : _
              ? "Object"
              : "",
        R =
          E || typeof e.constructor != "function"
            ? ""
            : e.constructor.name
              ? e.constructor.name + " "
              : "",
        M =
          R +
          (b || _
            ? "[" + Io.call(XS.call([], b || [], _ || []), ": ") + "] "
            : "");
      return S.length === 0
        ? M + "{}"
        : h
          ? M + "{" + T3(S, h) + "}"
          : M + "{ " + Io.call(S, ", ") + " }";
    }
    return String(e);
  };
function KB(n, e, t) {
  var i = (t.quoteStyle || e) === "double" ? '"' : "'";
  return i + n + i;
}
function Eue(n) {
  return _l.call(String(n), /"/g, "&quot;");
}
function S3(n) {
  return (
    Yl(n) === "[object Array]" && (!ir || !(typeof n == "object" && ir in n))
  );
}
function Mue(n) {
  return (
    Yl(n) === "[object Date]" && (!ir || !(typeof n == "object" && ir in n))
  );
}
function qS(n) {
  return (
    Yl(n) === "[object RegExp]" && (!ir || !(typeof n == "object" && ir in n))
  );
}
function Lue(n) {
  return (
    Yl(n) === "[object Error]" && (!ir || !(typeof n == "object" && ir in n))
  );
}
function Rue(n) {
  return (
    Yl(n) === "[object String]" && (!ir || !(typeof n == "object" && ir in n))
  );
}
function Bue(n) {
  return (
    Yl(n) === "[object Number]" && (!ir || !(typeof n == "object" && ir in n))
  );
}
function Pue(n) {
  return (
    Yl(n) === "[object Boolean]" && (!ir || !(typeof n == "object" && ir in n))
  );
}
function jB(n) {
  if (yd) return n && typeof n == "object" && n instanceof Symbol;
  if (typeof n == "symbol") return !0;
  if (!n || typeof n != "object" || !x3) return !1;
  try {
    return (x3.call(n), !0);
  } catch {}
  return !1;
}
function Nue(n) {
  if (!n || typeof n != "object" || !v3) return !1;
  try {
    return (v3.call(n), !0);
  } catch {}
  return !1;
}
var Due =
  Object.prototype.hasOwnProperty ||
  function (n) {
    return n in this;
  };
function cl(n, e) {
  return Due.call(n, e);
}
function Yl(n) {
  return bue.call(n);
}
function Gue(n) {
  if (n.name) return n.name;
  var e = xue.call(vue.call(n), /^function\s*([\w$]+)/);
  return e ? e[1] : null;
}
function $B(n, e) {
  if (n.indexOf) return n.indexOf(e);
  for (var t = 0, i = n.length; t < i; t++) if (n[t] === e) return t;
  return -1;
}
function Fue(n) {
  if (!aC || !n || typeof n != "object") return !1;
  try {
    aC.call(n);
    try {
      lC.call(n);
    } catch {
      return !0;
    }
    return n instanceof Map;
  } catch {}
  return !1;
}
function kue(n) {
  if (!cg || !n || typeof n != "object") return !1;
  try {
    cg.call(n, cg);
    try {
      ug.call(n, ug);
    } catch {
      return !0;
    }
    return n instanceof WeakMap;
  } catch {}
  return !1;
}
function Oue(n) {
  if (!zS || !n || typeof n != "object") return !1;
  try {
    return (zS.call(n), !0);
  } catch {}
  return !1;
}
function Uue(n) {
  if (!lC || !n || typeof n != "object") return !1;
  try {
    lC.call(n);
    try {
      aC.call(n);
    } catch {
      return !0;
    }
    return n instanceof Set;
  } catch {}
  return !1;
}
function Hue(n) {
  if (!ug || !n || typeof n != "object") return !1;
  try {
    ug.call(n, ug);
    try {
      cg.call(n, cg);
    } catch {
      return !0;
    }
    return n instanceof WeakSet;
  } catch {}
  return !1;
}
function Wue(n) {
  return !n || typeof n != "object"
    ? !1
    : typeof HTMLElement < "u" && n instanceof HTMLElement
      ? !0
      : typeof n.nodeName == "string" && typeof n.getAttribute == "function";
}
function JB(n, e) {
  if (n.length > e.maxStringLength) {
    var t = n.length - e.maxStringLength,
      i = "... " + t + " more character" + (t > 1 ? "s" : "");
    return JB(y5.call(n, 0, e.maxStringLength), e) + i;
  }
  var r = _l.call(_l.call(n, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, Vue);
  return KB(r, "single", e);
}
function Vue(n) {
  var e = n.charCodeAt(0),
    t = { 8: "b", 9: "t", 10: "n", 12: "f", 13: "r" }[e];
  return t ? "\\" + t : "\\x" + (e < 16 ? "0" : "") + wue.call(e.toString(16));
}
function _f(n) {
  return "Object(" + n + ")";
}
function yA(n) {
  return n + " { ? }";
}
function e6(n, e, t, i) {
  var r = i ? T3(t, i) : Io.call(t, ", ");
  return n + " (" + e + ") {" + r + "}";
}
function Zue(n) {
  for (var e = 0; e < n.length; e++)
    if (
      $B(
        n[e],
        `
`,
      ) >= 0
    )
      return !1;
  return !0;
}
function zue(n, e) {
  var t;
  if (n.indent === "	") t = "	";
  else if (typeof n.indent == "number" && n.indent > 0)
    t = Io.call(Array(n.indent + 1), " ");
  else return null;
  return { base: t, prev: Io.call(Array(e + 1), t) };
}
function T3(n, e) {
  if (n.length === 0) return "";
  var t =
    `
` +
    e.prev +
    e.base;
  return (
    t +
    Io.call(n, "," + t) +
    `
` +
    e.prev
  );
}
function N1(n, e) {
  var t = S3(n),
    i = [];
  if (t) {
    i.length = n.length;
    for (var r = 0; r < n.length; r++) i[r] = cl(n, r) ? e(n[r], n) : "";
  }
  var s = typeof AA == "function" ? AA(n) : [],
    o;
  if (yd) {
    o = {};
    for (var a = 0; a < s.length; a++) o["$" + s[a]] = s[a];
  }
  for (var l in n)
    cl(n, l) &&
      ((t && String(Number(l)) === l && l < n.length) ||
        (yd && o["$" + l] instanceof Symbol) ||
        (YB.call(/[^\w$]/, l)
          ? i.push(e(l, n) + ": " + e(n[l], n))
          : i.push(l + ": " + e(n[l], n))));
  if (typeof AA == "function")
    for (var c = 0; c < s.length; c++)
      XB.call(n, s[c]) && i.push("[" + e(s[c]) + "]: " + e(n[s[c]], n));
  return i;
}
var _5 = C5,
  jd = Cue,
  Yue = Tue,
  Xue = _5("%TypeError%"),
  D1 = _5("%WeakMap%", !0),
  G1 = _5("%Map%", !0),
  Kue = jd("WeakMap.prototype.get", !0),
  jue = jd("WeakMap.prototype.set", !0),
  $ue = jd("WeakMap.prototype.has", !0),
  Jue = jd("Map.prototype.get", !0),
  Que = jd("Map.prototype.set", !0),
  que = jd("Map.prototype.has", !0),
  b5 = function (n, e) {
    for (var t = n, i; (i = t.next) !== null; t = i)
      if (i.key === e)
        return ((t.next = i.next), (i.next = n.next), (n.next = i), i);
  },
  ehe = function (n, e) {
    var t = b5(n, e);
    return t && t.value;
  },
  the = function (n, e, t) {
    var i = b5(n, e);
    i ? (i.value = t) : (n.next = { key: e, next: n.next, value: t });
  },
  nhe = function (n, e) {
    return !!b5(n, e);
  },
  ihe = function () {
    var e,
      t,
      i,
      r = {
        assert: function (s) {
          if (!r.has(s))
            throw new Xue("Side channel does not contain " + Yue(s));
        },
        get: function (s) {
          if (D1 && s && (typeof s == "object" || typeof s == "function")) {
            if (e) return Kue(e, s);
          } else if (G1) {
            if (t) return Jue(t, s);
          } else if (i) return ehe(i, s);
        },
        has: function (s) {
          if (D1 && s && (typeof s == "object" || typeof s == "function")) {
            if (e) return $ue(e, s);
          } else if (G1) {
            if (t) return que(t, s);
          } else if (i) return nhe(i, s);
          return !1;
        },
        set: function (s, o) {
          D1 && s && (typeof s == "object" || typeof s == "function")
            ? (e || (e = new D1()), jue(e, s, o))
            : G1
              ? (t || (t = new G1()), Que(t, s, o))
              : (i || (i = { key: {}, next: null }), the(i, s, o));
        },
      };
    return r;
  },
  rhe = String.prototype.replace,
  she = /%20/g,
  _A = { RFC1738: "RFC1738", RFC3986: "RFC3986" },
  v5 = {
    default: _A.RFC3986,
    formatters: {
      RFC1738: function (n) {
        return rhe.call(n, she, "+");
      },
      RFC3986: function (n) {
        return String(n);
      },
    },
    RFC1738: _A.RFC1738,
    RFC3986: _A.RFC3986,
  },
  ohe = v5,
  bA = Object.prototype.hasOwnProperty,
  Oc = Array.isArray,
  ao = (function () {
    for (var n = [], e = 0; e < 256; ++e)
      n.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
    return n;
  })(),
  ahe = function (e) {
    for (; e.length > 1; ) {
      var t = e.pop(),
        i = t.obj[t.prop];
      if (Oc(i)) {
        for (var r = [], s = 0; s < i.length; ++s)
          typeof i[s] < "u" && r.push(i[s]);
        t.obj[t.prop] = r;
      }
    }
  },
  QB = function (e, t) {
    for (
      var i = t && t.plainObjects ? Object.create(null) : {}, r = 0;
      r < e.length;
      ++r
    )
      typeof e[r] < "u" && (i[r] = e[r]);
    return i;
  },
  lhe = function n(e, t, i) {
    if (!t) return e;
    if (typeof t != "object") {
      if (Oc(e)) e.push(t);
      else if (e && typeof e == "object")
        ((i && (i.plainObjects || i.allowPrototypes)) ||
          !bA.call(Object.prototype, t)) &&
          (e[t] = !0);
      else return [e, t];
      return e;
    }
    if (!e || typeof e != "object") return [e].concat(t);
    var r = e;
    return (
      Oc(e) && !Oc(t) && (r = QB(e, i)),
      Oc(e) && Oc(t)
        ? (t.forEach(function (s, o) {
            if (bA.call(e, o)) {
              var a = e[o];
              a && typeof a == "object" && s && typeof s == "object"
                ? (e[o] = n(a, s, i))
                : e.push(s);
            } else e[o] = s;
          }),
          e)
        : Object.keys(t).reduce(function (s, o) {
            var a = t[o];
            return (bA.call(s, o) ? (s[o] = n(s[o], a, i)) : (s[o] = a), s);
          }, r)
    );
  },
  che = function (e, t) {
    return Object.keys(t).reduce(function (i, r) {
      return ((i[r] = t[r]), i);
    }, e);
  },
  uhe = function (n, e, t) {
    var i = n.replace(/\+/g, " ");
    if (t === "iso-8859-1") return i.replace(/%[0-9a-f]{2}/gi, unescape);
    try {
      return decodeURIComponent(i);
    } catch {
      return i;
    }
  },
  hhe = function (e, t, i, r, s) {
    if (e.length === 0) return e;
    var o = e;
    if (
      (typeof e == "symbol"
        ? (o = Symbol.prototype.toString.call(e))
        : typeof e != "string" && (o = String(e)),
      i === "iso-8859-1")
    )
      return escape(o).replace(/%u[0-9a-f]{4}/gi, function (u) {
        return "%26%23" + parseInt(u.slice(2), 16) + "%3B";
      });
    for (var a = "", l = 0; l < o.length; ++l) {
      var c = o.charCodeAt(l);
      if (
        c === 45 ||
        c === 46 ||
        c === 95 ||
        c === 126 ||
        (c >= 48 && c <= 57) ||
        (c >= 65 && c <= 90) ||
        (c >= 97 && c <= 122) ||
        (s === ohe.RFC1738 && (c === 40 || c === 41))
      ) {
        a += o.charAt(l);
        continue;
      }
      if (c < 128) {
        a = a + ao[c];
        continue;
      }
      if (c < 2048) {
        a = a + (ao[192 | (c >> 6)] + ao[128 | (c & 63)]);
        continue;
      }
      if (c < 55296 || c >= 57344) {
        a =
          a +
          (ao[224 | (c >> 12)] +
            ao[128 | ((c >> 6) & 63)] +
            ao[128 | (c & 63)]);
        continue;
      }
      ((l += 1),
        (c = 65536 + (((c & 1023) << 10) | (o.charCodeAt(l) & 1023))),
        (a +=
          ao[240 | (c >> 18)] +
          ao[128 | ((c >> 12) & 63)] +
          ao[128 | ((c >> 6) & 63)] +
          ao[128 | (c & 63)]));
    }
    return a;
  },
  dhe = function (e) {
    for (
      var t = [{ obj: { o: e }, prop: "o" }], i = [], r = 0;
      r < t.length;
      ++r
    )
      for (
        var s = t[r], o = s.obj[s.prop], a = Object.keys(o), l = 0;
        l < a.length;
        ++l
      ) {
        var c = a[l],
          u = o[c];
        typeof u == "object" &&
          u !== null &&
          i.indexOf(u) === -1 &&
          (t.push({ obj: o, prop: c }), i.push(u));
      }
    return (ahe(t), e);
  },
  fhe = function (e) {
    return Object.prototype.toString.call(e) === "[object RegExp]";
  },
  ghe = function (e) {
    return !e || typeof e != "object"
      ? !1
      : !!(
          e.constructor &&
          e.constructor.isBuffer &&
          e.constructor.isBuffer(e)
        );
  },
  phe = function (e, t) {
    return [].concat(e, t);
  },
  mhe = function (e, t) {
    if (Oc(e)) {
      for (var i = [], r = 0; r < e.length; r += 1) i.push(t(e[r]));
      return i;
    }
    return t(e);
  },
  qB = {
    arrayToObject: QB,
    assign: che,
    combine: phe,
    compact: dhe,
    decode: uhe,
    encode: hhe,
    isBuffer: ghe,
    isRegExp: fhe,
    maybeMap: mhe,
    merge: lhe,
  },
  eP = ihe,
  j0 = qB,
  hg = v5,
  Che = Object.prototype.hasOwnProperty,
  t6 = {
    brackets: function (e) {
      return e + "[]";
    },
    comma: "comma",
    indices: function (e, t) {
      return e + "[" + t + "]";
    },
    repeat: function (e) {
      return e;
    },
  },
  fa = Array.isArray,
  Ihe = Array.prototype.push,
  tP = function (n, e) {
    Ihe.apply(n, fa(e) ? e : [e]);
  },
  Ahe = Date.prototype.toISOString,
  n6 = hg.default,
  Zi = {
    addQueryPrefix: !1,
    allowDots: !1,
    charset: "utf-8",
    charsetSentinel: !1,
    delimiter: "&",
    encode: !0,
    encoder: j0.encode,
    encodeValuesOnly: !1,
    format: n6,
    formatter: hg.formatters[n6],
    indices: !1,
    serializeDate: function (e) {
      return Ahe.call(e);
    },
    skipNulls: !1,
    strictNullHandling: !1,
  },
  yhe = function (e) {
    return (
      typeof e == "string" ||
      typeof e == "number" ||
      typeof e == "boolean" ||
      typeof e == "symbol" ||
      typeof e == "bigint"
    );
  },
  vA = {},
  _he = function n(e, t, i, r, s, o, a, l, c, u, h, d, f, g, p, m) {
    for (var C = e, A = m, I = 0, y = !1; (A = A.get(vA)) !== void 0 && !y; ) {
      var x = A.get(e);
      if (((I += 1), typeof x < "u")) {
        if (x === I) throw new RangeError("Cyclic object value");
        y = !0;
      }
      typeof A.get(vA) > "u" && (I = 0);
    }
    if (
      (typeof l == "function"
        ? (C = l(t, C))
        : C instanceof Date
          ? (C = h(C))
          : i === "comma" &&
            fa(C) &&
            (C = j0.maybeMap(C, function (O) {
              return O instanceof Date ? h(O) : O;
            })),
      C === null)
    ) {
      if (s) return a && !g ? a(t, Zi.encoder, p, "key", d) : t;
      C = "";
    }
    if (yhe(C) || j0.isBuffer(C)) {
      if (a) {
        var T = g ? t : a(t, Zi.encoder, p, "key", d);
        return [f(T) + "=" + f(a(C, Zi.encoder, p, "value", d))];
      }
      return [f(t) + "=" + f(String(C))];
    }
    var S = [];
    if (typeof C > "u") return S;
    var E;
    if (i === "comma" && fa(C))
      (g && a && (C = j0.maybeMap(C, a)),
        (E = [{ value: C.length > 0 ? C.join(",") || null : void 0 }]));
    else if (fa(l)) E = l;
    else {
      var _ = Object.keys(C);
      E = c ? _.sort(c) : _;
    }
    for (
      var b = r && fa(C) && C.length === 1 ? t + "[]" : t, R = 0;
      R < E.length;
      ++R
    ) {
      var M = E[R],
        L = typeof M == "object" && typeof M.value < "u" ? M.value : C[M];
      if (!(o && L === null)) {
        var P = fa(C)
          ? typeof i == "function"
            ? i(b, M)
            : b
          : b + (u ? "." + M : "[" + M + "]");
        m.set(e, I);
        var U = eP();
        (U.set(vA, m),
          tP(
            S,
            n(
              L,
              P,
              i,
              r,
              s,
              o,
              i === "comma" && g && fa(C) ? null : a,
              l,
              c,
              u,
              h,
              d,
              f,
              g,
              p,
              U,
            ),
          ));
      }
    }
    return S;
  },
  bhe = function (e) {
    if (!e) return Zi;
    if (
      e.encoder !== null &&
      typeof e.encoder < "u" &&
      typeof e.encoder != "function"
    )
      throw new TypeError("Encoder has to be a function.");
    var t = e.charset || Zi.charset;
    if (
      typeof e.charset < "u" &&
      e.charset !== "utf-8" &&
      e.charset !== "iso-8859-1"
    )
      throw new TypeError(
        "The charset option must be either utf-8, iso-8859-1, or undefined",
      );
    var i = hg.default;
    if (typeof e.format < "u") {
      if (!Che.call(hg.formatters, e.format))
        throw new TypeError("Unknown format option provided.");
      i = e.format;
    }
    var r = hg.formatters[i],
      s = Zi.filter;
    return (
      (typeof e.filter == "function" || fa(e.filter)) && (s = e.filter),
      {
        addQueryPrefix:
          typeof e.addQueryPrefix == "boolean"
            ? e.addQueryPrefix
            : Zi.addQueryPrefix,
        allowDots: typeof e.allowDots > "u" ? Zi.allowDots : !!e.allowDots,
        charset: t,
        charsetSentinel:
          typeof e.charsetSentinel == "boolean"
            ? e.charsetSentinel
            : Zi.charsetSentinel,
        delimiter: typeof e.delimiter > "u" ? Zi.delimiter : e.delimiter,
        encode: typeof e.encode == "boolean" ? e.encode : Zi.encode,
        encoder: typeof e.encoder == "function" ? e.encoder : Zi.encoder,
        encodeValuesOnly:
          typeof e.encodeValuesOnly == "boolean"
            ? e.encodeValuesOnly
            : Zi.encodeValuesOnly,
        filter: s,
        format: i,
        formatter: r,
        serializeDate:
          typeof e.serializeDate == "function"
            ? e.serializeDate
            : Zi.serializeDate,
        skipNulls: typeof e.skipNulls == "boolean" ? e.skipNulls : Zi.skipNulls,
        sort: typeof e.sort == "function" ? e.sort : null,
        strictNullHandling:
          typeof e.strictNullHandling == "boolean"
            ? e.strictNullHandling
            : Zi.strictNullHandling,
      }
    );
  },
  vhe = function (n, e) {
    var t = n,
      i = bhe(e),
      r,
      s;
    typeof i.filter == "function"
      ? ((s = i.filter), (t = s("", t)))
      : fa(i.filter) && ((s = i.filter), (r = s));
    var o = [];
    if (typeof t != "object" || t === null) return "";
    var a;
    e && e.arrayFormat in t6
      ? (a = e.arrayFormat)
      : e && "indices" in e
        ? (a = e.indices ? "indices" : "repeat")
        : (a = "indices");
    var l = t6[a];
    if (e && "commaRoundTrip" in e && typeof e.commaRoundTrip != "boolean")
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    var c = l === "comma" && e && e.commaRoundTrip;
    (r || (r = Object.keys(t)), i.sort && r.sort(i.sort));
    for (var u = eP(), h = 0; h < r.length; ++h) {
      var d = r[h];
      (i.skipNulls && t[d] === null) ||
        tP(
          o,
          _he(
            t[d],
            d,
            l,
            c,
            i.strictNullHandling,
            i.skipNulls,
            i.encode ? i.encoder : null,
            i.filter,
            i.sort,
            i.allowDots,
            i.serializeDate,
            i.format,
            i.formatter,
            i.encodeValuesOnly,
            i.charset,
            u,
          ),
        );
    }
    var f = o.join(i.delimiter),
      g = i.addQueryPrefix === !0 ? "?" : "";
    return (
      i.charsetSentinel &&
        (i.charset === "iso-8859-1"
          ? (g += "utf8=%26%2310003%3B&")
          : (g += "utf8=%E2%9C%93&")),
      f.length > 0 ? g + f : ""
    );
  },
  _d = qB,
  E3 = Object.prototype.hasOwnProperty,
  xhe = Array.isArray,
  vi = {
    allowDots: !1,
    allowPrototypes: !1,
    allowSparse: !1,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: !1,
    comma: !1,
    decoder: _d.decode,
    delimiter: "&",
    depth: 5,
    ignoreQueryPrefix: !1,
    interpretNumericEntities: !1,
    parameterLimit: 1e3,
    parseArrays: !0,
    plainObjects: !1,
    strictNullHandling: !1,
  },
  whe = function (n) {
    return n.replace(/&#(\d+);/g, function (e, t) {
      return String.fromCharCode(parseInt(t, 10));
    });
  },
  nP = function (n, e) {
    return n && typeof n == "string" && e.comma && n.indexOf(",") > -1
      ? n.split(",")
      : n;
  },
  She = "utf8=%26%2310003%3B",
  The = "utf8=%E2%9C%93",
  Ehe = function (e, t) {
    var i = { __proto__: null },
      r = t.ignoreQueryPrefix ? e.replace(/^\?/, "") : e,
      s = t.parameterLimit === 1 / 0 ? void 0 : t.parameterLimit,
      o = r.split(t.delimiter, s),
      a = -1,
      l,
      c = t.charset;
    if (t.charsetSentinel)
      for (l = 0; l < o.length; ++l)
        o[l].indexOf("utf8=") === 0 &&
          (o[l] === The ? (c = "utf-8") : o[l] === She && (c = "iso-8859-1"),
          (a = l),
          (l = o.length));
    for (l = 0; l < o.length; ++l)
      if (l !== a) {
        var u = o[l],
          h = u.indexOf("]="),
          d = h === -1 ? u.indexOf("=") : h + 1,
          f,
          g;
        (d === -1
          ? ((f = t.decoder(u, vi.decoder, c, "key")),
            (g = t.strictNullHandling ? null : ""))
          : ((f = t.decoder(u.slice(0, d), vi.decoder, c, "key")),
            (g = _d.maybeMap(nP(u.slice(d + 1), t), function (p) {
              return t.decoder(p, vi.decoder, c, "value");
            }))),
          g && t.interpretNumericEntities && c === "iso-8859-1" && (g = whe(g)),
          u.indexOf("[]=") > -1 && (g = xhe(g) ? [g] : g),
          E3.call(i, f) ? (i[f] = _d.combine(i[f], g)) : (i[f] = g));
      }
    return i;
  },
  Mhe = function (n, e, t, i) {
    for (var r = i ? e : nP(e, t), s = n.length - 1; s >= 0; --s) {
      var o,
        a = n[s];
      if (a === "[]" && t.parseArrays) o = [].concat(r);
      else {
        o = t.plainObjects ? Object.create(null) : {};
        var l =
            a.charAt(0) === "[" && a.charAt(a.length - 1) === "]"
              ? a.slice(1, -1)
              : a,
          c = parseInt(l, 10);
        !t.parseArrays && l === ""
          ? (o = { 0: r })
          : !isNaN(c) &&
              a !== l &&
              String(c) === l &&
              c >= 0 &&
              t.parseArrays &&
              c <= t.arrayLimit
            ? ((o = []), (o[c] = r))
            : l !== "__proto__" && (o[l] = r);
      }
      r = o;
    }
    return r;
  },
  Lhe = function (e, t, i, r) {
    if (e) {
      var s = i.allowDots ? e.replace(/\.([^.[]+)/g, "[$1]") : e,
        o = /(\[[^[\]]*])/,
        a = /(\[[^[\]]*])/g,
        l = i.depth > 0 && o.exec(s),
        c = l ? s.slice(0, l.index) : s,
        u = [];
      if (c) {
        if (
          !i.plainObjects &&
          E3.call(Object.prototype, c) &&
          !i.allowPrototypes
        )
          return;
        u.push(c);
      }
      for (
        var h = 0;
        i.depth > 0 && (l = a.exec(s)) !== null && h < i.depth;
      ) {
        if (
          ((h += 1),
          !i.plainObjects &&
            E3.call(Object.prototype, l[1].slice(1, -1)) &&
            !i.allowPrototypes)
        )
          return;
        u.push(l[1]);
      }
      return (l && u.push("[" + s.slice(l.index) + "]"), Mhe(u, t, i, r));
    }
  },
  Rhe = function (e) {
    if (!e) return vi;
    if (
      e.decoder !== null &&
      e.decoder !== void 0 &&
      typeof e.decoder != "function"
    )
      throw new TypeError("Decoder has to be a function.");
    if (
      typeof e.charset < "u" &&
      e.charset !== "utf-8" &&
      e.charset !== "iso-8859-1"
    )
      throw new TypeError(
        "The charset option must be either utf-8, iso-8859-1, or undefined",
      );
    var t = typeof e.charset > "u" ? vi.charset : e.charset;
    return {
      allowDots: typeof e.allowDots > "u" ? vi.allowDots : !!e.allowDots,
      allowPrototypes:
        typeof e.allowPrototypes == "boolean"
          ? e.allowPrototypes
          : vi.allowPrototypes,
      allowSparse:
        typeof e.allowSparse == "boolean" ? e.allowSparse : vi.allowSparse,
      arrayLimit:
        typeof e.arrayLimit == "number" ? e.arrayLimit : vi.arrayLimit,
      charset: t,
      charsetSentinel:
        typeof e.charsetSentinel == "boolean"
          ? e.charsetSentinel
          : vi.charsetSentinel,
      comma: typeof e.comma == "boolean" ? e.comma : vi.comma,
      decoder: typeof e.decoder == "function" ? e.decoder : vi.decoder,
      delimiter:
        typeof e.delimiter == "string" || _d.isRegExp(e.delimiter)
          ? e.delimiter
          : vi.delimiter,
      depth: typeof e.depth == "number" || e.depth === !1 ? +e.depth : vi.depth,
      ignoreQueryPrefix: e.ignoreQueryPrefix === !0,
      interpretNumericEntities:
        typeof e.interpretNumericEntities == "boolean"
          ? e.interpretNumericEntities
          : vi.interpretNumericEntities,
      parameterLimit:
        typeof e.parameterLimit == "number"
          ? e.parameterLimit
          : vi.parameterLimit,
      parseArrays: e.parseArrays !== !1,
      plainObjects:
        typeof e.plainObjects == "boolean" ? e.plainObjects : vi.plainObjects,
      strictNullHandling:
        typeof e.strictNullHandling == "boolean"
          ? e.strictNullHandling
          : vi.strictNullHandling,
    };
  },
  Bhe = function (n, e) {
    var t = Rhe(e);
    if (n === "" || n === null || typeof n > "u")
      return t.plainObjects ? Object.create(null) : {};
    for (
      var i = typeof n == "string" ? Ehe(n, t) : n,
        r = t.plainObjects ? Object.create(null) : {},
        s = Object.keys(i),
        o = 0;
      o < s.length;
      ++o
    ) {
      var a = s[o],
        l = Lhe(a, i[a], t, typeof n == "string");
      r = _d.merge(r, l, t);
    }
    return t.allowSparse === !0 ? r : _d.compact(r);
  },
  Phe = vhe,
  Nhe = Bhe,
  Dhe = v5,
  Ghe = { formats: Dhe, parse: Nhe, stringify: Phe },
  Fhe = zce;
function Ea() {
  ((this.protocol = null),
    (this.slashes = null),
    (this.auth = null),
    (this.host = null),
    (this.port = null),
    (this.hostname = null),
    (this.hash = null),
    (this.search = null),
    (this.query = null),
    (this.pathname = null),
    (this.path = null),
    (this.href = null));
}
var khe = /^([a-z0-9.+-]+:)/i,
  Ohe = /:[0-9]*$/,
  Uhe = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/,
  Hhe = [
    "<",
    ">",
    '"',
    "`",
    " ",
    "\r",
    `
`,
    "	",
  ],
  Whe = ["{", "}", "|", "\\", "^", "`"].concat(Hhe),
  M3 = ["'"].concat(Whe),
  i6 = ["%", "/", "?", ";", "#"].concat(M3),
  r6 = ["/", "?", "#"],
  Vhe = 255,
  s6 = /^[+a-z0-9A-Z_-]{0,63}$/,
  Zhe = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
  zhe = { javascript: !0, "javascript:": !0 },
  L3 = { javascript: !0, "javascript:": !0 },
  Wh = {
    http: !0,
    https: !0,
    ftp: !0,
    gopher: !0,
    file: !0,
    "http:": !0,
    "https:": !0,
    "ftp:": !0,
    "gopher:": !0,
    "file:": !0,
  },
  R3 = Ghe;
function Yhe(n, e, t) {
  if (n && typeof n == "object" && n instanceof Ea) return n;
  var i = new Ea();
  return (i.parse(n, e, t), i);
}
Ea.prototype.parse = function (n, e, t) {
  if (typeof n != "string")
    throw new TypeError("Parameter 'url' must be a string, not " + typeof n);
  var i = n.indexOf("?"),
    r = i !== -1 && i < n.indexOf("#") ? "?" : "#",
    s = n.split(r),
    o = /\\/g;
  ((s[0] = s[0].replace(o, "/")), (n = s.join(r)));
  var a = n;
  if (((a = a.trim()), !t && n.split("#").length === 1)) {
    var l = Uhe.exec(a);
    if (l)
      return (
        (this.path = a),
        (this.href = a),
        (this.pathname = l[1]),
        l[2]
          ? ((this.search = l[2]),
            e
              ? (this.query = R3.parse(this.search.substr(1)))
              : (this.query = this.search.substr(1)))
          : e && ((this.search = ""), (this.query = {})),
        this
      );
  }
  var c = khe.exec(a);
  if (c) {
    c = c[0];
    var u = c.toLowerCase();
    ((this.protocol = u), (a = a.substr(c.length)));
  }
  if (t || c || a.match(/^\/\/[^@/]+@[^@/]+/)) {
    var h = a.substr(0, 2) === "//";
    h && !(c && L3[c]) && ((a = a.substr(2)), (this.slashes = !0));
  }
  if (!L3[c] && (h || (c && !Wh[c]))) {
    for (var d = -1, f = 0; f < r6.length; f++) {
      var g = a.indexOf(r6[f]);
      g !== -1 && (d === -1 || g < d) && (d = g);
    }
    var p, m;
    (d === -1 ? (m = a.lastIndexOf("@")) : (m = a.lastIndexOf("@", d)),
      m !== -1 &&
        ((p = a.slice(0, m)),
        (a = a.slice(m + 1)),
        (this.auth = decodeURIComponent(p))),
      (d = -1));
    for (var f = 0; f < i6.length; f++) {
      var g = a.indexOf(i6[f]);
      g !== -1 && (d === -1 || g < d) && (d = g);
    }
    (d === -1 && (d = a.length),
      (this.host = a.slice(0, d)),
      (a = a.slice(d)),
      this.parseHost(),
      (this.hostname = this.hostname || ""));
    var C =
      this.hostname[0] === "[" &&
      this.hostname[this.hostname.length - 1] === "]";
    if (!C)
      for (var A = this.hostname.split(/\./), f = 0, I = A.length; f < I; f++) {
        var y = A[f];
        if (y && !y.match(s6)) {
          for (var x = "", T = 0, S = y.length; T < S; T++)
            y.charCodeAt(T) > 127 ? (x += "x") : (x += y[T]);
          if (!x.match(s6)) {
            var E = A.slice(0, f),
              _ = A.slice(f + 1),
              b = y.match(Zhe);
            (b && (E.push(b[1]), _.unshift(b[2])),
              _.length && (a = "/" + _.join(".") + a),
              (this.hostname = E.join(".")));
            break;
          }
        }
      }
    (this.hostname.length > Vhe
      ? (this.hostname = "")
      : (this.hostname = this.hostname.toLowerCase()),
      C || (this.hostname = Fhe.toASCII(this.hostname)));
    var R = this.port ? ":" + this.port : "",
      M = this.hostname || "";
    ((this.host = M + R),
      (this.href += this.host),
      C &&
        ((this.hostname = this.hostname.substr(1, this.hostname.length - 2)),
        a[0] !== "/" && (a = "/" + a)));
  }
  if (!zhe[u])
    for (var f = 0, I = M3.length; f < I; f++) {
      var L = M3[f];
      if (a.indexOf(L) !== -1) {
        var P = encodeURIComponent(L);
        (P === L && (P = escape(L)), (a = a.split(L).join(P)));
      }
    }
  var U = a.indexOf("#");
  U !== -1 && ((this.hash = a.substr(U)), (a = a.slice(0, U)));
  var O = a.indexOf("?");
  if (
    (O !== -1
      ? ((this.search = a.substr(O)),
        (this.query = a.substr(O + 1)),
        e && (this.query = R3.parse(this.query)),
        (a = a.slice(0, O)))
      : e && ((this.search = ""), (this.query = {})),
    a && (this.pathname = a),
    Wh[u] && this.hostname && !this.pathname && (this.pathname = "/"),
    this.pathname || this.search)
  ) {
    var R = this.pathname || "",
      V = this.search || "";
    this.path = R + V;
  }
  return ((this.href = this.format()), this);
};
Ea.prototype.format = function () {
  var n = this.auth || "";
  n && ((n = encodeURIComponent(n)), (n = n.replace(/%3A/i, ":")), (n += "@"));
  var e = this.protocol || "",
    t = this.pathname || "",
    i = this.hash || "",
    r = !1,
    s = "";
  (this.host
    ? (r = n + this.host)
    : this.hostname &&
      ((r =
        n +
        (this.hostname.indexOf(":") === -1
          ? this.hostname
          : "[" + this.hostname + "]")),
      this.port && (r += ":" + this.port)),
    this.query &&
      typeof this.query == "object" &&
      Object.keys(this.query).length &&
      (s = R3.stringify(this.query, {
        arrayFormat: "repeat",
        addQueryPrefix: !1,
      })));
  var o = this.search || (s && "?" + s) || "";
  return (
    e && e.substr(-1) !== ":" && (e += ":"),
    this.slashes || ((!e || Wh[e]) && r !== !1)
      ? ((r = "//" + (r || "")), t && t.charAt(0) !== "/" && (t = "/" + t))
      : r || (r = ""),
    i && i.charAt(0) !== "#" && (i = "#" + i),
    o && o.charAt(0) !== "?" && (o = "?" + o),
    (t = t.replace(/[?#]/g, function (a) {
      return encodeURIComponent(a);
    })),
    (o = o.replace("#", "%23")),
    e + r + t + o + i
  );
};
Ea.prototype.resolve = function (n) {
  return this.resolveObject(Yhe(n, !1, !0)).format();
};
Ea.prototype.resolveObject = function (n) {
  if (typeof n == "string") {
    var e = new Ea();
    (e.parse(n, !1, !0), (n = e));
  }
  for (var t = new Ea(), i = Object.keys(this), r = 0; r < i.length; r++) {
    var s = i[r];
    t[s] = this[s];
  }
  if (((t.hash = n.hash), n.href === "")) return ((t.href = t.format()), t);
  if (n.slashes && !n.protocol) {
    for (var o = Object.keys(n), a = 0; a < o.length; a++) {
      var l = o[a];
      l !== "protocol" && (t[l] = n[l]);
    }
    return (
      Wh[t.protocol] &&
        t.hostname &&
        !t.pathname &&
        ((t.pathname = "/"), (t.path = t.pathname)),
      (t.href = t.format()),
      t
    );
  }
  if (n.protocol && n.protocol !== t.protocol) {
    if (!Wh[n.protocol]) {
      for (var c = Object.keys(n), u = 0; u < c.length; u++) {
        var h = c[u];
        t[h] = n[h];
      }
      return ((t.href = t.format()), t);
    }
    if (((t.protocol = n.protocol), !n.host && !L3[n.protocol])) {
      for (
        var I = (n.pathname || "").split("/");
        I.length && !(n.host = I.shift());
      );
      (n.host || (n.host = ""),
        n.hostname || (n.hostname = ""),
        I[0] !== "" && I.unshift(""),
        I.length < 2 && I.unshift(""),
        (t.pathname = I.join("/")));
    } else t.pathname = n.pathname;
    if (
      ((t.search = n.search),
      (t.query = n.query),
      (t.host = n.host || ""),
      (t.auth = n.auth),
      (t.hostname = n.hostname || n.host),
      (t.port = n.port),
      t.pathname || t.search)
    ) {
      var d = t.pathname || "",
        f = t.search || "";
      t.path = d + f;
    }
    return ((t.slashes = t.slashes || n.slashes), (t.href = t.format()), t);
  }
  var g = t.pathname && t.pathname.charAt(0) === "/",
    p = n.host || (n.pathname && n.pathname.charAt(0) === "/"),
    m = p || g || (t.host && n.pathname),
    C = m,
    A = (t.pathname && t.pathname.split("/")) || [],
    I = (n.pathname && n.pathname.split("/")) || [],
    y = t.protocol && !Wh[t.protocol];
  if (
    (y &&
      ((t.hostname = ""),
      (t.port = null),
      t.host && (A[0] === "" ? (A[0] = t.host) : A.unshift(t.host)),
      (t.host = ""),
      n.protocol &&
        ((n.hostname = null),
        (n.port = null),
        n.host && (I[0] === "" ? (I[0] = n.host) : I.unshift(n.host)),
        (n.host = null)),
      (m = m && (I[0] === "" || A[0] === ""))),
    p)
  )
    ((t.host = n.host || n.host === "" ? n.host : t.host),
      (t.hostname = n.hostname || n.hostname === "" ? n.hostname : t.hostname),
      (t.search = n.search),
      (t.query = n.query),
      (A = I));
  else if (I.length)
    (A || (A = []),
      A.pop(),
      (A = A.concat(I)),
      (t.search = n.search),
      (t.query = n.query));
  else if (n.search != null) {
    if (y) {
      ((t.host = A.shift()), (t.hostname = t.host));
      var x = t.host && t.host.indexOf("@") > 0 ? t.host.split("@") : !1;
      x &&
        ((t.auth = x.shift()), (t.hostname = x.shift()), (t.host = t.hostname));
    }
    return (
      (t.search = n.search),
      (t.query = n.query),
      (t.pathname !== null || t.search !== null) &&
        (t.path = (t.pathname ? t.pathname : "") + (t.search ? t.search : "")),
      (t.href = t.format()),
      t
    );
  }
  if (!A.length)
    return (
      (t.pathname = null),
      t.search ? (t.path = "/" + t.search) : (t.path = null),
      (t.href = t.format()),
      t
    );
  for (
    var T = A.slice(-1)[0],
      S =
        ((t.host || n.host || A.length > 1) && (T === "." || T === "..")) ||
        T === "",
      E = 0,
      _ = A.length;
    _ >= 0;
    _--
  )
    ((T = A[_]),
      T === "."
        ? A.splice(_, 1)
        : T === ".."
          ? (A.splice(_, 1), E++)
          : E && (A.splice(_, 1), E--));
  if (!m && !C) for (; E--; E) A.unshift("..");
  (m && A[0] !== "" && (!A[0] || A[0].charAt(0) !== "/") && A.unshift(""),
    S && A.join("/").substr(-1) !== "/" && A.push(""));
  var b = A[0] === "" || (A[0] && A[0].charAt(0) === "/");
  if (y) {
    ((t.hostname = b ? "" : A.length ? A.shift() : ""), (t.host = t.hostname));
    var x = t.host && t.host.indexOf("@") > 0 ? t.host.split("@") : !1;
    x &&
      ((t.auth = x.shift()), (t.hostname = x.shift()), (t.host = t.hostname));
  }
  return (
    (m = m || (t.host && A.length)),
    m && !b && A.unshift(""),
    A.length > 0
      ? (t.pathname = A.join("/"))
      : ((t.pathname = null), (t.path = null)),
    (t.pathname !== null || t.search !== null) &&
      (t.path = (t.pathname ? t.pathname : "") + (t.search ? t.search : "")),
    (t.auth = n.auth || t.auth),
    (t.slashes = t.slashes || n.slashes),
    (t.href = t.format()),
    t
  );
};
Ea.prototype.parseHost = function () {
  var n = this.host,
    e = Ohe.exec(n);
  (e &&
    ((e = e[0]),
    e !== ":" && (this.port = e.substr(1)),
    (n = n.substr(0, n.length - e.length))),
    n && (this.hostname = n));
};
const o6 = {};
function Ht(n, e, t = 3) {
  if (o6[e]) return;
  let i = new Error().stack;
  (typeof i > "u"
    ? console.warn(
        "PixiJS Deprecation Warning: ",
        `${e}
Deprecated since v${n}`,
      )
    : ((i = i
        .split(
          `
`,
        )
        .splice(t).join(`
`)),
      console.groupCollapsed
        ? (console.groupCollapsed(
            "%cPixiJS Deprecation Warning: %c%s",
            "color:#614108;background:#fffbe6",
            "font-weight:normal;color:#614108;background:#fffbe6",
            `${e}
Deprecated since v${n}`,
          ),
          console.warn(i),
          console.groupEnd())
        : (console.warn(
            "PixiJS Deprecation Warning: ",
            `${e}
Deprecated since v${n}`,
          ),
          console.warn(i))),
    (o6[e] = !0));
}
function Os(n) {
  if (typeof n != "string")
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(n)}`);
}
function bf(n) {
  return n.split("?")[0].split("#")[0];
}
function Xhe(n) {
  return n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Khe(n, e, t) {
  return n.replace(new RegExp(Xhe(e), "g"), t);
}
function jhe(n, e) {
  let t = "",
    i = 0,
    r = -1,
    s = 0,
    o = -1;
  for (let a = 0; a <= n.length; ++a) {
    if (a < n.length) o = n.charCodeAt(a);
    else {
      if (o === 47) break;
      o = 47;
    }
    if (o === 47) {
      if (!(r === a - 1 || s === 1))
        if (r !== a - 1 && s === 2) {
          if (
            t.length < 2 ||
            i !== 2 ||
            t.charCodeAt(t.length - 1) !== 46 ||
            t.charCodeAt(t.length - 2) !== 46
          ) {
            if (t.length > 2) {
              const l = t.lastIndexOf("/");
              if (l !== t.length - 1) {
                (l === -1
                  ? ((t = ""), (i = 0))
                  : ((t = t.slice(0, l)),
                    (i = t.length - 1 - t.lastIndexOf("/"))),
                  (r = a),
                  (s = 0));
                continue;
              }
            } else if (t.length === 2 || t.length === 1) {
              ((t = ""), (i = 0), (r = a), (s = 0));
              continue;
            }
          }
          e && (t.length > 0 ? (t += "/..") : (t = ".."), (i = 2));
        } else
          (t.length > 0
            ? (t += `/${n.slice(r + 1, a)}`)
            : (t = n.slice(r + 1, a)),
            (i = a - r - 1));
      ((r = a), (s = 0));
    } else o === 46 && s !== -1 ? ++s : (s = -1);
  }
  return t;
}
const mr = {
  toPosix(n) {
    return Khe(n, "\\", "/");
  },
  isUrl(n) {
    return /^https?:/.test(this.toPosix(n));
  },
  isDataUrl(n) {
    return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(
      n,
    );
  },
  isBlobUrl(n) {
    return n.startsWith("blob:");
  },
  hasProtocol(n) {
    return /^[^/:]+:/.test(this.toPosix(n));
  },
  getProtocol(n) {
    (Os(n), (n = this.toPosix(n)));
    const e = /^file:\/\/\//.exec(n);
    if (e) return e[0];
    const t = /^[^/:]+:\/{0,2}/.exec(n);
    return t ? t[0] : "";
  },
  toAbsolute(n, e, t) {
    if ((Os(n), this.isDataUrl(n) || this.isBlobUrl(n))) return n;
    const i = bf(this.toPosix(e ?? Oe.ADAPTER.getBaseUrl())),
      r = bf(this.toPosix(t ?? this.rootname(i)));
    return (
      (n = this.toPosix(n)),
      n.startsWith("/")
        ? mr.join(r, n.slice(1))
        : this.isAbsolute(n)
          ? n
          : this.join(i, n)
    );
  },
  normalize(n) {
    if ((Os(n), n.length === 0)) return ".";
    if (this.isDataUrl(n) || this.isBlobUrl(n)) return n;
    n = this.toPosix(n);
    let e = "";
    const t = n.startsWith("/");
    this.hasProtocol(n) && ((e = this.rootname(n)), (n = n.slice(e.length)));
    const i = n.endsWith("/");
    return (
      (n = jhe(n, !1)),
      n.length > 0 && i && (n += "/"),
      t ? `/${n}` : e + n
    );
  },
  isAbsolute(n) {
    return (
      Os(n),
      (n = this.toPosix(n)),
      this.hasProtocol(n) ? !0 : n.startsWith("/")
    );
  },
  join(...n) {
    if (n.length === 0) return ".";
    let e;
    for (let t = 0; t < n.length; ++t) {
      const i = n[t];
      if ((Os(i), i.length > 0))
        if (e === void 0) e = i;
        else {
          const r = n[t - 1] ?? "";
          this.extname(r) ? (e += `/../${i}`) : (e += `/${i}`);
        }
    }
    return e === void 0 ? "." : this.normalize(e);
  },
  dirname(n) {
    if ((Os(n), n.length === 0)) return ".";
    n = this.toPosix(n);
    let e = n.charCodeAt(0);
    const t = e === 47;
    let i = -1,
      r = !0;
    const s = this.getProtocol(n),
      o = n;
    n = n.slice(s.length);
    for (let a = n.length - 1; a >= 1; --a)
      if (((e = n.charCodeAt(a)), e === 47)) {
        if (!r) {
          i = a;
          break;
        }
      } else r = !1;
    return i === -1
      ? t
        ? "/"
        : this.isUrl(o)
          ? s + n
          : s
      : t && i === 1
        ? "//"
        : s + n.slice(0, i);
  },
  rootname(n) {
    (Os(n), (n = this.toPosix(n)));
    let e = "";
    if (
      (n.startsWith("/") ? (e = "/") : (e = this.getProtocol(n)), this.isUrl(n))
    ) {
      const t = n.indexOf("/", e.length);
      (t !== -1 ? (e = n.slice(0, t)) : (e = n), e.endsWith("/") || (e += "/"));
    }
    return e;
  },
  basename(n, e) {
    (Os(n), e && Os(e), (n = bf(this.toPosix(n))));
    let t = 0,
      i = -1,
      r = !0,
      s;
    if (e !== void 0 && e.length > 0 && e.length <= n.length) {
      if (e.length === n.length && e === n) return "";
      let o = e.length - 1,
        a = -1;
      for (s = n.length - 1; s >= 0; --s) {
        const l = n.charCodeAt(s);
        if (l === 47) {
          if (!r) {
            t = s + 1;
            break;
          }
        } else
          (a === -1 && ((r = !1), (a = s + 1)),
            o >= 0 &&
              (l === e.charCodeAt(o)
                ? --o === -1 && (i = s)
                : ((o = -1), (i = a))));
      }
      return (t === i ? (i = a) : i === -1 && (i = n.length), n.slice(t, i));
    }
    for (s = n.length - 1; s >= 0; --s)
      if (n.charCodeAt(s) === 47) {
        if (!r) {
          t = s + 1;
          break;
        }
      } else i === -1 && ((r = !1), (i = s + 1));
    return i === -1 ? "" : n.slice(t, i);
  },
  extname(n) {
    (Os(n), (n = bf(this.toPosix(n))));
    let e = -1,
      t = 0,
      i = -1,
      r = !0,
      s = 0;
    for (let o = n.length - 1; o >= 0; --o) {
      const a = n.charCodeAt(o);
      if (a === 47) {
        if (!r) {
          t = o + 1;
          break;
        }
        continue;
      }
      (i === -1 && ((r = !1), (i = o + 1)),
        a === 46
          ? e === -1
            ? (e = o)
            : s !== 1 && (s = 1)
          : e !== -1 && (s = -1));
    }
    return e === -1 ||
      i === -1 ||
      s === 0 ||
      (s === 1 && e === i - 1 && e === t + 1)
      ? ""
      : n.slice(e, i);
  },
  parse(n) {
    Os(n);
    const e = { root: "", dir: "", base: "", ext: "", name: "" };
    if (n.length === 0) return e;
    n = bf(this.toPosix(n));
    let t = n.charCodeAt(0);
    const i = this.isAbsolute(n);
    let r;
    ((e.root = this.rootname(n)), i || this.hasProtocol(n) ? (r = 1) : (r = 0));
    let s = -1,
      o = 0,
      a = -1,
      l = !0,
      c = n.length - 1,
      u = 0;
    for (; c >= r; --c) {
      if (((t = n.charCodeAt(c)), t === 47)) {
        if (!l) {
          o = c + 1;
          break;
        }
        continue;
      }
      (a === -1 && ((l = !1), (a = c + 1)),
        t === 46
          ? s === -1
            ? (s = c)
            : u !== 1 && (u = 1)
          : s !== -1 && (u = -1));
    }
    return (
      s === -1 || a === -1 || u === 0 || (u === 1 && s === a - 1 && s === o + 1)
        ? a !== -1 &&
          (o === 0 && i
            ? (e.base = e.name = n.slice(1, a))
            : (e.base = e.name = n.slice(o, a)))
        : (o === 0 && i
            ? ((e.name = n.slice(1, s)), (e.base = n.slice(1, a)))
            : ((e.name = n.slice(o, s)), (e.base = n.slice(o, a))),
          (e.ext = n.slice(s, a))),
      (e.dir = this.dirname(n)),
      e
    );
  },
  sep: "/",
  delimiter: ":",
};
let xA;
async function $he() {
  return (
    xA ??
      (xA = (async () => {
        const n = document.createElement("canvas").getContext("webgl");
        if (!n) return Tr.UNPACK;
        const e = await new Promise((s) => {
          const o = document.createElement("video");
          ((o.onloadeddata = () => s(o)),
            (o.onerror = () => s(null)),
            (o.autoplay = !1),
            (o.crossOrigin = "anonymous"),
            (o.preload = "auto"),
            (o.src =
              "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM="),
            o.load());
        });
        if (!e) return Tr.UNPACK;
        const t = n.createTexture();
        n.bindTexture(n.TEXTURE_2D, t);
        const i = n.createFramebuffer();
        (n.bindFramebuffer(n.FRAMEBUFFER, i),
          n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.COLOR_ATTACHMENT0,
            n.TEXTURE_2D,
            t,
            0,
          ),
          n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
          n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, n.NONE),
          n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, e));
        const r = new Uint8Array(4);
        return (
          n.readPixels(0, 0, 1, 1, n.RGBA, n.UNSIGNED_BYTE, r),
          n.deleteFramebuffer(i),
          n.deleteTexture(t),
          n.getExtension("WEBGL_lose_context")?.loseContext(),
          r[0] <= r[3] ? Tr.PMA : Tr.UNPACK
        );
      })()),
    xA
  );
}
let wA;
function Jhe() {
  return (
    typeof wA > "u" &&
      (wA = (function () {
        const n = {
          stencil: !0,
          failIfMajorPerformanceCaveat: Oe.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT,
        };
        try {
          if (!Oe.ADAPTER.getWebGLRenderingContext()) return !1;
          const e = Oe.ADAPTER.createCanvas();
          let t =
            e.getContext("webgl", n) || e.getContext("experimental-webgl", n);
          const i = !!t?.getContextAttributes()?.stencil;
          if (t) {
            const r = t.getExtension("WEBGL_lose_context");
            r && r.loseContext();
          }
          return ((t = null), i);
        } catch {
          return !1;
        }
      })()),
    wA
  );
}
var Qhe = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) },
  ra = function (n) {
    return typeof n == "string" ? n.length > 0 : typeof n == "number";
  },
  Ei = function (n, e, t) {
    return (
      e === void 0 && (e = 0),
      t === void 0 && (t = Math.pow(10, e)),
      Math.round(t * n) / t + 0
    );
  },
  bs = function (n, e, t) {
    return (
      e === void 0 && (e = 0),
      t === void 0 && (t = 1),
      n > t ? t : n > e ? n : e
    );
  },
  iP = function (n) {
    return (n = isFinite(n) ? n % 360 : 0) > 0 ? n : n + 360;
  },
  a6 = function (n) {
    return {
      r: bs(n.r, 0, 255),
      g: bs(n.g, 0, 255),
      b: bs(n.b, 0, 255),
      a: bs(n.a),
    };
  },
  SA = function (n) {
    return { r: Ei(n.r), g: Ei(n.g), b: Ei(n.b), a: Ei(n.a, 3) };
  },
  qhe = /^#([0-9a-f]{3,8})$/i,
  F1 = function (n) {
    var e = n.toString(16);
    return e.length < 2 ? "0" + e : e;
  },
  rP = function (n) {
    var e = n.r,
      t = n.g,
      i = n.b,
      r = n.a,
      s = Math.max(e, t, i),
      o = s - Math.min(e, t, i),
      a = o
        ? s === e
          ? (t - i) / o
          : s === t
            ? 2 + (i - e) / o
            : 4 + (e - t) / o
        : 0;
    return {
      h: 60 * (a < 0 ? a + 6 : a),
      s: s ? (o / s) * 100 : 0,
      v: (s / 255) * 100,
      a: r,
    };
  },
  sP = function (n) {
    var e = n.h,
      t = n.s,
      i = n.v,
      r = n.a;
    ((e = (e / 360) * 6), (t /= 100), (i /= 100));
    var s = Math.floor(e),
      o = i * (1 - t),
      a = i * (1 - (e - s) * t),
      l = i * (1 - (1 - e + s) * t),
      c = s % 6;
    return {
      r: 255 * [i, a, o, o, l, i][c],
      g: 255 * [l, i, i, a, o, o][c],
      b: 255 * [o, o, l, i, i, a][c],
      a: r,
    };
  },
  l6 = function (n) {
    return { h: iP(n.h), s: bs(n.s, 0, 100), l: bs(n.l, 0, 100), a: bs(n.a) };
  },
  c6 = function (n) {
    return { h: Ei(n.h), s: Ei(n.s), l: Ei(n.l), a: Ei(n.a, 3) };
  },
  u6 = function (n) {
    return sP(
      ((t = (e = n).s),
      {
        h: e.h,
        s:
          (t *= ((i = e.l) < 50 ? i : 100 - i) / 100) > 0
            ? ((2 * t) / (i + t)) * 100
            : 0,
        v: i + t,
        a: e.a,
      }),
    );
    var e, t, i;
  },
  dg = function (n) {
    return {
      h: (e = rP(n)).h,
      s:
        (r = ((200 - (t = e.s)) * (i = e.v)) / 100) > 0 && r < 200
          ? ((t * i) / 100 / (r <= 100 ? r : 200 - r)) * 100
          : 0,
      l: r / 2,
      a: e.a,
    };
    var e, t, i, r;
  },
  ede =
    /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
  tde =
    /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
  nde =
    /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
  ide =
    /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
  B3 = {
    string: [
      [
        function (n) {
          var e = qhe.exec(n);
          return e
            ? (n = e[1]).length <= 4
              ? {
                  r: parseInt(n[0] + n[0], 16),
                  g: parseInt(n[1] + n[1], 16),
                  b: parseInt(n[2] + n[2], 16),
                  a:
                    n.length === 4 ? Ei(parseInt(n[3] + n[3], 16) / 255, 2) : 1,
                }
              : n.length === 6 || n.length === 8
                ? {
                    r: parseInt(n.substr(0, 2), 16),
                    g: parseInt(n.substr(2, 2), 16),
                    b: parseInt(n.substr(4, 2), 16),
                    a:
                      n.length === 8
                        ? Ei(parseInt(n.substr(6, 2), 16) / 255, 2)
                        : 1,
                  }
                : null
            : null;
        },
        "hex",
      ],
      [
        function (n) {
          var e = nde.exec(n) || ide.exec(n);
          return e
            ? e[2] !== e[4] || e[4] !== e[6]
              ? null
              : a6({
                  r: Number(e[1]) / (e[2] ? 100 / 255 : 1),
                  g: Number(e[3]) / (e[4] ? 100 / 255 : 1),
                  b: Number(e[5]) / (e[6] ? 100 / 255 : 1),
                  a: e[7] === void 0 ? 1 : Number(e[7]) / (e[8] ? 100 : 1),
                })
            : null;
        },
        "rgb",
      ],
      [
        function (n) {
          var e = ede.exec(n) || tde.exec(n);
          if (!e) return null;
          var t,
            i,
            r = l6({
              h:
                ((t = e[1]),
                (i = e[2]),
                i === void 0 && (i = "deg"),
                Number(t) * (Qhe[i] || 1)),
              s: Number(e[3]),
              l: Number(e[4]),
              a: e[5] === void 0 ? 1 : Number(e[5]) / (e[6] ? 100 : 1),
            });
          return u6(r);
        },
        "hsl",
      ],
    ],
    object: [
      [
        function (n) {
          var e = n.r,
            t = n.g,
            i = n.b,
            r = n.a,
            s = r === void 0 ? 1 : r;
          return ra(e) && ra(t) && ra(i)
            ? a6({ r: Number(e), g: Number(t), b: Number(i), a: Number(s) })
            : null;
        },
        "rgb",
      ],
      [
        function (n) {
          var e = n.h,
            t = n.s,
            i = n.l,
            r = n.a,
            s = r === void 0 ? 1 : r;
          if (!ra(e) || !ra(t) || !ra(i)) return null;
          var o = l6({
            h: Number(e),
            s: Number(t),
            l: Number(i),
            a: Number(s),
          });
          return u6(o);
        },
        "hsl",
      ],
      [
        function (n) {
          var e = n.h,
            t = n.s,
            i = n.v,
            r = n.a,
            s = r === void 0 ? 1 : r;
          if (!ra(e) || !ra(t) || !ra(i)) return null;
          var o = (function (a) {
            return {
              h: iP(a.h),
              s: bs(a.s, 0, 100),
              v: bs(a.v, 0, 100),
              a: bs(a.a),
            };
          })({ h: Number(e), s: Number(t), v: Number(i), a: Number(s) });
          return sP(o);
        },
        "hsv",
      ],
    ],
  },
  h6 = function (n, e) {
    for (var t = 0; t < e.length; t++) {
      var i = e[t][0](n);
      if (i) return [i, e[t][1]];
    }
    return [null, void 0];
  },
  rde = function (n) {
    return typeof n == "string"
      ? h6(n.trim(), B3.string)
      : typeof n == "object" && n !== null
        ? h6(n, B3.object)
        : [null, void 0];
  },
  TA = function (n, e) {
    var t = dg(n);
    return { h: t.h, s: bs(t.s + 100 * e, 0, 100), l: t.l, a: t.a };
  },
  EA = function (n) {
    return (299 * n.r + 587 * n.g + 114 * n.b) / 1e3 / 255;
  },
  d6 = function (n, e) {
    var t = dg(n);
    return { h: t.h, s: t.s, l: bs(t.l + 100 * e, 0, 100), a: t.a };
  },
  P3 = (function () {
    function n(e) {
      ((this.parsed = rde(e)[0]),
        (this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 }));
    }
    return (
      (n.prototype.isValid = function () {
        return this.parsed !== null;
      }),
      (n.prototype.brightness = function () {
        return Ei(EA(this.rgba), 2);
      }),
      (n.prototype.isDark = function () {
        return EA(this.rgba) < 0.5;
      }),
      (n.prototype.isLight = function () {
        return EA(this.rgba) >= 0.5;
      }),
      (n.prototype.toHex = function () {
        return (
          (e = SA(this.rgba)),
          (t = e.r),
          (i = e.g),
          (r = e.b),
          (o = (s = e.a) < 1 ? F1(Ei(255 * s)) : ""),
          "#" + F1(t) + F1(i) + F1(r) + o
        );
        var e, t, i, r, s, o;
      }),
      (n.prototype.toRgb = function () {
        return SA(this.rgba);
      }),
      (n.prototype.toRgbString = function () {
        return (
          (e = SA(this.rgba)),
          (t = e.r),
          (i = e.g),
          (r = e.b),
          (s = e.a) < 1
            ? "rgba(" + t + ", " + i + ", " + r + ", " + s + ")"
            : "rgb(" + t + ", " + i + ", " + r + ")"
        );
        var e, t, i, r, s;
      }),
      (n.prototype.toHsl = function () {
        return c6(dg(this.rgba));
      }),
      (n.prototype.toHslString = function () {
        return (
          (e = c6(dg(this.rgba))),
          (t = e.h),
          (i = e.s),
          (r = e.l),
          (s = e.a) < 1
            ? "hsla(" + t + ", " + i + "%, " + r + "%, " + s + ")"
            : "hsl(" + t + ", " + i + "%, " + r + "%)"
        );
        var e, t, i, r, s;
      }),
      (n.prototype.toHsv = function () {
        return (
          (e = rP(this.rgba)),
          { h: Ei(e.h), s: Ei(e.s), v: Ei(e.v), a: Ei(e.a, 3) }
        );
        var e;
      }),
      (n.prototype.invert = function () {
        return co({
          r: 255 - (e = this.rgba).r,
          g: 255 - e.g,
          b: 255 - e.b,
          a: e.a,
        });
        var e;
      }),
      (n.prototype.saturate = function (e) {
        return (e === void 0 && (e = 0.1), co(TA(this.rgba, e)));
      }),
      (n.prototype.desaturate = function (e) {
        return (e === void 0 && (e = 0.1), co(TA(this.rgba, -e)));
      }),
      (n.prototype.grayscale = function () {
        return co(TA(this.rgba, -1));
      }),
      (n.prototype.lighten = function (e) {
        return (e === void 0 && (e = 0.1), co(d6(this.rgba, e)));
      }),
      (n.prototype.darken = function (e) {
        return (e === void 0 && (e = 0.1), co(d6(this.rgba, -e)));
      }),
      (n.prototype.rotate = function (e) {
        return (e === void 0 && (e = 15), this.hue(this.hue() + e));
      }),
      (n.prototype.alpha = function (e) {
        return typeof e == "number"
          ? co({ r: (t = this.rgba).r, g: t.g, b: t.b, a: e })
          : Ei(this.rgba.a, 3);
        var t;
      }),
      (n.prototype.hue = function (e) {
        var t = dg(this.rgba);
        return typeof e == "number"
          ? co({ h: e, s: t.s, l: t.l, a: t.a })
          : Ei(t.h);
      }),
      (n.prototype.isEqual = function (e) {
        return this.toHex() === co(e).toHex();
      }),
      n
    );
  })(),
  co = function (n) {
    return n instanceof P3 ? n : new P3(n);
  },
  f6 = [],
  sde = function (n) {
    n.forEach(function (e) {
      f6.indexOf(e) < 0 && (e(P3, B3), f6.push(e));
    });
  };
function ode(n, e) {
  var t = {
      white: "#ffffff",
      bisque: "#ffe4c4",
      blue: "#0000ff",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      azure: "#f0ffff",
      whitesmoke: "#f5f5f5",
      papayawhip: "#ffefd5",
      plum: "#dda0dd",
      blanchedalmond: "#ffebcd",
      black: "#000000",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gainsboro: "#dcdcdc",
      cornsilk: "#fff8dc",
      cornflowerblue: "#6495ed",
      burlywood: "#deb887",
      aquamarine: "#7fffd4",
      beige: "#f5f5dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkkhaki: "#bdb76b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      peachpuff: "#ffdab9",
      darkmagenta: "#8b008b",
      darkred: "#8b0000",
      darkorchid: "#9932cc",
      darkorange: "#ff8c00",
      darkslateblue: "#483d8b",
      gray: "#808080",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      wheat: "#f5deb3",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      ghostwhite: "#f8f8ff",
      darkviolet: "#9400d3",
      magenta: "#ff00ff",
      green: "#008000",
      dodgerblue: "#1e90ff",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      blueviolet: "#8a2be2",
      forestgreen: "#228b22",
      lawngreen: "#7cfc00",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      fuchsia: "#ff00ff",
      brown: "#a52a2a",
      maroon: "#800000",
      mediumblue: "#0000cd",
      lightcoral: "#f08080",
      darkturquoise: "#00ced1",
      lightcyan: "#e0ffff",
      ivory: "#fffff0",
      lightyellow: "#ffffe0",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      linen: "#faf0e6",
      mediumaquamarine: "#66cdaa",
      lemonchiffon: "#fffacd",
      lime: "#00ff00",
      khaki: "#f0e68c",
      mediumseagreen: "#3cb371",
      limegreen: "#32cd32",
      mediumspringgreen: "#00fa9a",
      lightskyblue: "#87cefa",
      lightblue: "#add8e6",
      midnightblue: "#191970",
      lightpink: "#ffb6c1",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      mintcream: "#f5fffa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      navajowhite: "#ffdead",
      navy: "#000080",
      mediumvioletred: "#c71585",
      powderblue: "#b0e0e6",
      palegoldenrod: "#eee8aa",
      oldlace: "#fdf5e6",
      paleturquoise: "#afeeee",
      mediumturquoise: "#48d1cc",
      mediumorchid: "#ba55d3",
      rebeccapurple: "#663399",
      lightsteelblue: "#b0c4de",
      mediumslateblue: "#7b68ee",
      thistle: "#d8bfd8",
      tan: "#d2b48c",
      orchid: "#da70d6",
      mediumpurple: "#9370db",
      purple: "#800080",
      pink: "#ffc0cb",
      skyblue: "#87ceeb",
      springgreen: "#00ff7f",
      palegreen: "#98fb98",
      red: "#ff0000",
      yellow: "#ffff00",
      slateblue: "#6a5acd",
      lavenderblush: "#fff0f5",
      peru: "#cd853f",
      palevioletred: "#db7093",
      violet: "#ee82ee",
      teal: "#008080",
      slategray: "#708090",
      slategrey: "#708090",
      aliceblue: "#f0f8ff",
      darkseagreen: "#8fbc8f",
      darkolivegreen: "#556b2f",
      greenyellow: "#adff2f",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      tomato: "#ff6347",
      silver: "#c0c0c0",
      sienna: "#a0522d",
      lavender: "#e6e6fa",
      lightgreen: "#90ee90",
      orange: "#ffa500",
      orangered: "#ff4500",
      steelblue: "#4682b4",
      royalblue: "#4169e1",
      turquoise: "#40e0d0",
      yellowgreen: "#9acd32",
      salmon: "#fa8072",
      saddlebrown: "#8b4513",
      sandybrown: "#f4a460",
      rosybrown: "#bc8f8f",
      darksalmon: "#e9967a",
      lightgoldenrodyellow: "#fafad2",
      snow: "#fffafa",
      lightgrey: "#d3d3d3",
      lightgray: "#d3d3d3",
      dimgray: "#696969",
      dimgrey: "#696969",
      olivedrab: "#6b8e23",
      olive: "#808000",
    },
    i = {};
  for (var r in t) i[t[r]] = r;
  var s = {};
  ((n.prototype.toName = function (o) {
    if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
      return "transparent";
    var a,
      l,
      c = i[this.toHex()];
    if (c) return c;
    if (o?.closest) {
      var u = this.toRgb(),
        h = 1 / 0,
        d = "black";
      if (!s.length) for (var f in t) s[f] = new n(t[f]).toRgb();
      for (var g in t) {
        var p =
          ((a = u),
          (l = s[g]),
          Math.pow(a.r - l.r, 2) +
            Math.pow(a.g - l.g, 2) +
            Math.pow(a.b - l.b, 2));
        p < h && ((h = p), (d = g));
      }
      return d;
    }
  }),
    e.string.push([
      function (o) {
        var a = o.toLowerCase(),
          l = a === "transparent" ? "#0000" : t[a];
        return l ? new n(l).toRgb() : null;
      },
      "name",
    ]));
}
sde([ode]);
const ah = class $0 {
  constructor(e = 16777215) {
    ((this._value = null),
      (this._components = new Float32Array(4)),
      this._components.fill(1),
      (this._int = 16777215),
      (this.value = e));
  }
  get red() {
    return this._components[0];
  }
  get green() {
    return this._components[1];
  }
  get blue() {
    return this._components[2];
  }
  get alpha() {
    return this._components[3];
  }
  setValue(e) {
    return ((this.value = e), this);
  }
  set value(e) {
    if (e instanceof $0)
      ((this._value = this.cloneSource(e._value)),
        (this._int = e._int),
        this._components.set(e._components));
    else {
      if (e === null) throw new Error("Cannot set PIXI.Color#value to null");
      (this._value === null || !this.isSourceEqual(this._value, e)) &&
        (this.normalize(e), (this._value = this.cloneSource(e)));
    }
  }
  get value() {
    return this._value;
  }
  cloneSource(e) {
    return typeof e == "string" ||
      typeof e == "number" ||
      e instanceof Number ||
      e === null
      ? e
      : Array.isArray(e) || ArrayBuffer.isView(e)
        ? e.slice(0)
        : typeof e == "object" && e !== null
          ? { ...e }
          : e;
  }
  isSourceEqual(e, t) {
    const i = typeof e;
    if (i !== typeof t) return !1;
    if (i === "number" || i === "string" || e instanceof Number) return e === t;
    if (
      (Array.isArray(e) && Array.isArray(t)) ||
      (ArrayBuffer.isView(e) && ArrayBuffer.isView(t))
    )
      return e.length !== t.length ? !1 : e.every((r, s) => r === t[s]);
    if (e !== null && t !== null) {
      const r = Object.keys(e),
        s = Object.keys(t);
      return r.length !== s.length ? !1 : r.every((o) => e[o] === t[o]);
    }
    return e === t;
  }
  toRgba() {
    const [e, t, i, r] = this._components;
    return { r: e, g: t, b: i, a: r };
  }
  toRgb() {
    const [e, t, i] = this._components;
    return { r: e, g: t, b: i };
  }
  toRgbaString() {
    const [e, t, i] = this.toUint8RgbArray();
    return `rgba(${e},${t},${i},${this.alpha})`;
  }
  toUint8RgbArray(e) {
    const [t, i, r] = this._components;
    return (
      (e = e ?? []),
      (e[0] = Math.round(t * 255)),
      (e[1] = Math.round(i * 255)),
      (e[2] = Math.round(r * 255)),
      e
    );
  }
  toRgbArray(e) {
    e = e ?? [];
    const [t, i, r] = this._components;
    return ((e[0] = t), (e[1] = i), (e[2] = r), e);
  }
  toNumber() {
    return this._int;
  }
  toLittleEndianNumber() {
    const e = this._int;
    return (e >> 16) + (e & 65280) + ((e & 255) << 16);
  }
  multiply(e) {
    const [t, i, r, s] = $0.temp.setValue(e)._components;
    return (
      (this._components[0] *= t),
      (this._components[1] *= i),
      (this._components[2] *= r),
      (this._components[3] *= s),
      this.refreshInt(),
      (this._value = null),
      this
    );
  }
  premultiply(e, t = !0) {
    return (
      t &&
        ((this._components[0] *= e),
        (this._components[1] *= e),
        (this._components[2] *= e)),
      (this._components[3] = e),
      this.refreshInt(),
      (this._value = null),
      this
    );
  }
  toPremultiplied(e, t = !0) {
    if (e === 1) return (255 << 24) + this._int;
    if (e === 0) return t ? 0 : this._int;
    let i = (this._int >> 16) & 255,
      r = (this._int >> 8) & 255,
      s = this._int & 255;
    return (
      t &&
        ((i = (i * e + 0.5) | 0),
        (r = (r * e + 0.5) | 0),
        (s = (s * e + 0.5) | 0)),
      ((e * 255) << 24) + (i << 16) + (r << 8) + s
    );
  }
  toHex() {
    const e = this._int.toString(16);
    return `#${"000000".substring(0, 6 - e.length) + e}`;
  }
  toHexa() {
    const e = Math.round(this._components[3] * 255).toString(16);
    return this.toHex() + "00".substring(0, 2 - e.length) + e;
  }
  setAlpha(e) {
    return ((this._components[3] = this._clamp(e)), this);
  }
  round(e) {
    const [t, i, r] = this._components;
    return (
      (this._components[0] = Math.round(t * e) / e),
      (this._components[1] = Math.round(i * e) / e),
      (this._components[2] = Math.round(r * e) / e),
      this.refreshInt(),
      (this._value = null),
      this
    );
  }
  toArray(e) {
    e = e ?? [];
    const [t, i, r, s] = this._components;
    return ((e[0] = t), (e[1] = i), (e[2] = r), (e[3] = s), e);
  }
  normalize(e) {
    let t, i, r, s;
    if (
      (typeof e == "number" || e instanceof Number) &&
      e >= 0 &&
      e <= 16777215
    ) {
      const o = e;
      ((t = ((o >> 16) & 255) / 255),
        (i = ((o >> 8) & 255) / 255),
        (r = (o & 255) / 255),
        (s = 1));
    } else if (
      (Array.isArray(e) || e instanceof Float32Array) &&
      e.length >= 3 &&
      e.length <= 4
    )
      ((e = this._clamp(e)), ([t, i, r, s = 1] = e));
    else if (
      (e instanceof Uint8Array || e instanceof Uint8ClampedArray) &&
      e.length >= 3 &&
      e.length <= 4
    )
      ((e = this._clamp(e, 0, 255)),
        ([t, i, r, s = 255] = e),
        (t /= 255),
        (i /= 255),
        (r /= 255),
        (s /= 255));
    else if (typeof e == "string" || typeof e == "object") {
      if (typeof e == "string") {
        const a = $0.HEX_PATTERN.exec(e);
        a && (e = `#${a[2]}`);
      }
      const o = co(e);
      o.isValid() &&
        (({ r: t, g: i, b: r, a: s } = o.rgba),
        (t /= 255),
        (i /= 255),
        (r /= 255));
    }
    if (t !== void 0)
      ((this._components[0] = t),
        (this._components[1] = i),
        (this._components[2] = r),
        (this._components[3] = s),
        this.refreshInt());
    else throw new Error(`Unable to convert color ${e}`);
  }
  refreshInt() {
    this._clamp(this._components);
    const [e, t, i] = this._components;
    this._int = ((e * 255) << 16) + ((t * 255) << 8) + ((i * 255) | 0);
  }
  _clamp(e, t = 0, i = 1) {
    return typeof e == "number"
      ? Math.min(Math.max(e, t), i)
      : (e.forEach((r, s) => {
          e[s] = Math.min(Math.max(r, t), i);
        }),
        e);
  }
};
((ah.shared = new ah()),
  (ah.temp = new ah()),
  (ah.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i));
let Ln = ah;
function ade(n) {
  return (
    Ht("7.2.0", "utils.hex2string is deprecated, use Color#toHex instead"),
    Ln.shared.setValue(n).toHex()
  );
}
function lde(n) {
  return (
    Ht("7.2.0", "utils.rgb2hex is deprecated, use Color#toNumber instead"),
    Ln.shared.setValue(n).toNumber()
  );
}
function cde() {
  const n = [],
    e = [];
  for (let i = 0; i < 32; i++) ((n[i] = i), (e[i] = i));
  ((n[dt.NORMAL_NPM] = dt.NORMAL),
    (n[dt.ADD_NPM] = dt.ADD),
    (n[dt.SCREEN_NPM] = dt.SCREEN),
    (e[dt.NORMAL] = dt.NORMAL_NPM),
    (e[dt.ADD] = dt.ADD_NPM),
    (e[dt.SCREEN] = dt.SCREEN_NPM));
  const t = [];
  return (t.push(e), t.push(n), t);
}
const oP = cde();
function aP(n, e) {
  return oP[e ? 1 : 0][n];
}
function ude(n, e = null) {
  const t = n * 6;
  if (((e = e || new Uint16Array(t)), e.length !== t))
    throw new Error(
      `Out buffer length is incorrect, got ${e.length} and expected ${t}`,
    );
  for (let i = 0, r = 0; i < t; i += 6, r += 4)
    ((e[i + 0] = r + 0),
      (e[i + 1] = r + 1),
      (e[i + 2] = r + 2),
      (e[i + 3] = r + 0),
      (e[i + 4] = r + 2),
      (e[i + 5] = r + 3));
  return e;
}
function lP(n) {
  if (n.BYTES_PER_ELEMENT === 4)
    return n instanceof Float32Array
      ? "Float32Array"
      : n instanceof Uint32Array
        ? "Uint32Array"
        : "Int32Array";
  if (n.BYTES_PER_ELEMENT === 2) {
    if (n instanceof Uint16Array) return "Uint16Array";
  } else if (n.BYTES_PER_ELEMENT === 1 && n instanceof Uint8Array)
    return "Uint8Array";
  return null;
}
function cC(n) {
  return (
    (n += n === 0 ? 1 : 0),
    --n,
    (n |= n >>> 1),
    (n |= n >>> 2),
    (n |= n >>> 4),
    (n |= n >>> 8),
    (n |= n >>> 16),
    n + 1
  );
}
function g6(n) {
  return !(n & (n - 1)) && !!n;
}
function p6(n) {
  let e = (n > 65535 ? 1 : 0) << 4;
  n >>>= e;
  let t = (n > 255 ? 1 : 0) << 3;
  return (
    (n >>>= t),
    (e |= t),
    (t = (n > 15 ? 1 : 0) << 2),
    (n >>>= t),
    (e |= t),
    (t = (n > 3 ? 1 : 0) << 1),
    (n >>>= t),
    (e |= t),
    e | (n >> 1)
  );
}
function Vh(n, e, t) {
  const i = n.length;
  let r;
  if (e >= i || t === 0) return;
  t = e + t > i ? i - e : t;
  const s = i - t;
  for (r = e; r < s; ++r) n[r] = n[r + t];
  n.length = s;
}
function bl(n) {
  return n === 0 ? 0 : n < 0 ? -1 : 1;
}
let hde = 0;
function Cu() {
  return ++hde;
}
const N3 = class {
  constructor(n, e, t, i) {
    ((this.left = n), (this.top = e), (this.right = t), (this.bottom = i));
  }
  get width() {
    return this.right - this.left;
  }
  get height() {
    return this.bottom - this.top;
  }
  isEmpty() {
    return this.left === this.right || this.top === this.bottom;
  }
};
N3.EMPTY = new N3(0, 0, 0, 0);
let m6 = N3;
const C6 = {},
  uo = Object.create(null),
  el = Object.create(null);
class dde {
  constructor(e, t, i) {
    ((this._canvas = Oe.ADAPTER.createCanvas()),
      (this._context = this._canvas.getContext("2d")),
      (this.resolution = i || Oe.RESOLUTION),
      this.resize(e, t));
  }
  clear() {
    (this._checkDestroyed(),
      this._context.setTransform(1, 0, 0, 1, 0, 0),
      this._context.clearRect(0, 0, this._canvas.width, this._canvas.height));
  }
  resize(e, t) {
    (this._checkDestroyed(),
      (this._canvas.width = Math.round(e * this.resolution)),
      (this._canvas.height = Math.round(t * this.resolution)));
  }
  destroy() {
    ((this._context = null), (this._canvas = null));
  }
  get width() {
    return (this._checkDestroyed(), this._canvas.width);
  }
  set width(e) {
    (this._checkDestroyed(), (this._canvas.width = Math.round(e)));
  }
  get height() {
    return (this._checkDestroyed(), this._canvas.height);
  }
  set height(e) {
    (this._checkDestroyed(), (this._canvas.height = Math.round(e)));
  }
  get canvas() {
    return (this._checkDestroyed(), this._canvas);
  }
  get context() {
    return (this._checkDestroyed(), this._context);
  }
  _checkDestroyed() {
    if (this._canvas === null)
      throw new TypeError("The CanvasRenderTarget has already been destroyed");
  }
}
function I6(n, e, t) {
  for (let i = 0, r = 4 * t * e; i < e; ++i, r += 4)
    if (n[r + 3] !== 0) return !1;
  return !0;
}
function A6(n, e, t, i, r) {
  const s = 4 * e;
  for (let o = i, a = i * s + 4 * t; o <= r; ++o, a += s)
    if (n[a + 3] !== 0) return !1;
  return !0;
}
function fde(n) {
  const { width: e, height: t } = n,
    i = n.getContext("2d", { willReadFrequently: !0 });
  if (i === null) throw new TypeError("Failed to get canvas 2D context");
  const r = i.getImageData(0, 0, e, t).data;
  let s = 0,
    o = 0,
    a = e - 1,
    l = t - 1;
  for (; o < t && I6(r, e, o); ) ++o;
  if (o === t) return m6.EMPTY;
  for (; I6(r, e, l); ) --l;
  for (; A6(r, e, s, o, l); ) ++s;
  for (; A6(r, e, a, o, l); ) --a;
  return (++a, ++l, new m6(s, o, a, l));
}
function gde(n) {
  const e = fde(n),
    { width: t, height: i } = e;
  let r = null;
  if (!e.isEmpty()) {
    const s = n.getContext("2d");
    if (s === null) throw new TypeError("Failed to get canvas 2D context");
    r = s.getImageData(e.left, e.top, t, i);
  }
  return { width: t, height: i, data: r };
}
function pde(n, e = globalThis.location) {
  if (n.startsWith("data:")) return "";
  e = e || globalThis.location;
  const t = new URL(n, document.baseURI);
  return t.hostname !== e.hostname ||
    t.port !== e.port ||
    t.protocol !== e.protocol
    ? "anonymous"
    : "";
}
function Ga(n, e = 1) {
  const t = Oe.RETINA_PREFIX?.exec(n);
  return t ? parseFloat(t[1]) : e;
}
var De = ((n) => (
  (n.Renderer = "renderer"),
  (n.Application = "application"),
  (n.RendererSystem = "renderer-webgl-system"),
  (n.RendererPlugin = "renderer-webgl-plugin"),
  (n.CanvasRendererSystem = "renderer-canvas-system"),
  (n.CanvasRendererPlugin = "renderer-canvas-plugin"),
  (n.Asset = "asset"),
  (n.LoadParser = "load-parser"),
  (n.ResolveParser = "resolve-parser"),
  (n.CacheParser = "cache-parser"),
  (n.DetectionParser = "detection-parser"),
  n
))(De || {});
const D3 = (n) => {
    if (typeof n == "function" || (typeof n == "object" && n.extension)) {
      if (!n.extension)
        throw new Error("Extension class must have an extension object");
      n = {
        ...(typeof n.extension != "object"
          ? { type: n.extension }
          : n.extension),
        ref: n,
      };
    }
    if (typeof n == "object") n = { ...n };
    else throw new Error("Invalid extension type");
    return (typeof n.type == "string" && (n.type = [n.type]), n);
  },
  y6 = (n, e) => D3(n).priority ?? e,
  je = {
    _addHandlers: {},
    _removeHandlers: {},
    _queue: {},
    remove(...n) {
      return (
        n.map(D3).forEach((e) => {
          e.type.forEach((t) => this._removeHandlers[t]?.(e));
        }),
        this
      );
    },
    add(...n) {
      return (
        n.map(D3).forEach((e) => {
          e.type.forEach((t) => {
            const i = this._addHandlers,
              r = this._queue;
            i[t] ? i[t](e) : ((r[t] = r[t] || []), r[t].push(e));
          });
        }),
        this
      );
    },
    handle(n, e, t) {
      const i = this._addHandlers,
        r = this._removeHandlers;
      if (i[n] || r[n])
        throw new Error(`Extension type ${n} already has a handler`);
      ((i[n] = e), (r[n] = t));
      const s = this._queue;
      return (s[n] && (s[n].forEach((o) => e(o)), delete s[n]), this);
    },
    handleByMap(n, e) {
      return this.handle(
        n,
        (t) => {
          e[t.name] = t.ref;
        },
        (t) => {
          delete e[t.name];
        },
      );
    },
    handleByList(n, e, t = -1) {
      return this.handle(
        n,
        (i) => {
          e.includes(i.ref) ||
            (e.push(i.ref), e.sort((r, s) => y6(s, t) - y6(r, t)));
        },
        (i) => {
          const r = e.indexOf(i.ref);
          r !== -1 && e.splice(r, 1);
        },
      );
    },
  };
class G3 {
  constructor(e) {
    (typeof e == "number"
      ? (this.rawBinaryData = new ArrayBuffer(e))
      : e instanceof Uint8Array
        ? (this.rawBinaryData = e.buffer)
        : (this.rawBinaryData = e),
      (this.uint32View = new Uint32Array(this.rawBinaryData)),
      (this.float32View = new Float32Array(this.rawBinaryData)));
  }
  get int8View() {
    return (
      this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)),
      this._int8View
    );
  }
  get uint8View() {
    return (
      this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)),
      this._uint8View
    );
  }
  get int16View() {
    return (
      this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)),
      this._int16View
    );
  }
  get uint16View() {
    return (
      this._uint16View ||
        (this._uint16View = new Uint16Array(this.rawBinaryData)),
      this._uint16View
    );
  }
  get int32View() {
    return (
      this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)),
      this._int32View
    );
  }
  view(e) {
    return this[`${e}View`];
  }
  destroy() {
    ((this.rawBinaryData = null),
      (this._int8View = null),
      (this._uint8View = null),
      (this._int16View = null),
      (this._uint16View = null),
      (this._int32View = null),
      (this.uint32View = null),
      (this.float32View = null));
  }
  static sizeOf(e) {
    switch (e) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(`${e} isn't a valid view type`);
    }
  }
}
const mde = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}",
].join(`
`);
function Cde(n) {
  let e = "";
  for (let t = 0; t < n; ++t)
    (t > 0 &&
      (e += `
else `),
      t < n - 1 && (e += `if(test == ${t}.0){}`));
  return e;
}
function Ide(n, e) {
  if (n === 0)
    throw new Error(
      "Invalid value of `0` passed to `checkMaxIfStatementsInShader`",
    );
  const t = e.createShader(e.FRAGMENT_SHADER);
  for (;;) {
    const i = mde.replace(/%forloop%/gi, Cde(n));
    if (
      (e.shaderSource(t, i),
      e.compileShader(t),
      !e.getShaderParameter(t, e.COMPILE_STATUS))
    )
      n = (n / 2) | 0;
    else break;
  }
  return n;
}
const MA = 0,
  LA = 1,
  RA = 2,
  BA = 3,
  PA = 4,
  NA = 5;
class Yo {
  constructor() {
    ((this.data = 0),
      (this.blendMode = dt.NORMAL),
      (this.polygonOffset = 0),
      (this.blend = !0),
      (this.depthMask = !0));
  }
  get blend() {
    return !!(this.data & (1 << MA));
  }
  set blend(e) {
    !!(this.data & (1 << MA)) !== e && (this.data ^= 1 << MA);
  }
  get offsets() {
    return !!(this.data & (1 << LA));
  }
  set offsets(e) {
    !!(this.data & (1 << LA)) !== e && (this.data ^= 1 << LA);
  }
  get culling() {
    return !!(this.data & (1 << RA));
  }
  set culling(e) {
    !!(this.data & (1 << RA)) !== e && (this.data ^= 1 << RA);
  }
  get depthTest() {
    return !!(this.data & (1 << BA));
  }
  set depthTest(e) {
    !!(this.data & (1 << BA)) !== e && (this.data ^= 1 << BA);
  }
  get depthMask() {
    return !!(this.data & (1 << NA));
  }
  set depthMask(e) {
    !!(this.data & (1 << NA)) !== e && (this.data ^= 1 << NA);
  }
  get clockwiseFrontFace() {
    return !!(this.data & (1 << PA));
  }
  set clockwiseFrontFace(e) {
    !!(this.data & (1 << PA)) !== e && (this.data ^= 1 << PA);
  }
  get blendMode() {
    return this._blendMode;
  }
  set blendMode(e) {
    ((this.blend = e !== dt.NONE), (this._blendMode = e));
  }
  get polygonOffset() {
    return this._polygonOffset;
  }
  set polygonOffset(e) {
    ((this.offsets = !!e), (this._polygonOffset = e));
  }
  static for2d() {
    const e = new Yo();
    return ((e.depthTest = !1), (e.blend = !0), e);
  }
}
Yo.prototype.toString = function () {
  return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
};
const F3 = [];
function cP(n, e) {
  if (!n) return null;
  let t = "";
  if (typeof n == "string") {
    const i = /\.(\w{3,4})(?:$|\?|#)/i.exec(n);
    i && (t = i[1].toLowerCase());
  }
  for (let i = F3.length - 1; i >= 0; --i) {
    const r = F3[i];
    if (r.test && r.test(n, t)) return new r(n, e);
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}
class qs {
  constructor(e) {
    ((this.items = []), (this._name = e), (this._aliasCount = 0));
  }
  emit(e, t, i, r, s, o, a, l) {
    if (arguments.length > 8) throw new Error("max arguments reached");
    const { name: c, items: u } = this;
    this._aliasCount++;
    for (let h = 0, d = u.length; h < d; h++) u[h][c](e, t, i, r, s, o, a, l);
    return (u === this.items && this._aliasCount--, this);
  }
  ensureNonAliasedItems() {
    this._aliasCount > 0 &&
      this.items.length > 1 &&
      ((this._aliasCount = 0), (this.items = this.items.slice(0)));
  }
  add(e) {
    return (
      e[this._name] &&
        (this.ensureNonAliasedItems(), this.remove(e), this.items.push(e)),
      this
    );
  }
  remove(e) {
    const t = this.items.indexOf(e);
    return (
      t !== -1 && (this.ensureNonAliasedItems(), this.items.splice(t, 1)),
      this
    );
  }
  contains(e) {
    return this.items.includes(e);
  }
  removeAll() {
    return (this.ensureNonAliasedItems(), (this.items.length = 0), this);
  }
  destroy() {
    (this.removeAll(), (this.items = null), (this._name = null));
  }
  get empty() {
    return this.items.length === 0;
  }
  get name() {
    return this._name;
  }
}
Object.defineProperties(qs.prototype, {
  dispatch: { value: qs.prototype.emit },
  run: { value: qs.prototype.emit },
});
class jg {
  constructor(e = 0, t = 0) {
    ((this._width = e),
      (this._height = t),
      (this.destroyed = !1),
      (this.internal = !1),
      (this.onResize = new qs("setRealSize")),
      (this.onUpdate = new qs("update")),
      (this.onError = new qs("onError")));
  }
  bind(e) {
    (this.onResize.add(e),
      this.onUpdate.add(e),
      this.onError.add(e),
      (this._width || this._height) &&
        this.onResize.emit(this._width, this._height));
  }
  unbind(e) {
    (this.onResize.remove(e), this.onUpdate.remove(e), this.onError.remove(e));
  }
  resize(e, t) {
    (e !== this._width || t !== this._height) &&
      ((this._width = e), (this._height = t), this.onResize.emit(e, t));
  }
  get valid() {
    return !!this._width && !!this._height;
  }
  update() {
    this.destroyed || this.onUpdate.emit();
  }
  load() {
    return Promise.resolve(this);
  }
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  style(e, t, i) {
    return !1;
  }
  dispose() {}
  destroy() {
    this.destroyed ||
      ((this.destroyed = !0),
      this.dispose(),
      this.onError.removeAll(),
      (this.onError = null),
      this.onResize.removeAll(),
      (this.onResize = null),
      this.onUpdate.removeAll(),
      (this.onUpdate = null));
  }
  static test(e, t) {
    return !1;
  }
}
class gI extends jg {
  constructor(e, t) {
    const { width: i, height: r } = t || {};
    if (!i || !r) throw new Error("BufferResource width or height invalid");
    (super(i, r),
      (this.data = e),
      (this.unpackAlignment = t.unpackAlignment ?? 4));
  }
  upload(e, t, i) {
    const r = e.gl;
    (r.pixelStorei(r.UNPACK_ALIGNMENT, this.unpackAlignment),
      r.pixelStorei(
        r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
        t.alphaMode === Tr.UNPACK,
      ));
    const s = t.realWidth,
      o = t.realHeight;
    return (
      i.width === s && i.height === o
        ? r.texSubImage2D(t.target, 0, 0, 0, s, o, t.format, i.type, this.data)
        : ((i.width = s),
          (i.height = o),
          r.texImage2D(
            t.target,
            0,
            i.internalFormat,
            s,
            o,
            0,
            t.format,
            i.type,
            this.data,
          )),
      !0
    );
  }
  dispose() {
    this.data = null;
  }
  static test(e) {
    return (
      e === null ||
      e instanceof Int8Array ||
      e instanceof Uint8Array ||
      e instanceof Uint8ClampedArray ||
      e instanceof Int16Array ||
      e instanceof Uint16Array ||
      e instanceof Int32Array ||
      e instanceof Uint32Array ||
      e instanceof Float32Array
    );
  }
}
const Ade = { scaleMode: Ca.NEAREST, alphaMode: Tr.NPM },
  k3 = class lh extends Lp {
    constructor(e = null, t = null) {
      (super(), (t = Object.assign({}, lh.defaultOptions, t)));
      const {
        alphaMode: i,
        mipmap: r,
        anisotropicLevel: s,
        scaleMode: o,
        width: a,
        height: l,
        wrapMode: c,
        format: u,
        type: h,
        target: d,
        resolution: f,
        resourceOptions: g,
      } = t;
      (e && !(e instanceof jg) && ((e = cP(e, g)), (e.internal = !0)),
        (this.resolution = f || Oe.RESOLUTION),
        (this.width = Math.round((a || 0) * this.resolution) / this.resolution),
        (this.height =
          Math.round((l || 0) * this.resolution) / this.resolution),
        (this._mipmap = r),
        (this.anisotropicLevel = s),
        (this._wrapMode = c),
        (this._scaleMode = o),
        (this.format = u),
        (this.type = h),
        (this.target = d),
        (this.alphaMode = i),
        (this.uid = Cu()),
        (this.touched = 0),
        (this.isPowerOfTwo = !1),
        this._refreshPOT(),
        (this._glTextures = {}),
        (this.dirtyId = 0),
        (this.dirtyStyleId = 0),
        (this.cacheId = null),
        (this.valid = a > 0 && l > 0),
        (this.textureCacheIds = []),
        (this.destroyed = !1),
        (this.resource = null),
        (this._batchEnabled = 0),
        (this._batchLocation = 0),
        (this.parentTextureArray = null),
        this.setResource(e));
    }
    get realWidth() {
      return Math.round(this.width * this.resolution);
    }
    get realHeight() {
      return Math.round(this.height * this.resolution);
    }
    get mipmap() {
      return this._mipmap;
    }
    set mipmap(e) {
      this._mipmap !== e && ((this._mipmap = e), this.dirtyStyleId++);
    }
    get scaleMode() {
      return this._scaleMode;
    }
    set scaleMode(e) {
      this._scaleMode !== e && ((this._scaleMode = e), this.dirtyStyleId++);
    }
    get wrapMode() {
      return this._wrapMode;
    }
    set wrapMode(e) {
      this._wrapMode !== e && ((this._wrapMode = e), this.dirtyStyleId++);
    }
    setStyle(e, t) {
      let i;
      return (
        e !== void 0 &&
          e !== this.scaleMode &&
          ((this.scaleMode = e), (i = !0)),
        t !== void 0 && t !== this.mipmap && ((this.mipmap = t), (i = !0)),
        i && this.dirtyStyleId++,
        this
      );
    }
    setSize(e, t, i) {
      return ((i = i || this.resolution), this.setRealSize(e * i, t * i, i));
    }
    setRealSize(e, t, i) {
      return (
        (this.resolution = i || this.resolution),
        (this.width = Math.round(e) / this.resolution),
        (this.height = Math.round(t) / this.resolution),
        this._refreshPOT(),
        this.update(),
        this
      );
    }
    _refreshPOT() {
      this.isPowerOfTwo = g6(this.realWidth) && g6(this.realHeight);
    }
    setResolution(e) {
      const t = this.resolution;
      return t === e
        ? this
        : ((this.resolution = e),
          this.valid &&
            ((this.width = Math.round(this.width * t) / e),
            (this.height = Math.round(this.height * t) / e),
            this.emit("update", this)),
          this._refreshPOT(),
          this);
    }
    setResource(e) {
      if (this.resource === e) return this;
      if (this.resource) throw new Error("Resource can be set only once");
      return (e.bind(this), (this.resource = e), this);
    }
    update() {
      this.valid
        ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this))
        : this.width > 0 &&
          this.height > 0 &&
          ((this.valid = !0),
          this.emit("loaded", this),
          this.emit("update", this));
    }
    onError(e) {
      this.emit("error", this, e);
    }
    destroy() {
      (this.resource &&
        (this.resource.unbind(this),
        this.resource.internal && this.resource.destroy(),
        (this.resource = null)),
        this.cacheId &&
          (delete el[this.cacheId],
          delete uo[this.cacheId],
          (this.cacheId = null)),
        (this.valid = !1),
        this.dispose(),
        lh.removeFromCache(this),
        (this.textureCacheIds = null),
        (this.destroyed = !0),
        this.emit("destroyed", this),
        this.removeAllListeners());
    }
    dispose() {
      this.emit("dispose", this);
    }
    castToBaseTexture() {
      return this;
    }
    static from(e, t, i = Oe.STRICT_TEXTURE_CACHE) {
      const r = typeof e == "string";
      let s = null;
      if (r) s = e;
      else {
        if (!e._pixiId) {
          const a = t?.pixiIdPrefix || "pixiid";
          e._pixiId = `${a}_${Cu()}`;
        }
        s = e._pixiId;
      }
      let o = el[s];
      if (r && i && !o)
        throw new Error(
          `The cacheId "${s}" does not exist in BaseTextureCache.`,
        );
      return (
        o || ((o = new lh(e, t)), (o.cacheId = s), lh.addToCache(o, s)),
        o
      );
    }
    static fromBuffer(e, t, i, r) {
      e = e || new Float32Array(t * i * 4);
      const s = new gI(e, { width: t, height: i, ...r?.resourceOptions });
      let o, a;
      return (
        e instanceof Float32Array
          ? ((o = ve.RGBA), (a = et.FLOAT))
          : e instanceof Int32Array
            ? ((o = ve.RGBA_INTEGER), (a = et.INT))
            : e instanceof Uint32Array
              ? ((o = ve.RGBA_INTEGER), (a = et.UNSIGNED_INT))
              : e instanceof Int16Array
                ? ((o = ve.RGBA_INTEGER), (a = et.SHORT))
                : e instanceof Uint16Array
                  ? ((o = ve.RGBA_INTEGER), (a = et.UNSIGNED_SHORT))
                  : e instanceof Int8Array
                    ? ((o = ve.RGBA), (a = et.BYTE))
                    : ((o = ve.RGBA), (a = et.UNSIGNED_BYTE)),
        (s.internal = !0),
        new lh(s, Object.assign({}, Ade, { type: a, format: o }, r))
      );
    }
    static addToCache(e, t) {
      t &&
        (e.textureCacheIds.includes(t) || e.textureCacheIds.push(t),
        el[t] &&
          el[t] !== e &&
          console.warn(
            `BaseTexture added to the cache with an id [${t}] that already had an entry`,
          ),
        (el[t] = e));
    }
    static removeFromCache(e) {
      if (typeof e == "string") {
        const t = el[e];
        if (t) {
          const i = t.textureCacheIds.indexOf(e);
          return (i > -1 && t.textureCacheIds.splice(i, 1), delete el[e], t);
        }
      } else if (e?.textureCacheIds) {
        for (let t = 0; t < e.textureCacheIds.length; ++t)
          delete el[e.textureCacheIds[t]];
        return ((e.textureCacheIds.length = 0), e);
      }
      return null;
    }
  };
((k3.defaultOptions = {
  mipmap: Ho.POW2,
  anisotropicLevel: 0,
  scaleMode: Ca.LINEAR,
  wrapMode: Ll.CLAMP,
  alphaMode: Tr.UNPACK,
  target: Uh.TEXTURE_2D,
  format: ve.RGBA,
  type: et.UNSIGNED_BYTE,
}),
  (k3._globalBatch = 0));
let St = k3;
class O3 {
  constructor() {
    ((this.texArray = null),
      (this.blend = 0),
      (this.type = To.TRIANGLES),
      (this.start = 0),
      (this.size = 0),
      (this.data = null));
  }
}
let yde = 0,
  fi = class uP {
    constructor(e, t = !0, i = !1) {
      ((this.data = e || new Float32Array(1)),
        (this._glBuffers = {}),
        (this._updateID = 0),
        (this.index = i),
        (this.static = t),
        (this.id = yde++),
        (this.disposeRunner = new qs("disposeBuffer")));
    }
    update(e) {
      (e instanceof Array && (e = new Float32Array(e)),
        (this.data = e || this.data),
        this._updateID++);
    }
    dispose() {
      this.disposeRunner.emit(this, !1);
    }
    destroy() {
      (this.dispose(), (this.data = null));
    }
    set index(e) {
      this.type = e ? Ro.ELEMENT_ARRAY_BUFFER : Ro.ARRAY_BUFFER;
    }
    get index() {
      return this.type === Ro.ELEMENT_ARRAY_BUFFER;
    }
    static from(e) {
      return (e instanceof Array && (e = new Float32Array(e)), new uP(e));
    }
  };
class uC {
  constructor(e, t = 0, i = !1, r = et.FLOAT, s, o, a, l = 1) {
    ((this.buffer = e),
      (this.size = t),
      (this.normalized = i),
      (this.type = r),
      (this.stride = s),
      (this.start = o),
      (this.instance = a),
      (this.divisor = l));
  }
  destroy() {
    this.buffer = null;
  }
  static from(e, t, i, r, s) {
    return new uC(e, t, i, r, s);
  }
}
const _de = { Float32Array, Uint32Array, Int32Array, Uint8Array };
function bde(n, e) {
  let t = 0,
    i = 0;
  const r = {};
  for (let l = 0; l < n.length; l++) ((i += e[l]), (t += n[l].length));
  const s = new ArrayBuffer(t * 4);
  let o = null,
    a = 0;
  for (let l = 0; l < n.length; l++) {
    const c = e[l],
      u = n[l],
      h = lP(u);
    (r[h] || (r[h] = new _de[h](s)), (o = r[h]));
    for (let d = 0; d < u.length; d++) {
      const f = ((d / c) | 0) * i + a,
        g = d % c;
      o[f + g] = u[d];
    }
    a += c;
  }
  return new Float32Array(s);
}
const _6 = { 5126: 4, 5123: 2, 5121: 1 };
let vde = 0;
const xde = { Float32Array, Uint32Array, Int32Array, Uint8Array, Uint16Array };
class kl {
  constructor(e = [], t = {}) {
    ((this.buffers = e),
      (this.indexBuffer = null),
      (this.attributes = t),
      (this.glVertexArrayObjects = {}),
      (this.id = vde++),
      (this.instanced = !1),
      (this.instanceCount = 1),
      (this.disposeRunner = new qs("disposeGeometry")),
      (this.refCount = 0));
  }
  addAttribute(e, t, i = 0, r = !1, s, o, a, l = !1) {
    if (!t)
      throw new Error("You must pass a buffer when creating an attribute");
    t instanceof fi ||
      (t instanceof Array && (t = new Float32Array(t)), (t = new fi(t)));
    const c = e.split("|");
    if (c.length > 1) {
      for (let h = 0; h < c.length; h++) this.addAttribute(c[h], t, i, r, s);
      return this;
    }
    let u = this.buffers.indexOf(t);
    return (
      u === -1 && (this.buffers.push(t), (u = this.buffers.length - 1)),
      (this.attributes[e] = new uC(u, i, r, s, o, a, l)),
      (this.instanced = this.instanced || l),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  getBuffer(e) {
    return this.buffers[this.getAttribute(e).buffer];
  }
  addIndex(e) {
    return (
      e instanceof fi ||
        (e instanceof Array && (e = new Uint16Array(e)), (e = new fi(e))),
      (e.type = Ro.ELEMENT_ARRAY_BUFFER),
      (this.indexBuffer = e),
      this.buffers.includes(e) || this.buffers.push(e),
      this
    );
  }
  getIndex() {
    return this.indexBuffer;
  }
  interleave() {
    if (
      this.buffers.length === 1 ||
      (this.buffers.length === 2 && this.indexBuffer)
    )
      return this;
    const e = [],
      t = [],
      i = new fi();
    let r;
    for (r in this.attributes) {
      const s = this.attributes[r],
        o = this.buffers[s.buffer];
      (e.push(o.data), t.push((s.size * _6[s.type]) / 4), (s.buffer = 0));
    }
    for (i.data = bde(e, t), r = 0; r < this.buffers.length; r++)
      this.buffers[r] !== this.indexBuffer && this.buffers[r].destroy();
    return (
      (this.buffers = [i]),
      this.indexBuffer && this.buffers.push(this.indexBuffer),
      this
    );
  }
  getSize() {
    for (const e in this.attributes) {
      const t = this.attributes[e];
      return this.buffers[t.buffer].data.length / (t.stride / 4 || t.size);
    }
    return 0;
  }
  dispose() {
    this.disposeRunner.emit(this, !1);
  }
  destroy() {
    (this.dispose(),
      (this.buffers = null),
      (this.indexBuffer = null),
      (this.attributes = null));
  }
  clone() {
    const e = new kl();
    for (let t = 0; t < this.buffers.length; t++)
      e.buffers[t] = new fi(this.buffers[t].data.slice(0));
    for (const t in this.attributes) {
      const i = this.attributes[t];
      e.attributes[t] = new uC(
        i.buffer,
        i.size,
        i.normalized,
        i.type,
        i.stride,
        i.start,
        i.instance,
      );
    }
    return (
      this.indexBuffer &&
        ((e.indexBuffer = e.buffers[this.buffers.indexOf(this.indexBuffer)]),
        (e.indexBuffer.type = Ro.ELEMENT_ARRAY_BUFFER)),
      e
    );
  }
  static merge(e) {
    const t = new kl(),
      i = [],
      r = [],
      s = [];
    let o;
    for (let a = 0; a < e.length; a++) {
      o = e[a];
      for (let l = 0; l < o.buffers.length; l++)
        ((r[l] = r[l] || 0), (r[l] += o.buffers[l].data.length), (s[l] = 0));
    }
    for (let a = 0; a < o.buffers.length; a++)
      ((i[a] = new xde[lP(o.buffers[a].data)](r[a])),
        (t.buffers[a] = new fi(i[a])));
    for (let a = 0; a < e.length; a++) {
      o = e[a];
      for (let l = 0; l < o.buffers.length; l++)
        (i[l].set(o.buffers[l].data, s[l]), (s[l] += o.buffers[l].data.length));
    }
    if (((t.attributes = o.attributes), o.indexBuffer)) {
      ((t.indexBuffer = t.buffers[o.buffers.indexOf(o.indexBuffer)]),
        (t.indexBuffer.type = Ro.ELEMENT_ARRAY_BUFFER));
      let a = 0,
        l = 0,
        c = 0,
        u = 0;
      for (let h = 0; h < o.buffers.length; h++)
        if (o.buffers[h] !== o.indexBuffer) {
          u = h;
          break;
        }
      for (const h in o.attributes) {
        const d = o.attributes[h];
        (d.buffer | 0) === u && (l += (d.size * _6[d.type]) / 4);
      }
      for (let h = 0; h < e.length; h++) {
        const d = e[h].indexBuffer.data;
        for (let f = 0; f < d.length; f++) t.indexBuffer.data[f + c] += a;
        ((a += e[h].buffers[u].data.length / l), (c += d.length));
      }
    }
    return t;
  }
}
class hP extends kl {
  constructor(e = !1) {
    (super(),
      (this._buffer = new fi(null, e, !1)),
      (this._indexBuffer = new fi(null, e, !0)),
      this.addAttribute("aVertexPosition", this._buffer, 2, !1, et.FLOAT)
        .addAttribute("aTextureCoord", this._buffer, 2, !1, et.FLOAT)
        .addAttribute("aColor", this._buffer, 4, !0, et.UNSIGNED_BYTE)
        .addAttribute("aTextureId", this._buffer, 1, !0, et.FLOAT)
        .addIndex(this._indexBuffer));
  }
}
const hC = Math.PI * 2,
  wde = 180 / Math.PI,
  Sde = Math.PI / 180;
var Fi = ((n) => (
  (n[(n.POLY = 0)] = "POLY"),
  (n[(n.RECT = 1)] = "RECT"),
  (n[(n.CIRC = 2)] = "CIRC"),
  (n[(n.ELIP = 3)] = "ELIP"),
  (n[(n.RREC = 4)] = "RREC"),
  n
))(Fi || {});
class Qt {
  constructor(e = 0, t = 0) {
    ((this.x = 0), (this.y = 0), (this.x = e), (this.y = t));
  }
  clone() {
    return new Qt(this.x, this.y);
  }
  copyFrom(e) {
    return (this.set(e.x, e.y), this);
  }
  copyTo(e) {
    return (e.set(this.x, this.y), e);
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  set(e = 0, t = e) {
    return ((this.x = e), (this.y = t), this);
  }
}
Qt.prototype.toString = function () {
  return `[@pixi/math:Point x=${this.x} y=${this.y}]`;
};
const k1 = [new Qt(), new Qt(), new Qt(), new Qt()];
class Bt {
  constructor(e = 0, t = 0, i = 0, r = 0) {
    ((this.x = Number(e)),
      (this.y = Number(t)),
      (this.width = Number(i)),
      (this.height = Number(r)),
      (this.type = Fi.RECT));
  }
  get left() {
    return this.x;
  }
  get right() {
    return this.x + this.width;
  }
  get top() {
    return this.y;
  }
  get bottom() {
    return this.y + this.height;
  }
  static get EMPTY() {
    return new Bt(0, 0, 0, 0);
  }
  clone() {
    return new Bt(this.x, this.y, this.width, this.height);
  }
  copyFrom(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.width = e.width),
      (this.height = e.height),
      this
    );
  }
  copyTo(e) {
    return (
      (e.x = this.x),
      (e.y = this.y),
      (e.width = this.width),
      (e.height = this.height),
      e
    );
  }
  contains(e, t) {
    return this.width <= 0 || this.height <= 0
      ? !1
      : e >= this.x &&
          e < this.x + this.width &&
          t >= this.y &&
          t < this.y + this.height;
  }
  intersects(e, t) {
    if (!t) {
      const E = this.x < e.x ? e.x : this.x;
      if ((this.right > e.right ? e.right : this.right) <= E) return !1;
      const _ = this.y < e.y ? e.y : this.y;
      return (this.bottom > e.bottom ? e.bottom : this.bottom) > _;
    }
    const i = this.left,
      r = this.right,
      s = this.top,
      o = this.bottom;
    if (r <= i || o <= s) return !1;
    const a = k1[0].set(e.left, e.top),
      l = k1[1].set(e.left, e.bottom),
      c = k1[2].set(e.right, e.top),
      u = k1[3].set(e.right, e.bottom);
    if (c.x <= a.x || l.y <= a.y) return !1;
    const h = Math.sign(t.a * t.d - t.b * t.c);
    if (
      h === 0 ||
      (t.apply(a, a),
      t.apply(l, l),
      t.apply(c, c),
      t.apply(u, u),
      Math.max(a.x, l.x, c.x, u.x) <= i ||
        Math.min(a.x, l.x, c.x, u.x) >= r ||
        Math.max(a.y, l.y, c.y, u.y) <= s ||
        Math.min(a.y, l.y, c.y, u.y) >= o)
    )
      return !1;
    const d = h * (l.y - a.y),
      f = h * (a.x - l.x),
      g = d * i + f * s,
      p = d * r + f * s,
      m = d * i + f * o,
      C = d * r + f * o;
    if (
      Math.max(g, p, m, C) <= d * a.x + f * a.y ||
      Math.min(g, p, m, C) >= d * u.x + f * u.y
    )
      return !1;
    const A = h * (a.y - c.y),
      I = h * (c.x - a.x),
      y = A * i + I * s,
      x = A * r + I * s,
      T = A * i + I * o,
      S = A * r + I * o;
    return !(
      Math.max(y, x, T, S) <= A * a.x + I * a.y ||
      Math.min(y, x, T, S) >= A * u.x + I * u.y
    );
  }
  pad(e = 0, t = e) {
    return (
      (this.x -= e),
      (this.y -= t),
      (this.width += e * 2),
      (this.height += t * 2),
      this
    );
  }
  fit(e) {
    const t = Math.max(this.x, e.x),
      i = Math.min(this.x + this.width, e.x + e.width),
      r = Math.max(this.y, e.y),
      s = Math.min(this.y + this.height, e.y + e.height);
    return (
      (this.x = t),
      (this.width = Math.max(i - t, 0)),
      (this.y = r),
      (this.height = Math.max(s - r, 0)),
      this
    );
  }
  ceil(e = 1, t = 0.001) {
    const i = Math.ceil((this.x + this.width - t) * e) / e,
      r = Math.ceil((this.y + this.height - t) * e) / e;
    return (
      (this.x = Math.floor((this.x + t) * e) / e),
      (this.y = Math.floor((this.y + t) * e) / e),
      (this.width = i - this.x),
      (this.height = r - this.y),
      this
    );
  }
  enlarge(e) {
    const t = Math.min(this.x, e.x),
      i = Math.max(this.x + this.width, e.x + e.width),
      r = Math.min(this.y, e.y),
      s = Math.max(this.y + this.height, e.y + e.height);
    return (
      (this.x = t),
      (this.width = i - t),
      (this.y = r),
      (this.height = s - r),
      this
    );
  }
}
Bt.prototype.toString = function () {
  return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
};
class pI {
  constructor(e = 0, t = 0, i = 0) {
    ((this.x = e), (this.y = t), (this.radius = i), (this.type = Fi.CIRC));
  }
  clone() {
    return new pI(this.x, this.y, this.radius);
  }
  contains(e, t) {
    if (this.radius <= 0) return !1;
    const i = this.radius * this.radius;
    let r = this.x - e,
      s = this.y - t;
    return ((r *= r), (s *= s), r + s <= i);
  }
  getBounds() {
    return new Bt(
      this.x - this.radius,
      this.y - this.radius,
      this.radius * 2,
      this.radius * 2,
    );
  }
}
pI.prototype.toString = function () {
  return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
};
class mI {
  constructor(e = 0, t = 0, i = 0, r = 0) {
    ((this.x = e),
      (this.y = t),
      (this.width = i),
      (this.height = r),
      (this.type = Fi.ELIP));
  }
  clone() {
    return new mI(this.x, this.y, this.width, this.height);
  }
  contains(e, t) {
    if (this.width <= 0 || this.height <= 0) return !1;
    let i = (e - this.x) / this.width,
      r = (t - this.y) / this.height;
    return ((i *= i), (r *= r), i + r <= 1);
  }
  getBounds() {
    return new Bt(
      this.x - this.width,
      this.y - this.height,
      this.width,
      this.height,
    );
  }
}
mI.prototype.toString = function () {
  return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
};
class au {
  constructor(...e) {
    let t = Array.isArray(e[0]) ? e[0] : e;
    if (typeof t[0] != "number") {
      const i = [];
      for (let r = 0, s = t.length; r < s; r++) i.push(t[r].x, t[r].y);
      t = i;
    }
    ((this.points = t), (this.type = Fi.POLY), (this.closeStroke = !0));
  }
  clone() {
    const e = this.points.slice(),
      t = new au(e);
    return ((t.closeStroke = this.closeStroke), t);
  }
  contains(e, t) {
    let i = !1;
    const r = this.points.length / 2;
    for (let s = 0, o = r - 1; s < r; o = s++) {
      const a = this.points[s * 2],
        l = this.points[s * 2 + 1],
        c = this.points[o * 2],
        u = this.points[o * 2 + 1];
      l > t != u > t && e < (c - a) * ((t - l) / (u - l)) + a && (i = !i);
    }
    return i;
  }
}
au.prototype.toString = function () {
  return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((n, e) => `${n}, ${e}`, "")}]`;
};
class CI {
  constructor(e = 0, t = 0, i = 0, r = 0, s = 20) {
    ((this.x = e),
      (this.y = t),
      (this.width = i),
      (this.height = r),
      (this.radius = s),
      (this.type = Fi.RREC));
  }
  clone() {
    return new CI(this.x, this.y, this.width, this.height, this.radius);
  }
  contains(e, t) {
    if (this.width <= 0 || this.height <= 0) return !1;
    if (
      e >= this.x &&
      e <= this.x + this.width &&
      t >= this.y &&
      t <= this.y + this.height
    ) {
      const i = Math.max(
        0,
        Math.min(this.radius, Math.min(this.width, this.height) / 2),
      );
      if (
        (t >= this.y + i && t <= this.y + this.height - i) ||
        (e >= this.x + i && e <= this.x + this.width - i)
      )
        return !0;
      let r = e - (this.x + i),
        s = t - (this.y + i);
      const o = i * i;
      if (
        r * r + s * s <= o ||
        ((r = e - (this.x + this.width - i)), r * r + s * s <= o) ||
        ((s = t - (this.y + this.height - i)), r * r + s * s <= o) ||
        ((r = e - (this.x + i)), r * r + s * s <= o)
      )
        return !0;
    }
    return !1;
  }
}
CI.prototype.toString = function () {
  return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
};
class Rn {
  constructor(e = 1, t = 0, i = 0, r = 1, s = 0, o = 0) {
    ((this.array = null),
      (this.a = e),
      (this.b = t),
      (this.c = i),
      (this.d = r),
      (this.tx = s),
      (this.ty = o));
  }
  fromArray(e) {
    ((this.a = e[0]),
      (this.b = e[1]),
      (this.c = e[3]),
      (this.d = e[4]),
      (this.tx = e[2]),
      (this.ty = e[5]));
  }
  set(e, t, i, r, s, o) {
    return (
      (this.a = e),
      (this.b = t),
      (this.c = i),
      (this.d = r),
      (this.tx = s),
      (this.ty = o),
      this
    );
  }
  toArray(e, t) {
    this.array || (this.array = new Float32Array(9));
    const i = t || this.array;
    return (
      e
        ? ((i[0] = this.a),
          (i[1] = this.b),
          (i[2] = 0),
          (i[3] = this.c),
          (i[4] = this.d),
          (i[5] = 0),
          (i[6] = this.tx),
          (i[7] = this.ty),
          (i[8] = 1))
        : ((i[0] = this.a),
          (i[1] = this.c),
          (i[2] = this.tx),
          (i[3] = this.b),
          (i[4] = this.d),
          (i[5] = this.ty),
          (i[6] = 0),
          (i[7] = 0),
          (i[8] = 1)),
      i
    );
  }
  apply(e, t) {
    t = t || new Qt();
    const i = e.x,
      r = e.y;
    return (
      (t.x = this.a * i + this.c * r + this.tx),
      (t.y = this.b * i + this.d * r + this.ty),
      t
    );
  }
  applyInverse(e, t) {
    t = t || new Qt();
    const i = 1 / (this.a * this.d + this.c * -this.b),
      r = e.x,
      s = e.y;
    return (
      (t.x =
        this.d * i * r +
        -this.c * i * s +
        (this.ty * this.c - this.tx * this.d) * i),
      (t.y =
        this.a * i * s +
        -this.b * i * r +
        (-this.ty * this.a + this.tx * this.b) * i),
      t
    );
  }
  translate(e, t) {
    return ((this.tx += e), (this.ty += t), this);
  }
  scale(e, t) {
    return (
      (this.a *= e),
      (this.d *= t),
      (this.c *= e),
      (this.b *= t),
      (this.tx *= e),
      (this.ty *= t),
      this
    );
  }
  rotate(e) {
    const t = Math.cos(e),
      i = Math.sin(e),
      r = this.a,
      s = this.c,
      o = this.tx;
    return (
      (this.a = r * t - this.b * i),
      (this.b = r * i + this.b * t),
      (this.c = s * t - this.d * i),
      (this.d = s * i + this.d * t),
      (this.tx = o * t - this.ty * i),
      (this.ty = o * i + this.ty * t),
      this
    );
  }
  append(e) {
    const t = this.a,
      i = this.b,
      r = this.c,
      s = this.d;
    return (
      (this.a = e.a * t + e.b * r),
      (this.b = e.a * i + e.b * s),
      (this.c = e.c * t + e.d * r),
      (this.d = e.c * i + e.d * s),
      (this.tx = e.tx * t + e.ty * r + this.tx),
      (this.ty = e.tx * i + e.ty * s + this.ty),
      this
    );
  }
  setTransform(e, t, i, r, s, o, a, l, c) {
    return (
      (this.a = Math.cos(a + c) * s),
      (this.b = Math.sin(a + c) * s),
      (this.c = -Math.sin(a - l) * o),
      (this.d = Math.cos(a - l) * o),
      (this.tx = e - (i * this.a + r * this.c)),
      (this.ty = t - (i * this.b + r * this.d)),
      this
    );
  }
  prepend(e) {
    const t = this.tx;
    if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
      const i = this.a,
        r = this.c;
      ((this.a = i * e.a + this.b * e.c),
        (this.b = i * e.b + this.b * e.d),
        (this.c = r * e.a + this.d * e.c),
        (this.d = r * e.b + this.d * e.d));
    }
    return (
      (this.tx = t * e.a + this.ty * e.c + e.tx),
      (this.ty = t * e.b + this.ty * e.d + e.ty),
      this
    );
  }
  decompose(e) {
    const t = this.a,
      i = this.b,
      r = this.c,
      s = this.d,
      o = e.pivot,
      a = -Math.atan2(-r, s),
      l = Math.atan2(i, t),
      c = Math.abs(a + l);
    return (
      c < 1e-5 || Math.abs(hC - c) < 1e-5
        ? ((e.rotation = l), (e.skew.x = e.skew.y = 0))
        : ((e.rotation = 0), (e.skew.x = a), (e.skew.y = l)),
      (e.scale.x = Math.sqrt(t * t + i * i)),
      (e.scale.y = Math.sqrt(r * r + s * s)),
      (e.position.x = this.tx + (o.x * t + o.y * r)),
      (e.position.y = this.ty + (o.x * i + o.y * s)),
      e
    );
  }
  invert() {
    const e = this.a,
      t = this.b,
      i = this.c,
      r = this.d,
      s = this.tx,
      o = e * r - t * i;
    return (
      (this.a = r / o),
      (this.b = -t / o),
      (this.c = -i / o),
      (this.d = e / o),
      (this.tx = (i * this.ty - r * s) / o),
      (this.ty = -(e * this.ty - t * s) / o),
      this
    );
  }
  identity() {
    return (
      (this.a = 1),
      (this.b = 0),
      (this.c = 0),
      (this.d = 1),
      (this.tx = 0),
      (this.ty = 0),
      this
    );
  }
  clone() {
    const e = new Rn();
    return (
      (e.a = this.a),
      (e.b = this.b),
      (e.c = this.c),
      (e.d = this.d),
      (e.tx = this.tx),
      (e.ty = this.ty),
      e
    );
  }
  copyTo(e) {
    return (
      (e.a = this.a),
      (e.b = this.b),
      (e.c = this.c),
      (e.d = this.d),
      (e.tx = this.tx),
      (e.ty = this.ty),
      e
    );
  }
  copyFrom(e) {
    return (
      (this.a = e.a),
      (this.b = e.b),
      (this.c = e.c),
      (this.d = e.d),
      (this.tx = e.tx),
      (this.ty = e.ty),
      this
    );
  }
  static get IDENTITY() {
    return new Rn();
  }
  static get TEMP_MATRIX() {
    return new Rn();
  }
}
Rn.prototype.toString = function () {
  return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
};
const Mc = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1],
  Lc = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1],
  Rc = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1],
  Bc = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1],
  U3 = [],
  dP = [],
  O1 = Math.sign;
function Tde() {
  for (let n = 0; n < 16; n++) {
    const e = [];
    U3.push(e);
    for (let t = 0; t < 16; t++) {
      const i = O1(Mc[n] * Mc[t] + Rc[n] * Lc[t]),
        r = O1(Lc[n] * Mc[t] + Bc[n] * Lc[t]),
        s = O1(Mc[n] * Rc[t] + Rc[n] * Bc[t]),
        o = O1(Lc[n] * Rc[t] + Bc[n] * Bc[t]);
      for (let a = 0; a < 16; a++)
        if (Mc[a] === i && Lc[a] === r && Rc[a] === s && Bc[a] === o) {
          e.push(a);
          break;
        }
    }
  }
  for (let n = 0; n < 16; n++) {
    const e = new Rn();
    (e.set(Mc[n], Lc[n], Rc[n], Bc[n], 0, 0), dP.push(e));
  }
}
Tde();
const Fn = {
  E: 0,
  SE: 1,
  S: 2,
  SW: 3,
  W: 4,
  NW: 5,
  N: 6,
  NE: 7,
  MIRROR_VERTICAL: 8,
  MAIN_DIAGONAL: 10,
  MIRROR_HORIZONTAL: 12,
  REVERSE_DIAGONAL: 14,
  uX: (n) => Mc[n],
  uY: (n) => Lc[n],
  vX: (n) => Rc[n],
  vY: (n) => Bc[n],
  inv: (n) => (n & 8 ? n & 15 : -n & 7),
  add: (n, e) => U3[n][e],
  sub: (n, e) => U3[n][Fn.inv(e)],
  rotate180: (n) => n ^ 4,
  isVertical: (n) => (n & 3) === 2,
  byDirection: (n, e) =>
    Math.abs(n) * 2 <= Math.abs(e)
      ? e >= 0
        ? Fn.S
        : Fn.N
      : Math.abs(e) * 2 <= Math.abs(n)
        ? n > 0
          ? Fn.E
          : Fn.W
        : e > 0
          ? n > 0
            ? Fn.SE
            : Fn.SW
          : n > 0
            ? Fn.NE
            : Fn.NW,
  matrixAppendRotationInv: (n, e, t = 0, i = 0) => {
    const r = dP[Fn.inv(e)];
    ((r.tx = t), (r.ty = i), n.append(r));
  },
};
class Aa {
  constructor(e, t, i = 0, r = 0) {
    ((this._x = i), (this._y = r), (this.cb = e), (this.scope = t));
  }
  clone(e = this.cb, t = this.scope) {
    return new Aa(e, t, this._x, this._y);
  }
  set(e = 0, t = e) {
    return (
      (this._x !== e || this._y !== t) &&
        ((this._x = e), (this._y = t), this.cb.call(this.scope)),
      this
    );
  }
  copyFrom(e) {
    return (
      (this._x !== e.x || this._y !== e.y) &&
        ((this._x = e.x), (this._y = e.y), this.cb.call(this.scope)),
      this
    );
  }
  copyTo(e) {
    return (e.set(this._x, this._y), e);
  }
  equals(e) {
    return e.x === this._x && e.y === this._y;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x !== e && ((this._x = e), this.cb.call(this.scope));
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y !== e && ((this._y = e), this.cb.call(this.scope));
  }
}
Aa.prototype.toString = function () {
  return `[@pixi/math:ObservablePoint x=${this.x} y=${this.y} scope=${this.scope}]`;
};
const H3 = class {
  constructor() {
    ((this.worldTransform = new Rn()),
      (this.localTransform = new Rn()),
      (this.position = new Aa(this.onChange, this, 0, 0)),
      (this.scale = new Aa(this.onChange, this, 1, 1)),
      (this.pivot = new Aa(this.onChange, this, 0, 0)),
      (this.skew = new Aa(this.updateSkew, this, 0, 0)),
      (this._rotation = 0),
      (this._cx = 1),
      (this._sx = 0),
      (this._cy = 0),
      (this._sy = 1),
      (this._localID = 0),
      (this._currentLocalID = 0),
      (this._worldID = 0),
      (this._parentID = 0));
  }
  onChange() {
    this._localID++;
  }
  updateSkew() {
    ((this._cx = Math.cos(this._rotation + this.skew.y)),
      (this._sx = Math.sin(this._rotation + this.skew.y)),
      (this._cy = -Math.sin(this._rotation - this.skew.x)),
      (this._sy = Math.cos(this._rotation - this.skew.x)),
      this._localID++);
  }
  updateLocalTransform() {
    const n = this.localTransform;
    this._localID !== this._currentLocalID &&
      ((n.a = this._cx * this.scale.x),
      (n.b = this._sx * this.scale.x),
      (n.c = this._cy * this.scale.y),
      (n.d = this._sy * this.scale.y),
      (n.tx = this.position.x - (this.pivot.x * n.a + this.pivot.y * n.c)),
      (n.ty = this.position.y - (this.pivot.x * n.b + this.pivot.y * n.d)),
      (this._currentLocalID = this._localID),
      (this._parentID = -1));
  }
  updateTransform(n) {
    const e = this.localTransform;
    if (
      (this._localID !== this._currentLocalID &&
        ((e.a = this._cx * this.scale.x),
        (e.b = this._sx * this.scale.x),
        (e.c = this._cy * this.scale.y),
        (e.d = this._sy * this.scale.y),
        (e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c)),
        (e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d)),
        (this._currentLocalID = this._localID),
        (this._parentID = -1)),
      this._parentID !== n._worldID)
    ) {
      const t = n.worldTransform,
        i = this.worldTransform;
      ((i.a = e.a * t.a + e.b * t.c),
        (i.b = e.a * t.b + e.b * t.d),
        (i.c = e.c * t.a + e.d * t.c),
        (i.d = e.c * t.b + e.d * t.d),
        (i.tx = e.tx * t.a + e.ty * t.c + t.tx),
        (i.ty = e.tx * t.b + e.ty * t.d + t.ty),
        (this._parentID = n._worldID),
        this._worldID++);
    }
  }
  setFromMatrix(n) {
    (n.decompose(this), this._localID++);
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(n) {
    this._rotation !== n && ((this._rotation = n), this.updateSkew());
  }
};
H3.IDENTITY = new H3();
let x5 = H3;
x5.prototype.toString = function () {
  return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
};
var Ede = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor *= texture2D(uSampler, vTextureCoord);
}`,
  Mde = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void){
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vTextureCoord = aTextureCoord;
}
`;
function b6(n, e, t) {
  const i = n.createShader(e);
  return (n.shaderSource(i, t), n.compileShader(i), i);
}
function DA(n) {
  const e = new Array(n);
  for (let t = 0; t < e.length; t++) e[t] = !1;
  return e;
}
function fP(n, e) {
  switch (n) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * e);
    case "vec3":
      return new Float32Array(3 * e);
    case "vec4":
      return new Float32Array(4 * e);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * e);
    case "ivec3":
      return new Int32Array(3 * e);
    case "ivec4":
      return new Int32Array(4 * e);
    case "uvec2":
      return new Uint32Array(2 * e);
    case "uvec3":
      return new Uint32Array(3 * e);
    case "uvec4":
      return new Uint32Array(4 * e);
    case "bool":
      return !1;
    case "bvec2":
      return DA(2 * e);
    case "bvec3":
      return DA(3 * e);
    case "bvec4":
      return DA(4 * e);
    case "mat2":
      return new Float32Array([1, 0, 0, 1]);
    case "mat3":
      return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    case "mat4":
      return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  }
  return null;
}
const Zh = [
    {
      test: (n) => n.type === "float" && n.size === 1 && !n.isArray,
      code: (n) => `
            if(uv["${n}"] !== ud["${n}"].value)
            {
                ud["${n}"].value = uv["${n}"]
                gl.uniform1f(ud["${n}"].location, uv["${n}"])
            }
            `,
    },
    {
      test: (n, e) =>
        (n.type === "sampler2D" ||
          n.type === "samplerCube" ||
          n.type === "sampler2DArray") &&
        n.size === 1 &&
        !n.isArray &&
        (e == null || e.castToBaseTexture !== void 0),
      code: (n) => `t = syncData.textureCount++;

            renderer.texture.bind(uv["${n}"], t);

            if(ud["${n}"].value !== t)
            {
                ud["${n}"].value = t;
                gl.uniform1i(ud["${n}"].location, t);
; // eslint-disable-line max-len
            }`,
    },
    {
      test: (n, e) =>
        n.type === "mat3" && n.size === 1 && !n.isArray && e.a !== void 0,
      code: (n) => `
            gl.uniformMatrix3fv(ud["${n}"].location, false, uv["${n}"].toArray(true));
            `,
      codeUbo: (n) => `
                var ${n}_matrix = uv.${n}.toArray(true);

                data[offset] = ${n}_matrix[0];
                data[offset+1] = ${n}_matrix[1];
                data[offset+2] = ${n}_matrix[2];
        
                data[offset + 4] = ${n}_matrix[3];
                data[offset + 5] = ${n}_matrix[4];
                data[offset + 6] = ${n}_matrix[5];
        
                data[offset + 8] = ${n}_matrix[6];
                data[offset + 9] = ${n}_matrix[7];
                data[offset + 10] = ${n}_matrix[8];
            `,
    },
    {
      test: (n, e) =>
        n.type === "vec2" && n.size === 1 && !n.isArray && e.x !== void 0,
      code: (n) => `
                cv = ud["${n}"].value;
                v = uv["${n}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${n}"].location, v.x, v.y);
                }`,
      codeUbo: (n) => `
                v = uv.${n};

                data[offset] = v.x;
                data[offset+1] = v.y;
            `,
    },
    {
      test: (n) => n.type === "vec2" && n.size === 1 && !n.isArray,
      code: (n) => `
                cv = ud["${n}"].value;
                v = uv["${n}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${n}"].location, v[0], v[1]);
                }
            `,
    },
    {
      test: (n, e) =>
        n.type === "vec4" && n.size === 1 && !n.isArray && e.width !== void 0,
      code: (n) => `
                cv = ud["${n}"].value;
                v = uv["${n}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${n}"].location, v.x, v.y, v.width, v.height)
                }`,
      codeUbo: (n) => `
                    v = uv.${n};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `,
    },
    {
      test: (n, e) =>
        n.type === "vec4" && n.size === 1 && !n.isArray && e.red !== void 0,
      code: (n) => `
                cv = ud["${n}"].value;
                v = uv["${n}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
                    cv[3] = v.alpha;
                    gl.uniform4f(ud["${n}"].location, v.red, v.green, v.blue, v.alpha)
                }`,
      codeUbo: (n) => `
                    v = uv.${n};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                    data[offset+3] = v.alpha;
                `,
    },
    {
      test: (n, e) =>
        n.type === "vec3" && n.size === 1 && !n.isArray && e.red !== void 0,
      code: (n) => `
                cv = ud["${n}"].value;
                v = uv["${n}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
    
                    gl.uniform3f(ud["${n}"].location, v.red, v.green, v.blue)
                }`,
      codeUbo: (n) => `
                    v = uv.${n};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                `,
    },
    {
      test: (n) => n.type === "vec4" && n.size === 1 && !n.isArray,
      code: (n) => `
                cv = ud["${n}"].value;
                v = uv["${n}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${n}"].location, v[0], v[1], v[2], v[3])
                }`,
    },
  ],
  Lde = {
    float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
    vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
    vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
    vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
    int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
    ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
    ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
    ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
    uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
    uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
    uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
    uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
    bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
    bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
    bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
    bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
    mat2: "gl.uniformMatrix2fv(location, false, v)",
    mat3: "gl.uniformMatrix3fv(location, false, v)",
    mat4: "gl.uniformMatrix4fv(location, false, v)",
    sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
    samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
    sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  },
  Rde = {
    float: "gl.uniform1fv(location, v)",
    vec2: "gl.uniform2fv(location, v)",
    vec3: "gl.uniform3fv(location, v)",
    vec4: "gl.uniform4fv(location, v)",
    mat4: "gl.uniformMatrix4fv(location, false, v)",
    mat3: "gl.uniformMatrix3fv(location, false, v)",
    mat2: "gl.uniformMatrix2fv(location, false, v)",
    int: "gl.uniform1iv(location, v)",
    ivec2: "gl.uniform2iv(location, v)",
    ivec3: "gl.uniform3iv(location, v)",
    ivec4: "gl.uniform4iv(location, v)",
    uint: "gl.uniform1uiv(location, v)",
    uvec2: "gl.uniform2uiv(location, v)",
    uvec3: "gl.uniform3uiv(location, v)",
    uvec4: "gl.uniform4uiv(location, v)",
    bool: "gl.uniform1iv(location, v)",
    bvec2: "gl.uniform2iv(location, v)",
    bvec3: "gl.uniform3iv(location, v)",
    bvec4: "gl.uniform4iv(location, v)",
    sampler2D: "gl.uniform1iv(location, v)",
    samplerCube: "gl.uniform1iv(location, v)",
    sampler2DArray: "gl.uniform1iv(location, v)",
  };
function Bde(n, e) {
  const t = [
    `
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `,
  ];
  for (const i in n.uniforms) {
    const r = e[i];
    if (!r) {
      n.uniforms[i]?.group === !0 &&
        (n.uniforms[i].ubo
          ? t.push(`
                        renderer.shader.syncUniformBufferGroup(uv.${i}, '${i}');
                    `)
          : t.push(`
                        renderer.shader.syncUniformGroup(uv.${i}, syncData);
                    `));
      continue;
    }
    const s = n.uniforms[i];
    let o = !1;
    for (let a = 0; a < Zh.length; a++)
      if (Zh[a].test(r, s)) {
        (t.push(Zh[a].code(i, s)), (o = !0));
        break;
      }
    if (!o) {
      const a = (r.size === 1 && !r.isArray ? Lde : Rde)[r.type].replace(
        "location",
        `ud["${i}"].location`,
      );
      t.push(`
            cu = ud["${i}"];
            cv = cu.value;
            v = uv["${i}"];
            ${a};`);
    }
  }
  return new Function(
    "ud",
    "uv",
    "renderer",
    "syncData",
    t.join(`
`),
  );
}
const gP = {};
let U1 = gP;
function Pde() {
  if (U1 === gP || U1?.isContextLost()) {
    const n = Oe.ADAPTER.createCanvas();
    let e;
    (Oe.PREFER_ENV >= Tu.WEBGL2 && (e = n.getContext("webgl2", {})),
      e ||
        ((e =
          n.getContext("webgl", {}) || n.getContext("experimental-webgl", {})),
        e ? e.getExtension("WEBGL_draw_buffers") : (e = null)),
      (U1 = e));
  }
  return U1;
}
let H1;
function Nde() {
  if (!H1) {
    H1 = _s.MEDIUM;
    const n = Pde();
    n &&
      n.getShaderPrecisionFormat &&
      (H1 = n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT)
        .precision
        ? _s.HIGH
        : _s.MEDIUM);
  }
  return H1;
}
function v6(n, e) {
  const t = n
      .getShaderSource(e)
      .split(
        `
`,
      )
      .map((c, u) => `${u}: ${c}`),
    i = n.getShaderInfoLog(e),
    r = i.split(`
`),
    s = {},
    o = r
      .map((c) => parseFloat(c.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1")))
      .filter((c) => (c && !s[c] ? ((s[c] = !0), !0) : !1)),
    a = [""];
  o.forEach((c) => {
    ((t[c - 1] = `%c${t[c - 1]}%c`),
      a.push(
        "background: #FF0000; color:#FFFFFF; font-size: 10px",
        "font-size: 10px",
      ));
  });
  const l = t.join(`
`);
  ((a[0] = l),
    console.error(i),
    console.groupCollapsed("click to view full shader code"),
    console.warn(...a),
    console.groupEnd());
}
function Dde(n, e, t, i) {
  n.getProgramParameter(e, n.LINK_STATUS) ||
    (n.getShaderParameter(t, n.COMPILE_STATUS) || v6(n, t),
    n.getShaderParameter(i, n.COMPILE_STATUS) || v6(n, i),
    console.error("PixiJS Error: Could not initialize shader."),
    n.getProgramInfoLog(e) !== "" &&
      console.warn(
        "PixiJS Warning: gl.getProgramInfoLog()",
        n.getProgramInfoLog(e),
      ));
}
const Gde = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1,
};
function pP(n) {
  return Gde[n];
}
let W1 = null;
const x6 = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray",
};
function mP(n, e) {
  if (!W1) {
    const t = Object.keys(x6);
    W1 = {};
    for (let i = 0; i < t.length; ++i) {
      const r = t[i];
      W1[n[r]] = x6[r];
    }
  }
  return W1[e];
}
function w6(n, e, t) {
  if (n.substring(0, 9) !== "precision") {
    let i = e;
    return (
      e === _s.HIGH && t !== _s.HIGH && (i = _s.MEDIUM),
      `precision ${i} float;
${n}`
    );
  } else if (t !== _s.HIGH && n.substring(0, 15) === "precision highp")
    return n.replace("precision highp", "precision mediump");
  return n;
}
let vf;
function Fde() {
  if (typeof vf == "boolean") return vf;
  try {
    vf =
      new Function(
        "param1",
        "param2",
        "param3",
        "return param1[param2] === param3;",
      )({ a: "b" }, "a", "b") === !0;
  } catch {
    vf = !1;
  }
  return vf;
}
let kde = 0;
const V1 = {},
  W3 = class ch {
    constructor(e, t, i = "pixi-shader", r = {}) {
      ((this.extra = {}),
        (this.id = kde++),
        (this.vertexSrc = e || ch.defaultVertexSrc),
        (this.fragmentSrc = t || ch.defaultFragmentSrc),
        (this.vertexSrc = this.vertexSrc.trim()),
        (this.fragmentSrc = this.fragmentSrc.trim()),
        (this.extra = r),
        this.vertexSrc.substring(0, 8) !== "#version" &&
          ((i = i.replace(/\s+/g, "-")),
          V1[i] ? (V1[i]++, (i += `-${V1[i]}`)) : (V1[i] = 1),
          (this.vertexSrc = `#define SHADER_NAME ${i}
${this.vertexSrc}`),
          (this.fragmentSrc = `#define SHADER_NAME ${i}
${this.fragmentSrc}`),
          (this.vertexSrc = w6(
            this.vertexSrc,
            ch.defaultVertexPrecision,
            _s.HIGH,
          )),
          (this.fragmentSrc = w6(
            this.fragmentSrc,
            ch.defaultFragmentPrecision,
            Nde(),
          ))),
        (this.glPrograms = {}),
        (this.syncUniforms = null));
    }
    static get defaultVertexSrc() {
      return Mde;
    }
    static get defaultFragmentSrc() {
      return Ede;
    }
    static from(e, t, i) {
      const r = e + t;
      let s = C6[r];
      return (s || (C6[r] = s = new ch(e, t, i)), s);
    }
  };
((W3.defaultVertexPrecision = _s.HIGH),
  (W3.defaultFragmentPrecision = Ia.apple.device ? _s.HIGH : _s.MEDIUM));
let ya = W3,
  Ode = 0;
class eo {
  constructor(e, t, i) {
    ((this.group = !0),
      (this.syncUniforms = {}),
      (this.dirtyId = 0),
      (this.id = Ode++),
      (this.static = !!t),
      (this.ubo = !!i),
      e instanceof fi
        ? ((this.buffer = e),
          (this.buffer.type = Ro.UNIFORM_BUFFER),
          (this.autoManage = !1),
          (this.ubo = !0))
        : ((this.uniforms = e),
          this.ubo &&
            ((this.buffer = new fi(new Float32Array(1))),
            (this.buffer.type = Ro.UNIFORM_BUFFER),
            (this.autoManage = !0))));
  }
  update() {
    (this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update());
  }
  add(e, t, i) {
    if (!this.ubo) this.uniforms[e] = new eo(t, i);
    else
      throw new Error(
        "[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them",
      );
  }
  static from(e, t, i) {
    return new eo(e, t, i);
  }
  static uboFrom(e, t) {
    return new eo(e, t ?? !0, !0);
  }
}
class Bo {
  constructor(e, t) {
    ((this.uniformBindCount = 0),
      (this.program = e),
      t
        ? t instanceof eo
          ? (this.uniformGroup = t)
          : (this.uniformGroup = new eo(t))
        : (this.uniformGroup = new eo({})),
      (this.disposeRunner = new qs("disposeShader")));
  }
  checkUniformExists(e, t) {
    if (t.uniforms[e]) return !0;
    for (const i in t.uniforms) {
      const r = t.uniforms[i];
      if (r.group === !0 && this.checkUniformExists(e, r)) return !0;
    }
    return !1;
  }
  destroy() {
    ((this.uniformGroup = null),
      this.disposeRunner.emit(this),
      this.disposeRunner.destroy());
  }
  get uniforms() {
    return this.uniformGroup.uniforms;
  }
  static from(e, t, i) {
    const r = ya.from(e, t);
    return new Bo(r, i);
  }
}
class Ude {
  constructor(e, t) {
    if (
      ((this.vertexSrc = e),
      (this.fragTemplate = t),
      (this.programCache = {}),
      (this.defaultGroupCache = {}),
      !t.includes("%count%"))
    )
      throw new Error('Fragment template must contain "%count%".');
    if (!t.includes("%forloop%"))
      throw new Error('Fragment template must contain "%forloop%".');
  }
  generateShader(e) {
    if (!this.programCache[e]) {
      const i = new Int32Array(e);
      for (let s = 0; s < e; s++) i[s] = s;
      this.defaultGroupCache[e] = eo.from({ uSamplers: i }, !0);
      let r = this.fragTemplate;
      ((r = r.replace(/%count%/gi, `${e}`)),
        (r = r.replace(/%forloop%/gi, this.generateSampleSrc(e))),
        (this.programCache[e] = new ya(this.vertexSrc, r)));
    }
    const t = {
      tint: new Float32Array([1, 1, 1, 1]),
      translationMatrix: new Rn(),
      default: this.defaultGroupCache[e],
    };
    return new Bo(this.programCache[e], t);
  }
  generateSampleSrc(e) {
    let t = "";
    ((t += `
`),
      (t += `
`));
    for (let i = 0; i < e; i++)
      (i > 0 &&
        (t += `
else `),
        i < e - 1 && (t += `if(vTextureId < ${i}.5)`),
        (t += `
{`),
        (t += `
	color = texture2D(uSamplers[${i}], vTextureCoord);`),
        (t += `
}`));
    return (
      (t += `
`),
      (t += `
`),
      t
    );
  }
}
class V3 {
  constructor() {
    ((this.elements = []), (this.ids = []), (this.count = 0));
  }
  clear() {
    for (let e = 0; e < this.count; e++) this.elements[e] = null;
    this.count = 0;
  }
}
function Hde() {
  return !Ia.apple.device;
}
function Wde(n) {
  let e = !0;
  const t = Oe.ADAPTER.getNavigator();
  if (Ia.tablet || Ia.phone) {
    if (Ia.apple.device) {
      const i = t.userAgent.match(/OS (\d+)_(\d+)?/);
      i && parseInt(i[1], 10) < 11 && (e = !1);
    }
    if (Ia.android.device) {
      const i = t.userAgent.match(/Android\s([0-9.]*)/);
      i && parseInt(i[1], 10) < 7 && (e = !1);
    }
  }
  return e ? n : 4;
}
class II {
  constructor(e) {
    this.renderer = e;
  }
  flush() {}
  destroy() {
    this.renderer = null;
  }
  start() {}
  stop() {
    this.flush();
  }
  render(e) {}
}
var Vde = `varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = color * vColor;
}
`,
  Zde = `precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
}
`;
const Hf = class Ws extends II {
  constructor(e) {
    (super(e),
      this.setShaderGenerator(),
      (this.geometryClass = hP),
      (this.vertexSize = 6),
      (this.state = Yo.for2d()),
      (this.size = Ws.defaultBatchSize * 4),
      (this._vertexCount = 0),
      (this._indexCount = 0),
      (this._bufferedElements = []),
      (this._bufferedTextures = []),
      (this._bufferSize = 0),
      (this._shader = null),
      (this._packedGeometries = []),
      (this._packedGeometryPoolSize = 2),
      (this._flushId = 0),
      (this._aBuffers = {}),
      (this._iBuffers = {}),
      (this.maxTextures = 1),
      this.renderer.on("prerender", this.onPrerender, this),
      e.runners.contextChange.add(this),
      (this._dcIndex = 0),
      (this._aIndex = 0),
      (this._iIndex = 0),
      (this._attributeBuffer = null),
      (this._indexBuffer = null),
      (this._tempBoundTextures = []));
  }
  static get defaultMaxTextures() {
    return (
      (this._defaultMaxTextures = this._defaultMaxTextures ?? Wde(32)),
      this._defaultMaxTextures
    );
  }
  static set defaultMaxTextures(e) {
    this._defaultMaxTextures = e;
  }
  static get canUploadSameBuffer() {
    return (
      (this._canUploadSameBuffer = this._canUploadSameBuffer ?? Hde()),
      this._canUploadSameBuffer
    );
  }
  static set canUploadSameBuffer(e) {
    this._canUploadSameBuffer = e;
  }
  get MAX_TEXTURES() {
    return (
      Ht(
        "7.1.0",
        "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures",
      ),
      this.maxTextures
    );
  }
  static get defaultVertexSrc() {
    return Zde;
  }
  static get defaultFragmentTemplate() {
    return Vde;
  }
  setShaderGenerator({
    vertex: e = Ws.defaultVertexSrc,
    fragment: t = Ws.defaultFragmentTemplate,
  } = {}) {
    this.shaderGenerator = new Ude(e, t);
  }
  contextChange() {
    const e = this.renderer.gl;
    (Oe.PREFER_ENV === Tu.WEBGL_LEGACY
      ? (this.maxTextures = 1)
      : ((this.maxTextures = Math.min(
          e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
          Ws.defaultMaxTextures,
        )),
        (this.maxTextures = Ide(this.maxTextures, e))),
      (this._shader = this.shaderGenerator.generateShader(this.maxTextures)));
    for (let t = 0; t < this._packedGeometryPoolSize; t++)
      this._packedGeometries[t] = new this.geometryClass();
    this.initFlushBuffers();
  }
  initFlushBuffers() {
    const { _drawCallPool: e, _textureArrayPool: t } = Ws,
      i = this.size / 4,
      r = Math.floor(i / this.maxTextures) + 1;
    for (; e.length < i; ) e.push(new O3());
    for (; t.length < r; ) t.push(new V3());
    for (let s = 0; s < this.maxTextures; s++)
      this._tempBoundTextures[s] = null;
  }
  onPrerender() {
    this._flushId = 0;
  }
  render(e) {
    e._texture.valid &&
      (this._vertexCount + e.vertexData.length / 2 > this.size && this.flush(),
      (this._vertexCount += e.vertexData.length / 2),
      (this._indexCount += e.indices.length),
      (this._bufferedTextures[this._bufferSize] = e._texture.baseTexture),
      (this._bufferedElements[this._bufferSize++] = e));
  }
  buildTexturesAndDrawCalls() {
    const { _bufferedTextures: e, maxTextures: t } = this,
      i = Ws._textureArrayPool,
      r = this.renderer.batch,
      s = this._tempBoundTextures,
      o = this.renderer.textureGC.count;
    let a = ++St._globalBatch,
      l = 0,
      c = i[0],
      u = 0;
    r.copyBoundTextures(s, t);
    for (let h = 0; h < this._bufferSize; ++h) {
      const d = e[h];
      ((e[h] = null),
        d._batchEnabled !== a &&
          (c.count >= t &&
            (r.boundArray(c, s, a, t),
            this.buildDrawCalls(c, u, h),
            (u = h),
            (c = i[++l]),
            ++a),
          (d._batchEnabled = a),
          (d.touched = o),
          (c.elements[c.count++] = d)));
    }
    c.count > 0 &&
      (r.boundArray(c, s, a, t),
      this.buildDrawCalls(c, u, this._bufferSize),
      ++l,
      ++a);
    for (let h = 0; h < s.length; h++) s[h] = null;
    St._globalBatch = a;
  }
  buildDrawCalls(e, t, i) {
    const {
        _bufferedElements: r,
        _attributeBuffer: s,
        _indexBuffer: o,
        vertexSize: a,
      } = this,
      l = Ws._drawCallPool;
    let c = this._dcIndex,
      u = this._aIndex,
      h = this._iIndex,
      d = l[c];
    ((d.start = this._iIndex), (d.texArray = e));
    for (let f = t; f < i; ++f) {
      const g = r[f],
        p = g._texture.baseTexture,
        m = oP[p.alphaMode ? 1 : 0][g.blendMode];
      ((r[f] = null),
        t < f &&
          d.blend !== m &&
          ((d.size = h - d.start),
          (t = f),
          (d = l[++c]),
          (d.texArray = e),
          (d.start = h)),
        this.packInterleavedGeometry(g, s, o, u, h),
        (u += (g.vertexData.length / 2) * a),
        (h += g.indices.length),
        (d.blend = m));
    }
    (t < i && ((d.size = h - d.start), ++c),
      (this._dcIndex = c),
      (this._aIndex = u),
      (this._iIndex = h));
  }
  bindAndClearTexArray(e) {
    const t = this.renderer.texture;
    for (let i = 0; i < e.count; i++)
      (t.bind(e.elements[i], e.ids[i]), (e.elements[i] = null));
    e.count = 0;
  }
  updateGeometry() {
    const { _packedGeometries: e, _attributeBuffer: t, _indexBuffer: i } = this;
    Ws.canUploadSameBuffer
      ? (e[this._flushId]._buffer.update(t.rawBinaryData),
        e[this._flushId]._indexBuffer.update(i),
        this.renderer.geometry.updateBuffers())
      : (this._packedGeometryPoolSize <= this._flushId &&
          (this._packedGeometryPoolSize++,
          (e[this._flushId] = new this.geometryClass())),
        e[this._flushId]._buffer.update(t.rawBinaryData),
        e[this._flushId]._indexBuffer.update(i),
        this.renderer.geometry.bind(e[this._flushId]),
        this.renderer.geometry.updateBuffers(),
        this._flushId++);
  }
  drawBatches() {
    const e = this._dcIndex,
      { gl: t, state: i } = this.renderer,
      r = Ws._drawCallPool;
    let s = null;
    for (let o = 0; o < e; o++) {
      const { texArray: a, type: l, size: c, start: u, blend: h } = r[o];
      (s !== a && ((s = a), this.bindAndClearTexArray(a)),
        (this.state.blendMode = h),
        i.set(this.state),
        t.drawElements(l, c, t.UNSIGNED_SHORT, u * 2));
    }
  }
  flush() {
    this._vertexCount !== 0 &&
      ((this._attributeBuffer = this.getAttributeBuffer(this._vertexCount)),
      (this._indexBuffer = this.getIndexBuffer(this._indexCount)),
      (this._aIndex = 0),
      (this._iIndex = 0),
      (this._dcIndex = 0),
      this.buildTexturesAndDrawCalls(),
      this.updateGeometry(),
      this.drawBatches(),
      (this._bufferSize = 0),
      (this._vertexCount = 0),
      (this._indexCount = 0));
  }
  start() {
    (this.renderer.state.set(this.state),
      this.renderer.texture.ensureSamplerType(this.maxTextures),
      this.renderer.shader.bind(this._shader),
      Ws.canUploadSameBuffer &&
        this.renderer.geometry.bind(this._packedGeometries[this._flushId]));
  }
  stop() {
    this.flush();
  }
  destroy() {
    for (let e = 0; e < this._packedGeometryPoolSize; e++)
      this._packedGeometries[e] && this._packedGeometries[e].destroy();
    (this.renderer.off("prerender", this.onPrerender, this),
      (this._aBuffers = null),
      (this._iBuffers = null),
      (this._packedGeometries = null),
      (this._attributeBuffer = null),
      (this._indexBuffer = null),
      this._shader && (this._shader.destroy(), (this._shader = null)),
      super.destroy());
  }
  getAttributeBuffer(e) {
    const t = cC(Math.ceil(e / 8)),
      i = p6(t),
      r = t * 8;
    this._aBuffers.length <= i && (this._iBuffers.length = i + 1);
    let s = this._aBuffers[r];
    return (s || (this._aBuffers[r] = s = new G3(r * this.vertexSize * 4)), s);
  }
  getIndexBuffer(e) {
    const t = cC(Math.ceil(e / 12)),
      i = p6(t),
      r = t * 12;
    this._iBuffers.length <= i && (this._iBuffers.length = i + 1);
    let s = this._iBuffers[i];
    return (s || (this._iBuffers[i] = s = new Uint16Array(r)), s);
  }
  packInterleavedGeometry(e, t, i, r, s) {
    const { uint32View: o, float32View: a } = t,
      l = r / this.vertexSize,
      c = e.uvs,
      u = e.indices,
      h = e.vertexData,
      d = e._texture.baseTexture._batchLocation,
      f = Math.min(e.worldAlpha, 1),
      g = Ln.shared
        .setValue(e._tintRGB)
        .toPremultiplied(f, e._texture.baseTexture.alphaMode > 0);
    for (let p = 0; p < h.length; p += 2)
      ((a[r++] = h[p]),
        (a[r++] = h[p + 1]),
        (a[r++] = c[p]),
        (a[r++] = c[p + 1]),
        (o[r++] = g),
        (a[r++] = d));
    for (let p = 0; p < u.length; p++) i[s++] = l + u[p];
  }
};
((Hf.defaultBatchSize = 4096),
  (Hf.extension = { name: "batch", type: De.RendererPlugin }),
  (Hf._drawCallPool = []),
  (Hf._textureArrayPool = []));
let Pc = Hf;
je.add(Pc);
var zde = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor = texture2D(uSampler, vTextureCoord);
}
`,
  Yde = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
const Z3 = class Wf extends Bo {
  constructor(e, t, i) {
    const r = ya.from(e || Wf.defaultVertexSrc, t || Wf.defaultFragmentSrc);
    (super(r, i),
      (this.padding = 0),
      (this.resolution = Wf.defaultResolution),
      (this.multisample = Wf.defaultMultisample),
      (this.enabled = !0),
      (this.autoFit = !0),
      (this.state = new Yo()));
  }
  apply(e, t, i, r, s) {
    e.applyFilter(this, t, i, r);
  }
  get blendMode() {
    return this.state.blendMode;
  }
  set blendMode(e) {
    this.state.blendMode = e;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(e) {
    this._resolution = e;
  }
  static get defaultVertexSrc() {
    return Yde;
  }
  static get defaultFragmentSrc() {
    return zde;
  }
};
((Z3.defaultResolution = 1), (Z3.defaultMultisample = ri.NONE));
let fr = Z3;
class dC {
  constructor() {
    ((this.clearBeforeRender = !0),
      (this._backgroundColor = new Ln(0)),
      (this.alpha = 1));
  }
  init(e) {
    this.clearBeforeRender = e.clearBeforeRender;
    const { backgroundColor: t, background: i, backgroundAlpha: r } = e,
      s = i ?? t;
    (s !== void 0 && (this.color = s), (this.alpha = r));
  }
  get color() {
    return this._backgroundColor.value;
  }
  set color(e) {
    this._backgroundColor.setValue(e);
  }
  get alpha() {
    return this._backgroundColor.alpha;
  }
  set alpha(e) {
    this._backgroundColor.setAlpha(e);
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  destroy() {}
}
((dC.defaultOptions = {
  backgroundAlpha: 1,
  backgroundColor: 0,
  clearBeforeRender: !0,
}),
  (dC.extension = {
    type: [De.RendererSystem, De.CanvasRendererSystem],
    name: "background",
  }));
je.add(dC);
class CP {
  constructor(e) {
    ((this.renderer = e),
      (this.emptyRenderer = new II(e)),
      (this.currentRenderer = this.emptyRenderer));
  }
  setObjectRenderer(e) {
    this.currentRenderer !== e &&
      (this.currentRenderer.stop(),
      (this.currentRenderer = e),
      this.currentRenderer.start());
  }
  flush() {
    this.setObjectRenderer(this.emptyRenderer);
  }
  reset() {
    this.setObjectRenderer(this.emptyRenderer);
  }
  copyBoundTextures(e, t) {
    const { boundTextures: i } = this.renderer.texture;
    for (let r = t - 1; r >= 0; --r)
      ((e[r] = i[r] || null), e[r] && (e[r]._batchLocation = r));
  }
  boundArray(e, t, i, r) {
    const { elements: s, ids: o, count: a } = e;
    let l = 0;
    for (let c = 0; c < a; c++) {
      const u = s[c],
        h = u._batchLocation;
      if (h >= 0 && h < r && t[h] === u) {
        o[c] = h;
        continue;
      }
      for (; l < r; ) {
        const d = t[l];
        if (d && d._batchEnabled === i && d._batchLocation === l) {
          l++;
          continue;
        }
        ((o[c] = l), (u._batchLocation = l), (t[l] = u));
        break;
      }
    }
  }
  destroy() {
    this.renderer = null;
  }
}
CP.extension = { type: De.RendererSystem, name: "batch" };
je.add(CP);
let S6 = 0;
class fC {
  constructor(e) {
    ((this.renderer = e),
      (this.webGLVersion = 1),
      (this.extensions = {}),
      (this.supports = { uint32Indices: !1 }),
      (this.handleContextLost = this.handleContextLost.bind(this)),
      (this.handleContextRestored = this.handleContextRestored.bind(this)));
  }
  get isLost() {
    return !this.gl || this.gl.isContextLost();
  }
  contextChange(e) {
    ((this.gl = e), (this.renderer.gl = e), (this.renderer.CONTEXT_UID = S6++));
  }
  init(e) {
    if (e.context) this.initFromContext(e.context);
    else {
      const t = this.renderer.background.alpha < 1,
        i = e.premultipliedAlpha;
      ((this.preserveDrawingBuffer = e.preserveDrawingBuffer),
        (this.useContextAlpha = e.useContextAlpha),
        (this.powerPreference = e.powerPreference),
        this.initFromOptions({
          alpha: t,
          premultipliedAlpha: i,
          antialias: e.antialias,
          stencil: !0,
          preserveDrawingBuffer: e.preserveDrawingBuffer,
          powerPreference: e.powerPreference,
        }));
    }
  }
  initFromContext(e) {
    ((this.gl = e),
      this.validateContext(e),
      (this.renderer.gl = e),
      (this.renderer.CONTEXT_UID = S6++),
      this.renderer.runners.contextChange.emit(e));
    const t = this.renderer.view;
    t.addEventListener !== void 0 &&
      (t.addEventListener("webglcontextlost", this.handleContextLost, !1),
      t.addEventListener(
        "webglcontextrestored",
        this.handleContextRestored,
        !1,
      ));
  }
  initFromOptions(e) {
    const t = this.createContext(this.renderer.view, e);
    this.initFromContext(t);
  }
  createContext(e, t) {
    let i;
    if ((Oe.PREFER_ENV >= Tu.WEBGL2 && (i = e.getContext("webgl2", t)), i))
      this.webGLVersion = 2;
    else if (
      ((this.webGLVersion = 1),
      (i = e.getContext("webgl", t) || e.getContext("experimental-webgl", t)),
      !i)
    )
      throw new Error(
        "This browser does not support WebGL. Try using the canvas renderer",
      );
    return ((this.gl = i), this.getExtensions(), this.gl);
  }
  getExtensions() {
    const { gl: e } = this,
      t = {
        loseContext: e.getExtension("WEBGL_lose_context"),
        anisotropicFiltering: e.getExtension("EXT_texture_filter_anisotropic"),
        floatTextureLinear: e.getExtension("OES_texture_float_linear"),
        s3tc: e.getExtension("WEBGL_compressed_texture_s3tc"),
        s3tc_sRGB: e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
        etc: e.getExtension("WEBGL_compressed_texture_etc"),
        etc1: e.getExtension("WEBGL_compressed_texture_etc1"),
        pvrtc:
          e.getExtension("WEBGL_compressed_texture_pvrtc") ||
          e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
        atc: e.getExtension("WEBGL_compressed_texture_atc"),
        astc: e.getExtension("WEBGL_compressed_texture_astc"),
      };
    this.webGLVersion === 1
      ? Object.assign(this.extensions, t, {
          drawBuffers: e.getExtension("WEBGL_draw_buffers"),
          depthTexture: e.getExtension("WEBGL_depth_texture"),
          vertexArrayObject:
            e.getExtension("OES_vertex_array_object") ||
            e.getExtension("MOZ_OES_vertex_array_object") ||
            e.getExtension("WEBKIT_OES_vertex_array_object"),
          uint32ElementIndex: e.getExtension("OES_element_index_uint"),
          floatTexture: e.getExtension("OES_texture_float"),
          floatTextureLinear: e.getExtension("OES_texture_float_linear"),
          textureHalfFloat: e.getExtension("OES_texture_half_float"),
          textureHalfFloatLinear: e.getExtension(
            "OES_texture_half_float_linear",
          ),
        })
      : this.webGLVersion === 2 &&
        Object.assign(this.extensions, t, {
          colorBufferFloat: e.getExtension("EXT_color_buffer_float"),
        });
  }
  handleContextLost(e) {
    (e.preventDefault(),
      setTimeout(() => {
        this.gl.isContextLost() &&
          this.extensions.loseContext &&
          this.extensions.loseContext.restoreContext();
      }, 0));
  }
  handleContextRestored() {
    this.renderer.runners.contextChange.emit(this.gl);
  }
  destroy() {
    const e = this.renderer.view;
    ((this.renderer = null),
      e.removeEventListener !== void 0 &&
        (e.removeEventListener("webglcontextlost", this.handleContextLost),
        e.removeEventListener(
          "webglcontextrestored",
          this.handleContextRestored,
        )),
      this.gl.useProgram(null),
      this.extensions.loseContext && this.extensions.loseContext.loseContext());
  }
  postrender() {
    this.renderer.objectRenderer.renderingToScreen && this.gl.flush();
  }
  validateContext(e) {
    const t = e.getContextAttributes(),
      i =
        "WebGL2RenderingContext" in globalThis &&
        e instanceof globalThis.WebGL2RenderingContext;
    (i && (this.webGLVersion = 2),
      t &&
        !t.stencil &&
        console.warn(
          "Provided WebGL context does not have a stencil buffer, masks may not render correctly",
        ));
    const r = i || !!e.getExtension("OES_element_index_uint");
    ((this.supports.uint32Indices = r),
      r ||
        console.warn(
          "Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly",
        ));
  }
}
((fC.defaultOptions = {
  context: null,
  antialias: !1,
  premultipliedAlpha: !0,
  preserveDrawingBuffer: !1,
  powerPreference: "default",
}),
  (fC.extension = { type: De.RendererSystem, name: "context" }));
je.add(fC);
class z3 {
  constructor(e, t) {
    if (
      ((this.width = Math.round(e)),
      (this.height = Math.round(t)),
      !this.width || !this.height)
    )
      throw new Error("Framebuffer width or height is zero");
    ((this.stencil = !1),
      (this.depth = !1),
      (this.dirtyId = 0),
      (this.dirtyFormat = 0),
      (this.dirtySize = 0),
      (this.depthTexture = null),
      (this.colorTextures = []),
      (this.glFramebuffers = {}),
      (this.disposeRunner = new qs("disposeFramebuffer")),
      (this.multisample = ri.NONE));
  }
  get colorTexture() {
    return this.colorTextures[0];
  }
  addColorTexture(e = 0, t) {
    return (
      (this.colorTextures[e] =
        t ||
        new St(null, {
          scaleMode: Ca.NEAREST,
          resolution: 1,
          mipmap: Ho.OFF,
          width: this.width,
          height: this.height,
        })),
      this.dirtyId++,
      this.dirtyFormat++,
      this
    );
  }
  addDepthTexture(e) {
    return (
      (this.depthTexture =
        e ||
        new St(null, {
          scaleMode: Ca.NEAREST,
          resolution: 1,
          width: this.width,
          height: this.height,
          mipmap: Ho.OFF,
          format: ve.DEPTH_COMPONENT,
          type: et.UNSIGNED_SHORT,
        })),
      this.dirtyId++,
      this.dirtyFormat++,
      this
    );
  }
  enableDepth() {
    return ((this.depth = !0), this.dirtyId++, this.dirtyFormat++, this);
  }
  enableStencil() {
    return ((this.stencil = !0), this.dirtyId++, this.dirtyFormat++, this);
  }
  resize(e, t) {
    if (((e = Math.round(e)), (t = Math.round(t)), !e || !t))
      throw new Error("Framebuffer width and height must not be zero");
    if (!(e === this.width && t === this.height)) {
      ((this.width = e), (this.height = t), this.dirtyId++, this.dirtySize++);
      for (let i = 0; i < this.colorTextures.length; i++) {
        const r = this.colorTextures[i],
          s = r.resolution;
        r.setSize(e / s, t / s);
      }
      if (this.depthTexture) {
        const i = this.depthTexture.resolution;
        this.depthTexture.setSize(e / i, t / i);
      }
    }
  }
  dispose() {
    this.disposeRunner.emit(this, !1);
  }
  destroyDepthTexture() {
    this.depthTexture &&
      (this.depthTexture.destroy(),
      (this.depthTexture = null),
      ++this.dirtyId,
      ++this.dirtyFormat);
  }
}
class IP extends St {
  constructor(e = {}) {
    if (typeof e == "number") {
      const t = arguments[0],
        i = arguments[1],
        r = arguments[2],
        s = arguments[3];
      e = { width: t, height: i, scaleMode: r, resolution: s };
    }
    ((e.width = e.width ?? 100),
      (e.height = e.height ?? 100),
      e.multisample ?? (e.multisample = ri.NONE),
      super(null, e),
      (this.mipmap = Ho.OFF),
      (this.valid = !0),
      (this._clear = new Ln([0, 0, 0, 0])),
      (this.framebuffer = new z3(
        this.realWidth,
        this.realHeight,
      ).addColorTexture(0, this)),
      (this.framebuffer.multisample = e.multisample),
      (this.maskStack = []),
      (this.filterStack = [{}]));
  }
  set clearColor(e) {
    this._clear.setValue(e);
  }
  get clearColor() {
    return this._clear.value;
  }
  get clear() {
    return this._clear;
  }
  get multisample() {
    return this.framebuffer.multisample;
  }
  set multisample(e) {
    this.framebuffer.multisample = e;
  }
  resize(e, t) {
    (this.framebuffer.resize(e * this.resolution, t * this.resolution),
      this.setRealSize(this.framebuffer.width, this.framebuffer.height));
  }
  dispose() {
    (this.framebuffer.dispose(), super.dispose());
  }
  destroy() {
    (super.destroy(),
      this.framebuffer.destroyDepthTexture(),
      (this.framebuffer = null));
  }
}
class Ol extends jg {
  constructor(e) {
    const t = e,
      i = t.naturalWidth || t.videoWidth || t.width,
      r = t.naturalHeight || t.videoHeight || t.height;
    (super(i, r), (this.source = e), (this.noSubImage = !1));
  }
  static crossOrigin(e, t, i) {
    i === void 0 && !t.startsWith("data:")
      ? (e.crossOrigin = pde(t))
      : i !== !1 && (e.crossOrigin = typeof i == "string" ? i : "anonymous");
  }
  upload(e, t, i, r) {
    const s = e.gl,
      o = t.realWidth,
      a = t.realHeight;
    if (
      ((r = r || this.source),
      typeof HTMLImageElement < "u" && r instanceof HTMLImageElement)
    ) {
      if (!r.complete || r.naturalWidth === 0) return !1;
    } else if (
      typeof HTMLVideoElement < "u" &&
      r instanceof HTMLVideoElement &&
      r.readyState <= 1
    )
      return !1;
    return (
      s.pixelStorei(
        s.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
        t.alphaMode === Tr.UNPACK,
      ),
      !this.noSubImage &&
      t.target === s.TEXTURE_2D &&
      i.width === o &&
      i.height === a
        ? s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, t.format, i.type, r)
        : ((i.width = o),
          (i.height = a),
          s.texImage2D(t.target, 0, i.internalFormat, t.format, i.type, r)),
      !0
    );
  }
  update() {
    if (this.destroyed) return;
    const e = this.source,
      t = e.naturalWidth || e.videoWidth || e.width,
      i = e.naturalHeight || e.videoHeight || e.height;
    (this.resize(t, i), super.update());
  }
  dispose() {
    this.source = null;
  }
}
class AP extends Ol {
  constructor(e, t) {
    if (((t = t || {}), typeof e == "string")) {
      const i = new Image();
      (Ol.crossOrigin(i, e, t.crossorigin), (i.src = e), (e = i));
    }
    (super(e),
      !e.complete &&
        this._width &&
        this._height &&
        ((this._width = 0), (this._height = 0)),
      (this.url = e.src),
      (this._process = null),
      (this.preserveBitmap = !1),
      (this.createBitmap =
        (t.createBitmap ?? Oe.CREATE_IMAGE_BITMAP) &&
        !!globalThis.createImageBitmap),
      (this.alphaMode = typeof t.alphaMode == "number" ? t.alphaMode : null),
      (this.bitmap = null),
      (this._load = null),
      t.autoLoad !== !1 && this.load());
  }
  load(e) {
    return this._load
      ? this._load
      : (e !== void 0 && (this.createBitmap = e),
        (this._load = new Promise((t, i) => {
          const r = this.source;
          this.url = r.src;
          const s = () => {
            this.destroyed ||
              ((r.onload = null),
              (r.onerror = null),
              this.update(),
              (this._load = null),
              this.createBitmap ? t(this.process()) : t(this));
          };
          r.complete && r.src
            ? s()
            : ((r.onload = s),
              (r.onerror = (o) => {
                (i(o), this.onError.emit(o));
              }));
        })),
        this._load);
  }
  process() {
    const e = this.source;
    if (this._process !== null) return this._process;
    if (this.bitmap !== null || !globalThis.createImageBitmap)
      return Promise.resolve(this);
    const t = globalThis.createImageBitmap,
      i = !e.crossOrigin || e.crossOrigin === "anonymous";
    return (
      (this._process = fetch(e.src, { mode: i ? "cors" : "no-cors" })
        .then((r) => r.blob())
        .then((r) =>
          t(r, 0, 0, e.width, e.height, {
            premultiplyAlpha:
              this.alphaMode === null || this.alphaMode === Tr.UNPACK
                ? "premultiply"
                : "none",
          }),
        )
        .then((r) =>
          this.destroyed
            ? Promise.reject()
            : ((this.bitmap = r),
              this.update(),
              (this._process = null),
              Promise.resolve(this)),
        )),
      this._process
    );
  }
  upload(e, t, i) {
    if (
      (typeof this.alphaMode == "number" && (t.alphaMode = this.alphaMode),
      !this.createBitmap)
    )
      return super.upload(e, t, i);
    if (!this.bitmap && (this.process(), !this.bitmap)) return !1;
    if ((super.upload(e, t, i, this.bitmap), !this.preserveBitmap)) {
      let r = !0;
      const s = t._glTextures;
      for (const o in s) {
        const a = s[o];
        if (a !== i && a.dirtyId !== t.dirtyId) {
          r = !1;
          break;
        }
      }
      r && (this.bitmap.close && this.bitmap.close(), (this.bitmap = null));
    }
    return !0;
  }
  dispose() {
    ((this.source.onload = null),
      (this.source.onerror = null),
      super.dispose(),
      this.bitmap && (this.bitmap.close(), (this.bitmap = null)),
      (this._process = null),
      (this._load = null));
  }
  static test(e) {
    return (
      typeof HTMLImageElement < "u" &&
      (typeof e == "string" || e instanceof HTMLImageElement)
    );
  }
}
class w5 {
  constructor() {
    ((this.x0 = 0),
      (this.y0 = 0),
      (this.x1 = 1),
      (this.y1 = 0),
      (this.x2 = 1),
      (this.y2 = 1),
      (this.x3 = 0),
      (this.y3 = 1),
      (this.uvsFloat32 = new Float32Array(8)));
  }
  set(e, t, i) {
    const r = t.width,
      s = t.height;
    if (i) {
      const o = e.width / 2 / r,
        a = e.height / 2 / s,
        l = e.x / r + o,
        c = e.y / s + a;
      ((i = Fn.add(i, Fn.NW)),
        (this.x0 = l + o * Fn.uX(i)),
        (this.y0 = c + a * Fn.uY(i)),
        (i = Fn.add(i, 2)),
        (this.x1 = l + o * Fn.uX(i)),
        (this.y1 = c + a * Fn.uY(i)),
        (i = Fn.add(i, 2)),
        (this.x2 = l + o * Fn.uX(i)),
        (this.y2 = c + a * Fn.uY(i)),
        (i = Fn.add(i, 2)),
        (this.x3 = l + o * Fn.uX(i)),
        (this.y3 = c + a * Fn.uY(i)));
    } else
      ((this.x0 = e.x / r),
        (this.y0 = e.y / s),
        (this.x1 = (e.x + e.width) / r),
        (this.y1 = e.y / s),
        (this.x2 = (e.x + e.width) / r),
        (this.y2 = (e.y + e.height) / s),
        (this.x3 = e.x / r),
        (this.y3 = (e.y + e.height) / s));
    ((this.uvsFloat32[0] = this.x0),
      (this.uvsFloat32[1] = this.y0),
      (this.uvsFloat32[2] = this.x1),
      (this.uvsFloat32[3] = this.y1),
      (this.uvsFloat32[4] = this.x2),
      (this.uvsFloat32[5] = this.y2),
      (this.uvsFloat32[6] = this.x3),
      (this.uvsFloat32[7] = this.y3));
  }
}
w5.prototype.toString = function () {
  return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`;
};
const T6 = new w5();
function Z1(n) {
  ((n.destroy = function () {}),
    (n.on = function () {}),
    (n.once = function () {}),
    (n.emit = function () {}));
}
class Qe extends Lp {
  constructor(e, t, i, r, s, o, a) {
    if (
      (super(),
      (this.noFrame = !1),
      t || ((this.noFrame = !0), (t = new Bt(0, 0, 1, 1))),
      e instanceof Qe && (e = e.baseTexture),
      (this.baseTexture = e),
      (this._frame = t),
      (this.trim = r),
      (this.valid = !1),
      (this.destroyed = !1),
      (this._uvs = T6),
      (this.uvMatrix = null),
      (this.orig = i || t),
      (this._rotate = Number(s || 0)),
      s === !0)
    )
      this._rotate = 2;
    else if (this._rotate % 2 !== 0)
      throw new Error(
        "attempt to use diamond-shaped UVs. If you are sure, set rotation manually",
      );
    ((this.defaultAnchor = o ? new Qt(o.x, o.y) : new Qt(0, 0)),
      (this.defaultBorders = a),
      (this._updateID = 0),
      (this.textureCacheIds = []),
      e.valid
        ? this.noFrame
          ? e.valid && this.onBaseTextureUpdated(e)
          : (this.frame = t)
        : e.once("loaded", this.onBaseTextureUpdated, this),
      this.noFrame && e.on("update", this.onBaseTextureUpdated, this));
  }
  update() {
    this.baseTexture.resource && this.baseTexture.resource.update();
  }
  onBaseTextureUpdated(e) {
    if (this.noFrame) {
      if (!this.baseTexture.valid) return;
      ((this._frame.width = e.width),
        (this._frame.height = e.height),
        (this.valid = !0),
        this.updateUvs());
    } else this.frame = this._frame;
    this.emit("update", this);
  }
  destroy(e) {
    if (this.baseTexture) {
      if (e) {
        const { resource: t } = this.baseTexture;
        (t?.url && uo[t.url] && Qe.removeFromCache(t.url),
          this.baseTexture.destroy());
      }
      (this.baseTexture.off("loaded", this.onBaseTextureUpdated, this),
        this.baseTexture.off("update", this.onBaseTextureUpdated, this),
        (this.baseTexture = null));
    }
    ((this._frame = null),
      (this._uvs = null),
      (this.trim = null),
      (this.orig = null),
      (this.valid = !1),
      Qe.removeFromCache(this),
      (this.textureCacheIds = null),
      (this.destroyed = !0),
      this.emit("destroyed", this),
      this.removeAllListeners());
  }
  clone() {
    const e = this._frame.clone(),
      t = this._frame === this.orig ? e : this.orig.clone(),
      i = new Qe(
        this.baseTexture,
        !this.noFrame && e,
        t,
        this.trim?.clone(),
        this.rotate,
        this.defaultAnchor,
        this.defaultBorders,
      );
    return (this.noFrame && (i._frame = e), i);
  }
  updateUvs() {
    (this._uvs === T6 && (this._uvs = new w5()),
      this._uvs.set(this._frame, this.baseTexture, this.rotate),
      this._updateID++);
  }
  static from(e, t = {}, i = Oe.STRICT_TEXTURE_CACHE) {
    const r = typeof e == "string";
    let s = null;
    if (r) s = e;
    else if (e instanceof St) {
      if (!e.cacheId) {
        const a = t?.pixiIdPrefix || "pixiid";
        ((e.cacheId = `${a}-${Cu()}`), St.addToCache(e, e.cacheId));
      }
      s = e.cacheId;
    } else {
      if (!e._pixiId) {
        const a = t?.pixiIdPrefix || "pixiid";
        e._pixiId = `${a}_${Cu()}`;
      }
      s = e._pixiId;
    }
    let o = uo[s];
    if (r && i && !o)
      throw new Error(`The cacheId "${s}" does not exist in TextureCache.`);
    return (
      !o && !(e instanceof St)
        ? (t.resolution || (t.resolution = Ga(e)),
          (o = new Qe(new St(e, t))),
          (o.baseTexture.cacheId = s),
          St.addToCache(o.baseTexture, s),
          Qe.addToCache(o, s))
        : !o && e instanceof St && ((o = new Qe(e)), Qe.addToCache(o, s)),
      o
    );
  }
  static fromURL(e, t) {
    const i = Object.assign({ autoLoad: !1 }, t?.resourceOptions),
      r = Qe.from(e, Object.assign({ resourceOptions: i }, t), !1),
      s = r.baseTexture.resource;
    return r.baseTexture.valid
      ? Promise.resolve(r)
      : s.load().then(() => Promise.resolve(r));
  }
  static fromBuffer(e, t, i, r) {
    return new Qe(St.fromBuffer(e, t, i, r));
  }
  static fromLoader(e, t, i, r) {
    const s = new St(
        e,
        Object.assign(
          { scaleMode: St.defaultOptions.scaleMode, resolution: Ga(t) },
          r,
        ),
      ),
      { resource: o } = s;
    o instanceof AP && (o.url = t);
    const a = new Qe(s);
    return (
      i || (i = t),
      St.addToCache(a.baseTexture, i),
      Qe.addToCache(a, i),
      i !== t && (St.addToCache(a.baseTexture, t), Qe.addToCache(a, t)),
      a.baseTexture.valid
        ? Promise.resolve(a)
        : new Promise((l) => {
            a.baseTexture.once("loaded", () => l(a));
          })
    );
  }
  static addToCache(e, t) {
    t &&
      (e.textureCacheIds.includes(t) || e.textureCacheIds.push(t),
      uo[t] &&
        uo[t] !== e &&
        console.warn(
          `Texture added to the cache with an id [${t}] that already had an entry`,
        ),
      (uo[t] = e));
  }
  static removeFromCache(e) {
    if (typeof e == "string") {
      const t = uo[e];
      if (t) {
        const i = t.textureCacheIds.indexOf(e);
        return (i > -1 && t.textureCacheIds.splice(i, 1), delete uo[e], t);
      }
    } else if (e?.textureCacheIds) {
      for (let t = 0; t < e.textureCacheIds.length; ++t)
        uo[e.textureCacheIds[t]] === e && delete uo[e.textureCacheIds[t]];
      return ((e.textureCacheIds.length = 0), e);
    }
    return null;
  }
  get resolution() {
    return this.baseTexture.resolution;
  }
  get frame() {
    return this._frame;
  }
  set frame(e) {
    ((this._frame = e), (this.noFrame = !1));
    const { x: t, y: i, width: r, height: s } = e,
      o = t + r > this.baseTexture.width,
      a = i + s > this.baseTexture.height;
    if (o || a) {
      const l = o && a ? "and" : "or",
        c = `X: ${t} + ${r} = ${t + r} > ${this.baseTexture.width}`,
        u = `Y: ${i} + ${s} = ${i + s} > ${this.baseTexture.height}`;
      throw new Error(
        `Texture Error: frame does not fit inside the base Texture dimensions: ${c} ${l} ${u}`,
      );
    }
    ((this.valid = r && s && this.baseTexture.valid),
      !this.trim && !this.rotate && (this.orig = e),
      this.valid && this.updateUvs());
  }
  get rotate() {
    return this._rotate;
  }
  set rotate(e) {
    ((this._rotate = e), this.valid && this.updateUvs());
  }
  get width() {
    return this.orig.width;
  }
  get height() {
    return this.orig.height;
  }
  castToBaseTexture() {
    return this.baseTexture;
  }
  static get EMPTY() {
    return (
      Qe._EMPTY ||
        ((Qe._EMPTY = new Qe(new St())),
        Z1(Qe._EMPTY),
        Z1(Qe._EMPTY.baseTexture)),
      Qe._EMPTY
    );
  }
  static get WHITE() {
    if (!Qe._WHITE) {
      const e = Oe.ADAPTER.createCanvas(16, 16),
        t = e.getContext("2d");
      ((e.width = 16),
        (e.height = 16),
        (t.fillStyle = "white"),
        t.fillRect(0, 0, 16, 16),
        (Qe._WHITE = new Qe(St.from(e))),
        Z1(Qe._WHITE),
        Z1(Qe._WHITE.baseTexture));
    }
    return Qe._WHITE;
  }
}
class Eu extends Qe {
  constructor(e, t) {
    (super(e, t),
      (this.valid = !0),
      (this.filterFrame = null),
      (this.filterPoolKey = null),
      this.updateUvs());
  }
  get framebuffer() {
    return this.baseTexture.framebuffer;
  }
  get multisample() {
    return this.framebuffer.multisample;
  }
  set multisample(e) {
    this.framebuffer.multisample = e;
  }
  resize(e, t, i = !0) {
    const r = this.baseTexture.resolution,
      s = Math.round(e * r) / r,
      o = Math.round(t * r) / r;
    ((this.valid = s > 0 && o > 0),
      (this._frame.width = this.orig.width = s),
      (this._frame.height = this.orig.height = o),
      i && this.baseTexture.resize(s, o),
      this.updateUvs());
  }
  setResolution(e) {
    const { baseTexture: t } = this;
    t.resolution !== e &&
      (t.setResolution(e), this.resize(t.width, t.height, !1));
  }
  static create(e) {
    return new Eu(new IP(e));
  }
}
class yP {
  constructor(e) {
    ((this.texturePool = {}),
      (this.textureOptions = e || {}),
      (this.enableFullScreen = !1),
      (this._pixelsWidth = 0),
      (this._pixelsHeight = 0));
  }
  createTexture(e, t, i = ri.NONE) {
    const r = new IP(
      Object.assign(
        { width: e, height: t, resolution: 1, multisample: i },
        this.textureOptions,
      ),
    );
    return new Eu(r);
  }
  getOptimalTexture(e, t, i = 1, r = ri.NONE) {
    let s;
    ((e = Math.max(Math.ceil(e * i - 1e-6), 1)),
      (t = Math.max(Math.ceil(t * i - 1e-6), 1)),
      !this.enableFullScreen ||
      e !== this._pixelsWidth ||
      t !== this._pixelsHeight
        ? ((e = cC(e)),
          (t = cC(t)),
          (s = (((e & 65535) << 16) | (t & 65535)) >>> 0),
          r > 1 && (s += r * 4294967296))
        : (s = r > 1 ? -r : -1),
      this.texturePool[s] || (this.texturePool[s] = []));
    let o = this.texturePool[s].pop();
    return (
      o || (o = this.createTexture(e, t, r)),
      (o.filterPoolKey = s),
      o.setResolution(i),
      o
    );
  }
  getFilterTexture(e, t, i) {
    const r = this.getOptimalTexture(
      e.width,
      e.height,
      t || e.resolution,
      i || ri.NONE,
    );
    return ((r.filterFrame = e.filterFrame), r);
  }
  returnTexture(e) {
    const t = e.filterPoolKey;
    ((e.filterFrame = null), this.texturePool[t].push(e));
  }
  returnFilterTexture(e) {
    this.returnTexture(e);
  }
  clear(e) {
    if (((e = e !== !1), e))
      for (const t in this.texturePool) {
        const i = this.texturePool[t];
        if (i) for (let r = 0; r < i.length; r++) i[r].destroy(!0);
      }
    this.texturePool = {};
  }
  setScreenSize(e) {
    if (!(e.width === this._pixelsWidth && e.height === this._pixelsHeight)) {
      this.enableFullScreen = e.width > 0 && e.height > 0;
      for (const t in this.texturePool) {
        if (!(Number(t) < 0)) continue;
        const i = this.texturePool[t];
        if (i) for (let r = 0; r < i.length; r++) i[r].destroy(!0);
        this.texturePool[t] = [];
      }
      ((this._pixelsWidth = e.width), (this._pixelsHeight = e.height));
    }
  }
}
yP.SCREEN_KEY = -1;
class Xde extends kl {
  constructor() {
    (super(),
      this.addAttribute(
        "aVertexPosition",
        new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
      ).addIndex([0, 1, 3, 2]));
  }
}
class _P extends kl {
  constructor() {
    (super(),
      (this.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1])),
      (this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])),
      (this.vertexBuffer = new fi(this.vertices)),
      (this.uvBuffer = new fi(this.uvs)),
      this.addAttribute("aVertexPosition", this.vertexBuffer)
        .addAttribute("aTextureCoord", this.uvBuffer)
        .addIndex([0, 1, 2, 0, 2, 3]));
  }
  map(e, t) {
    let i = 0,
      r = 0;
    return (
      (this.uvs[0] = i),
      (this.uvs[1] = r),
      (this.uvs[2] = i + t.width / e.width),
      (this.uvs[3] = r),
      (this.uvs[4] = i + t.width / e.width),
      (this.uvs[5] = r + t.height / e.height),
      (this.uvs[6] = i),
      (this.uvs[7] = r + t.height / e.height),
      (i = t.x),
      (r = t.y),
      (this.vertices[0] = i),
      (this.vertices[1] = r),
      (this.vertices[2] = i + t.width),
      (this.vertices[3] = r),
      (this.vertices[4] = i + t.width),
      (this.vertices[5] = r + t.height),
      (this.vertices[6] = i),
      (this.vertices[7] = r + t.height),
      this.invalidate(),
      this
    );
  }
  invalidate() {
    return (this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this);
  }
}
class Kde {
  constructor() {
    ((this.renderTexture = null),
      (this.target = null),
      (this.legacy = !1),
      (this.resolution = 1),
      (this.multisample = ri.NONE),
      (this.sourceFrame = new Bt()),
      (this.destinationFrame = new Bt()),
      (this.bindingSourceFrame = new Bt()),
      (this.bindingDestinationFrame = new Bt()),
      (this.filters = []),
      (this.transform = null));
  }
  clear() {
    ((this.target = null), (this.filters = null), (this.renderTexture = null));
  }
}
const z1 = [new Qt(), new Qt(), new Qt(), new Qt()],
  GA = new Rn();
class bP {
  constructor(e) {
    ((this.renderer = e),
      (this.defaultFilterStack = [{}]),
      (this.texturePool = new yP()),
      (this.statePool = []),
      (this.quad = new Xde()),
      (this.quadUv = new _P()),
      (this.tempRect = new Bt()),
      (this.activeState = {}),
      (this.globalUniforms = new eo(
        {
          outputFrame: new Bt(),
          inputSize: new Float32Array(4),
          inputPixel: new Float32Array(4),
          inputClamp: new Float32Array(4),
          resolution: 1,
          filterArea: new Float32Array(4),
          filterClamp: new Float32Array(4),
        },
        !0,
      )),
      (this.forceClear = !1),
      (this.useMaxPadding = !1));
  }
  init() {
    this.texturePool.setScreenSize(this.renderer.view);
  }
  push(e, t) {
    const i = this.renderer,
      r = this.defaultFilterStack,
      s = this.statePool.pop() || new Kde(),
      o = i.renderTexture;
    let a, l;
    if (o.current) {
      const m = o.current;
      ((a = m.resolution), (l = m.multisample));
    } else ((a = i.resolution), (l = i.multisample));
    let c = t[0].resolution || a,
      u = t[0].multisample ?? l,
      h = t[0].padding,
      d = t[0].autoFit,
      f = t[0].legacy ?? !0;
    for (let m = 1; m < t.length; m++) {
      const C = t[m];
      ((c = Math.min(c, C.resolution || a)),
        (u = Math.min(u, C.multisample ?? l)),
        (h = this.useMaxPadding ? Math.max(h, C.padding) : h + C.padding),
        (d = d && C.autoFit),
        (f = f || (C.legacy ?? !0)));
    }
    (r.length === 1 && (this.defaultFilterStack[0].renderTexture = o.current),
      r.push(s),
      (s.resolution = c),
      (s.multisample = u),
      (s.legacy = f),
      (s.target = e),
      s.sourceFrame.copyFrom(e.filterArea || e.getBounds(!0)),
      s.sourceFrame.pad(h));
    const g = this.tempRect.copyFrom(o.sourceFrame);
    (i.projection.transform &&
      this.transformAABB(GA.copyFrom(i.projection.transform).invert(), g),
      d
        ? (s.sourceFrame.fit(g),
          (s.sourceFrame.width <= 0 || s.sourceFrame.height <= 0) &&
            ((s.sourceFrame.width = 0), (s.sourceFrame.height = 0)))
        : s.sourceFrame.intersects(g) ||
          ((s.sourceFrame.width = 0), (s.sourceFrame.height = 0)),
      this.roundFrame(
        s.sourceFrame,
        o.current ? o.current.resolution : i.resolution,
        o.sourceFrame,
        o.destinationFrame,
        i.projection.transform,
      ),
      (s.renderTexture = this.getOptimalFilterTexture(
        s.sourceFrame.width,
        s.sourceFrame.height,
        c,
        u,
      )),
      (s.filters = t),
      (s.destinationFrame.width = s.renderTexture.width),
      (s.destinationFrame.height = s.renderTexture.height));
    const p = this.tempRect;
    ((p.x = 0),
      (p.y = 0),
      (p.width = s.sourceFrame.width),
      (p.height = s.sourceFrame.height),
      (s.renderTexture.filterFrame = s.sourceFrame),
      s.bindingSourceFrame.copyFrom(o.sourceFrame),
      s.bindingDestinationFrame.copyFrom(o.destinationFrame),
      (s.transform = i.projection.transform),
      (i.projection.transform = null),
      o.bind(s.renderTexture, s.sourceFrame, p),
      i.framebuffer.clear(0, 0, 0, 0));
  }
  pop() {
    const e = this.defaultFilterStack,
      t = e.pop(),
      i = t.filters;
    this.activeState = t;
    const r = this.globalUniforms.uniforms;
    ((r.outputFrame = t.sourceFrame), (r.resolution = t.resolution));
    const s = r.inputSize,
      o = r.inputPixel,
      a = r.inputClamp;
    if (
      ((s[0] = t.destinationFrame.width),
      (s[1] = t.destinationFrame.height),
      (s[2] = 1 / s[0]),
      (s[3] = 1 / s[1]),
      (o[0] = Math.round(s[0] * t.resolution)),
      (o[1] = Math.round(s[1] * t.resolution)),
      (o[2] = 1 / o[0]),
      (o[3] = 1 / o[1]),
      (a[0] = 0.5 * o[2]),
      (a[1] = 0.5 * o[3]),
      (a[2] = t.sourceFrame.width * s[2] - 0.5 * o[2]),
      (a[3] = t.sourceFrame.height * s[3] - 0.5 * o[3]),
      t.legacy)
    ) {
      const c = r.filterArea;
      ((c[0] = t.destinationFrame.width),
        (c[1] = t.destinationFrame.height),
        (c[2] = t.sourceFrame.x),
        (c[3] = t.sourceFrame.y),
        (r.filterClamp = r.inputClamp));
    }
    this.globalUniforms.update();
    const l = e[e.length - 1];
    if ((this.renderer.framebuffer.blit(), i.length === 1))
      (i[0].apply(this, t.renderTexture, l.renderTexture, Co.BLEND, t),
        this.returnFilterTexture(t.renderTexture));
    else {
      let c = t.renderTexture,
        u = this.getOptimalFilterTexture(c.width, c.height, t.resolution);
      u.filterFrame = c.filterFrame;
      let h = 0;
      for (h = 0; h < i.length - 1; ++h) {
        (h === 1 &&
          t.multisample > 1 &&
          ((u = this.getOptimalFilterTexture(c.width, c.height, t.resolution)),
          (u.filterFrame = c.filterFrame)),
          i[h].apply(this, c, u, Co.CLEAR, t));
        const d = c;
        ((c = u), (u = d));
      }
      (i[h].apply(this, c, l.renderTexture, Co.BLEND, t),
        h > 1 && t.multisample > 1 && this.returnFilterTexture(t.renderTexture),
        this.returnFilterTexture(c),
        this.returnFilterTexture(u));
    }
    (t.clear(), this.statePool.push(t));
  }
  bindAndClear(e, t = Co.CLEAR) {
    const { renderTexture: i, state: r } = this.renderer;
    if (
      (e ===
      this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture
        ? (this.renderer.projection.transform = this.activeState.transform)
        : (this.renderer.projection.transform = null),
      e?.filterFrame)
    ) {
      const o = this.tempRect;
      ((o.x = 0),
        (o.y = 0),
        (o.width = e.filterFrame.width),
        (o.height = e.filterFrame.height),
        i.bind(e, e.filterFrame, o));
    } else
      e !==
      this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture
        ? i.bind(e)
        : this.renderer.renderTexture.bind(
            e,
            this.activeState.bindingSourceFrame,
            this.activeState.bindingDestinationFrame,
          );
    const s = r.stateId & 1 || this.forceClear;
    (t === Co.CLEAR || (t === Co.BLIT && s)) &&
      this.renderer.framebuffer.clear(0, 0, 0, 0);
  }
  applyFilter(e, t, i, r) {
    const s = this.renderer;
    (s.state.set(e.state),
      this.bindAndClear(i, r),
      (e.uniforms.uSampler = t),
      (e.uniforms.filterGlobals = this.globalUniforms),
      s.shader.bind(e),
      (e.legacy = !!e.program.attributeData.aTextureCoord),
      e.legacy
        ? (this.quadUv.map(t._frame, t.filterFrame),
          s.geometry.bind(this.quadUv),
          s.geometry.draw(To.TRIANGLES))
        : (s.geometry.bind(this.quad), s.geometry.draw(To.TRIANGLE_STRIP)));
  }
  calculateSpriteMatrix(e, t) {
    const { sourceFrame: i, destinationFrame: r } = this.activeState,
      { orig: s } = t._texture,
      o = e.set(r.width, 0, 0, r.height, i.x, i.y),
      a = t.worldTransform.copyTo(Rn.TEMP_MATRIX);
    return (
      a.invert(),
      o.prepend(a),
      o.scale(1 / s.width, 1 / s.height),
      o.translate(t.anchor.x, t.anchor.y),
      o
    );
  }
  destroy() {
    ((this.renderer = null), this.texturePool.clear(!1));
  }
  getOptimalFilterTexture(e, t, i = 1, r = ri.NONE) {
    return this.texturePool.getOptimalTexture(e, t, i, r);
  }
  getFilterTexture(e, t, i) {
    if (typeof e == "number") {
      const s = e;
      ((e = t), (t = s));
    }
    e = e || this.activeState.renderTexture;
    const r = this.texturePool.getOptimalTexture(
      e.width,
      e.height,
      t || e.resolution,
      i || ri.NONE,
    );
    return ((r.filterFrame = e.filterFrame), r);
  }
  returnFilterTexture(e) {
    this.texturePool.returnTexture(e);
  }
  emptyPool() {
    this.texturePool.clear(!0);
  }
  resize() {
    this.texturePool.setScreenSize(this.renderer.view);
  }
  transformAABB(e, t) {
    const i = z1[0],
      r = z1[1],
      s = z1[2],
      o = z1[3];
    (i.set(t.left, t.top),
      r.set(t.left, t.bottom),
      s.set(t.right, t.top),
      o.set(t.right, t.bottom),
      e.apply(i, i),
      e.apply(r, r),
      e.apply(s, s),
      e.apply(o, o));
    const a = Math.min(i.x, r.x, s.x, o.x),
      l = Math.min(i.y, r.y, s.y, o.y),
      c = Math.max(i.x, r.x, s.x, o.x),
      u = Math.max(i.y, r.y, s.y, o.y);
    ((t.x = a), (t.y = l), (t.width = c - a), (t.height = u - l));
  }
  roundFrame(e, t, i, r, s) {
    if (!(e.width <= 0 || e.height <= 0 || i.width <= 0 || i.height <= 0)) {
      if (s) {
        const { a: o, b: a, c: l, d: c } = s;
        if (
          (Math.abs(a) > 1e-4 || Math.abs(l) > 1e-4) &&
          (Math.abs(o) > 1e-4 || Math.abs(c) > 1e-4)
        )
          return;
      }
      ((s = s ? GA.copyFrom(s) : GA.identity()),
        s
          .translate(-i.x, -i.y)
          .scale(r.width / i.width, r.height / i.height)
          .translate(r.x, r.y),
        this.transformAABB(s, e),
        e.ceil(t),
        this.transformAABB(s.invert(), e));
    }
  }
}
bP.extension = { type: De.RendererSystem, name: "filter" };
je.add(bP);
class jde {
  constructor(e) {
    ((this.framebuffer = e),
      (this.stencil = null),
      (this.dirtyId = -1),
      (this.dirtyFormat = -1),
      (this.dirtySize = -1),
      (this.multisample = ri.NONE),
      (this.msaaBuffer = null),
      (this.blitFramebuffer = null),
      (this.mipLevel = 0));
  }
}
const $de = new Bt();
class vP {
  constructor(e) {
    ((this.renderer = e),
      (this.managedFramebuffers = []),
      (this.unknownFramebuffer = new z3(10, 10)),
      (this.msaaSamples = null));
  }
  contextChange() {
    this.disposeAll(!0);
    const e = (this.gl = this.renderer.gl);
    if (
      ((this.CONTEXT_UID = this.renderer.CONTEXT_UID),
      (this.current = this.unknownFramebuffer),
      (this.viewport = new Bt()),
      (this.hasMRT = !0),
      (this.writeDepthTexture = !0),
      this.renderer.context.webGLVersion === 1)
    ) {
      let t = this.renderer.context.extensions.drawBuffers,
        i = this.renderer.context.extensions.depthTexture;
      (Oe.PREFER_ENV === Tu.WEBGL_LEGACY && ((t = null), (i = null)),
        t
          ? (e.drawBuffers = (r) => t.drawBuffersWEBGL(r))
          : ((this.hasMRT = !1), (e.drawBuffers = () => {})),
        i || (this.writeDepthTexture = !1));
    } else
      this.msaaSamples = e.getInternalformatParameter(
        e.RENDERBUFFER,
        e.RGBA8,
        e.SAMPLES,
      );
  }
  bind(e, t, i = 0) {
    const { gl: r } = this;
    if (e) {
      const s = e.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(e);
      (this.current !== e &&
        ((this.current = e), r.bindFramebuffer(r.FRAMEBUFFER, s.framebuffer)),
        s.mipLevel !== i && (e.dirtyId++, e.dirtyFormat++, (s.mipLevel = i)),
        s.dirtyId !== e.dirtyId &&
          ((s.dirtyId = e.dirtyId),
          s.dirtyFormat !== e.dirtyFormat
            ? ((s.dirtyFormat = e.dirtyFormat),
              (s.dirtySize = e.dirtySize),
              this.updateFramebuffer(e, i))
            : s.dirtySize !== e.dirtySize &&
              ((s.dirtySize = e.dirtySize), this.resizeFramebuffer(e))));
      for (let o = 0; o < e.colorTextures.length; o++) {
        const a = e.colorTextures[o];
        this.renderer.texture.unbind(a.parentTextureArray || a);
      }
      if ((e.depthTexture && this.renderer.texture.unbind(e.depthTexture), t)) {
        const o = t.width >> i,
          a = t.height >> i,
          l = o / t.width;
        this.setViewport(t.x * l, t.y * l, o, a);
      } else {
        const o = e.width >> i,
          a = e.height >> i;
        this.setViewport(0, 0, o, a);
      }
    } else
      (this.current &&
        ((this.current = null), r.bindFramebuffer(r.FRAMEBUFFER, null)),
        t
          ? this.setViewport(t.x, t.y, t.width, t.height)
          : this.setViewport(0, 0, this.renderer.width, this.renderer.height));
  }
  setViewport(e, t, i, r) {
    const s = this.viewport;
    ((e = Math.round(e)),
      (t = Math.round(t)),
      (i = Math.round(i)),
      (r = Math.round(r)),
      (s.width !== i || s.height !== r || s.x !== e || s.y !== t) &&
        ((s.x = e),
        (s.y = t),
        (s.width = i),
        (s.height = r),
        this.gl.viewport(e, t, i, r)));
  }
  get size() {
    return this.current
      ? { x: 0, y: 0, width: this.current.width, height: this.current.height }
      : {
          x: 0,
          y: 0,
          width: this.renderer.width,
          height: this.renderer.height,
        };
  }
  clear(e, t, i, r, s = A3.COLOR | A3.DEPTH) {
    const { gl: o } = this;
    (o.clearColor(e, t, i, r), o.clear(s));
  }
  initFramebuffer(e) {
    const { gl: t } = this,
      i = new jde(t.createFramebuffer());
    return (
      (i.multisample = this.detectSamples(e.multisample)),
      (e.glFramebuffers[this.CONTEXT_UID] = i),
      this.managedFramebuffers.push(e),
      e.disposeRunner.add(this),
      i
    );
  }
  resizeFramebuffer(e) {
    const { gl: t } = this,
      i = e.glFramebuffers[this.CONTEXT_UID];
    if (i.stencil) {
      t.bindRenderbuffer(t.RENDERBUFFER, i.stencil);
      let o;
      (this.renderer.context.webGLVersion === 1
        ? (o = t.DEPTH_STENCIL)
        : e.depth && e.stencil
          ? (o = t.DEPTH24_STENCIL8)
          : e.depth
            ? (o = t.DEPTH_COMPONENT24)
            : (o = t.STENCIL_INDEX8),
        i.msaaBuffer
          ? t.renderbufferStorageMultisample(
              t.RENDERBUFFER,
              i.multisample,
              o,
              e.width,
              e.height,
            )
          : t.renderbufferStorage(t.RENDERBUFFER, o, e.width, e.height));
    }
    const r = e.colorTextures;
    let s = r.length;
    t.drawBuffers || (s = Math.min(s, 1));
    for (let o = 0; o < s; o++) {
      const a = r[o],
        l = a.parentTextureArray || a;
      (this.renderer.texture.bind(l, 0),
        o === 0 &&
          i.msaaBuffer &&
          (t.bindRenderbuffer(t.RENDERBUFFER, i.msaaBuffer),
          t.renderbufferStorageMultisample(
            t.RENDERBUFFER,
            i.multisample,
            l._glTextures[this.CONTEXT_UID].internalFormat,
            e.width,
            e.height,
          )));
    }
    e.depthTexture &&
      this.writeDepthTexture &&
      this.renderer.texture.bind(e.depthTexture, 0);
  }
  updateFramebuffer(e, t) {
    const { gl: i } = this,
      r = e.glFramebuffers[this.CONTEXT_UID],
      s = e.colorTextures;
    let o = s.length;
    (i.drawBuffers || (o = Math.min(o, 1)),
      r.multisample > 1 && this.canMultisampleFramebuffer(e)
        ? (r.msaaBuffer = r.msaaBuffer || i.createRenderbuffer())
        : r.msaaBuffer &&
          (i.deleteRenderbuffer(r.msaaBuffer),
          (r.msaaBuffer = null),
          r.blitFramebuffer &&
            (r.blitFramebuffer.dispose(), (r.blitFramebuffer = null))));
    const a = [];
    for (let l = 0; l < o; l++) {
      const c = s[l],
        u = c.parentTextureArray || c;
      (this.renderer.texture.bind(u, 0),
        l === 0 && r.msaaBuffer
          ? (i.bindRenderbuffer(i.RENDERBUFFER, r.msaaBuffer),
            i.renderbufferStorageMultisample(
              i.RENDERBUFFER,
              r.multisample,
              u._glTextures[this.CONTEXT_UID].internalFormat,
              e.width,
              e.height,
            ),
            i.framebufferRenderbuffer(
              i.FRAMEBUFFER,
              i.COLOR_ATTACHMENT0,
              i.RENDERBUFFER,
              r.msaaBuffer,
            ))
          : (i.framebufferTexture2D(
              i.FRAMEBUFFER,
              i.COLOR_ATTACHMENT0 + l,
              c.target,
              u._glTextures[this.CONTEXT_UID].texture,
              t,
            ),
            a.push(i.COLOR_ATTACHMENT0 + l)));
    }
    if (
      (a.length > 1 && i.drawBuffers(a),
      e.depthTexture && this.writeDepthTexture)
    ) {
      const l = e.depthTexture;
      (this.renderer.texture.bind(l, 0),
        i.framebufferTexture2D(
          i.FRAMEBUFFER,
          i.DEPTH_ATTACHMENT,
          i.TEXTURE_2D,
          l._glTextures[this.CONTEXT_UID].texture,
          t,
        ));
    }
    if ((e.stencil || e.depth) && !(e.depthTexture && this.writeDepthTexture)) {
      r.stencil = r.stencil || i.createRenderbuffer();
      let l, c;
      (this.renderer.context.webGLVersion === 1
        ? ((l = i.DEPTH_STENCIL_ATTACHMENT), (c = i.DEPTH_STENCIL))
        : e.depth && e.stencil
          ? ((l = i.DEPTH_STENCIL_ATTACHMENT), (c = i.DEPTH24_STENCIL8))
          : e.depth
            ? ((l = i.DEPTH_ATTACHMENT), (c = i.DEPTH_COMPONENT24))
            : ((l = i.STENCIL_ATTACHMENT), (c = i.STENCIL_INDEX8)),
        i.bindRenderbuffer(i.RENDERBUFFER, r.stencil),
        r.msaaBuffer
          ? i.renderbufferStorageMultisample(
              i.RENDERBUFFER,
              r.multisample,
              c,
              e.width,
              e.height,
            )
          : i.renderbufferStorage(i.RENDERBUFFER, c, e.width, e.height),
        i.framebufferRenderbuffer(i.FRAMEBUFFER, l, i.RENDERBUFFER, r.stencil));
    } else r.stencil && (i.deleteRenderbuffer(r.stencil), (r.stencil = null));
  }
  canMultisampleFramebuffer(e) {
    return (
      this.renderer.context.webGLVersion !== 1 &&
      e.colorTextures.length <= 1 &&
      !e.depthTexture
    );
  }
  detectSamples(e) {
    const { msaaSamples: t } = this;
    let i = ri.NONE;
    if (e <= 1 || t === null) return i;
    for (let r = 0; r < t.length; r++)
      if (t[r] <= e) {
        i = t[r];
        break;
      }
    return (i === 1 && (i = ri.NONE), i);
  }
  blit(e, t, i) {
    const { current: r, renderer: s, gl: o, CONTEXT_UID: a } = this;
    if (s.context.webGLVersion !== 2 || !r) return;
    const l = r.glFramebuffers[a];
    if (!l) return;
    if (!e) {
      if (!l.msaaBuffer) return;
      const u = r.colorTextures[0];
      if (!u) return;
      (l.blitFramebuffer ||
        ((l.blitFramebuffer = new z3(r.width, r.height)),
        l.blitFramebuffer.addColorTexture(0, u)),
        (e = l.blitFramebuffer),
        e.colorTextures[0] !== u &&
          ((e.colorTextures[0] = u), e.dirtyId++, e.dirtyFormat++),
        (e.width !== r.width || e.height !== r.height) &&
          ((e.width = r.width),
          (e.height = r.height),
          e.dirtyId++,
          e.dirtySize++));
    }
    (t || ((t = $de), (t.width = r.width), (t.height = r.height)),
      i || (i = t));
    const c = t.width === i.width && t.height === i.height;
    (this.bind(e),
      o.bindFramebuffer(o.READ_FRAMEBUFFER, l.framebuffer),
      o.blitFramebuffer(
        t.left,
        t.top,
        t.right,
        t.bottom,
        i.left,
        i.top,
        i.right,
        i.bottom,
        o.COLOR_BUFFER_BIT,
        c ? o.NEAREST : o.LINEAR,
      ),
      o.bindFramebuffer(
        o.READ_FRAMEBUFFER,
        e.glFramebuffers[this.CONTEXT_UID].framebuffer,
      ));
  }
  disposeFramebuffer(e, t) {
    const i = e.glFramebuffers[this.CONTEXT_UID],
      r = this.gl;
    if (!i) return;
    delete e.glFramebuffers[this.CONTEXT_UID];
    const s = this.managedFramebuffers.indexOf(e);
    (s >= 0 && this.managedFramebuffers.splice(s, 1),
      e.disposeRunner.remove(this),
      t ||
        (r.deleteFramebuffer(i.framebuffer),
        i.msaaBuffer && r.deleteRenderbuffer(i.msaaBuffer),
        i.stencil && r.deleteRenderbuffer(i.stencil)),
      i.blitFramebuffer && this.disposeFramebuffer(i.blitFramebuffer, t));
  }
  disposeAll(e) {
    const t = this.managedFramebuffers;
    this.managedFramebuffers = [];
    for (let i = 0; i < t.length; i++) this.disposeFramebuffer(t[i], e);
  }
  forceStencil() {
    const e = this.current;
    if (!e) return;
    const t = e.glFramebuffers[this.CONTEXT_UID];
    if (!t || (t.stencil && e.stencil)) return;
    e.stencil = !0;
    const i = e.width,
      r = e.height,
      s = this.gl,
      o = (t.stencil = s.createRenderbuffer());
    s.bindRenderbuffer(s.RENDERBUFFER, o);
    let a, l;
    (this.renderer.context.webGLVersion === 1
      ? ((a = s.DEPTH_STENCIL_ATTACHMENT), (l = s.DEPTH_STENCIL))
      : e.depth
        ? ((a = s.DEPTH_STENCIL_ATTACHMENT), (l = s.DEPTH24_STENCIL8))
        : ((a = s.STENCIL_ATTACHMENT), (l = s.STENCIL_INDEX8)),
      t.msaaBuffer
        ? s.renderbufferStorageMultisample(
            s.RENDERBUFFER,
            t.multisample,
            l,
            i,
            r,
          )
        : s.renderbufferStorage(s.RENDERBUFFER, l, i, r),
      s.framebufferRenderbuffer(s.FRAMEBUFFER, a, s.RENDERBUFFER, o));
  }
  reset() {
    ((this.current = this.unknownFramebuffer), (this.viewport = new Bt()));
  }
  destroy() {
    this.renderer = null;
  }
}
vP.extension = { type: De.RendererSystem, name: "framebuffer" };
je.add(vP);
const FA = { 5126: 4, 5123: 2, 5121: 1 };
class xP {
  constructor(e) {
    ((this.renderer = e),
      (this._activeGeometry = null),
      (this._activeVao = null),
      (this.hasVao = !0),
      (this.hasInstance = !0),
      (this.canUseUInt32ElementIndex = !1),
      (this.managedGeometries = {}));
  }
  contextChange() {
    this.disposeAll(!0);
    const e = (this.gl = this.renderer.gl),
      t = this.renderer.context;
    if (
      ((this.CONTEXT_UID = this.renderer.CONTEXT_UID), t.webGLVersion !== 2)
    ) {
      let i = this.renderer.context.extensions.vertexArrayObject;
      (Oe.PREFER_ENV === Tu.WEBGL_LEGACY && (i = null),
        i
          ? ((e.createVertexArray = () => i.createVertexArrayOES()),
            (e.bindVertexArray = (r) => i.bindVertexArrayOES(r)),
            (e.deleteVertexArray = (r) => i.deleteVertexArrayOES(r)))
          : ((this.hasVao = !1),
            (e.createVertexArray = () => null),
            (e.bindVertexArray = () => null),
            (e.deleteVertexArray = () => null)));
    }
    if (t.webGLVersion !== 2) {
      const i = e.getExtension("ANGLE_instanced_arrays");
      i
        ? ((e.vertexAttribDivisor = (r, s) => i.vertexAttribDivisorANGLE(r, s)),
          (e.drawElementsInstanced = (r, s, o, a, l) =>
            i.drawElementsInstancedANGLE(r, s, o, a, l)),
          (e.drawArraysInstanced = (r, s, o, a) =>
            i.drawArraysInstancedANGLE(r, s, o, a)))
        : (this.hasInstance = !1);
    }
    this.canUseUInt32ElementIndex =
      t.webGLVersion === 2 || !!t.extensions.uint32ElementIndex;
  }
  bind(e, t) {
    t = t || this.renderer.shader.shader;
    const { gl: i } = this;
    let r = e.glVertexArrayObjects[this.CONTEXT_UID],
      s = !1;
    r ||
      ((this.managedGeometries[e.id] = e),
      e.disposeRunner.add(this),
      (e.glVertexArrayObjects[this.CONTEXT_UID] = r = {}),
      (s = !0));
    const o = r[t.program.id] || this.initGeometryVao(e, t, s);
    ((this._activeGeometry = e),
      this._activeVao !== o &&
        ((this._activeVao = o),
        this.hasVao ? i.bindVertexArray(o) : this.activateVao(e, t.program)),
      this.updateBuffers());
  }
  reset() {
    this.unbind();
  }
  updateBuffers() {
    const e = this._activeGeometry,
      t = this.renderer.buffer;
    for (let i = 0; i < e.buffers.length; i++) {
      const r = e.buffers[i];
      t.update(r);
    }
  }
  checkCompatibility(e, t) {
    const i = e.attributes,
      r = t.attributeData;
    for (const s in r)
      if (!i[s])
        throw new Error(
          `shader and geometry incompatible, geometry missing the "${s}" attribute`,
        );
  }
  getSignature(e, t) {
    const i = e.attributes,
      r = t.attributeData,
      s = ["g", e.id];
    for (const o in i) r[o] && s.push(o, r[o].location);
    return s.join("-");
  }
  initGeometryVao(e, t, i = !0) {
    const r = this.gl,
      s = this.CONTEXT_UID,
      o = this.renderer.buffer,
      a = t.program;
    (a.glPrograms[s] || this.renderer.shader.generateProgram(t),
      this.checkCompatibility(e, a));
    const l = this.getSignature(e, a),
      c = e.glVertexArrayObjects[this.CONTEXT_UID];
    let u = c[l];
    if (u) return ((c[a.id] = u), u);
    const h = e.buffers,
      d = e.attributes,
      f = {},
      g = {};
    for (const p in h) ((f[p] = 0), (g[p] = 0));
    for (const p in d)
      (!d[p].size && a.attributeData[p]
        ? (d[p].size = a.attributeData[p].size)
        : d[p].size ||
          console.warn(
            `PIXI Geometry attribute '${p}' size cannot be determined (likely the bound shader does not have the attribute)`,
          ),
        (f[d[p].buffer] += d[p].size * FA[d[p].type]));
    for (const p in d) {
      const m = d[p],
        C = m.size;
      (m.stride === void 0 &&
        (f[m.buffer] === C * FA[m.type]
          ? (m.stride = 0)
          : (m.stride = f[m.buffer])),
        m.start === void 0 &&
          ((m.start = g[m.buffer]), (g[m.buffer] += C * FA[m.type])));
    }
    ((u = r.createVertexArray()), r.bindVertexArray(u));
    for (let p = 0; p < h.length; p++) {
      const m = h[p];
      (o.bind(m), i && m._glBuffers[s].refCount++);
    }
    return (
      this.activateVao(e, a),
      (c[a.id] = u),
      (c[l] = u),
      r.bindVertexArray(null),
      o.unbind(Ro.ARRAY_BUFFER),
      u
    );
  }
  disposeGeometry(e, t) {
    if (!this.managedGeometries[e.id]) return;
    delete this.managedGeometries[e.id];
    const i = e.glVertexArrayObjects[this.CONTEXT_UID],
      r = this.gl,
      s = e.buffers,
      o = this.renderer?.buffer;
    if ((e.disposeRunner.remove(this), !!i)) {
      if (o)
        for (let a = 0; a < s.length; a++) {
          const l = s[a]._glBuffers[this.CONTEXT_UID];
          l && (l.refCount--, l.refCount === 0 && !t && o.dispose(s[a], t));
        }
      if (!t) {
        for (const a in i)
          if (a[0] === "g") {
            const l = i[a];
            (this._activeVao === l && this.unbind(), r.deleteVertexArray(l));
          }
      }
      delete e.glVertexArrayObjects[this.CONTEXT_UID];
    }
  }
  disposeAll(e) {
    const t = Object.keys(this.managedGeometries);
    for (let i = 0; i < t.length; i++)
      this.disposeGeometry(this.managedGeometries[t[i]], e);
  }
  activateVao(e, t) {
    const i = this.gl,
      r = this.CONTEXT_UID,
      s = this.renderer.buffer,
      o = e.buffers,
      a = e.attributes;
    e.indexBuffer && s.bind(e.indexBuffer);
    let l = null;
    for (const c in a) {
      const u = a[c],
        h = o[u.buffer],
        d = h._glBuffers[r];
      if (t.attributeData[c]) {
        l !== d && (s.bind(h), (l = d));
        const f = t.attributeData[c].location;
        if (
          (i.enableVertexAttribArray(f),
          i.vertexAttribPointer(
            f,
            u.size,
            u.type || i.FLOAT,
            u.normalized,
            u.stride,
            u.start,
          ),
          u.instance)
        )
          if (this.hasInstance) i.vertexAttribDivisor(f, u.divisor);
          else
            throw new Error(
              "geometry error, GPU Instancing is not supported on this device",
            );
      }
    }
  }
  draw(e, t, i, r) {
    const { gl: s } = this,
      o = this._activeGeometry;
    if (o.indexBuffer) {
      const a = o.indexBuffer.data.BYTES_PER_ELEMENT,
        l = a === 2 ? s.UNSIGNED_SHORT : s.UNSIGNED_INT;
      a === 2 || (a === 4 && this.canUseUInt32ElementIndex)
        ? o.instanced
          ? s.drawElementsInstanced(
              e,
              t || o.indexBuffer.data.length,
              l,
              (i || 0) * a,
              r || 1,
            )
          : s.drawElements(e, t || o.indexBuffer.data.length, l, (i || 0) * a)
        : console.warn("unsupported index buffer type: uint32");
    } else
      o.instanced
        ? s.drawArraysInstanced(e, i, t || o.getSize(), r || 1)
        : s.drawArrays(e, i, t || o.getSize());
    return this;
  }
  unbind() {
    (this.gl.bindVertexArray(null),
      (this._activeVao = null),
      (this._activeGeometry = null));
  }
  destroy() {
    this.renderer = null;
  }
}
xP.extension = { type: De.RendererSystem, name: "geometry" };
je.add(xP);
const E6 = new Rn();
class wP {
  constructor(e, t) {
    ((this._texture = e),
      (this.mapCoord = new Rn()),
      (this.uClampFrame = new Float32Array(4)),
      (this.uClampOffset = new Float32Array(2)),
      (this._textureID = -1),
      (this._updateID = 0),
      (this.clampOffset = 0),
      (this.clampMargin = typeof t > "u" ? 0.5 : t),
      (this.isSimple = !1));
  }
  get texture() {
    return this._texture;
  }
  set texture(e) {
    ((this._texture = e), (this._textureID = -1));
  }
  multiplyUvs(e, t) {
    t === void 0 && (t = e);
    const i = this.mapCoord;
    for (let r = 0; r < e.length; r += 2) {
      const s = e[r],
        o = e[r + 1];
      ((t[r] = s * i.a + o * i.c + i.tx),
        (t[r + 1] = s * i.b + o * i.d + i.ty));
    }
    return t;
  }
  update(e) {
    const t = this._texture;
    if (!t || !t.valid || (!e && this._textureID === t._updateID)) return !1;
    ((this._textureID = t._updateID), this._updateID++);
    const i = t._uvs;
    this.mapCoord.set(
      i.x1 - i.x0,
      i.y1 - i.y0,
      i.x3 - i.x0,
      i.y3 - i.y0,
      i.x0,
      i.y0,
    );
    const r = t.orig,
      s = t.trim;
    s &&
      (E6.set(
        r.width / s.width,
        0,
        0,
        r.height / s.height,
        -s.x / s.width,
        -s.y / s.height,
      ),
      this.mapCoord.append(E6));
    const o = t.baseTexture,
      a = this.uClampFrame,
      l = this.clampMargin / o.resolution,
      c = this.clampOffset;
    return (
      (a[0] = (t._frame.x + l + c) / o.width),
      (a[1] = (t._frame.y + l + c) / o.height),
      (a[2] = (t._frame.x + t._frame.width - l + c) / o.width),
      (a[3] = (t._frame.y + t._frame.height - l + c) / o.height),
      (this.uClampOffset[0] = c / o.realWidth),
      (this.uClampOffset[1] = c / o.realHeight),
      (this.isSimple =
        t._frame.width === o.width &&
        t._frame.height === o.height &&
        t.rotate === 0),
      !0
    );
  }
}
var Jde = `varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mask;
uniform float alpha;
uniform float npmAlpha;
uniform vec4 maskClamp;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    vec4 original = texture2D(uSampler, vTextureCoord);
    vec4 masky = texture2D(mask, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    gl_FragColor = original;
}
`,
  Qde = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 otherMatrix;

varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
}
`;
class qde extends fr {
  constructor(e, t, i) {
    let r = null;
    (typeof e != "string" &&
      t === void 0 &&
      i === void 0 &&
      ((r = e), (e = void 0), (t = void 0), (i = void 0)),
      super(e || Qde, t || Jde, i),
      (this.maskSprite = r),
      (this.maskMatrix = new Rn()));
  }
  get maskSprite() {
    return this._maskSprite;
  }
  set maskSprite(e) {
    ((this._maskSprite = e),
      this._maskSprite && (this._maskSprite.renderable = !1));
  }
  apply(e, t, i, r) {
    const s = this._maskSprite,
      o = s._texture;
    o.valid &&
      (o.uvMatrix || (o.uvMatrix = new wP(o, 0)),
      o.uvMatrix.update(),
      (this.uniforms.npmAlpha = o.baseTexture.alphaMode ? 0 : 1),
      (this.uniforms.mask = o),
      (this.uniforms.otherMatrix = e
        .calculateSpriteMatrix(this.maskMatrix, s)
        .prepend(o.uvMatrix.mapCoord)),
      (this.uniforms.alpha = s.worldAlpha),
      (this.uniforms.maskClamp = o.uvMatrix.uClampFrame),
      e.applyFilter(this, t, i, r));
  }
}
class efe {
  constructor(e = null) {
    ((this.type = hi.NONE),
      (this.autoDetect = !0),
      (this.maskObject = e || null),
      (this.pooled = !1),
      (this.isMaskData = !0),
      (this.resolution = null),
      (this.multisample = fr.defaultMultisample),
      (this.enabled = !0),
      (this.colorMask = 15),
      (this._filters = null),
      (this._stencilCounter = 0),
      (this._scissorCounter = 0),
      (this._scissorRect = null),
      (this._scissorRectLocal = null),
      (this._colorMask = 15),
      (this._target = null));
  }
  get filter() {
    return this._filters ? this._filters[0] : null;
  }
  set filter(e) {
    e
      ? this._filters
        ? (this._filters[0] = e)
        : (this._filters = [e])
      : (this._filters = null);
  }
  reset() {
    (this.pooled &&
      ((this.maskObject = null), (this.type = hi.NONE), (this.autoDetect = !0)),
      (this._target = null),
      (this._scissorRectLocal = null));
  }
  copyCountersOrReset(e) {
    e
      ? ((this._stencilCounter = e._stencilCounter),
        (this._scissorCounter = e._scissorCounter),
        (this._scissorRect = e._scissorRect))
      : ((this._stencilCounter = 0),
        (this._scissorCounter = 0),
        (this._scissorRect = null));
  }
}
class SP {
  constructor(e) {
    ((this.renderer = e),
      (this.enableScissor = !0),
      (this.alphaMaskPool = []),
      (this.maskDataPool = []),
      (this.maskStack = []),
      (this.alphaMaskIndex = 0));
  }
  setMaskStack(e) {
    ((this.maskStack = e),
      this.renderer.scissor.setMaskStack(e),
      this.renderer.stencil.setMaskStack(e));
  }
  push(e, t) {
    let i = t;
    if (!i.isMaskData) {
      const s = this.maskDataPool.pop() || new efe();
      ((s.pooled = !0), (s.maskObject = t), (i = s));
    }
    const r =
      this.maskStack.length !== 0
        ? this.maskStack[this.maskStack.length - 1]
        : null;
    if (
      (i.copyCountersOrReset(r),
      (i._colorMask = r ? r._colorMask : 15),
      i.autoDetect && this.detect(i),
      (i._target = e),
      i.type !== hi.SPRITE && this.maskStack.push(i),
      i.enabled)
    )
      switch (i.type) {
        case hi.SCISSOR:
          this.renderer.scissor.push(i);
          break;
        case hi.STENCIL:
          this.renderer.stencil.push(i);
          break;
        case hi.SPRITE:
          (i.copyCountersOrReset(null), this.pushSpriteMask(i));
          break;
        case hi.COLOR:
          this.pushColorMask(i);
          break;
      }
    i.type === hi.SPRITE && this.maskStack.push(i);
  }
  pop(e) {
    const t = this.maskStack.pop();
    if (!(!t || t._target !== e)) {
      if (t.enabled)
        switch (t.type) {
          case hi.SCISSOR:
            this.renderer.scissor.pop(t);
            break;
          case hi.STENCIL:
            this.renderer.stencil.pop(t.maskObject);
            break;
          case hi.SPRITE:
            this.popSpriteMask(t);
            break;
          case hi.COLOR:
            this.popColorMask(t);
            break;
        }
      if (
        (t.reset(),
        t.pooled && this.maskDataPool.push(t),
        this.maskStack.length !== 0)
      ) {
        const i = this.maskStack[this.maskStack.length - 1];
        i.type === hi.SPRITE &&
          i._filters &&
          (i._filters[0].maskSprite = i.maskObject);
      }
    }
  }
  detect(e) {
    const t = e.maskObject;
    t
      ? t.isSprite
        ? (e.type = hi.SPRITE)
        : this.enableScissor && this.renderer.scissor.testScissor(e)
          ? (e.type = hi.SCISSOR)
          : (e.type = hi.STENCIL)
      : (e.type = hi.COLOR);
  }
  pushSpriteMask(e) {
    const { maskObject: t } = e,
      i = e._target;
    let r = e._filters;
    (r ||
      ((r = this.alphaMaskPool[this.alphaMaskIndex]),
      r || (r = this.alphaMaskPool[this.alphaMaskIndex] = [new qde()])),
      (r[0].resolution = e.resolution),
      (r[0].multisample = e.multisample),
      (r[0].maskSprite = t));
    const s = i.filterArea;
    ((i.filterArea = t.getBounds(!0)),
      this.renderer.filter.push(i, r),
      (i.filterArea = s),
      e._filters || this.alphaMaskIndex++);
  }
  popSpriteMask(e) {
    (this.renderer.filter.pop(),
      e._filters
        ? (e._filters[0].maskSprite = null)
        : (this.alphaMaskIndex--,
          (this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null)));
  }
  pushColorMask(e) {
    const t = e._colorMask,
      i = (e._colorMask = t & e.colorMask);
    i !== t &&
      this.renderer.gl.colorMask(
        (i & 1) !== 0,
        (i & 2) !== 0,
        (i & 4) !== 0,
        (i & 8) !== 0,
      );
  }
  popColorMask(e) {
    const t = e._colorMask,
      i =
        this.maskStack.length > 0
          ? this.maskStack[this.maskStack.length - 1]._colorMask
          : 15;
    i !== t &&
      this.renderer.gl.colorMask(
        (i & 1) !== 0,
        (i & 2) !== 0,
        (i & 4) !== 0,
        (i & 8) !== 0,
      );
  }
  destroy() {
    this.renderer = null;
  }
}
SP.extension = { type: De.RendererSystem, name: "mask" };
je.add(SP);
class TP {
  constructor(e) {
    ((this.renderer = e), (this.maskStack = []), (this.glConst = 0));
  }
  getStackLength() {
    return this.maskStack.length;
  }
  setMaskStack(e) {
    const { gl: t } = this.renderer,
      i = this.getStackLength();
    this.maskStack = e;
    const r = this.getStackLength();
    r !== i &&
      (r === 0
        ? t.disable(this.glConst)
        : (t.enable(this.glConst), this._useCurrent()));
  }
  _useCurrent() {}
  destroy() {
    ((this.renderer = null), (this.maskStack = null));
  }
}
const M6 = new Rn(),
  L6 = [],
  EP = class J0 extends TP {
    constructor(e) {
      (super(e),
        (this.glConst = Oe.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST));
    }
    getStackLength() {
      const e = this.maskStack[this.maskStack.length - 1];
      return e ? e._scissorCounter : 0;
    }
    calcScissorRect(e) {
      if (e._scissorRectLocal) return;
      const t = e._scissorRect,
        { maskObject: i } = e,
        { renderer: r } = this,
        s = r.renderTexture,
        o = i.getBounds(!0, L6.pop() ?? new Bt());
      (this.roundFrameToPixels(
        o,
        s.current ? s.current.resolution : r.resolution,
        s.sourceFrame,
        s.destinationFrame,
        r.projection.transform,
      ),
        t && o.fit(t),
        (e._scissorRectLocal = o));
    }
    static isMatrixRotated(e) {
      if (!e) return !1;
      const { a: t, b: i, c: r, d: s } = e;
      return (
        (Math.abs(i) > 1e-4 || Math.abs(r) > 1e-4) &&
        (Math.abs(t) > 1e-4 || Math.abs(s) > 1e-4)
      );
    }
    testScissor(e) {
      const { maskObject: t } = e;
      if (
        !t.isFastRect ||
        !t.isFastRect() ||
        J0.isMatrixRotated(t.worldTransform) ||
        J0.isMatrixRotated(this.renderer.projection.transform)
      )
        return !1;
      this.calcScissorRect(e);
      const i = e._scissorRectLocal;
      return i.width > 0 && i.height > 0;
    }
    roundFrameToPixels(e, t, i, r, s) {
      J0.isMatrixRotated(s) ||
        ((s = s ? M6.copyFrom(s) : M6.identity()),
        s
          .translate(-i.x, -i.y)
          .scale(r.width / i.width, r.height / i.height)
          .translate(r.x, r.y),
        this.renderer.filter.transformAABB(s, e),
        e.fit(r),
        (e.x = Math.round(e.x * t)),
        (e.y = Math.round(e.y * t)),
        (e.width = Math.round(e.width * t)),
        (e.height = Math.round(e.height * t)));
    }
    push(e) {
      e._scissorRectLocal || this.calcScissorRect(e);
      const { gl: t } = this.renderer;
      (e._scissorRect || t.enable(t.SCISSOR_TEST),
        e._scissorCounter++,
        (e._scissorRect = e._scissorRectLocal),
        this._useCurrent());
    }
    pop(e) {
      const { gl: t } = this.renderer;
      (e && L6.push(e._scissorRectLocal),
        this.getStackLength() > 0
          ? this._useCurrent()
          : t.disable(t.SCISSOR_TEST));
    }
    _useCurrent() {
      const e = this.maskStack[this.maskStack.length - 1]._scissorRect;
      let t;
      (this.renderer.renderTexture.current
        ? (t = e.y)
        : (t = this.renderer.height - e.height - e.y),
        this.renderer.gl.scissor(e.x, t, e.width, e.height));
    }
  };
EP.extension = { type: De.RendererSystem, name: "scissor" };
let tfe = EP;
je.add(tfe);
class MP extends TP {
  constructor(e) {
    (super(e),
      (this.glConst = Oe.ADAPTER.getWebGLRenderingContext().STENCIL_TEST));
  }
  getStackLength() {
    const e = this.maskStack[this.maskStack.length - 1];
    return e ? e._stencilCounter : 0;
  }
  push(e) {
    const t = e.maskObject,
      { gl: i } = this.renderer,
      r = e._stencilCounter;
    (r === 0 &&
      (this.renderer.framebuffer.forceStencil(),
      i.clearStencil(0),
      i.clear(i.STENCIL_BUFFER_BIT),
      i.enable(i.STENCIL_TEST)),
      e._stencilCounter++);
    const s = e._colorMask;
    (s !== 0 && ((e._colorMask = 0), i.colorMask(!1, !1, !1, !1)),
      i.stencilFunc(i.EQUAL, r, 4294967295),
      i.stencilOp(i.KEEP, i.KEEP, i.INCR),
      (t.renderable = !0),
      t.render(this.renderer),
      this.renderer.batch.flush(),
      (t.renderable = !1),
      s !== 0 &&
        ((e._colorMask = s),
        i.colorMask(
          (s & 1) !== 0,
          (s & 2) !== 0,
          (s & 4) !== 0,
          (s & 8) !== 0,
        )),
      this._useCurrent());
  }
  pop(e) {
    const t = this.renderer.gl;
    if (this.getStackLength() === 0) t.disable(t.STENCIL_TEST);
    else {
      const i =
          this.maskStack.length !== 0
            ? this.maskStack[this.maskStack.length - 1]
            : null,
        r = i ? i._colorMask : 15;
      (r !== 0 && ((i._colorMask = 0), t.colorMask(!1, !1, !1, !1)),
        t.stencilOp(t.KEEP, t.KEEP, t.DECR),
        (e.renderable = !0),
        e.render(this.renderer),
        this.renderer.batch.flush(),
        (e.renderable = !1),
        r !== 0 &&
          ((i._colorMask = r),
          t.colorMask(
            (r & 1) !== 0,
            (r & 2) !== 0,
            (r & 4) !== 0,
            (r & 8) !== 0,
          )),
        this._useCurrent());
    }
  }
  _useCurrent() {
    const e = this.renderer.gl;
    (e.stencilFunc(e.EQUAL, this.getStackLength(), 4294967295),
      e.stencilOp(e.KEEP, e.KEEP, e.KEEP));
  }
}
MP.extension = { type: De.RendererSystem, name: "stencil" };
je.add(MP);
class LP {
  constructor(e) {
    ((this.renderer = e),
      (this.plugins = {}),
      Object.defineProperties(this.plugins, {
        extract: {
          enumerable: !1,
          get() {
            return (
              Ht(
                "7.0.0",
                "renderer.plugins.extract has moved to renderer.extract",
              ),
              e.extract
            );
          },
        },
        prepare: {
          enumerable: !1,
          get() {
            return (
              Ht(
                "7.0.0",
                "renderer.plugins.prepare has moved to renderer.prepare",
              ),
              e.prepare
            );
          },
        },
        interaction: {
          enumerable: !1,
          get() {
            return (
              Ht(
                "7.0.0",
                "renderer.plugins.interaction has been deprecated, use renderer.events",
              ),
              e.events
            );
          },
        },
      }));
  }
  init() {
    const e = this.rendererPlugins;
    for (const t in e) this.plugins[t] = new e[t](this.renderer);
  }
  destroy() {
    for (const e in this.plugins)
      (this.plugins[e].destroy(), (this.plugins[e] = null));
  }
}
LP.extension = {
  type: [De.RendererSystem, De.CanvasRendererSystem],
  name: "_plugin",
};
je.add(LP);
class RP {
  constructor(e) {
    ((this.renderer = e),
      (this.destinationFrame = null),
      (this.sourceFrame = null),
      (this.defaultFrame = null),
      (this.projectionMatrix = new Rn()),
      (this.transform = null));
  }
  update(e, t, i, r) {
    ((this.destinationFrame = e || this.destinationFrame || this.defaultFrame),
      (this.sourceFrame = t || this.sourceFrame || e),
      this.calculateProjection(this.destinationFrame, this.sourceFrame, i, r),
      this.transform && this.projectionMatrix.append(this.transform));
    const s = this.renderer;
    ((s.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix),
      s.globalUniforms.update(),
      s.shader.shader &&
        s.shader.syncUniformGroup(s.shader.shader.uniforms.globals));
  }
  calculateProjection(e, t, i, r) {
    const s = this.projectionMatrix,
      o = r ? -1 : 1;
    (s.identity(),
      (s.a = (1 / t.width) * 2),
      (s.d = o * ((1 / t.height) * 2)),
      (s.tx = -1 - t.x * s.a),
      (s.ty = -o - t.y * s.d));
  }
  setTransform(e) {}
  destroy() {
    this.renderer = null;
  }
}
RP.extension = { type: De.RendererSystem, name: "projection" };
je.add(RP);
const nfe = new x5(),
  R6 = new Bt();
class BP {
  constructor(e) {
    ((this.renderer = e), (this._tempMatrix = new Rn()));
  }
  generateTexture(e, t) {
    const { region: i, ...r } = t || {},
      s = i?.copyTo(R6) || e.getLocalBounds(R6, !0),
      o = r.resolution || this.renderer.resolution;
    ((s.width = Math.max(s.width, 1 / o)),
      (s.height = Math.max(s.height, 1 / o)),
      (r.width = s.width),
      (r.height = s.height),
      (r.resolution = o),
      r.multisample ?? (r.multisample = this.renderer.multisample));
    const a = Eu.create(r);
    ((this._tempMatrix.tx = -s.x), (this._tempMatrix.ty = -s.y));
    const l = e.transform;
    return (
      (e.transform = nfe),
      this.renderer.render(e, {
        renderTexture: a,
        transform: this._tempMatrix,
        skipUpdateTransform: !!e.parent,
        blit: !0,
      }),
      (e.transform = l),
      a
    );
  }
  destroy() {}
}
BP.extension = {
  type: [De.RendererSystem, De.CanvasRendererSystem],
  name: "textureGenerator",
};
je.add(BP);
const fc = new Bt(),
  xf = new Bt();
class PP {
  constructor(e) {
    ((this.renderer = e),
      (this.defaultMaskStack = []),
      (this.current = null),
      (this.sourceFrame = new Bt()),
      (this.destinationFrame = new Bt()),
      (this.viewportFrame = new Bt()));
  }
  contextChange() {
    const e = this.renderer?.gl.getContextAttributes();
    this._rendererPremultipliedAlpha = !!(e && e.alpha && e.premultipliedAlpha);
  }
  bind(e = null, t, i) {
    const r = this.renderer;
    this.current = e;
    let s, o, a;
    e
      ? ((s = e.baseTexture),
        (a = s.resolution),
        t ||
          ((fc.width = e.frame.width), (fc.height = e.frame.height), (t = fc)),
        i ||
          ((xf.x = e.frame.x),
          (xf.y = e.frame.y),
          (xf.width = t.width),
          (xf.height = t.height),
          (i = xf)),
        (o = s.framebuffer))
      : ((a = r.resolution),
        t ||
          ((fc.width = r._view.screen.width),
          (fc.height = r._view.screen.height),
          (t = fc)),
        i || ((i = fc), (i.width = t.width), (i.height = t.height)));
    const l = this.viewportFrame;
    ((l.x = i.x * a),
      (l.y = i.y * a),
      (l.width = i.width * a),
      (l.height = i.height * a),
      e || (l.y = r.view.height - (l.y + l.height)),
      l.ceil(),
      this.renderer.framebuffer.bind(o, l),
      this.renderer.projection.update(i, t, a, !o),
      e
        ? this.renderer.mask.setMaskStack(s.maskStack)
        : this.renderer.mask.setMaskStack(this.defaultMaskStack),
      this.sourceFrame.copyFrom(t),
      this.destinationFrame.copyFrom(i));
  }
  clear(e, t) {
    const i = this.current
        ? this.current.baseTexture.clear
        : this.renderer.background.backgroundColor,
      r = Ln.shared.setValue(e || i);
    ((this.current && this.current.baseTexture.alphaMode > 0) ||
      (!this.current && this._rendererPremultipliedAlpha)) &&
      r.premultiply(r.alpha);
    const s = this.destinationFrame,
      o = this.current ? this.current.baseTexture : this.renderer._view.screen,
      a = s.width !== o.width || s.height !== o.height;
    if (a) {
      let { x: l, y: c, width: u, height: h } = this.viewportFrame;
      ((l = Math.round(l)),
        (c = Math.round(c)),
        (u = Math.round(u)),
        (h = Math.round(h)),
        this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST),
        this.renderer.gl.scissor(l, c, u, h));
    }
    (this.renderer.framebuffer.clear(r.red, r.green, r.blue, r.alpha, t),
      a && this.renderer.scissor.pop());
  }
  resize() {
    this.bind(null);
  }
  reset() {
    this.bind(null);
  }
  destroy() {
    this.renderer = null;
  }
}
PP.extension = { type: De.RendererSystem, name: "renderTexture" };
je.add(PP);
class ife {
  constructor(e, t) {
    ((this.program = e),
      (this.uniformData = t),
      (this.uniformGroups = {}),
      (this.uniformDirtyGroups = {}),
      (this.uniformBufferBindings = {}));
  }
  destroy() {
    ((this.uniformData = null),
      (this.uniformGroups = null),
      (this.uniformDirtyGroups = null),
      (this.uniformBufferBindings = null),
      (this.program = null));
  }
}
function rfe(n, e) {
  const t = {},
    i = e.getProgramParameter(n, e.ACTIVE_ATTRIBUTES);
  for (let r = 0; r < i; r++) {
    const s = e.getActiveAttrib(n, r);
    if (s.name.startsWith("gl_")) continue;
    const o = mP(e, s.type),
      a = {
        type: o,
        name: s.name,
        size: pP(o),
        location: e.getAttribLocation(n, s.name),
      };
    t[s.name] = a;
  }
  return t;
}
function sfe(n, e) {
  const t = {},
    i = e.getProgramParameter(n, e.ACTIVE_UNIFORMS);
  for (let r = 0; r < i; r++) {
    const s = e.getActiveUniform(n, r),
      o = s.name.replace(/\[.*?\]$/, ""),
      a = !!s.name.match(/\[.*?\]$/),
      l = mP(e, s.type);
    t[o] = {
      name: o,
      index: r,
      type: l,
      size: s.size,
      isArray: a,
      value: fP(l, s.size),
    };
  }
  return t;
}
function ofe(n, e) {
  const t = b6(n, n.VERTEX_SHADER, e.vertexSrc),
    i = b6(n, n.FRAGMENT_SHADER, e.fragmentSrc),
    r = n.createProgram();
  (n.attachShader(r, t), n.attachShader(r, i));
  const s = e.extra?.transformFeedbackVaryings;
  if (
    (s &&
      (typeof n.transformFeedbackVaryings != "function"
        ? console.warn(
            "TransformFeedback is not supported but TransformFeedbackVaryings are given.",
          )
        : n.transformFeedbackVaryings(
            r,
            s.names,
            s.bufferMode === "separate"
              ? n.SEPARATE_ATTRIBS
              : n.INTERLEAVED_ATTRIBS,
          )),
    n.linkProgram(r),
    n.getProgramParameter(r, n.LINK_STATUS) || Dde(n, r, t, i),
    (e.attributeData = rfe(r, n)),
    (e.uniformData = sfe(r, n)),
    !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertexSrc))
  ) {
    const a = Object.keys(e.attributeData);
    a.sort((l, c) => (l > c ? 1 : -1));
    for (let l = 0; l < a.length; l++)
      ((e.attributeData[a[l]].location = l), n.bindAttribLocation(r, l, a[l]));
    n.linkProgram(r);
  }
  (n.deleteShader(t), n.deleteShader(i));
  const o = {};
  for (const a in e.uniformData) {
    const l = e.uniformData[a];
    o[a] = { location: n.getUniformLocation(r, a), value: fP(l.type, l.size) };
  }
  return new ife(r, o);
}
function afe(n, e, t, i, r) {
  t.buffer.update(r);
}
const lfe = {
    float: `
        data[offset] = v;
    `,
    vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
    vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
    vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
    mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
    mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
    mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `,
  },
  NP = {
    float: 4,
    vec2: 8,
    vec3: 12,
    vec4: 16,
    int: 4,
    ivec2: 8,
    ivec3: 12,
    ivec4: 16,
    uint: 4,
    uvec2: 8,
    uvec3: 12,
    uvec4: 16,
    bool: 4,
    bvec2: 8,
    bvec3: 12,
    bvec4: 16,
    mat2: 16 * 2,
    mat3: 16 * 3,
    mat4: 16 * 4,
  };
function cfe(n) {
  const e = n.map((s) => ({ data: s, offset: 0, dataLen: 0, dirty: 0 }));
  let t = 0,
    i = 0,
    r = 0;
  for (let s = 0; s < e.length; s++) {
    const o = e[s];
    if (
      ((t = NP[o.data.type]),
      o.data.size > 1 && (t = Math.max(t, 16) * o.data.size),
      (o.dataLen = t),
      i % t !== 0 && i < 16)
    ) {
      const a = (i % t) % 16;
      ((i += a), (r += a));
    }
    i + t > 16
      ? ((r = Math.ceil(r / 16) * 16), (o.offset = r), (r += t), (i = t))
      : ((o.offset = r), (i += t), (r += t));
  }
  return ((r = Math.ceil(r / 16) * 16), { uboElements: e, size: r });
}
function ufe(n, e) {
  const t = [];
  for (const i in n) e[i] && t.push(e[i]);
  return (t.sort((i, r) => i.index - r.index), t);
}
function hfe(n, e) {
  if (!n.autoManage) return { size: 0, syncFunc: afe };
  const t = ufe(n.uniforms, e),
    { uboElements: i, size: r } = cfe(t),
    s = [
      `
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `,
    ];
  for (let o = 0; o < i.length; o++) {
    const a = i[o],
      l = n.uniforms[a.data.name],
      c = a.data.name;
    let u = !1;
    for (let h = 0; h < Zh.length; h++) {
      const d = Zh[h];
      if (d.codeUbo && d.test(a.data, l)) {
        (s.push(`offset = ${a.offset / 4};`, Zh[h].codeUbo(a.data.name, l)),
          (u = !0));
        break;
      }
    }
    if (!u)
      if (a.data.size > 1) {
        const h = pP(a.data.type),
          d = Math.max(NP[a.data.type] / 16, 1),
          f = h / d,
          g = (4 - (f % 4)) % 4;
        s.push(`
                cv = ud.${c}.value;
                v = uv.${c};
                offset = ${a.offset / 4};

                t = 0;

                for(var i=0; i < ${a.data.size * d}; i++)
                {
                    for(var j = 0; j < ${f}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${g};
                }

                `);
      } else {
        const h = lfe[a.data.type];
        s.push(`
                cv = ud.${c}.value;
                v = uv.${c};
                offset = ${a.offset / 4};
                ${h};
                `);
      }
  }
  return (
    s.push(`
       renderer.buffer.update(buffer);
    `),
    {
      size: r,
      syncFunc: new Function(
        "ud",
        "uv",
        "renderer",
        "syncData",
        "buffer",
        s.join(`
`),
      ),
    }
  );
}
let dfe = 0;
const Y1 = { textureCount: 0, uboCount: 0 };
class DP {
  constructor(e) {
    ((this.destroyed = !1),
      (this.renderer = e),
      this.systemCheck(),
      (this.gl = null),
      (this.shader = null),
      (this.program = null),
      (this.cache = {}),
      (this._uboCache = {}),
      (this.id = dfe++));
  }
  systemCheck() {
    if (!Fde())
      throw new Error(
        "Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.",
      );
  }
  contextChange(e) {
    ((this.gl = e), this.reset());
  }
  bind(e, t) {
    (e.disposeRunner.add(this),
      (e.uniforms.globals = this.renderer.globalUniforms));
    const i = e.program,
      r = i.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(e);
    return (
      (this.shader = e),
      this.program !== i && ((this.program = i), this.gl.useProgram(r.program)),
      t ||
        ((Y1.textureCount = 0),
        (Y1.uboCount = 0),
        this.syncUniformGroup(e.uniformGroup, Y1)),
      r
    );
  }
  setUniforms(e) {
    const t = this.shader.program,
      i = t.glPrograms[this.renderer.CONTEXT_UID];
    t.syncUniforms(i.uniformData, e, this.renderer);
  }
  syncUniformGroup(e, t) {
    const i = this.getGlProgram();
    (!e.static || e.dirtyId !== i.uniformDirtyGroups[e.id]) &&
      ((i.uniformDirtyGroups[e.id] = e.dirtyId), this.syncUniforms(e, i, t));
  }
  syncUniforms(e, t, i) {
    (e.syncUniforms[this.shader.program.id] || this.createSyncGroups(e))(
      t.uniformData,
      e.uniforms,
      this.renderer,
      i,
    );
  }
  createSyncGroups(e) {
    const t = this.getSignature(e, this.shader.program.uniformData, "u");
    return (
      this.cache[t] ||
        (this.cache[t] = Bde(e, this.shader.program.uniformData)),
      (e.syncUniforms[this.shader.program.id] = this.cache[t]),
      e.syncUniforms[this.shader.program.id]
    );
  }
  syncUniformBufferGroup(e, t) {
    const i = this.getGlProgram();
    if (!e.static || e.dirtyId !== 0 || !i.uniformGroups[e.id]) {
      e.dirtyId = 0;
      const r = i.uniformGroups[e.id] || this.createSyncBufferGroup(e, i, t);
      (e.buffer.update(),
        r(i.uniformData, e.uniforms, this.renderer, Y1, e.buffer));
    }
    this.renderer.buffer.bindBufferBase(e.buffer, i.uniformBufferBindings[t]);
  }
  createSyncBufferGroup(e, t, i) {
    const { gl: r } = this.renderer;
    this.renderer.buffer.bind(e.buffer);
    const s = this.gl.getUniformBlockIndex(t.program, i);
    ((t.uniformBufferBindings[i] = this.shader.uniformBindCount),
      r.uniformBlockBinding(t.program, s, this.shader.uniformBindCount),
      this.shader.uniformBindCount++);
    const o = this.getSignature(e, this.shader.program.uniformData, "ubo");
    let a = this._uboCache[o];
    if (
      (a || (a = this._uboCache[o] = hfe(e, this.shader.program.uniformData)),
      e.autoManage)
    ) {
      const l = new Float32Array(a.size / 4);
      e.buffer.update(l);
    }
    return ((t.uniformGroups[e.id] = a.syncFunc), t.uniformGroups[e.id]);
  }
  getSignature(e, t, i) {
    const r = e.uniforms,
      s = [`${i}-`];
    for (const o in r) (s.push(o), t[o] && s.push(t[o].type));
    return s.join("-");
  }
  getGlProgram() {
    return this.shader
      ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID]
      : null;
  }
  generateProgram(e) {
    const t = this.gl,
      i = e.program,
      r = ofe(t, i);
    return ((i.glPrograms[this.renderer.CONTEXT_UID] = r), r);
  }
  reset() {
    ((this.program = null), (this.shader = null));
  }
  disposeShader(e) {
    this.shader === e && (this.shader = null);
  }
  destroy() {
    ((this.renderer = null), (this.destroyed = !0));
  }
}
DP.extension = { type: De.RendererSystem, name: "shader" };
je.add(DP);
class gC {
  constructor(e) {
    this.renderer = e;
  }
  run(e) {
    const { renderer: t } = this;
    (t.runners.init.emit(t.options),
      e.hello &&
        console.log(`PixiJS 7.3.1 - ${t.rendererLogId} - https://pixijs.com`),
      t.resize(t.screen.width, t.screen.height));
  }
  destroy() {}
}
((gC.defaultOptions = { hello: !1 }),
  (gC.extension = {
    type: [De.RendererSystem, De.CanvasRendererSystem],
    name: "startup",
  }));
je.add(gC);
function ffe(n, e = []) {
  return (
    (e[dt.NORMAL] = [n.ONE, n.ONE_MINUS_SRC_ALPHA]),
    (e[dt.ADD] = [n.ONE, n.ONE]),
    (e[dt.MULTIPLY] = [
      n.DST_COLOR,
      n.ONE_MINUS_SRC_ALPHA,
      n.ONE,
      n.ONE_MINUS_SRC_ALPHA,
    ]),
    (e[dt.SCREEN] = [
      n.ONE,
      n.ONE_MINUS_SRC_COLOR,
      n.ONE,
      n.ONE_MINUS_SRC_ALPHA,
    ]),
    (e[dt.OVERLAY] = [n.ONE, n.ONE_MINUS_SRC_ALPHA]),
    (e[dt.DARKEN] = [n.ONE, n.ONE_MINUS_SRC_ALPHA]),
    (e[dt.LIGHTEN] = [n.ONE, n.ONE_MINUS_SRC_ALPHA]),
    (e[dt.COLOR_DODGE] = [n.ONE, n.ONE_MINUS_SRC_ALPHA]),
    (e[dt.COLOR_BURN] = [n.ONE, n.ONE_MINUS_SRC_ALPHA]),
    (e[dt.HARD_LIGHT] = [n.ONE, n.ONE_MINUS_SRC_ALPHA]),
    (e[dt.SOFT_LIGHT] = [n.ONE, n.ONE_MINUS_SRC_ALPHA]),
    (e[dt.DIFFERENCE] = [n.ONE, n.ONE_MINUS_SRC_ALPHA]),
    (e[dt.EXCLUSION] = [n.ONE, n.ONE_MINUS_SRC_ALPHA]),
    (e[dt.HUE] = [n.ONE, n.ONE_MINUS_SRC_ALPHA]),
    (e[dt.SATURATION] = [n.ONE, n.ONE_MINUS_SRC_ALPHA]),
    (e[dt.COLOR] = [n.ONE, n.ONE_MINUS_SRC_ALPHA]),
    (e[dt.LUMINOSITY] = [n.ONE, n.ONE_MINUS_SRC_ALPHA]),
    (e[dt.NONE] = [0, 0]),
    (e[dt.NORMAL_NPM] = [
      n.SRC_ALPHA,
      n.ONE_MINUS_SRC_ALPHA,
      n.ONE,
      n.ONE_MINUS_SRC_ALPHA,
    ]),
    (e[dt.ADD_NPM] = [n.SRC_ALPHA, n.ONE, n.ONE, n.ONE]),
    (e[dt.SCREEN_NPM] = [
      n.SRC_ALPHA,
      n.ONE_MINUS_SRC_COLOR,
      n.ONE,
      n.ONE_MINUS_SRC_ALPHA,
    ]),
    (e[dt.SRC_IN] = [n.DST_ALPHA, n.ZERO]),
    (e[dt.SRC_OUT] = [n.ONE_MINUS_DST_ALPHA, n.ZERO]),
    (e[dt.SRC_ATOP] = [n.DST_ALPHA, n.ONE_MINUS_SRC_ALPHA]),
    (e[dt.DST_OVER] = [n.ONE_MINUS_DST_ALPHA, n.ONE]),
    (e[dt.DST_IN] = [n.ZERO, n.SRC_ALPHA]),
    (e[dt.DST_OUT] = [n.ZERO, n.ONE_MINUS_SRC_ALPHA]),
    (e[dt.DST_ATOP] = [n.ONE_MINUS_DST_ALPHA, n.SRC_ALPHA]),
    (e[dt.XOR] = [n.ONE_MINUS_DST_ALPHA, n.ONE_MINUS_SRC_ALPHA]),
    (e[dt.SUBTRACT] = [
      n.ONE,
      n.ONE,
      n.ONE,
      n.ONE,
      n.FUNC_REVERSE_SUBTRACT,
      n.FUNC_ADD,
    ]),
    e
  );
}
const gfe = 0,
  pfe = 1,
  mfe = 2,
  Cfe = 3,
  Ife = 4,
  Afe = 5,
  GP = class Y3 {
    constructor() {
      ((this.gl = null),
        (this.stateId = 0),
        (this.polygonOffset = 0),
        (this.blendMode = dt.NONE),
        (this._blendEq = !1),
        (this.map = []),
        (this.map[gfe] = this.setBlend),
        (this.map[pfe] = this.setOffset),
        (this.map[mfe] = this.setCullFace),
        (this.map[Cfe] = this.setDepthTest),
        (this.map[Ife] = this.setFrontFace),
        (this.map[Afe] = this.setDepthMask),
        (this.checks = []),
        (this.defaultState = new Yo()),
        (this.defaultState.blend = !0));
    }
    contextChange(e) {
      ((this.gl = e),
        (this.blendModes = ffe(e)),
        this.set(this.defaultState),
        this.reset());
    }
    set(e) {
      if (((e = e || this.defaultState), this.stateId !== e.data)) {
        let t = this.stateId ^ e.data,
          i = 0;
        for (; t; )
          (t & 1 && this.map[i].call(this, !!(e.data & (1 << i))),
            (t = t >> 1),
            i++);
        this.stateId = e.data;
      }
      for (let t = 0; t < this.checks.length; t++) this.checks[t](this, e);
    }
    forceState(e) {
      e = e || this.defaultState;
      for (let t = 0; t < this.map.length; t++)
        this.map[t].call(this, !!(e.data & (1 << t)));
      for (let t = 0; t < this.checks.length; t++) this.checks[t](this, e);
      this.stateId = e.data;
    }
    setBlend(e) {
      (this.updateCheck(Y3.checkBlendMode, e),
        this.gl[e ? "enable" : "disable"](this.gl.BLEND));
    }
    setOffset(e) {
      (this.updateCheck(Y3.checkPolygonOffset, e),
        this.gl[e ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL));
    }
    setDepthTest(e) {
      this.gl[e ? "enable" : "disable"](this.gl.DEPTH_TEST);
    }
    setDepthMask(e) {
      this.gl.depthMask(e);
    }
    setCullFace(e) {
      this.gl[e ? "enable" : "disable"](this.gl.CULL_FACE);
    }
    setFrontFace(e) {
      this.gl.frontFace(this.gl[e ? "CW" : "CCW"]);
    }
    setBlendMode(e) {
      if (e === this.blendMode) return;
      this.blendMode = e;
      const t = this.blendModes[e],
        i = this.gl;
      (t.length === 2
        ? i.blendFunc(t[0], t[1])
        : i.blendFuncSeparate(t[0], t[1], t[2], t[3]),
        t.length === 6
          ? ((this._blendEq = !0), i.blendEquationSeparate(t[4], t[5]))
          : this._blendEq &&
            ((this._blendEq = !1),
            i.blendEquationSeparate(i.FUNC_ADD, i.FUNC_ADD)));
    }
    setPolygonOffset(e, t) {
      this.gl.polygonOffset(e, t);
    }
    reset() {
      (this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1),
        this.forceState(this.defaultState),
        (this._blendEq = !0),
        (this.blendMode = -1),
        this.setBlendMode(0));
    }
    updateCheck(e, t) {
      const i = this.checks.indexOf(e);
      t && i === -1
        ? this.checks.push(e)
        : !t && i !== -1 && this.checks.splice(i, 1);
    }
    static checkBlendMode(e, t) {
      e.setBlendMode(t.blendMode);
    }
    static checkPolygonOffset(e, t) {
      e.setPolygonOffset(1, t.polygonOffset);
    }
    destroy() {
      this.gl = null;
    }
  };
GP.extension = { type: De.RendererSystem, name: "state" };
let yfe = GP;
je.add(yfe);
class _fe extends Lp {
  constructor() {
    (super(...arguments), (this.runners = {}), (this._systemsHash = {}));
  }
  setup(e) {
    this.addRunners(...e.runners);
    const t = (e.priority ?? []).filter((r) => e.systems[r]),
      i = [...t, ...Object.keys(e.systems).filter((r) => !t.includes(r))];
    for (const r of i) this.addSystem(e.systems[r], r);
  }
  addRunners(...e) {
    e.forEach((t) => {
      this.runners[t] = new qs(t);
    });
  }
  addSystem(e, t) {
    const i = new e(this);
    if (this[t]) throw new Error(`Whoops! The name "${t}" is already in use`);
    ((this[t] = i), (this._systemsHash[t] = i));
    for (const r in this.runners) this.runners[r].add(i);
    return this;
  }
  emitWithCustomOptions(e, t) {
    const i = Object.keys(this._systemsHash);
    e.items.forEach((r) => {
      const s = i.find((o) => this._systemsHash[o] === r);
      r[e.name](t[s]);
    });
  }
  destroy() {
    (Object.values(this.runners).forEach((e) => {
      e.destroy();
    }),
      (this._systemsHash = {}));
  }
}
const Vf = class Q0 {
  constructor(e) {
    ((this.renderer = e),
      (this.count = 0),
      (this.checkCount = 0),
      (this.maxIdle = Q0.defaultMaxIdle),
      (this.checkCountMax = Q0.defaultCheckCountMax),
      (this.mode = Q0.defaultMode));
  }
  postrender() {
    this.renderer.objectRenderer.renderingToScreen &&
      (this.count++,
      this.mode !== p5.MANUAL &&
        (this.checkCount++,
        this.checkCount > this.checkCountMax &&
          ((this.checkCount = 0), this.run())));
  }
  run() {
    const e = this.renderer.texture,
      t = e.managedTextures;
    let i = !1;
    for (let r = 0; r < t.length; r++) {
      const s = t[r];
      s.resource &&
        this.count - s.touched > this.maxIdle &&
        (e.destroyTexture(s, !0), (t[r] = null), (i = !0));
    }
    if (i) {
      let r = 0;
      for (let s = 0; s < t.length; s++) t[s] !== null && (t[r++] = t[s]);
      t.length = r;
    }
  }
  unload(e) {
    const t = this.renderer.texture,
      i = e._texture;
    i && !i.framebuffer && t.destroyTexture(i);
    for (let r = e.children.length - 1; r >= 0; r--) this.unload(e.children[r]);
  }
  destroy() {
    this.renderer = null;
  }
};
((Vf.defaultMode = p5.AUTO),
  (Vf.defaultMaxIdle = 60 * 60),
  (Vf.defaultCheckCountMax = 60 * 10),
  (Vf.extension = { type: De.RendererSystem, name: "textureGC" }));
let Nc = Vf;
je.add(Nc);
class kA {
  constructor(e) {
    ((this.texture = e),
      (this.width = -1),
      (this.height = -1),
      (this.dirtyId = -1),
      (this.dirtyStyleId = -1),
      (this.mipmap = !1),
      (this.wrapMode = 33071),
      (this.type = et.UNSIGNED_BYTE),
      (this.internalFormat = ve.RGBA),
      (this.samplerType = 0));
  }
}
function bfe(n) {
  let e;
  return (
    "WebGL2RenderingContext" in globalThis &&
    n instanceof globalThis.WebGL2RenderingContext
      ? (e = {
          [n.RGB]: ke.FLOAT,
          [n.RGBA]: ke.FLOAT,
          [n.ALPHA]: ke.FLOAT,
          [n.LUMINANCE]: ke.FLOAT,
          [n.LUMINANCE_ALPHA]: ke.FLOAT,
          [n.R8]: ke.FLOAT,
          [n.R8_SNORM]: ke.FLOAT,
          [n.RG8]: ke.FLOAT,
          [n.RG8_SNORM]: ke.FLOAT,
          [n.RGB8]: ke.FLOAT,
          [n.RGB8_SNORM]: ke.FLOAT,
          [n.RGB565]: ke.FLOAT,
          [n.RGBA4]: ke.FLOAT,
          [n.RGB5_A1]: ke.FLOAT,
          [n.RGBA8]: ke.FLOAT,
          [n.RGBA8_SNORM]: ke.FLOAT,
          [n.RGB10_A2]: ke.FLOAT,
          [n.RGB10_A2UI]: ke.FLOAT,
          [n.SRGB8]: ke.FLOAT,
          [n.SRGB8_ALPHA8]: ke.FLOAT,
          [n.R16F]: ke.FLOAT,
          [n.RG16F]: ke.FLOAT,
          [n.RGB16F]: ke.FLOAT,
          [n.RGBA16F]: ke.FLOAT,
          [n.R32F]: ke.FLOAT,
          [n.RG32F]: ke.FLOAT,
          [n.RGB32F]: ke.FLOAT,
          [n.RGBA32F]: ke.FLOAT,
          [n.R11F_G11F_B10F]: ke.FLOAT,
          [n.RGB9_E5]: ke.FLOAT,
          [n.R8I]: ke.INT,
          [n.R8UI]: ke.UINT,
          [n.R16I]: ke.INT,
          [n.R16UI]: ke.UINT,
          [n.R32I]: ke.INT,
          [n.R32UI]: ke.UINT,
          [n.RG8I]: ke.INT,
          [n.RG8UI]: ke.UINT,
          [n.RG16I]: ke.INT,
          [n.RG16UI]: ke.UINT,
          [n.RG32I]: ke.INT,
          [n.RG32UI]: ke.UINT,
          [n.RGB8I]: ke.INT,
          [n.RGB8UI]: ke.UINT,
          [n.RGB16I]: ke.INT,
          [n.RGB16UI]: ke.UINT,
          [n.RGB32I]: ke.INT,
          [n.RGB32UI]: ke.UINT,
          [n.RGBA8I]: ke.INT,
          [n.RGBA8UI]: ke.UINT,
          [n.RGBA16I]: ke.INT,
          [n.RGBA16UI]: ke.UINT,
          [n.RGBA32I]: ke.INT,
          [n.RGBA32UI]: ke.UINT,
          [n.DEPTH_COMPONENT16]: ke.FLOAT,
          [n.DEPTH_COMPONENT24]: ke.FLOAT,
          [n.DEPTH_COMPONENT32F]: ke.FLOAT,
          [n.DEPTH_STENCIL]: ke.FLOAT,
          [n.DEPTH24_STENCIL8]: ke.FLOAT,
          [n.DEPTH32F_STENCIL8]: ke.FLOAT,
        })
      : (e = {
          [n.RGB]: ke.FLOAT,
          [n.RGBA]: ke.FLOAT,
          [n.ALPHA]: ke.FLOAT,
          [n.LUMINANCE]: ke.FLOAT,
          [n.LUMINANCE_ALPHA]: ke.FLOAT,
          [n.DEPTH_STENCIL]: ke.FLOAT,
        }),
    e
  );
}
function vfe(n) {
  let e;
  return (
    "WebGL2RenderingContext" in globalThis &&
    n instanceof globalThis.WebGL2RenderingContext
      ? (e = {
          [et.UNSIGNED_BYTE]: {
            [ve.RGBA]: n.RGBA8,
            [ve.RGB]: n.RGB8,
            [ve.RG]: n.RG8,
            [ve.RED]: n.R8,
            [ve.RGBA_INTEGER]: n.RGBA8UI,
            [ve.RGB_INTEGER]: n.RGB8UI,
            [ve.RG_INTEGER]: n.RG8UI,
            [ve.RED_INTEGER]: n.R8UI,
            [ve.ALPHA]: n.ALPHA,
            [ve.LUMINANCE]: n.LUMINANCE,
            [ve.LUMINANCE_ALPHA]: n.LUMINANCE_ALPHA,
          },
          [et.BYTE]: {
            [ve.RGBA]: n.RGBA8_SNORM,
            [ve.RGB]: n.RGB8_SNORM,
            [ve.RG]: n.RG8_SNORM,
            [ve.RED]: n.R8_SNORM,
            [ve.RGBA_INTEGER]: n.RGBA8I,
            [ve.RGB_INTEGER]: n.RGB8I,
            [ve.RG_INTEGER]: n.RG8I,
            [ve.RED_INTEGER]: n.R8I,
          },
          [et.UNSIGNED_SHORT]: {
            [ve.RGBA_INTEGER]: n.RGBA16UI,
            [ve.RGB_INTEGER]: n.RGB16UI,
            [ve.RG_INTEGER]: n.RG16UI,
            [ve.RED_INTEGER]: n.R16UI,
            [ve.DEPTH_COMPONENT]: n.DEPTH_COMPONENT16,
          },
          [et.SHORT]: {
            [ve.RGBA_INTEGER]: n.RGBA16I,
            [ve.RGB_INTEGER]: n.RGB16I,
            [ve.RG_INTEGER]: n.RG16I,
            [ve.RED_INTEGER]: n.R16I,
          },
          [et.UNSIGNED_INT]: {
            [ve.RGBA_INTEGER]: n.RGBA32UI,
            [ve.RGB_INTEGER]: n.RGB32UI,
            [ve.RG_INTEGER]: n.RG32UI,
            [ve.RED_INTEGER]: n.R32UI,
            [ve.DEPTH_COMPONENT]: n.DEPTH_COMPONENT24,
          },
          [et.INT]: {
            [ve.RGBA_INTEGER]: n.RGBA32I,
            [ve.RGB_INTEGER]: n.RGB32I,
            [ve.RG_INTEGER]: n.RG32I,
            [ve.RED_INTEGER]: n.R32I,
          },
          [et.FLOAT]: {
            [ve.RGBA]: n.RGBA32F,
            [ve.RGB]: n.RGB32F,
            [ve.RG]: n.RG32F,
            [ve.RED]: n.R32F,
            [ve.DEPTH_COMPONENT]: n.DEPTH_COMPONENT32F,
          },
          [et.HALF_FLOAT]: {
            [ve.RGBA]: n.RGBA16F,
            [ve.RGB]: n.RGB16F,
            [ve.RG]: n.RG16F,
            [ve.RED]: n.R16F,
          },
          [et.UNSIGNED_SHORT_5_6_5]: { [ve.RGB]: n.RGB565 },
          [et.UNSIGNED_SHORT_4_4_4_4]: { [ve.RGBA]: n.RGBA4 },
          [et.UNSIGNED_SHORT_5_5_5_1]: { [ve.RGBA]: n.RGB5_A1 },
          [et.UNSIGNED_INT_2_10_10_10_REV]: {
            [ve.RGBA]: n.RGB10_A2,
            [ve.RGBA_INTEGER]: n.RGB10_A2UI,
          },
          [et.UNSIGNED_INT_10F_11F_11F_REV]: { [ve.RGB]: n.R11F_G11F_B10F },
          [et.UNSIGNED_INT_5_9_9_9_REV]: { [ve.RGB]: n.RGB9_E5 },
          [et.UNSIGNED_INT_24_8]: { [ve.DEPTH_STENCIL]: n.DEPTH24_STENCIL8 },
          [et.FLOAT_32_UNSIGNED_INT_24_8_REV]: {
            [ve.DEPTH_STENCIL]: n.DEPTH32F_STENCIL8,
          },
        })
      : (e = {
          [et.UNSIGNED_BYTE]: {
            [ve.RGBA]: n.RGBA,
            [ve.RGB]: n.RGB,
            [ve.ALPHA]: n.ALPHA,
            [ve.LUMINANCE]: n.LUMINANCE,
            [ve.LUMINANCE_ALPHA]: n.LUMINANCE_ALPHA,
          },
          [et.UNSIGNED_SHORT_5_6_5]: { [ve.RGB]: n.RGB },
          [et.UNSIGNED_SHORT_4_4_4_4]: { [ve.RGBA]: n.RGBA },
          [et.UNSIGNED_SHORT_5_5_5_1]: { [ve.RGBA]: n.RGBA },
        }),
    e
  );
}
class FP {
  constructor(e) {
    ((this.renderer = e),
      (this.boundTextures = []),
      (this.currentLocation = -1),
      (this.managedTextures = []),
      (this._unknownBoundTextures = !1),
      (this.unknownTexture = new St()),
      (this.hasIntegerTextures = !1));
  }
  contextChange() {
    const e = (this.gl = this.renderer.gl);
    ((this.CONTEXT_UID = this.renderer.CONTEXT_UID),
      (this.webGLVersion = this.renderer.context.webGLVersion),
      (this.internalFormats = vfe(e)),
      (this.samplerTypes = bfe(e)));
    const t = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS);
    this.boundTextures.length = t;
    for (let r = 0; r < t; r++) this.boundTextures[r] = null;
    this.emptyTextures = {};
    const i = new kA(e.createTexture());
    (e.bindTexture(e.TEXTURE_2D, i.texture),
      e.texImage2D(
        e.TEXTURE_2D,
        0,
        e.RGBA,
        1,
        1,
        0,
        e.RGBA,
        e.UNSIGNED_BYTE,
        new Uint8Array(4),
      ),
      (this.emptyTextures[e.TEXTURE_2D] = i),
      (this.emptyTextures[e.TEXTURE_CUBE_MAP] = new kA(e.createTexture())),
      e.bindTexture(
        e.TEXTURE_CUBE_MAP,
        this.emptyTextures[e.TEXTURE_CUBE_MAP].texture,
      ));
    for (let r = 0; r < 6; r++)
      e.texImage2D(
        e.TEXTURE_CUBE_MAP_POSITIVE_X + r,
        0,
        e.RGBA,
        1,
        1,
        0,
        e.RGBA,
        e.UNSIGNED_BYTE,
        null,
      );
    (e.texParameteri(e.TEXTURE_CUBE_MAP, e.TEXTURE_MAG_FILTER, e.LINEAR),
      e.texParameteri(e.TEXTURE_CUBE_MAP, e.TEXTURE_MIN_FILTER, e.LINEAR));
    for (let r = 0; r < this.boundTextures.length; r++) this.bind(null, r);
  }
  bind(e, t = 0) {
    const { gl: i } = this;
    if (((e = e?.castToBaseTexture()), e?.valid && !e.parentTextureArray)) {
      e.touched = this.renderer.textureGC.count;
      const r = e._glTextures[this.CONTEXT_UID] || this.initTexture(e);
      (this.boundTextures[t] !== e &&
        (this.currentLocation !== t &&
          ((this.currentLocation = t), i.activeTexture(i.TEXTURE0 + t)),
        i.bindTexture(e.target, r.texture)),
        r.dirtyId !== e.dirtyId
          ? (this.currentLocation !== t &&
              ((this.currentLocation = t), i.activeTexture(i.TEXTURE0 + t)),
            this.updateTexture(e))
          : r.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(e),
        (this.boundTextures[t] = e));
    } else
      (this.currentLocation !== t &&
        ((this.currentLocation = t), i.activeTexture(i.TEXTURE0 + t)),
        i.bindTexture(i.TEXTURE_2D, this.emptyTextures[i.TEXTURE_2D].texture),
        (this.boundTextures[t] = null));
  }
  reset() {
    ((this._unknownBoundTextures = !0),
      (this.hasIntegerTextures = !1),
      (this.currentLocation = -1));
    for (let e = 0; e < this.boundTextures.length; e++)
      this.boundTextures[e] = this.unknownTexture;
  }
  unbind(e) {
    const { gl: t, boundTextures: i } = this;
    if (this._unknownBoundTextures) {
      this._unknownBoundTextures = !1;
      for (let r = 0; r < i.length; r++)
        i[r] === this.unknownTexture && this.bind(null, r);
    }
    for (let r = 0; r < i.length; r++)
      i[r] === e &&
        (this.currentLocation !== r &&
          (t.activeTexture(t.TEXTURE0 + r), (this.currentLocation = r)),
        t.bindTexture(e.target, this.emptyTextures[e.target].texture),
        (i[r] = null));
  }
  ensureSamplerType(e) {
    const { boundTextures: t, hasIntegerTextures: i, CONTEXT_UID: r } = this;
    if (i)
      for (let s = e - 1; s >= 0; --s) {
        const o = t[s];
        o &&
          o._glTextures[r].samplerType !== ke.FLOAT &&
          this.renderer.texture.unbind(o);
      }
  }
  initTexture(e) {
    const t = new kA(this.gl.createTexture());
    return (
      (t.dirtyId = -1),
      (e._glTextures[this.CONTEXT_UID] = t),
      this.managedTextures.push(e),
      e.on("dispose", this.destroyTexture, this),
      t
    );
  }
  initTextureType(e, t) {
    ((t.internalFormat = this.internalFormats[e.type]?.[e.format] ?? e.format),
      (t.samplerType = this.samplerTypes[t.internalFormat] ?? ke.FLOAT),
      this.webGLVersion === 2 && e.type === et.HALF_FLOAT
        ? (t.type = this.gl.HALF_FLOAT)
        : (t.type = e.type));
  }
  updateTexture(e) {
    const t = e._glTextures[this.CONTEXT_UID];
    if (!t) return;
    const i = this.renderer;
    if ((this.initTextureType(e, t), e.resource?.upload(i, e, t)))
      t.samplerType !== ke.FLOAT && (this.hasIntegerTextures = !0);
    else {
      const r = e.realWidth,
        s = e.realHeight,
        o = i.gl;
      (t.width !== r || t.height !== s || t.dirtyId < 0) &&
        ((t.width = r),
        (t.height = s),
        o.texImage2D(
          e.target,
          0,
          t.internalFormat,
          r,
          s,
          0,
          e.format,
          t.type,
          null,
        ));
    }
    (e.dirtyStyleId !== t.dirtyStyleId && this.updateTextureStyle(e),
      (t.dirtyId = e.dirtyId));
  }
  destroyTexture(e, t) {
    const { gl: i } = this;
    if (
      ((e = e.castToBaseTexture()),
      e._glTextures[this.CONTEXT_UID] &&
        (this.unbind(e),
        i.deleteTexture(e._glTextures[this.CONTEXT_UID].texture),
        e.off("dispose", this.destroyTexture, this),
        delete e._glTextures[this.CONTEXT_UID],
        !t))
    ) {
      const r = this.managedTextures.indexOf(e);
      r !== -1 && Vh(this.managedTextures, r, 1);
    }
  }
  updateTextureStyle(e) {
    const t = e._glTextures[this.CONTEXT_UID];
    t &&
      ((e.mipmap === Ho.POW2 || this.webGLVersion !== 2) && !e.isPowerOfTwo
        ? (t.mipmap = !1)
        : (t.mipmap = e.mipmap >= 1),
      this.webGLVersion !== 2 && !e.isPowerOfTwo
        ? (t.wrapMode = Ll.CLAMP)
        : (t.wrapMode = e.wrapMode),
      e.resource?.style(this.renderer, e, t) || this.setStyle(e, t),
      (t.dirtyStyleId = e.dirtyStyleId));
  }
  setStyle(e, t) {
    const i = this.gl;
    if (
      (t.mipmap && e.mipmap !== Ho.ON_MANUAL && i.generateMipmap(e.target),
      i.texParameteri(e.target, i.TEXTURE_WRAP_S, t.wrapMode),
      i.texParameteri(e.target, i.TEXTURE_WRAP_T, t.wrapMode),
      t.mipmap)
    ) {
      i.texParameteri(
        e.target,
        i.TEXTURE_MIN_FILTER,
        e.scaleMode === Ca.LINEAR
          ? i.LINEAR_MIPMAP_LINEAR
          : i.NEAREST_MIPMAP_NEAREST,
      );
      const r = this.renderer.context.extensions.anisotropicFiltering;
      if (r && e.anisotropicLevel > 0 && e.scaleMode === Ca.LINEAR) {
        const s = Math.min(
          e.anisotropicLevel,
          i.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT),
        );
        i.texParameterf(e.target, r.TEXTURE_MAX_ANISOTROPY_EXT, s);
      }
    } else
      i.texParameteri(
        e.target,
        i.TEXTURE_MIN_FILTER,
        e.scaleMode === Ca.LINEAR ? i.LINEAR : i.NEAREST,
      );
    i.texParameteri(
      e.target,
      i.TEXTURE_MAG_FILTER,
      e.scaleMode === Ca.LINEAR ? i.LINEAR : i.NEAREST,
    );
  }
  destroy() {
    this.renderer = null;
  }
}
FP.extension = { type: De.RendererSystem, name: "texture" };
je.add(FP);
class kP {
  constructor(e) {
    this.renderer = e;
  }
  contextChange() {
    ((this.gl = this.renderer.gl),
      (this.CONTEXT_UID = this.renderer.CONTEXT_UID));
  }
  bind(e) {
    const { gl: t, CONTEXT_UID: i } = this,
      r = e._glTransformFeedbacks[i] || this.createGLTransformFeedback(e);
    t.bindTransformFeedback(t.TRANSFORM_FEEDBACK, r);
  }
  unbind() {
    const { gl: e } = this;
    e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, null);
  }
  beginTransformFeedback(e, t) {
    const { gl: i, renderer: r } = this;
    (t && r.shader.bind(t), i.beginTransformFeedback(e));
  }
  endTransformFeedback() {
    const { gl: e } = this;
    e.endTransformFeedback();
  }
  createGLTransformFeedback(e) {
    const { gl: t, renderer: i, CONTEXT_UID: r } = this,
      s = t.createTransformFeedback();
    ((e._glTransformFeedbacks[r] = s),
      t.bindTransformFeedback(t.TRANSFORM_FEEDBACK, s));
    for (let o = 0; o < e.buffers.length; o++) {
      const a = e.buffers[o];
      a &&
        (i.buffer.update(a),
        a._glBuffers[r].refCount++,
        t.bindBufferBase(
          t.TRANSFORM_FEEDBACK_BUFFER,
          o,
          a._glBuffers[r].buffer || null,
        ));
    }
    return (
      t.bindTransformFeedback(t.TRANSFORM_FEEDBACK, null),
      e.disposeRunner.add(this),
      s
    );
  }
  disposeTransformFeedback(e, t) {
    const i = e._glTransformFeedbacks[this.CONTEXT_UID],
      r = this.gl;
    e.disposeRunner.remove(this);
    const s = this.renderer.buffer;
    if (s)
      for (let o = 0; o < e.buffers.length; o++) {
        const a = e.buffers[o];
        if (!a) continue;
        const l = a._glBuffers[this.CONTEXT_UID];
        l && (l.refCount--, l.refCount === 0 && !t && s.dispose(a, t));
      }
    i &&
      (t || r.deleteTransformFeedback(i),
      delete e._glTransformFeedbacks[this.CONTEXT_UID]);
  }
  destroy() {
    this.renderer = null;
  }
}
kP.extension = { type: De.RendererSystem, name: "transformFeedback" };
je.add(kP);
class pC {
  constructor(e) {
    this.renderer = e;
  }
  init(e) {
    ((this.screen = new Bt(0, 0, e.width, e.height)),
      (this.element = e.view || Oe.ADAPTER.createCanvas()),
      (this.resolution = e.resolution || Oe.RESOLUTION),
      (this.autoDensity = !!e.autoDensity));
  }
  resizeView(e, t) {
    ((this.element.width = Math.round(e * this.resolution)),
      (this.element.height = Math.round(t * this.resolution)));
    const i = this.element.width / this.resolution,
      r = this.element.height / this.resolution;
    ((this.screen.width = i),
      (this.screen.height = r),
      this.autoDensity &&
        ((this.element.style.width = `${i}px`),
        (this.element.style.height = `${r}px`)),
      this.renderer.emit("resize", i, r),
      this.renderer.runners.resize.emit(this.screen.width, this.screen.height));
  }
  destroy(e) {
    (e && this.element.parentNode?.removeChild(this.element),
      (this.renderer = null),
      (this.element = null),
      (this.screen = null));
  }
}
((pC.defaultOptions = {
  width: 800,
  height: 600,
  resolution: void 0,
  autoDensity: !1,
}),
  (pC.extension = {
    type: [De.RendererSystem, De.CanvasRendererSystem],
    name: "_view",
  }));
je.add(pC);
Oe.PREFER_ENV = Tu.WEBGL2;
Oe.STRICT_TEXTURE_CACHE = !1;
Oe.RENDER_OPTIONS = {
  ...fC.defaultOptions,
  ...dC.defaultOptions,
  ...pC.defaultOptions,
  ...gC.defaultOptions,
};
Object.defineProperties(Oe, {
  WRAP_MODE: {
    get() {
      return St.defaultOptions.wrapMode;
    },
    set(n) {
      (Ht(
        "7.1.0",
        "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode",
      ),
        (St.defaultOptions.wrapMode = n));
    },
  },
  SCALE_MODE: {
    get() {
      return St.defaultOptions.scaleMode;
    },
    set(n) {
      (Ht(
        "7.1.0",
        "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode",
      ),
        (St.defaultOptions.scaleMode = n));
    },
  },
  MIPMAP_TEXTURES: {
    get() {
      return St.defaultOptions.mipmap;
    },
    set(n) {
      (Ht(
        "7.1.0",
        "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap",
      ),
        (St.defaultOptions.mipmap = n));
    },
  },
  ANISOTROPIC_LEVEL: {
    get() {
      return St.defaultOptions.anisotropicLevel;
    },
    set(n) {
      (Ht(
        "7.1.0",
        "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel",
      ),
        (St.defaultOptions.anisotropicLevel = n));
    },
  },
  FILTER_RESOLUTION: {
    get() {
      return (
        Ht(
          "7.1.0",
          "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution",
        ),
        fr.defaultResolution
      );
    },
    set(n) {
      fr.defaultResolution = n;
    },
  },
  FILTER_MULTISAMPLE: {
    get() {
      return (
        Ht(
          "7.1.0",
          "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample",
        ),
        fr.defaultMultisample
      );
    },
    set(n) {
      fr.defaultMultisample = n;
    },
  },
  SPRITE_MAX_TEXTURES: {
    get() {
      return Pc.defaultMaxTextures;
    },
    set(n) {
      (Ht(
        "7.1.0",
        "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures",
      ),
        (Pc.defaultMaxTextures = n));
    },
  },
  SPRITE_BATCH_SIZE: {
    get() {
      return Pc.defaultBatchSize;
    },
    set(n) {
      (Ht(
        "7.1.0",
        "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize",
      ),
        (Pc.defaultBatchSize = n));
    },
  },
  CAN_UPLOAD_SAME_BUFFER: {
    get() {
      return Pc.canUploadSameBuffer;
    },
    set(n) {
      (Ht(
        "7.1.0",
        "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer",
      ),
        (Pc.canUploadSameBuffer = n));
    },
  },
  GC_MODE: {
    get() {
      return Nc.defaultMode;
    },
    set(n) {
      (Ht(
        "7.1.0",
        "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode",
      ),
        (Nc.defaultMode = n));
    },
  },
  GC_MAX_IDLE: {
    get() {
      return Nc.defaultMaxIdle;
    },
    set(n) {
      (Ht(
        "7.1.0",
        "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle",
      ),
        (Nc.defaultMaxIdle = n));
    },
  },
  GC_MAX_CHECK_COUNT: {
    get() {
      return Nc.defaultCheckCountMax;
    },
    set(n) {
      (Ht(
        "7.1.0",
        "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax",
      ),
        (Nc.defaultCheckCountMax = n));
    },
  },
  PRECISION_VERTEX: {
    get() {
      return ya.defaultVertexPrecision;
    },
    set(n) {
      (Ht(
        "7.1.0",
        "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision",
      ),
        (ya.defaultVertexPrecision = n));
    },
  },
  PRECISION_FRAGMENT: {
    get() {
      return ya.defaultFragmentPrecision;
    },
    set(n) {
      (Ht(
        "7.1.0",
        "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision",
      ),
        (ya.defaultFragmentPrecision = n));
    },
  },
});
var Iu = ((n) => (
  (n[(n.INTERACTION = 50)] = "INTERACTION"),
  (n[(n.HIGH = 25)] = "HIGH"),
  (n[(n.NORMAL = 0)] = "NORMAL"),
  (n[(n.LOW = -25)] = "LOW"),
  (n[(n.UTILITY = -50)] = "UTILITY"),
  n
))(Iu || {});
class OA {
  constructor(e, t = null, i = 0, r = !1) {
    ((this.next = null),
      (this.previous = null),
      (this._destroyed = !1),
      (this.fn = e),
      (this.context = t),
      (this.priority = i),
      (this.once = r));
  }
  match(e, t = null) {
    return this.fn === e && this.context === t;
  }
  emit(e) {
    this.fn && (this.context ? this.fn.call(this.context, e) : this.fn(e));
    const t = this.next;
    return (
      this.once && this.destroy(!0),
      this._destroyed && (this.next = null),
      t
    );
  }
  connect(e) {
    ((this.previous = e),
      e.next && (e.next.previous = this),
      (this.next = e.next),
      (e.next = this));
  }
  destroy(e = !1) {
    ((this._destroyed = !0),
      (this.fn = null),
      (this.context = null),
      this.previous && (this.previous.next = this.next),
      this.next && (this.next.previous = this.previous));
    const t = this.next;
    return ((this.next = e ? null : t), (this.previous = null), t);
  }
}
const OP = class Ur {
  constructor() {
    ((this.autoStart = !1),
      (this.deltaTime = 1),
      (this.lastTime = -1),
      (this.speed = 1),
      (this.started = !1),
      (this._requestId = null),
      (this._maxElapsedMS = 100),
      (this._minElapsedMS = 0),
      (this._protected = !1),
      (this._lastFrame = -1),
      (this._head = new OA(null, null, 1 / 0)),
      (this.deltaMS = 1 / Ur.targetFPMS),
      (this.elapsedMS = 1 / Ur.targetFPMS),
      (this._tick = (e) => {
        ((this._requestId = null),
          this.started &&
            (this.update(e),
            this.started &&
              this._requestId === null &&
              this._head.next &&
              (this._requestId = requestAnimationFrame(this._tick))));
      }));
  }
  _requestIfNeeded() {
    this._requestId === null &&
      this._head.next &&
      ((this.lastTime = performance.now()),
      (this._lastFrame = this.lastTime),
      (this._requestId = requestAnimationFrame(this._tick)));
  }
  _cancelIfNeeded() {
    this._requestId !== null &&
      (cancelAnimationFrame(this._requestId), (this._requestId = null));
  }
  _startIfPossible() {
    this.started ? this._requestIfNeeded() : this.autoStart && this.start();
  }
  add(e, t, i = Iu.NORMAL) {
    return this._addListener(new OA(e, t, i));
  }
  addOnce(e, t, i = Iu.NORMAL) {
    return this._addListener(new OA(e, t, i, !0));
  }
  _addListener(e) {
    let t = this._head.next,
      i = this._head;
    if (!t) e.connect(i);
    else {
      for (; t; ) {
        if (e.priority > t.priority) {
          e.connect(i);
          break;
        }
        ((i = t), (t = t.next));
      }
      e.previous || e.connect(i);
    }
    return (this._startIfPossible(), this);
  }
  remove(e, t) {
    let i = this._head.next;
    for (; i; ) i.match(e, t) ? (i = i.destroy()) : (i = i.next);
    return (this._head.next || this._cancelIfNeeded(), this);
  }
  get count() {
    if (!this._head) return 0;
    let e = 0,
      t = this._head;
    for (; (t = t.next); ) e++;
    return e;
  }
  start() {
    this.started || ((this.started = !0), this._requestIfNeeded());
  }
  stop() {
    this.started && ((this.started = !1), this._cancelIfNeeded());
  }
  destroy() {
    if (!this._protected) {
      this.stop();
      let e = this._head.next;
      for (; e; ) e = e.destroy(!0);
      (this._head.destroy(), (this._head = null));
    }
  }
  update(e = performance.now()) {
    let t;
    if (e > this.lastTime) {
      if (
        ((t = this.elapsedMS = e - this.lastTime),
        t > this._maxElapsedMS && (t = this._maxElapsedMS),
        (t *= this.speed),
        this._minElapsedMS)
      ) {
        const s = (e - this._lastFrame) | 0;
        if (s < this._minElapsedMS) return;
        this._lastFrame = e - (s % this._minElapsedMS);
      }
      ((this.deltaMS = t), (this.deltaTime = this.deltaMS * Ur.targetFPMS));
      const i = this._head;
      let r = i.next;
      for (; r; ) r = r.emit(this.deltaTime);
      i.next || this._cancelIfNeeded();
    } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
    this.lastTime = e;
  }
  get FPS() {
    return 1e3 / this.elapsedMS;
  }
  get minFPS() {
    return 1e3 / this._maxElapsedMS;
  }
  set minFPS(e) {
    const t = Math.min(this.maxFPS, e),
      i = Math.min(Math.max(0, t) / 1e3, Ur.targetFPMS);
    this._maxElapsedMS = 1 / i;
  }
  get maxFPS() {
    return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
  }
  set maxFPS(e) {
    if (e === 0) this._minElapsedMS = 0;
    else {
      const t = Math.max(this.minFPS, e);
      this._minElapsedMS = 1 / (t / 1e3);
    }
  }
  static get shared() {
    if (!Ur._shared) {
      const e = (Ur._shared = new Ur());
      ((e.autoStart = !0), (e._protected = !0));
    }
    return Ur._shared;
  }
  static get system() {
    if (!Ur._system) {
      const e = (Ur._system = new Ur());
      ((e.autoStart = !0), (e._protected = !0));
    }
    return Ur._system;
  }
};
OP.targetFPMS = 0.06;
let Er = OP;
Object.defineProperties(Oe, {
  TARGET_FPMS: {
    get() {
      return Er.targetFPMS;
    },
    set(n) {
      (Ht("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS"),
        (Er.targetFPMS = n));
    },
  },
});
class UP {
  static init(e) {
    ((e = Object.assign({ autoStart: !0, sharedTicker: !1 }, e)),
      Object.defineProperty(this, "ticker", {
        set(t) {
          (this._ticker && this._ticker.remove(this.render, this),
            (this._ticker = t),
            t && t.add(this.render, this, Iu.LOW));
        },
        get() {
          return this._ticker;
        },
      }),
      (this.stop = () => {
        this._ticker.stop();
      }),
      (this.start = () => {
        this._ticker.start();
      }),
      (this._ticker = null),
      (this.ticker = e.sharedTicker ? Er.shared : new Er()),
      e.autoStart && this.start());
  }
  static destroy() {
    if (this._ticker) {
      const e = this._ticker;
      ((this.ticker = null), e.destroy());
    }
  }
}
UP.extension = De.Application;
je.add(UP);
const HP = [];
je.handleByList(De.Renderer, HP);
function xfe(n) {
  for (const e of HP) if (e.test(n)) return new e(n);
  throw new Error("Unable to auto-detect a suitable renderer.");
}
var wfe = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`,
  Sfe = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
const Tfe = wfe,
  WP = Sfe;
class VP {
  constructor(e) {
    this.renderer = e;
  }
  contextChange(e) {
    let t;
    if (this.renderer.context.webGLVersion === 1) {
      const i = e.getParameter(e.FRAMEBUFFER_BINDING);
      (e.bindFramebuffer(e.FRAMEBUFFER, null),
        (t = e.getParameter(e.SAMPLES)),
        e.bindFramebuffer(e.FRAMEBUFFER, i));
    } else {
      const i = e.getParameter(e.DRAW_FRAMEBUFFER_BINDING);
      (e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
        (t = e.getParameter(e.SAMPLES)),
        e.bindFramebuffer(e.DRAW_FRAMEBUFFER, i));
    }
    t >= ri.HIGH
      ? (this.multisample = ri.HIGH)
      : t >= ri.MEDIUM
        ? (this.multisample = ri.MEDIUM)
        : t >= ri.LOW
          ? (this.multisample = ri.LOW)
          : (this.multisample = ri.NONE);
  }
  destroy() {}
}
VP.extension = { type: De.RendererSystem, name: "_multisample" };
je.add(VP);
class Efe {
  constructor(e) {
    ((this.buffer = e || null),
      (this.updateID = -1),
      (this.byteLength = -1),
      (this.refCount = 0));
  }
}
class ZP {
  constructor(e) {
    ((this.renderer = e),
      (this.managedBuffers = {}),
      (this.boundBufferBases = {}));
  }
  destroy() {
    this.renderer = null;
  }
  contextChange() {
    (this.disposeAll(!0),
      (this.gl = this.renderer.gl),
      (this.CONTEXT_UID = this.renderer.CONTEXT_UID));
  }
  bind(e) {
    const { gl: t, CONTEXT_UID: i } = this,
      r = e._glBuffers[i] || this.createGLBuffer(e);
    t.bindBuffer(e.type, r.buffer);
  }
  unbind(e) {
    const { gl: t } = this;
    t.bindBuffer(e, null);
  }
  bindBufferBase(e, t) {
    const { gl: i, CONTEXT_UID: r } = this;
    if (this.boundBufferBases[t] !== e) {
      const s = e._glBuffers[r] || this.createGLBuffer(e);
      ((this.boundBufferBases[t] = e),
        i.bindBufferBase(i.UNIFORM_BUFFER, t, s.buffer));
    }
  }
  bindBufferRange(e, t, i) {
    const { gl: r, CONTEXT_UID: s } = this;
    i = i || 0;
    const o = e._glBuffers[s] || this.createGLBuffer(e);
    r.bindBufferRange(r.UNIFORM_BUFFER, t || 0, o.buffer, i * 256, 256);
  }
  update(e) {
    const { gl: t, CONTEXT_UID: i } = this,
      r = e._glBuffers[i] || this.createGLBuffer(e);
    if (e._updateID !== r.updateID)
      if (
        ((r.updateID = e._updateID),
        t.bindBuffer(e.type, r.buffer),
        r.byteLength >= e.data.byteLength)
      )
        t.bufferSubData(e.type, 0, e.data);
      else {
        const s = e.static ? t.STATIC_DRAW : t.DYNAMIC_DRAW;
        ((r.byteLength = e.data.byteLength), t.bufferData(e.type, e.data, s));
      }
  }
  dispose(e, t) {
    if (!this.managedBuffers[e.id]) return;
    delete this.managedBuffers[e.id];
    const i = e._glBuffers[this.CONTEXT_UID],
      r = this.gl;
    (e.disposeRunner.remove(this),
      i &&
        (t || r.deleteBuffer(i.buffer), delete e._glBuffers[this.CONTEXT_UID]));
  }
  disposeAll(e) {
    const t = Object.keys(this.managedBuffers);
    for (let i = 0; i < t.length; i++)
      this.dispose(this.managedBuffers[t[i]], e);
  }
  createGLBuffer(e) {
    const { CONTEXT_UID: t, gl: i } = this;
    return (
      (e._glBuffers[t] = new Efe(i.createBuffer())),
      (this.managedBuffers[e.id] = e),
      e.disposeRunner.add(this),
      e._glBuffers[t]
    );
  }
}
ZP.extension = { type: De.RendererSystem, name: "buffer" };
je.add(ZP);
class zP {
  constructor(e) {
    this.renderer = e;
  }
  render(e, t) {
    const i = this.renderer;
    let r, s, o, a;
    if (
      (t &&
        ((r = t.renderTexture),
        (s = t.clear),
        (o = t.transform),
        (a = t.skipUpdateTransform)),
      (this.renderingToScreen = !r),
      i.runners.prerender.emit(),
      i.emit("prerender"),
      (i.projection.transform = o),
      !i.context.isLost)
    ) {
      if ((r || (this.lastObjectRendered = e), !a)) {
        const l = e.enableTempParent();
        (e.updateTransform(), e.disableTempParent(l));
      }
      (i.renderTexture.bind(r),
        i.batch.currentRenderer.start(),
        (s ?? i.background.clearBeforeRender) && i.renderTexture.clear(),
        e.render(i),
        i.batch.currentRenderer.flush(),
        r && (t.blit && i.framebuffer.blit(), r.baseTexture.update()),
        i.runners.postrender.emit(),
        (i.projection.transform = null),
        i.emit("postrender"));
    }
  }
  destroy() {
    ((this.renderer = null), (this.lastObjectRendered = null));
  }
}
zP.extension = { type: De.RendererSystem, name: "objectRenderer" };
je.add(zP);
const q0 = class X3 extends _fe {
  constructor(e) {
    (super(),
      (this.type = GB.WEBGL),
      (e = Object.assign({}, Oe.RENDER_OPTIONS, e)),
      (this.gl = null),
      (this.CONTEXT_UID = 0),
      (this.globalUniforms = new eo({ projectionMatrix: new Rn() }, !0)));
    const t = {
      runners: [
        "init",
        "destroy",
        "contextChange",
        "resolutionChange",
        "reset",
        "update",
        "postrender",
        "prerender",
        "resize",
      ],
      systems: X3.__systems,
      priority: [
        "_view",
        "textureGenerator",
        "background",
        "_plugin",
        "startup",
        "context",
        "state",
        "texture",
        "buffer",
        "geometry",
        "framebuffer",
        "transformFeedback",
        "mask",
        "scissor",
        "stencil",
        "projection",
        "textureGC",
        "filter",
        "renderTexture",
        "batch",
        "objectRenderer",
        "_multisample",
      ],
    };
    (this.setup(t),
      "useContextAlpha" in e &&
        (Ht(
          "7.0.0",
          "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead",
        ),
        (e.premultipliedAlpha =
          e.useContextAlpha && e.useContextAlpha !== "notMultiplied"),
        (e.backgroundAlpha = e.useContextAlpha === !1 ? 1 : e.backgroundAlpha)),
      (this._plugin.rendererPlugins = X3.__plugins),
      (this.options = e),
      this.startup.run(this.options));
  }
  static test(e) {
    return e?.forceCanvas ? !1 : Jhe();
  }
  render(e, t) {
    this.objectRenderer.render(e, t);
  }
  resize(e, t) {
    this._view.resizeView(e, t);
  }
  reset() {
    return (this.runners.reset.emit(), this);
  }
  clear() {
    (this.renderTexture.bind(), this.renderTexture.clear());
  }
  destroy(e = !1) {
    (this.runners.destroy.items.reverse(),
      this.emitWithCustomOptions(this.runners.destroy, { _view: e }),
      super.destroy());
  }
  get plugins() {
    return this._plugin.plugins;
  }
  get multisample() {
    return this._multisample.multisample;
  }
  get width() {
    return this._view.element.width;
  }
  get height() {
    return this._view.element.height;
  }
  get resolution() {
    return this._view.resolution;
  }
  set resolution(e) {
    ((this._view.resolution = e), this.runners.resolutionChange.emit(e));
  }
  get autoDensity() {
    return this._view.autoDensity;
  }
  get view() {
    return this._view.element;
  }
  get screen() {
    return this._view.screen;
  }
  get lastObjectRendered() {
    return this.objectRenderer.lastObjectRendered;
  }
  get renderingToScreen() {
    return this.objectRenderer.renderingToScreen;
  }
  get rendererLogId() {
    return `WebGL ${this.context.webGLVersion}`;
  }
  get clearBeforeRender() {
    return (
      Ht(
        "7.0.0",
        "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead.",
      ),
      this.background.clearBeforeRender
    );
  }
  get useContextAlpha() {
    return (
      Ht(
        "7.0.0",
        "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead.",
      ),
      this.context.useContextAlpha
    );
  }
  get preserveDrawingBuffer() {
    return (
      Ht(
        "7.0.0",
        "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context",
      ),
      this.context.preserveDrawingBuffer
    );
  }
  get backgroundColor() {
    return (
      Ht(
        "7.0.0",
        "renderer.backgroundColor has been deprecated, use renderer.background.color instead.",
      ),
      this.background.color
    );
  }
  set backgroundColor(e) {
    (Ht(
      "7.0.0",
      "renderer.backgroundColor has been deprecated, use renderer.background.color instead.",
    ),
      (this.background.color = e));
  }
  get backgroundAlpha() {
    return (
      Ht(
        "7.0.0",
        "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.",
      ),
      this.background.alpha
    );
  }
  set backgroundAlpha(e) {
    (Ht(
      "7.0.0",
      "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.",
    ),
      (this.background.alpha = e));
  }
  get powerPreference() {
    return (
      Ht(
        "7.0.0",
        "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context",
      ),
      this.context.powerPreference
    );
  }
  generateTexture(e, t) {
    return this.textureGenerator.generateTexture(e, t);
  }
};
((q0.extension = { type: De.Renderer, priority: 1 }),
  (q0.__plugins = {}),
  (q0.__systems = {}));
let S5 = q0;
je.handleByMap(De.RendererPlugin, S5.__plugins);
je.handleByMap(De.RendererSystem, S5.__systems);
je.add(S5);
class YP extends jg {
  constructor(e, t) {
    const { width: i, height: r } = t || {};
    (super(i, r), (this.items = []), (this.itemDirtyIds = []));
    for (let s = 0; s < e; s++) {
      const o = new St();
      (this.items.push(o), this.itemDirtyIds.push(-2));
    }
    ((this.length = e), (this._load = null), (this.baseTexture = null));
  }
  initFromArray(e, t) {
    for (let i = 0; i < this.length; i++)
      e[i] &&
        (e[i].castToBaseTexture
          ? this.addBaseTextureAt(e[i].castToBaseTexture(), i)
          : e[i] instanceof jg
            ? this.addResourceAt(e[i], i)
            : this.addResourceAt(cP(e[i], t), i));
  }
  dispose() {
    for (let e = 0, t = this.length; e < t; e++) this.items[e].destroy();
    ((this.items = null), (this.itemDirtyIds = null), (this._load = null));
  }
  addResourceAt(e, t) {
    if (!this.items[t]) throw new Error(`Index ${t} is out of bounds`);
    return (
      e.valid && !this.valid && this.resize(e.width, e.height),
      this.items[t].setResource(e),
      this
    );
  }
  bind(e) {
    if (this.baseTexture !== null)
      throw new Error("Only one base texture per TextureArray is allowed");
    super.bind(e);
    for (let t = 0; t < this.length; t++)
      ((this.items[t].parentTextureArray = e),
        this.items[t].on("update", e.update, e));
  }
  unbind(e) {
    super.unbind(e);
    for (let t = 0; t < this.length; t++)
      ((this.items[t].parentTextureArray = null),
        this.items[t].off("update", e.update, e));
  }
  load() {
    if (this._load) return this._load;
    const e = this.items
      .map((t) => t.resource)
      .filter((t) => t)
      .map((t) => t.load());
    return (
      (this._load = Promise.all(e).then(() => {
        const { realWidth: t, realHeight: i } = this.items[0];
        return (this.resize(t, i), this.update(), Promise.resolve(this));
      })),
      this._load
    );
  }
}
class Mfe extends YP {
  constructor(e, t) {
    const { width: i, height: r } = t || {};
    let s, o;
    (Array.isArray(e) ? ((s = e), (o = e.length)) : (o = e),
      super(o, { width: i, height: r }),
      s && this.initFromArray(s, t));
  }
  addBaseTextureAt(e, t) {
    if (e.resource) this.addResourceAt(e.resource, t);
    else throw new Error("ArrayResource does not support RenderTexture");
    return this;
  }
  bind(e) {
    (super.bind(e), (e.target = Uh.TEXTURE_2D_ARRAY));
  }
  upload(e, t, i) {
    const { length: r, itemDirtyIds: s, items: o } = this,
      { gl: a } = e;
    i.dirtyId < 0 &&
      a.texImage3D(
        a.TEXTURE_2D_ARRAY,
        0,
        i.internalFormat,
        this._width,
        this._height,
        r,
        0,
        t.format,
        i.type,
        null,
      );
    for (let l = 0; l < r; l++) {
      const c = o[l];
      s[l] < c.dirtyId &&
        ((s[l] = c.dirtyId),
        c.valid &&
          a.texSubImage3D(
            a.TEXTURE_2D_ARRAY,
            0,
            0,
            0,
            l,
            c.resource.width,
            c.resource.height,
            1,
            t.format,
            i.type,
            c.resource.source,
          ));
    }
    return !0;
  }
}
class Lfe extends Ol {
  constructor(e) {
    super(e);
  }
  static test(e) {
    const { OffscreenCanvas: t } = globalThis;
    return t && e instanceof t
      ? !0
      : globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement;
  }
}
const XP = class Zf extends YP {
  constructor(e, t) {
    const { width: i, height: r, autoLoad: s, linkBaseTexture: o } = t || {};
    if (e && e.length !== Zf.SIDES)
      throw new Error(`Invalid length. Got ${e.length}, expected 6`);
    super(6, { width: i, height: r });
    for (let a = 0; a < Zf.SIDES; a++)
      this.items[a].target = Uh.TEXTURE_CUBE_MAP_POSITIVE_X + a;
    ((this.linkBaseTexture = o !== !1),
      e && this.initFromArray(e, t),
      s !== !1 && this.load());
  }
  bind(e) {
    (super.bind(e), (e.target = Uh.TEXTURE_CUBE_MAP));
  }
  addBaseTextureAt(e, t, i) {
    if ((i === void 0 && (i = this.linkBaseTexture), !this.items[t]))
      throw new Error(`Index ${t} is out of bounds`);
    if (
      !this.linkBaseTexture ||
      e.parentTextureArray ||
      Object.keys(e._glTextures).length > 0
    )
      if (e.resource) this.addResourceAt(e.resource, t);
      else
        throw new Error(
          "CubeResource does not support copying of renderTexture.",
        );
    else
      ((e.target = Uh.TEXTURE_CUBE_MAP_POSITIVE_X + t),
        (e.parentTextureArray = this.baseTexture),
        (this.items[t] = e));
    return (
      e.valid && !this.valid && this.resize(e.realWidth, e.realHeight),
      (this.items[t] = e),
      this
    );
  }
  upload(e, t, i) {
    const r = this.itemDirtyIds;
    for (let s = 0; s < Zf.SIDES; s++) {
      const o = this.items[s];
      (r[s] < o.dirtyId || i.dirtyId < t.dirtyId) &&
        (o.valid && o.resource
          ? (o.resource.upload(e, o, i), (r[s] = o.dirtyId))
          : r[s] < -1 &&
            (e.gl.texImage2D(
              o.target,
              0,
              i.internalFormat,
              t.realWidth,
              t.realHeight,
              0,
              t.format,
              i.type,
              null,
            ),
            (r[s] = -1)));
    }
    return !0;
  }
  static test(e) {
    return Array.isArray(e) && e.length === Zf.SIDES;
  }
};
XP.SIDES = 6;
let Rfe = XP;
class xh extends Ol {
  constructor(e, t) {
    t = t || {};
    let i, r, s;
    (typeof e == "string"
      ? ((i = xh.EMPTY), (r = e), (s = !0))
      : ((i = e), (r = null), (s = !1)),
      super(i),
      (this.url = r),
      (this.crossOrigin = t.crossOrigin ?? !0),
      (this.alphaMode = typeof t.alphaMode == "number" ? t.alphaMode : null),
      (this.ownsImageBitmap = t.ownsImageBitmap ?? s),
      (this._load = null),
      t.autoLoad !== !1 && this.load());
  }
  load() {
    return this._load
      ? this._load
      : ((this._load = new Promise(async (e, t) => {
          if (this.url === null) {
            e(this);
            return;
          }
          try {
            const i = await Oe.ADAPTER.fetch(this.url, {
              mode: this.crossOrigin ? "cors" : "no-cors",
            });
            if (this.destroyed) return;
            const r = await i.blob();
            if (this.destroyed) return;
            const s = await createImageBitmap(r, {
              premultiplyAlpha:
                this.alphaMode === null || this.alphaMode === Tr.UNPACK
                  ? "premultiply"
                  : "none",
            });
            if (this.destroyed) {
              s.close();
              return;
            }
            ((this.source = s), this.update(), e(this));
          } catch (i) {
            if (this.destroyed) return;
            (t(i), this.onError.emit(i));
          }
        })),
        this._load);
  }
  upload(e, t, i) {
    return this.source instanceof ImageBitmap
      ? (typeof this.alphaMode == "number" && (t.alphaMode = this.alphaMode),
        super.upload(e, t, i))
      : (this.load(), !1);
  }
  dispose() {
    (this.ownsImageBitmap &&
      this.source instanceof ImageBitmap &&
      this.source.close(),
      super.dispose(),
      (this._load = null));
  }
  static test(e) {
    return (
      !!globalThis.createImageBitmap &&
      typeof ImageBitmap < "u" &&
      (typeof e == "string" || e instanceof ImageBitmap)
    );
  }
  static get EMPTY() {
    return (
      (xh._EMPTY = xh._EMPTY ?? Oe.ADAPTER.createCanvas(0, 0)),
      xh._EMPTY
    );
  }
}
const K3 = class em extends Ol {
  constructor(e, t) {
    ((t = t || {}),
      super(Oe.ADAPTER.createCanvas()),
      (this._width = 0),
      (this._height = 0),
      (this.svg = e),
      (this.scale = t.scale || 1),
      (this._overrideWidth = t.width),
      (this._overrideHeight = t.height),
      (this._resolve = null),
      (this._crossorigin = t.crossorigin),
      (this._load = null),
      t.autoLoad !== !1 && this.load());
  }
  load() {
    return this._load
      ? this._load
      : ((this._load = new Promise((e) => {
          if (
            ((this._resolve = () => {
              (this.update(), e(this));
            }),
            em.SVG_XML.test(this.svg.trim()))
          ) {
            if (!btoa)
              throw new Error(
                "Your browser doesn't support base64 conversions.",
              );
            this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`;
          }
          this._loadSvg();
        })),
        this._load);
  }
  _loadSvg() {
    const e = new Image();
    (Ol.crossOrigin(e, this.svg, this._crossorigin),
      (e.src = this.svg),
      (e.onerror = (t) => {
        this._resolve && ((e.onerror = null), this.onError.emit(t));
      }),
      (e.onload = () => {
        if (!this._resolve) return;
        const t = e.width,
          i = e.height;
        if (!t || !i)
          throw new Error(
            "The SVG image must have width and height defined (in pixels), canvas API needs them.",
          );
        let r = t * this.scale,
          s = i * this.scale;
        ((this._overrideWidth || this._overrideHeight) &&
          ((r = this._overrideWidth || (this._overrideHeight / i) * t),
          (s = this._overrideHeight || (this._overrideWidth / t) * i)),
          (r = Math.round(r)),
          (s = Math.round(s)));
        const o = this.source;
        ((o.width = r),
          (o.height = s),
          (o._pixiId = `canvas_${Cu()}`),
          o.getContext("2d").drawImage(e, 0, 0, t, i, 0, 0, r, s),
          this._resolve(),
          (this._resolve = null));
      }));
  }
  static getSize(e) {
    const t = em.SVG_SIZE.exec(e),
      i = {};
    return (
      t &&
        ((i[t[1]] = Math.round(parseFloat(t[3]))),
        (i[t[5]] = Math.round(parseFloat(t[7])))),
      i
    );
  }
  dispose() {
    (super.dispose(), (this._resolve = null), (this._crossorigin = null));
  }
  static test(e, t) {
    return (
      t === "svg" ||
      (typeof e == "string" && e.startsWith("data:image/svg+xml")) ||
      (typeof e == "string" && em.SVG_XML.test(e))
    );
  }
};
((K3.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m),
  (K3.SVG_SIZE =
    /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i));
let j3 = K3;
const $3 = class J3 extends Ol {
  constructor(e, t) {
    if (((t = t || {}), !(e instanceof HTMLVideoElement))) {
      const i = document.createElement("video");
      (t.autoLoad !== !1 && i.setAttribute("preload", "auto"),
        t.playsinline !== !1 &&
          (i.setAttribute("webkit-playsinline", ""),
          i.setAttribute("playsinline", "")),
        t.muted === !0 && (i.setAttribute("muted", ""), (i.muted = !0)),
        t.loop === !0 && i.setAttribute("loop", ""),
        t.autoPlay !== !1 && i.setAttribute("autoplay", ""),
        typeof e == "string" && (e = [e]));
      const r = e[0].src || e[0];
      Ol.crossOrigin(i, r, t.crossorigin);
      for (let s = 0; s < e.length; ++s) {
        const o = document.createElement("source");
        let { src: a, mime: l } = e[s];
        if (((a = a || e[s]), a.startsWith("data:")))
          l = a.slice(5, a.indexOf(";"));
        else if (!a.startsWith("blob:")) {
          const c = a.split("?").shift().toLowerCase(),
            u = c.slice(c.lastIndexOf(".") + 1);
          l = l || J3.MIME_TYPES[u] || `video/${u}`;
        }
        ((o.src = a), l && (o.type = l), i.appendChild(o));
      }
      e = i;
    }
    (super(e),
      (this.noSubImage = !0),
      (this._autoUpdate = !0),
      (this._isConnectedToTicker = !1),
      (this._updateFPS = t.updateFPS || 0),
      (this._msToNextUpdate = 0),
      (this.autoPlay = t.autoPlay !== !1),
      (this._videoFrameRequestCallback =
        this._videoFrameRequestCallback.bind(this)),
      (this._videoFrameRequestCallbackHandle = null),
      (this._load = null),
      (this._resolve = null),
      (this._reject = null),
      (this._onCanPlay = this._onCanPlay.bind(this)),
      (this._onError = this._onError.bind(this)),
      (this._onPlayStart = this._onPlayStart.bind(this)),
      (this._onPlayStop = this._onPlayStop.bind(this)),
      (this._onSeeked = this._onSeeked.bind(this)),
      t.autoLoad !== !1 && this.load());
  }
  update(e = 0) {
    if (!this.destroyed) {
      if (this._updateFPS) {
        const t = Er.shared.elapsedMS * this.source.playbackRate;
        this._msToNextUpdate = Math.floor(this._msToNextUpdate - t);
      }
      (!this._updateFPS || this._msToNextUpdate <= 0) &&
        (super.update(),
        (this._msToNextUpdate = this._updateFPS
          ? Math.floor(1e3 / this._updateFPS)
          : 0));
    }
  }
  _videoFrameRequestCallback() {
    (this.update(),
      this.destroyed
        ? (this._videoFrameRequestCallbackHandle = null)
        : (this._videoFrameRequestCallbackHandle =
            this.source.requestVideoFrameCallback(
              this._videoFrameRequestCallback,
            )));
  }
  load() {
    if (this._load) return this._load;
    const e = this.source;
    return (
      (e.readyState === e.HAVE_ENOUGH_DATA ||
        e.readyState === e.HAVE_FUTURE_DATA) &&
        e.width &&
        e.height &&
        (e.complete = !0),
      e.addEventListener("play", this._onPlayStart),
      e.addEventListener("pause", this._onPlayStop),
      e.addEventListener("seeked", this._onSeeked),
      this._isSourceReady()
        ? this._onCanPlay()
        : (e.addEventListener("canplay", this._onCanPlay),
          e.addEventListener("canplaythrough", this._onCanPlay),
          e.addEventListener("error", this._onError, !0)),
      (this._load = new Promise((t, i) => {
        this.valid
          ? t(this)
          : ((this._resolve = t), (this._reject = i), e.load());
      })),
      this._load
    );
  }
  _onError(e) {
    (this.source.removeEventListener("error", this._onError, !0),
      this.onError.emit(e),
      this._reject &&
        (this._reject(e), (this._reject = null), (this._resolve = null)));
  }
  _isSourcePlaying() {
    const e = this.source;
    return !e.paused && !e.ended && this._isSourceReady();
  }
  _isSourceReady() {
    return this.source.readyState > 2;
  }
  _onPlayStart() {
    (this.valid || this._onCanPlay(), this._configureAutoUpdate());
  }
  _onPlayStop() {
    this._configureAutoUpdate();
  }
  _onSeeked() {
    this._autoUpdate &&
      !this._isSourcePlaying() &&
      ((this._msToNextUpdate = 0), this.update(), (this._msToNextUpdate = 0));
  }
  _onCanPlay() {
    const e = this.source;
    (e.removeEventListener("canplay", this._onCanPlay),
      e.removeEventListener("canplaythrough", this._onCanPlay));
    const t = this.valid;
    ((this._msToNextUpdate = 0),
      this.update(),
      (this._msToNextUpdate = 0),
      !t &&
        this._resolve &&
        (this._resolve(this), (this._resolve = null), (this._reject = null)),
      this._isSourcePlaying()
        ? this._onPlayStart()
        : this.autoPlay && e.play());
  }
  dispose() {
    this._configureAutoUpdate();
    const e = this.source;
    (e &&
      (e.removeEventListener("play", this._onPlayStart),
      e.removeEventListener("pause", this._onPlayStop),
      e.removeEventListener("seeked", this._onSeeked),
      e.removeEventListener("canplay", this._onCanPlay),
      e.removeEventListener("canplaythrough", this._onCanPlay),
      e.removeEventListener("error", this._onError, !0),
      e.pause(),
      (e.src = ""),
      e.load()),
      super.dispose());
  }
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(e) {
    e !== this._autoUpdate &&
      ((this._autoUpdate = e), this._configureAutoUpdate());
  }
  get updateFPS() {
    return this._updateFPS;
  }
  set updateFPS(e) {
    e !== this._updateFPS &&
      ((this._updateFPS = e), this._configureAutoUpdate());
  }
  _configureAutoUpdate() {
    this._autoUpdate && this._isSourcePlaying()
      ? !this._updateFPS && this.source.requestVideoFrameCallback
        ? (this._isConnectedToTicker &&
            (Er.shared.remove(this.update, this),
            (this._isConnectedToTicker = !1),
            (this._msToNextUpdate = 0)),
          this._videoFrameRequestCallbackHandle === null &&
            (this._videoFrameRequestCallbackHandle =
              this.source.requestVideoFrameCallback(
                this._videoFrameRequestCallback,
              )))
        : (this._videoFrameRequestCallbackHandle !== null &&
            (this.source.cancelVideoFrameCallback(
              this._videoFrameRequestCallbackHandle,
            ),
            (this._videoFrameRequestCallbackHandle = null)),
          this._isConnectedToTicker ||
            (Er.shared.add(this.update, this),
            (this._isConnectedToTicker = !0),
            (this._msToNextUpdate = 0)))
      : (this._videoFrameRequestCallbackHandle !== null &&
          (this.source.cancelVideoFrameCallback(
            this._videoFrameRequestCallbackHandle,
          ),
          (this._videoFrameRequestCallbackHandle = null)),
        this._isConnectedToTicker &&
          (Er.shared.remove(this.update, this),
          (this._isConnectedToTicker = !1),
          (this._msToNextUpdate = 0)));
  }
  static test(e, t) {
    return (
      (globalThis.HTMLVideoElement && e instanceof HTMLVideoElement) ||
      J3.TYPES.includes(t)
    );
  }
};
(($3.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"]),
  ($3.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4",
  }));
let KP = $3;
F3.push(xh, AP, Lfe, KP, j3, gI, Rfe, Mfe);
class mC {
  constructor() {
    ((this.minX = 1 / 0),
      (this.minY = 1 / 0),
      (this.maxX = -1 / 0),
      (this.maxY = -1 / 0),
      (this.rect = null),
      (this.updateID = -1));
  }
  isEmpty() {
    return this.minX > this.maxX || this.minY > this.maxY;
  }
  clear() {
    ((this.minX = 1 / 0),
      (this.minY = 1 / 0),
      (this.maxX = -1 / 0),
      (this.maxY = -1 / 0));
  }
  getRectangle(e) {
    return this.minX > this.maxX || this.minY > this.maxY
      ? Bt.EMPTY
      : ((e = e || new Bt(0, 0, 1, 1)),
        (e.x = this.minX),
        (e.y = this.minY),
        (e.width = this.maxX - this.minX),
        (e.height = this.maxY - this.minY),
        e);
  }
  addPoint(e) {
    ((this.minX = Math.min(this.minX, e.x)),
      (this.maxX = Math.max(this.maxX, e.x)),
      (this.minY = Math.min(this.minY, e.y)),
      (this.maxY = Math.max(this.maxY, e.y)));
  }
  addPointMatrix(e, t) {
    const { a: i, b: r, c: s, d: o, tx: a, ty: l } = e,
      c = i * t.x + s * t.y + a,
      u = r * t.x + o * t.y + l;
    ((this.minX = Math.min(this.minX, c)),
      (this.maxX = Math.max(this.maxX, c)),
      (this.minY = Math.min(this.minY, u)),
      (this.maxY = Math.max(this.maxY, u)));
  }
  addQuad(e) {
    let t = this.minX,
      i = this.minY,
      r = this.maxX,
      s = this.maxY,
      o = e[0],
      a = e[1];
    ((t = o < t ? o : t),
      (i = a < i ? a : i),
      (r = o > r ? o : r),
      (s = a > s ? a : s),
      (o = e[2]),
      (a = e[3]),
      (t = o < t ? o : t),
      (i = a < i ? a : i),
      (r = o > r ? o : r),
      (s = a > s ? a : s),
      (o = e[4]),
      (a = e[5]),
      (t = o < t ? o : t),
      (i = a < i ? a : i),
      (r = o > r ? o : r),
      (s = a > s ? a : s),
      (o = e[6]),
      (a = e[7]),
      (t = o < t ? o : t),
      (i = a < i ? a : i),
      (r = o > r ? o : r),
      (s = a > s ? a : s),
      (this.minX = t),
      (this.minY = i),
      (this.maxX = r),
      (this.maxY = s));
  }
  addFrame(e, t, i, r, s) {
    this.addFrameMatrix(e.worldTransform, t, i, r, s);
  }
  addFrameMatrix(e, t, i, r, s) {
    const o = e.a,
      a = e.b,
      l = e.c,
      c = e.d,
      u = e.tx,
      h = e.ty;
    let d = this.minX,
      f = this.minY,
      g = this.maxX,
      p = this.maxY,
      m = o * t + l * i + u,
      C = a * t + c * i + h;
    ((d = m < d ? m : d),
      (f = C < f ? C : f),
      (g = m > g ? m : g),
      (p = C > p ? C : p),
      (m = o * r + l * i + u),
      (C = a * r + c * i + h),
      (d = m < d ? m : d),
      (f = C < f ? C : f),
      (g = m > g ? m : g),
      (p = C > p ? C : p),
      (m = o * t + l * s + u),
      (C = a * t + c * s + h),
      (d = m < d ? m : d),
      (f = C < f ? C : f),
      (g = m > g ? m : g),
      (p = C > p ? C : p),
      (m = o * r + l * s + u),
      (C = a * r + c * s + h),
      (d = m < d ? m : d),
      (f = C < f ? C : f),
      (g = m > g ? m : g),
      (p = C > p ? C : p),
      (this.minX = d),
      (this.minY = f),
      (this.maxX = g),
      (this.maxY = p));
  }
  addVertexData(e, t, i) {
    let r = this.minX,
      s = this.minY,
      o = this.maxX,
      a = this.maxY;
    for (let l = t; l < i; l += 2) {
      const c = e[l],
        u = e[l + 1];
      ((r = c < r ? c : r),
        (s = u < s ? u : s),
        (o = c > o ? c : o),
        (a = u > a ? u : a));
    }
    ((this.minX = r), (this.minY = s), (this.maxX = o), (this.maxY = a));
  }
  addVertices(e, t, i, r) {
    this.addVerticesMatrix(e.worldTransform, t, i, r);
  }
  addVerticesMatrix(e, t, i, r, s = 0, o = s) {
    const a = e.a,
      l = e.b,
      c = e.c,
      u = e.d,
      h = e.tx,
      d = e.ty;
    let f = this.minX,
      g = this.minY,
      p = this.maxX,
      m = this.maxY;
    for (let C = i; C < r; C += 2) {
      const A = t[C],
        I = t[C + 1],
        y = a * A + c * I + h,
        x = u * I + l * A + d;
      ((f = Math.min(f, y - s)),
        (p = Math.max(p, y + s)),
        (g = Math.min(g, x - o)),
        (m = Math.max(m, x + o)));
    }
    ((this.minX = f), (this.minY = g), (this.maxX = p), (this.maxY = m));
  }
  addBounds(e) {
    const t = this.minX,
      i = this.minY,
      r = this.maxX,
      s = this.maxY;
    ((this.minX = e.minX < t ? e.minX : t),
      (this.minY = e.minY < i ? e.minY : i),
      (this.maxX = e.maxX > r ? e.maxX : r),
      (this.maxY = e.maxY > s ? e.maxY : s));
  }
  addBoundsMask(e, t) {
    const i = e.minX > t.minX ? e.minX : t.minX,
      r = e.minY > t.minY ? e.minY : t.minY,
      s = e.maxX < t.maxX ? e.maxX : t.maxX,
      o = e.maxY < t.maxY ? e.maxY : t.maxY;
    if (i <= s && r <= o) {
      const a = this.minX,
        l = this.minY,
        c = this.maxX,
        u = this.maxY;
      ((this.minX = i < a ? i : a),
        (this.minY = r < l ? r : l),
        (this.maxX = s > c ? s : c),
        (this.maxY = o > u ? o : u));
    }
  }
  addBoundsMatrix(e, t) {
    this.addFrameMatrix(t, e.minX, e.minY, e.maxX, e.maxY);
  }
  addBoundsArea(e, t) {
    const i = e.minX > t.x ? e.minX : t.x,
      r = e.minY > t.y ? e.minY : t.y,
      s = e.maxX < t.x + t.width ? e.maxX : t.x + t.width,
      o = e.maxY < t.y + t.height ? e.maxY : t.y + t.height;
    if (i <= s && r <= o) {
      const a = this.minX,
        l = this.minY,
        c = this.maxX,
        u = this.maxY;
      ((this.minX = i < a ? i : a),
        (this.minY = r < l ? r : l),
        (this.maxX = s > c ? s : c),
        (this.maxY = o > u ? o : u));
    }
  }
  pad(e = 0, t = e) {
    this.isEmpty() ||
      ((this.minX -= e), (this.maxX += e), (this.minY -= t), (this.maxY += t));
  }
  addFramePad(e, t, i, r, s, o) {
    ((e -= s),
      (t -= o),
      (i += s),
      (r += o),
      (this.minX = this.minX < e ? this.minX : e),
      (this.maxX = this.maxX > i ? this.maxX : i),
      (this.minY = this.minY < t ? this.minY : t),
      (this.maxY = this.maxY > r ? this.maxY : r));
  }
}
class Wn extends Lp {
  constructor() {
    (super(),
      (this.tempDisplayObjectParent = null),
      (this.transform = new x5()),
      (this.alpha = 1),
      (this.visible = !0),
      (this.renderable = !0),
      (this.cullable = !1),
      (this.cullArea = null),
      (this.parent = null),
      (this.worldAlpha = 1),
      (this._lastSortedIndex = 0),
      (this._zIndex = 0),
      (this.filterArea = null),
      (this.filters = null),
      (this._enabledFilters = null),
      (this._bounds = new mC()),
      (this._localBounds = null),
      (this._boundsID = 0),
      (this._boundsRect = null),
      (this._localBoundsRect = null),
      (this._mask = null),
      (this._maskRefCount = 0),
      (this._destroyed = !1),
      (this.isSprite = !1),
      (this.isMask = !1));
  }
  static mixin(e) {
    const t = Object.keys(e);
    for (let i = 0; i < t.length; ++i) {
      const r = t[i];
      Object.defineProperty(
        Wn.prototype,
        r,
        Object.getOwnPropertyDescriptor(e, r),
      );
    }
  }
  get destroyed() {
    return this._destroyed;
  }
  _recursivePostUpdateTransform() {
    this.parent
      ? (this.parent._recursivePostUpdateTransform(),
        this.transform.updateTransform(this.parent.transform))
      : this.transform.updateTransform(this._tempDisplayObjectParent.transform);
  }
  updateTransform() {
    (this._boundsID++,
      this.transform.updateTransform(this.parent.transform),
      (this.worldAlpha = this.alpha * this.parent.worldAlpha));
  }
  getBounds(e, t) {
    return (
      e ||
        (this.parent
          ? (this._recursivePostUpdateTransform(), this.updateTransform())
          : ((this.parent = this._tempDisplayObjectParent),
            this.updateTransform(),
            (this.parent = null))),
      this._bounds.updateID !== this._boundsID &&
        (this.calculateBounds(), (this._bounds.updateID = this._boundsID)),
      t ||
        (this._boundsRect || (this._boundsRect = new Bt()),
        (t = this._boundsRect)),
      this._bounds.getRectangle(t)
    );
  }
  getLocalBounds(e) {
    (e ||
      (this._localBoundsRect || (this._localBoundsRect = new Bt()),
      (e = this._localBoundsRect)),
      this._localBounds || (this._localBounds = new mC()));
    const t = this.transform,
      i = this.parent;
    ((this.parent = null),
      (this._tempDisplayObjectParent.worldAlpha = i?.worldAlpha ?? 1),
      (this.transform = this._tempDisplayObjectParent.transform));
    const r = this._bounds,
      s = this._boundsID;
    this._bounds = this._localBounds;
    const o = this.getBounds(!1, e);
    return (
      (this.parent = i),
      (this.transform = t),
      (this._bounds = r),
      (this._bounds.updateID += this._boundsID - s),
      o
    );
  }
  toGlobal(e, t, i = !1) {
    return (
      i ||
        (this._recursivePostUpdateTransform(),
        this.parent
          ? this.displayObjectUpdateTransform()
          : ((this.parent = this._tempDisplayObjectParent),
            this.displayObjectUpdateTransform(),
            (this.parent = null))),
      this.worldTransform.apply(e, t)
    );
  }
  toLocal(e, t, i, r) {
    return (
      t && (e = t.toGlobal(e, i, r)),
      r ||
        (this._recursivePostUpdateTransform(),
        this.parent
          ? this.displayObjectUpdateTransform()
          : ((this.parent = this._tempDisplayObjectParent),
            this.displayObjectUpdateTransform(),
            (this.parent = null))),
      this.worldTransform.applyInverse(e, i)
    );
  }
  setParent(e) {
    if (!e || !e.addChild)
      throw new Error("setParent: Argument must be a Container");
    return (e.addChild(this), e);
  }
  removeFromParent() {
    this.parent?.removeChild(this);
  }
  setTransform(e = 0, t = 0, i = 1, r = 1, s = 0, o = 0, a = 0, l = 0, c = 0) {
    return (
      (this.position.x = e),
      (this.position.y = t),
      (this.scale.x = i || 1),
      (this.scale.y = r || 1),
      (this.rotation = s),
      (this.skew.x = o),
      (this.skew.y = a),
      (this.pivot.x = l),
      (this.pivot.y = c),
      this
    );
  }
  destroy(e) {
    (this.removeFromParent(),
      (this._destroyed = !0),
      (this.transform = null),
      (this.parent = null),
      (this._bounds = null),
      (this.mask = null),
      (this.cullArea = null),
      (this.filters = null),
      (this.filterArea = null),
      (this.hitArea = null),
      (this.eventMode = "auto"),
      (this.interactiveChildren = !1),
      this.emit("destroyed"),
      this.removeAllListeners());
  }
  get _tempDisplayObjectParent() {
    return (
      this.tempDisplayObjectParent === null &&
        (this.tempDisplayObjectParent = new Bfe()),
      this.tempDisplayObjectParent
    );
  }
  enableTempParent() {
    const e = this.parent;
    return ((this.parent = this._tempDisplayObjectParent), e);
  }
  disableTempParent(e) {
    this.parent = e;
  }
  get x() {
    return this.position.x;
  }
  set x(e) {
    this.transform.position.x = e;
  }
  get y() {
    return this.position.y;
  }
  set y(e) {
    this.transform.position.y = e;
  }
  get worldTransform() {
    return this.transform.worldTransform;
  }
  get localTransform() {
    return this.transform.localTransform;
  }
  get position() {
    return this.transform.position;
  }
  set position(e) {
    this.transform.position.copyFrom(e);
  }
  get scale() {
    return this.transform.scale;
  }
  set scale(e) {
    this.transform.scale.copyFrom(e);
  }
  get pivot() {
    return this.transform.pivot;
  }
  set pivot(e) {
    this.transform.pivot.copyFrom(e);
  }
  get skew() {
    return this.transform.skew;
  }
  set skew(e) {
    this.transform.skew.copyFrom(e);
  }
  get rotation() {
    return this.transform.rotation;
  }
  set rotation(e) {
    this.transform.rotation = e;
  }
  get angle() {
    return this.transform.rotation * wde;
  }
  set angle(e) {
    this.transform.rotation = e * Sde;
  }
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(e) {
    ((this._zIndex = e), this.parent && (this.parent.sortDirty = !0));
  }
  get worldVisible() {
    let e = this;
    do {
      if (!e.visible) return !1;
      e = e.parent;
    } while (e);
    return !0;
  }
  get mask() {
    return this._mask;
  }
  set mask(e) {
    if (this._mask !== e) {
      if (this._mask) {
        const t = this._mask.isMaskData ? this._mask.maskObject : this._mask;
        t &&
          (t._maskRefCount--,
          t._maskRefCount === 0 && ((t.renderable = !0), (t.isMask = !1)));
      }
      if (((this._mask = e), this._mask)) {
        const t = this._mask.isMaskData ? this._mask.maskObject : this._mask;
        t &&
          (t._maskRefCount === 0 && ((t.renderable = !1), (t.isMask = !0)),
          t._maskRefCount++);
      }
    }
  }
}
class Bfe extends Wn {
  constructor() {
    (super(...arguments), (this.sortDirty = null));
  }
}
Wn.prototype.displayObjectUpdateTransform = Wn.prototype.updateTransform;
const Pfe = new Rn();
function Nfe(n, e) {
  return n.zIndex === e.zIndex
    ? n._lastSortedIndex - e._lastSortedIndex
    : n.zIndex - e.zIndex;
}
const jP = class Q3 extends Wn {
  constructor() {
    (super(),
      (this.children = []),
      (this.sortableChildren = Q3.defaultSortableChildren),
      (this.sortDirty = !1));
  }
  onChildrenChange(e) {}
  addChild(...e) {
    if (e.length > 1) for (let t = 0; t < e.length; t++) this.addChild(e[t]);
    else {
      const t = e[0];
      (t.parent && t.parent.removeChild(t),
        (t.parent = this),
        (this.sortDirty = !0),
        (t.transform._parentID = -1),
        this.children.push(t),
        this._boundsID++,
        this.onChildrenChange(this.children.length - 1),
        this.emit("childAdded", t, this, this.children.length - 1),
        t.emit("added", this));
    }
    return e[0];
  }
  addChildAt(e, t) {
    if (t < 0 || t > this.children.length)
      throw new Error(
        `${e}addChildAt: The index ${t} supplied is out of bounds ${this.children.length}`,
      );
    return (
      e.parent && e.parent.removeChild(e),
      (e.parent = this),
      (this.sortDirty = !0),
      (e.transform._parentID = -1),
      this.children.splice(t, 0, e),
      this._boundsID++,
      this.onChildrenChange(t),
      e.emit("added", this),
      this.emit("childAdded", e, this, t),
      e
    );
  }
  swapChildren(e, t) {
    if (e === t) return;
    const i = this.getChildIndex(e),
      r = this.getChildIndex(t);
    ((this.children[i] = t),
      (this.children[r] = e),
      this.onChildrenChange(i < r ? i : r));
  }
  getChildIndex(e) {
    const t = this.children.indexOf(e);
    if (t === -1)
      throw new Error(
        "The supplied DisplayObject must be a child of the caller",
      );
    return t;
  }
  setChildIndex(e, t) {
    if (t < 0 || t >= this.children.length)
      throw new Error(
        `The index ${t} supplied is out of bounds ${this.children.length}`,
      );
    const i = this.getChildIndex(e);
    (Vh(this.children, i, 1),
      this.children.splice(t, 0, e),
      this.onChildrenChange(t));
  }
  getChildAt(e) {
    if (e < 0 || e >= this.children.length)
      throw new Error(`getChildAt: Index (${e}) does not exist.`);
    return this.children[e];
  }
  removeChild(...e) {
    if (e.length > 1) for (let t = 0; t < e.length; t++) this.removeChild(e[t]);
    else {
      const t = e[0],
        i = this.children.indexOf(t);
      if (i === -1) return null;
      ((t.parent = null),
        (t.transform._parentID = -1),
        Vh(this.children, i, 1),
        this._boundsID++,
        this.onChildrenChange(i),
        t.emit("removed", this),
        this.emit("childRemoved", t, this, i));
    }
    return e[0];
  }
  removeChildAt(e) {
    const t = this.getChildAt(e);
    return (
      (t.parent = null),
      (t.transform._parentID = -1),
      Vh(this.children, e, 1),
      this._boundsID++,
      this.onChildrenChange(e),
      t.emit("removed", this),
      this.emit("childRemoved", t, this, e),
      t
    );
  }
  removeChildren(e = 0, t = this.children.length) {
    const i = e,
      r = t,
      s = r - i;
    let o;
    if (s > 0 && s <= r) {
      o = this.children.splice(i, s);
      for (let a = 0; a < o.length; ++a)
        ((o[a].parent = null),
          o[a].transform && (o[a].transform._parentID = -1));
      (this._boundsID++, this.onChildrenChange(e));
      for (let a = 0; a < o.length; ++a)
        (o[a].emit("removed", this), this.emit("childRemoved", o[a], this, a));
      return o;
    } else if (s === 0 && this.children.length === 0) return [];
    throw new RangeError(
      "removeChildren: numeric values are outside the acceptable range.",
    );
  }
  sortChildren() {
    let e = !1;
    for (let t = 0, i = this.children.length; t < i; ++t) {
      const r = this.children[t];
      ((r._lastSortedIndex = t), !e && r.zIndex !== 0 && (e = !0));
    }
    (e && this.children.length > 1 && this.children.sort(Nfe),
      (this.sortDirty = !1));
  }
  updateTransform() {
    (this.sortableChildren && this.sortDirty && this.sortChildren(),
      this._boundsID++,
      this.transform.updateTransform(this.parent.transform),
      (this.worldAlpha = this.alpha * this.parent.worldAlpha));
    for (let e = 0, t = this.children.length; e < t; ++e) {
      const i = this.children[e];
      i.visible && i.updateTransform();
    }
  }
  calculateBounds() {
    (this._bounds.clear(), this._calculateBounds());
    for (let e = 0; e < this.children.length; e++) {
      const t = this.children[e];
      if (!(!t.visible || !t.renderable))
        if ((t.calculateBounds(), t._mask)) {
          const i = t._mask.isMaskData ? t._mask.maskObject : t._mask;
          i
            ? (i.calculateBounds(),
              this._bounds.addBoundsMask(t._bounds, i._bounds))
            : this._bounds.addBounds(t._bounds);
        } else
          t.filterArea
            ? this._bounds.addBoundsArea(t._bounds, t.filterArea)
            : this._bounds.addBounds(t._bounds);
    }
    this._bounds.updateID = this._boundsID;
  }
  getLocalBounds(e, t = !1) {
    const i = super.getLocalBounds(e);
    if (!t)
      for (let r = 0, s = this.children.length; r < s; ++r) {
        const o = this.children[r];
        o.visible && o.updateTransform();
      }
    return i;
  }
  _calculateBounds() {}
  _renderWithCulling(e) {
    const t = e.renderTexture.sourceFrame;
    if (!(t.width > 0 && t.height > 0)) return;
    let i, r;
    this.cullArea
      ? ((i = this.cullArea), (r = this.worldTransform))
      : this._render !== Q3.prototype._render && (i = this.getBounds(!0));
    const s = e.projection.transform;
    if (
      (s && (r ? ((r = Pfe.copyFrom(r)), r.prepend(s)) : (r = s)),
      i && t.intersects(i, r))
    )
      this._render(e);
    else if (this.cullArea) return;
    for (let o = 0, a = this.children.length; o < a; ++o) {
      const l = this.children[o],
        c = l.cullable;
      ((l.cullable = c || !this.cullArea), l.render(e), (l.cullable = c));
    }
  }
  render(e) {
    if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))
      if (this._mask || this.filters?.length) this.renderAdvanced(e);
      else if (this.cullable) this._renderWithCulling(e);
      else {
        this._render(e);
        for (let t = 0, i = this.children.length; t < i; ++t)
          this.children[t].render(e);
      }
  }
  renderAdvanced(e) {
    const t = this.filters,
      i = this._mask;
    if (t) {
      (this._enabledFilters || (this._enabledFilters = []),
        (this._enabledFilters.length = 0));
      for (let s = 0; s < t.length; s++)
        t[s].enabled && this._enabledFilters.push(t[s]);
    }
    const r =
      (t && this._enabledFilters?.length) ||
      (i &&
        (!i.isMaskData || (i.enabled && (i.autoDetect || i.type !== hi.NONE))));
    if (
      (r && e.batch.flush(),
      t &&
        this._enabledFilters?.length &&
        e.filter.push(this, this._enabledFilters),
      i && e.mask.push(this, this._mask),
      this.cullable)
    )
      this._renderWithCulling(e);
    else {
      this._render(e);
      for (let s = 0, o = this.children.length; s < o; ++s)
        this.children[s].render(e);
    }
    (r && e.batch.flush(),
      i && e.mask.pop(this),
      t && this._enabledFilters?.length && e.filter.pop());
  }
  _render(e) {}
  destroy(e) {
    (super.destroy(), (this.sortDirty = !1));
    const t = typeof e == "boolean" ? e : e?.children,
      i = this.removeChildren(0, this.children.length);
    if (t) for (let r = 0; r < i.length; ++r) i[r].destroy(e);
  }
  get width() {
    return this.scale.x * this.getLocalBounds().width;
  }
  set width(e) {
    const t = this.getLocalBounds().width;
    (t !== 0 ? (this.scale.x = e / t) : (this.scale.x = 1), (this._width = e));
  }
  get height() {
    return this.scale.y * this.getLocalBounds().height;
  }
  set height(e) {
    const t = this.getLocalBounds().height;
    (t !== 0 ? (this.scale.y = e / t) : (this.scale.y = 1), (this._height = e));
  }
};
jP.defaultSortableChildren = !1;
let Rs = jP;
Rs.prototype.containerUpdateTransform = Rs.prototype.updateTransform;
Object.defineProperties(Oe, {
  SORTABLE_CHILDREN: {
    get() {
      return Rs.defaultSortableChildren;
    },
    set(n) {
      (Ht(
        "7.1.0",
        "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren",
      ),
        (Rs.defaultSortableChildren = n));
    },
  },
});
const wf = new Qt(),
  Dfe = new Uint16Array([0, 1, 2, 0, 2, 3]);
class $d extends Rs {
  constructor(e) {
    (super(),
      (this._anchor = new Aa(
        this._onAnchorUpdate,
        this,
        e ? e.defaultAnchor.x : 0,
        e ? e.defaultAnchor.y : 0,
      )),
      (this._texture = null),
      (this._width = 0),
      (this._height = 0),
      (this._tintColor = new Ln(16777215)),
      (this._tintRGB = null),
      (this.tint = 16777215),
      (this.blendMode = dt.NORMAL),
      (this._cachedTint = 16777215),
      (this.uvs = null),
      (this.texture = e || Qe.EMPTY),
      (this.vertexData = new Float32Array(8)),
      (this.vertexTrimmedData = null),
      (this._transformID = -1),
      (this._textureID = -1),
      (this._transformTrimmedID = -1),
      (this._textureTrimmedID = -1),
      (this.indices = Dfe),
      (this.pluginName = "batch"),
      (this.isSprite = !0),
      (this._roundPixels = Oe.ROUND_PIXELS));
  }
  _onTextureUpdate() {
    ((this._textureID = -1),
      (this._textureTrimmedID = -1),
      (this._cachedTint = 16777215),
      this._width &&
        (this.scale.x =
          (bl(this.scale.x) * this._width) / this._texture.orig.width),
      this._height &&
        (this.scale.y =
          (bl(this.scale.y) * this._height) / this._texture.orig.height));
  }
  _onAnchorUpdate() {
    ((this._transformID = -1), (this._transformTrimmedID = -1));
  }
  calculateVertices() {
    const e = this._texture;
    if (
      this._transformID === this.transform._worldID &&
      this._textureID === e._updateID
    )
      return;
    (this._textureID !== e._updateID &&
      (this.uvs = this._texture._uvs.uvsFloat32),
      (this._transformID = this.transform._worldID),
      (this._textureID = e._updateID));
    const t = this.transform.worldTransform,
      i = t.a,
      r = t.b,
      s = t.c,
      o = t.d,
      a = t.tx,
      l = t.ty,
      c = this.vertexData,
      u = e.trim,
      h = e.orig,
      d = this._anchor;
    let f = 0,
      g = 0,
      p = 0,
      m = 0;
    if (
      (u
        ? ((g = u.x - d._x * h.width),
          (f = g + u.width),
          (m = u.y - d._y * h.height),
          (p = m + u.height))
        : ((g = -d._x * h.width),
          (f = g + h.width),
          (m = -d._y * h.height),
          (p = m + h.height)),
      (c[0] = i * g + s * m + a),
      (c[1] = o * m + r * g + l),
      (c[2] = i * f + s * m + a),
      (c[3] = o * m + r * f + l),
      (c[4] = i * f + s * p + a),
      (c[5] = o * p + r * f + l),
      (c[6] = i * g + s * p + a),
      (c[7] = o * p + r * g + l),
      this._roundPixels)
    ) {
      const C = Oe.RESOLUTION;
      for (let A = 0; A < c.length; ++A) c[A] = Math.round(c[A] * C) / C;
    }
  }
  calculateTrimmedVertices() {
    if (!this.vertexTrimmedData) this.vertexTrimmedData = new Float32Array(8);
    else if (
      this._transformTrimmedID === this.transform._worldID &&
      this._textureTrimmedID === this._texture._updateID
    )
      return;
    ((this._transformTrimmedID = this.transform._worldID),
      (this._textureTrimmedID = this._texture._updateID));
    const e = this._texture,
      t = this.vertexTrimmedData,
      i = e.orig,
      r = this._anchor,
      s = this.transform.worldTransform,
      o = s.a,
      a = s.b,
      l = s.c,
      c = s.d,
      u = s.tx,
      h = s.ty,
      d = -r._x * i.width,
      f = d + i.width,
      g = -r._y * i.height,
      p = g + i.height;
    if (
      ((t[0] = o * d + l * g + u),
      (t[1] = c * g + a * d + h),
      (t[2] = o * f + l * g + u),
      (t[3] = c * g + a * f + h),
      (t[4] = o * f + l * p + u),
      (t[5] = c * p + a * f + h),
      (t[6] = o * d + l * p + u),
      (t[7] = c * p + a * d + h),
      this._roundPixels)
    ) {
      const m = Oe.RESOLUTION;
      for (let C = 0; C < t.length; ++C) t[C] = Math.round(t[C] * m) / m;
    }
  }
  _render(e) {
    (this.calculateVertices(),
      e.batch.setObjectRenderer(e.plugins[this.pluginName]),
      e.plugins[this.pluginName].render(this));
  }
  _calculateBounds() {
    const e = this._texture.trim,
      t = this._texture.orig;
    !e || (e.width === t.width && e.height === t.height)
      ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData))
      : (this.calculateTrimmedVertices(),
        this._bounds.addQuad(this.vertexTrimmedData));
  }
  getLocalBounds(e) {
    return this.children.length === 0
      ? (this._localBounds || (this._localBounds = new mC()),
        (this._localBounds.minX = this._texture.orig.width * -this._anchor._x),
        (this._localBounds.minY = this._texture.orig.height * -this._anchor._y),
        (this._localBounds.maxX =
          this._texture.orig.width * (1 - this._anchor._x)),
        (this._localBounds.maxY =
          this._texture.orig.height * (1 - this._anchor._y)),
        e ||
          (this._localBoundsRect || (this._localBoundsRect = new Bt()),
          (e = this._localBoundsRect)),
        this._localBounds.getRectangle(e))
      : super.getLocalBounds.call(this, e);
  }
  containsPoint(e) {
    this.worldTransform.applyInverse(e, wf);
    const t = this._texture.orig.width,
      i = this._texture.orig.height,
      r = -t * this.anchor.x;
    let s = 0;
    return (
      wf.x >= r &&
      wf.x < r + t &&
      ((s = -i * this.anchor.y), wf.y >= s && wf.y < s + i)
    );
  }
  destroy(e) {
    if (
      (super.destroy(e),
      this._texture.off("update", this._onTextureUpdate, this),
      (this._anchor = null),
      typeof e == "boolean" ? e : e?.texture)
    ) {
      const t = typeof e == "boolean" ? e : e?.baseTexture;
      this._texture.destroy(!!t);
    }
    this._texture = null;
  }
  static from(e, t) {
    const i = e instanceof Qe ? e : Qe.from(e, t);
    return new $d(i);
  }
  set roundPixels(e) {
    (this._roundPixels !== e &&
      ((this._transformID = -1), (this._transformTrimmedID = -1)),
      (this._roundPixels = e));
  }
  get roundPixels() {
    return this._roundPixels;
  }
  get width() {
    return Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(e) {
    const t = bl(this.scale.x) || 1;
    ((this.scale.x = (t * e) / this._texture.orig.width), (this._width = e));
  }
  get height() {
    return Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(e) {
    const t = bl(this.scale.y) || 1;
    ((this.scale.y = (t * e) / this._texture.orig.height), (this._height = e));
  }
  get anchor() {
    return this._anchor;
  }
  set anchor(e) {
    this._anchor.copyFrom(e);
  }
  get tint() {
    return this._tintColor.value;
  }
  set tint(e) {
    (this._tintColor.setValue(e),
      (this._tintRGB = this._tintColor.toLittleEndianNumber()));
  }
  get tintValue() {
    return this._tintColor.toNumber();
  }
  get texture() {
    return this._texture;
  }
  set texture(e) {
    this._texture !== e &&
      (this._texture &&
        this._texture.off("update", this._onTextureUpdate, this),
      (this._texture = e || Qe.EMPTY),
      (this._cachedTint = 16777215),
      (this._textureID = -1),
      (this._textureTrimmedID = -1),
      e &&
        (e.baseTexture.valid
          ? this._onTextureUpdate()
          : e.once("update", this._onTextureUpdate, this)));
  }
}
const $P = new Rn();
Wn.prototype._cacheAsBitmap = !1;
Wn.prototype._cacheData = null;
Wn.prototype._cacheAsBitmapResolution = null;
Wn.prototype._cacheAsBitmapMultisample = null;
class Gfe {
  constructor() {
    ((this.textureCacheId = null),
      (this.originalRender = null),
      (this.originalRenderCanvas = null),
      (this.originalCalculateBounds = null),
      (this.originalGetLocalBounds = null),
      (this.originalUpdateTransform = null),
      (this.originalDestroy = null),
      (this.originalMask = null),
      (this.originalFilterArea = null),
      (this.originalContainsPoint = null),
      (this.sprite = null));
  }
}
Object.defineProperties(Wn.prototype, {
  cacheAsBitmapResolution: {
    get() {
      return this._cacheAsBitmapResolution;
    },
    set(n) {
      n !== this._cacheAsBitmapResolution &&
        ((this._cacheAsBitmapResolution = n),
        this.cacheAsBitmap &&
          ((this.cacheAsBitmap = !1), (this.cacheAsBitmap = !0)));
    },
  },
  cacheAsBitmapMultisample: {
    get() {
      return this._cacheAsBitmapMultisample;
    },
    set(n) {
      n !== this._cacheAsBitmapMultisample &&
        ((this._cacheAsBitmapMultisample = n),
        this.cacheAsBitmap &&
          ((this.cacheAsBitmap = !1), (this.cacheAsBitmap = !0)));
    },
  },
  cacheAsBitmap: {
    get() {
      return this._cacheAsBitmap;
    },
    set(n) {
      if (this._cacheAsBitmap === n) return;
      this._cacheAsBitmap = n;
      let e;
      n
        ? (this._cacheData || (this._cacheData = new Gfe()),
          (e = this._cacheData),
          (e.originalRender = this.render),
          (e.originalRenderCanvas = this.renderCanvas),
          (e.originalUpdateTransform = this.updateTransform),
          (e.originalCalculateBounds = this.calculateBounds),
          (e.originalGetLocalBounds = this.getLocalBounds),
          (e.originalDestroy = this.destroy),
          (e.originalContainsPoint = this.containsPoint),
          (e.originalMask = this._mask),
          (e.originalFilterArea = this.filterArea),
          (this.render = this._renderCached),
          (this.renderCanvas = this._renderCachedCanvas),
          (this.destroy = this._cacheAsBitmapDestroy))
        : ((e = this._cacheData),
          e.sprite && this._destroyCachedDisplayObject(),
          (this.render = e.originalRender),
          (this.renderCanvas = e.originalRenderCanvas),
          (this.calculateBounds = e.originalCalculateBounds),
          (this.getLocalBounds = e.originalGetLocalBounds),
          (this.destroy = e.originalDestroy),
          (this.updateTransform = e.originalUpdateTransform),
          (this.containsPoint = e.originalContainsPoint),
          (this._mask = e.originalMask),
          (this.filterArea = e.originalFilterArea));
    },
  },
});
Wn.prototype._renderCached = function (n) {
  !this.visible ||
    this.worldAlpha <= 0 ||
    !this.renderable ||
    (this._initCachedDisplayObject(n),
    (this._cacheData.sprite.transform._worldID = this.transform._worldID),
    (this._cacheData.sprite.worldAlpha = this.worldAlpha),
    this._cacheData.sprite._render(n));
};
Wn.prototype._initCachedDisplayObject = function (n) {
  if (this._cacheData?.sprite) return;
  const e = this.alpha;
  ((this.alpha = 1), n.batch.flush());
  const t = this.getLocalBounds(new Bt(), !0);
  if (this.filters?.length) {
    const d = this.filters[0].padding;
    t.pad(d);
  }
  const i = this.cacheAsBitmapResolution || n.resolution;
  (t.ceil(i),
    (t.width = Math.max(t.width, 1 / i)),
    (t.height = Math.max(t.height, 1 / i)));
  const r = n.renderTexture.current,
    s = n.renderTexture.sourceFrame.clone(),
    o = n.renderTexture.destinationFrame.clone(),
    a = n.projection.transform,
    l = Eu.create({
      width: t.width,
      height: t.height,
      resolution: i,
      multisample: this.cacheAsBitmapMultisample ?? n.multisample,
    }),
    c = `cacheAsBitmap_${Cu()}`;
  ((this._cacheData.textureCacheId = c),
    St.addToCache(l.baseTexture, c),
    Qe.addToCache(l, c));
  const u = this.transform.localTransform
    .copyTo($P)
    .invert()
    .translate(-t.x, -t.y);
  ((this.render = this._cacheData.originalRender),
    n.render(this, {
      renderTexture: l,
      clear: !0,
      transform: u,
      skipUpdateTransform: !1,
    }),
    n.framebuffer.blit(),
    (n.projection.transform = a),
    n.renderTexture.bind(r, s, o),
    (this.render = this._renderCached),
    (this.updateTransform = this.displayObjectUpdateTransform),
    (this.calculateBounds = this._calculateCachedBounds),
    (this.getLocalBounds = this._getCachedLocalBounds),
    (this._mask = null),
    (this.filterArea = null),
    (this.alpha = e));
  const h = new $d(l);
  ((h.transform.worldTransform = this.transform.worldTransform),
    (h.anchor.x = -(t.x / t.width)),
    (h.anchor.y = -(t.y / t.height)),
    (h.alpha = e),
    (h._bounds = this._bounds),
    (this._cacheData.sprite = h),
    (this.transform._parentID = -1),
    this.parent
      ? this.updateTransform()
      : (this.enableTempParent(),
        this.updateTransform(),
        this.disableTempParent(null)),
    (this.containsPoint = h.containsPoint.bind(h)));
};
Wn.prototype._renderCachedCanvas = function (n) {
  !this.visible ||
    this.worldAlpha <= 0 ||
    !this.renderable ||
    (this._initCachedDisplayObjectCanvas(n),
    (this._cacheData.sprite.worldAlpha = this.worldAlpha),
    this._cacheData.sprite._renderCanvas(n));
};
Wn.prototype._initCachedDisplayObjectCanvas = function (n) {
  if (this._cacheData?.sprite) return;
  const e = this.getLocalBounds(new Bt(), !0),
    t = this.alpha;
  this.alpha = 1;
  const i = n.canvasContext.activeContext,
    r = n._projTransform,
    s = this.cacheAsBitmapResolution || n.resolution;
  (e.ceil(s),
    (e.width = Math.max(e.width, 1 / s)),
    (e.height = Math.max(e.height, 1 / s)));
  const o = Eu.create({ width: e.width, height: e.height, resolution: s }),
    a = `cacheAsBitmap_${Cu()}`;
  ((this._cacheData.textureCacheId = a),
    St.addToCache(o.baseTexture, a),
    Qe.addToCache(o, a));
  const l = $P;
  (this.transform.localTransform.copyTo(l),
    l.invert(),
    (l.tx -= e.x),
    (l.ty -= e.y),
    (this.renderCanvas = this._cacheData.originalRenderCanvas),
    n.render(this, {
      renderTexture: o,
      clear: !0,
      transform: l,
      skipUpdateTransform: !1,
    }),
    (n.canvasContext.activeContext = i),
    (n._projTransform = r),
    (this.renderCanvas = this._renderCachedCanvas),
    (this.updateTransform = this.displayObjectUpdateTransform),
    (this.calculateBounds = this._calculateCachedBounds),
    (this.getLocalBounds = this._getCachedLocalBounds),
    (this._mask = null),
    (this.filterArea = null),
    (this.alpha = t));
  const c = new $d(o);
  ((c.transform.worldTransform = this.transform.worldTransform),
    (c.anchor.x = -(e.x / e.width)),
    (c.anchor.y = -(e.y / e.height)),
    (c.alpha = t),
    (c._bounds = this._bounds),
    (this._cacheData.sprite = c),
    (this.transform._parentID = -1),
    this.parent
      ? this.updateTransform()
      : ((this.parent = n._tempDisplayObjectParent),
        this.updateTransform(),
        (this.parent = null)),
    (this.containsPoint = c.containsPoint.bind(c)));
};
Wn.prototype._calculateCachedBounds = function () {
  (this._bounds.clear(),
    (this._cacheData.sprite.transform._worldID = this.transform._worldID),
    this._cacheData.sprite._calculateBounds(),
    (this._bounds.updateID = this._boundsID));
};
Wn.prototype._getCachedLocalBounds = function () {
  return this._cacheData.sprite.getLocalBounds(null);
};
Wn.prototype._destroyCachedDisplayObject = function () {
  (this._cacheData.sprite._texture.destroy(!0),
    (this._cacheData.sprite = null),
    St.removeFromCache(this._cacheData.textureCacheId),
    Qe.removeFromCache(this._cacheData.textureCacheId),
    (this._cacheData.textureCacheId = null));
};
Wn.prototype._cacheAsBitmapDestroy = function (n) {
  ((this.cacheAsBitmap = !1), this.destroy(n));
};
Wn.prototype.name = null;
Rs.prototype.getChildByName = function (n, e) {
  for (let t = 0, i = this.children.length; t < i; t++)
    if (this.children[t].name === n) return this.children[t];
  if (e)
    for (let t = 0, i = this.children.length; t < i; t++) {
      const r = this.children[t];
      if (!r.getChildByName) continue;
      const s = r.getChildByName(n, !0);
      if (s) return s;
    }
  return null;
};
Wn.prototype.getGlobalPosition = function (n = new Qt(), e = !1) {
  return (
    this.parent
      ? this.parent.toGlobal(this.position, n, e)
      : ((n.x = this.position.x), (n.y = this.position.y)),
    n
  );
};
var Ffe = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform float uAlpha;

void main(void)
{
   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;
}
`;
class kfe extends fr {
  constructor(e = 1) {
    (super(Tfe, Ffe, { uAlpha: 1 }), (this.alpha = e));
  }
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(e) {
    this.uniforms.uAlpha = e;
  }
}
const Ofe = {
    5: [0.153388, 0.221461, 0.250301],
    7: [0.071303, 0.131514, 0.189879, 0.214607],
    9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
    11: [0.0093, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
    13: [0.002406, 0.009255, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
    15: [
      489e-6, 0.002403, 0.009246, 0.02784, 0.065602, 0.120999, 0.174697,
      0.197448,
    ],
  },
  Ufe = [
    "varying vec2 vBlurTexCoords[%size%];",
    "uniform sampler2D uSampler;",
    "void main(void)",
    "{",
    "    gl_FragColor = vec4(0.0);",
    "    %blur%",
    "}",
  ].join(`
`);
function Hfe(n) {
  const e = Ofe[n],
    t = e.length;
  let i = Ufe,
    r = "";
  const s =
    "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
  let o;
  for (let a = 0; a < n; a++) {
    let l = s.replace("%index%", a.toString());
    ((o = a),
      a >= t && (o = n - a - 1),
      (l = l.replace("%value%", e[o].toString())),
      (r += l),
      (r += `
`));
  }
  return (
    (i = i.replace("%blur%", r)),
    (i = i.replace("%size%", n.toString())),
    i
  );
}
const Wfe = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
function Vfe(n, e) {
  const t = Math.ceil(n / 2);
  let i = Wfe,
    r = "",
    s;
  e
    ? (s =
        "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);")
    : (s =
        "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);");
  for (let o = 0; o < n; o++) {
    let a = s.replace("%index%", o.toString());
    ((a = a.replace("%sampleIndex%", `${o - (t - 1)}.0`)),
      (r += a),
      (r += `
`));
  }
  return (
    (i = i.replace("%blur%", r)),
    (i = i.replace("%size%", n.toString())),
    i
  );
}
class q3 extends fr {
  constructor(e, t = 8, i = 4, r = fr.defaultResolution, s = 5) {
    const o = Vfe(s, e),
      a = Hfe(s);
    (super(o, a),
      (this.horizontal = e),
      (this.resolution = r),
      (this._quality = 0),
      (this.quality = i),
      (this.blur = t));
  }
  apply(e, t, i, r) {
    if (
      (i
        ? this.horizontal
          ? (this.uniforms.strength = (1 / i.width) * (i.width / t.width))
          : (this.uniforms.strength = (1 / i.height) * (i.height / t.height))
        : this.horizontal
          ? (this.uniforms.strength =
              (1 / e.renderer.width) * (e.renderer.width / t.width))
          : (this.uniforms.strength =
              (1 / e.renderer.height) * (e.renderer.height / t.height)),
      (this.uniforms.strength *= this.strength),
      (this.uniforms.strength /= this.passes),
      this.passes === 1)
    )
      e.applyFilter(this, t, i, r);
    else {
      const s = e.getFilterTexture(),
        o = e.renderer;
      let a = t,
        l = s;
      ((this.state.blend = !1), e.applyFilter(this, a, l, Co.CLEAR));
      for (let c = 1; c < this.passes - 1; c++) {
        (e.bindAndClear(a, Co.BLIT), (this.uniforms.uSampler = l));
        const u = l;
        ((l = a), (a = u), o.shader.bind(this), o.geometry.draw(5));
      }
      ((this.state.blend = !0),
        e.applyFilter(this, l, i, r),
        e.returnFilterTexture(s));
    }
  }
  get blur() {
    return this.strength;
  }
  set blur(e) {
    ((this.padding = 1 + Math.abs(e) * 2), (this.strength = e));
  }
  get quality() {
    return this._quality;
  }
  set quality(e) {
    ((this._quality = e), (this.passes = e));
  }
}
class Zfe extends fr {
  constructor(e = 8, t = 4, i = fr.defaultResolution, r = 5) {
    (super(),
      (this._repeatEdgePixels = !1),
      (this.blurXFilter = new q3(!0, e, t, i, r)),
      (this.blurYFilter = new q3(!1, e, t, i, r)),
      (this.resolution = i),
      (this.quality = t),
      (this.blur = e),
      (this.repeatEdgePixels = !1));
  }
  apply(e, t, i, r) {
    const s = Math.abs(this.blurXFilter.strength),
      o = Math.abs(this.blurYFilter.strength);
    if (s && o) {
      const a = e.getFilterTexture();
      (this.blurXFilter.apply(e, t, a, Co.CLEAR),
        this.blurYFilter.apply(e, a, i, r),
        e.returnFilterTexture(a));
    } else
      o
        ? this.blurYFilter.apply(e, t, i, r)
        : this.blurXFilter.apply(e, t, i, r);
  }
  updatePadding() {
    this._repeatEdgePixels
      ? (this.padding = 0)
      : (this.padding =
          Math.max(
            Math.abs(this.blurXFilter.strength),
            Math.abs(this.blurYFilter.strength),
          ) * 2);
  }
  get blur() {
    return this.blurXFilter.blur;
  }
  set blur(e) {
    ((this.blurXFilter.blur = this.blurYFilter.blur = e), this.updatePadding());
  }
  get quality() {
    return this.blurXFilter.quality;
  }
  set quality(e) {
    this.blurXFilter.quality = this.blurYFilter.quality = e;
  }
  get blurX() {
    return this.blurXFilter.blur;
  }
  set blurX(e) {
    ((this.blurXFilter.blur = e), this.updatePadding());
  }
  get blurY() {
    return this.blurYFilter.blur;
  }
  set blurY(e) {
    ((this.blurYFilter.blur = e), this.updatePadding());
  }
  get blendMode() {
    return this.blurYFilter.blendMode;
  }
  set blendMode(e) {
    this.blurYFilter.blendMode = e;
  }
  get repeatEdgePixels() {
    return this._repeatEdgePixels;
  }
  set repeatEdgePixels(e) {
    ((this._repeatEdgePixels = e), this.updatePadding());
  }
}
var zfe = `varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform float m[20];
uniform float uAlpha;

void main(void)
{
    vec4 c = texture2D(uSampler, vTextureCoord);

    if (uAlpha == 0.0) {
        gl_FragColor = c;
        return;
    }

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.rgb /= c.a;
    }

    vec4 result;

    result.r = (m[0] * c.r);
        result.r += (m[1] * c.g);
        result.r += (m[2] * c.b);
        result.r += (m[3] * c.a);
        result.r += m[4];

    result.g = (m[5] * c.r);
        result.g += (m[6] * c.g);
        result.g += (m[7] * c.b);
        result.g += (m[8] * c.a);
        result.g += m[9];

    result.b = (m[10] * c.r);
       result.b += (m[11] * c.g);
       result.b += (m[12] * c.b);
       result.b += (m[13] * c.a);
       result.b += m[14];

    result.a = (m[15] * c.r);
       result.a += (m[16] * c.g);
       result.a += (m[17] * c.b);
       result.a += (m[18] * c.a);
       result.a += m[19];

    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    gl_FragColor = vec4(rgb, result.a);
}
`;
class eb extends fr {
  constructor() {
    const e = {
      m: new Float32Array([
        1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0,
      ]),
      uAlpha: 1,
    };
    (super(WP, zfe, e), (this.alpha = 1));
  }
  _loadMatrix(e, t = !1) {
    let i = e;
    (t && (this._multiply(i, this.uniforms.m, e), (i = this._colorMatrix(i))),
      (this.uniforms.m = i));
  }
  _multiply(e, t, i) {
    return (
      (e[0] = t[0] * i[0] + t[1] * i[5] + t[2] * i[10] + t[3] * i[15]),
      (e[1] = t[0] * i[1] + t[1] * i[6] + t[2] * i[11] + t[3] * i[16]),
      (e[2] = t[0] * i[2] + t[1] * i[7] + t[2] * i[12] + t[3] * i[17]),
      (e[3] = t[0] * i[3] + t[1] * i[8] + t[2] * i[13] + t[3] * i[18]),
      (e[4] = t[0] * i[4] + t[1] * i[9] + t[2] * i[14] + t[3] * i[19] + t[4]),
      (e[5] = t[5] * i[0] + t[6] * i[5] + t[7] * i[10] + t[8] * i[15]),
      (e[6] = t[5] * i[1] + t[6] * i[6] + t[7] * i[11] + t[8] * i[16]),
      (e[7] = t[5] * i[2] + t[6] * i[7] + t[7] * i[12] + t[8] * i[17]),
      (e[8] = t[5] * i[3] + t[6] * i[8] + t[7] * i[13] + t[8] * i[18]),
      (e[9] = t[5] * i[4] + t[6] * i[9] + t[7] * i[14] + t[8] * i[19] + t[9]),
      (e[10] = t[10] * i[0] + t[11] * i[5] + t[12] * i[10] + t[13] * i[15]),
      (e[11] = t[10] * i[1] + t[11] * i[6] + t[12] * i[11] + t[13] * i[16]),
      (e[12] = t[10] * i[2] + t[11] * i[7] + t[12] * i[12] + t[13] * i[17]),
      (e[13] = t[10] * i[3] + t[11] * i[8] + t[12] * i[13] + t[13] * i[18]),
      (e[14] =
        t[10] * i[4] + t[11] * i[9] + t[12] * i[14] + t[13] * i[19] + t[14]),
      (e[15] = t[15] * i[0] + t[16] * i[5] + t[17] * i[10] + t[18] * i[15]),
      (e[16] = t[15] * i[1] + t[16] * i[6] + t[17] * i[11] + t[18] * i[16]),
      (e[17] = t[15] * i[2] + t[16] * i[7] + t[17] * i[12] + t[18] * i[17]),
      (e[18] = t[15] * i[3] + t[16] * i[8] + t[17] * i[13] + t[18] * i[18]),
      (e[19] =
        t[15] * i[4] + t[16] * i[9] + t[17] * i[14] + t[18] * i[19] + t[19]),
      e
    );
  }
  _colorMatrix(e) {
    const t = new Float32Array(e);
    return ((t[4] /= 255), (t[9] /= 255), (t[14] /= 255), (t[19] /= 255), t);
  }
  brightness(e, t) {
    const i = [e, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 1, 0];
    this._loadMatrix(i, t);
  }
  tint(e, t) {
    const [i, r, s] = Ln.shared.setValue(e).toArray(),
      o = [i, 0, 0, 0, 0, 0, r, 0, 0, 0, 0, 0, s, 0, 0, 0, 0, 0, 1, 0];
    this._loadMatrix(o, t);
  }
  greyscale(e, t) {
    const i = [e, e, e, 0, 0, e, e, e, 0, 0, e, e, e, 0, 0, 0, 0, 0, 1, 0];
    this._loadMatrix(i, t);
  }
  blackAndWhite(e) {
    const t = [
      0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0, 0, 0, 1,
      0,
    ];
    this._loadMatrix(t, e);
  }
  hue(e, t) {
    e = ((e || 0) / 180) * Math.PI;
    const i = Math.cos(e),
      r = Math.sin(e),
      s = Math.sqrt,
      o = 1 / 3,
      a = s(o),
      l = i + (1 - i) * o,
      c = o * (1 - i) - a * r,
      u = o * (1 - i) + a * r,
      h = o * (1 - i) + a * r,
      d = i + o * (1 - i),
      f = o * (1 - i) - a * r,
      g = o * (1 - i) - a * r,
      p = o * (1 - i) + a * r,
      m = i + o * (1 - i),
      C = [l, c, u, 0, 0, h, d, f, 0, 0, g, p, m, 0, 0, 0, 0, 0, 1, 0];
    this._loadMatrix(C, t);
  }
  contrast(e, t) {
    const i = (e || 0) + 1,
      r = -0.5 * (i - 1),
      s = [i, 0, 0, 0, r, 0, i, 0, 0, r, 0, 0, i, 0, r, 0, 0, 0, 1, 0];
    this._loadMatrix(s, t);
  }
  saturate(e = 0, t) {
    const i = (e * 2) / 3 + 1,
      r = (i - 1) * -0.5,
      s = [i, r, r, 0, 0, r, i, r, 0, 0, r, r, i, 0, 0, 0, 0, 0, 1, 0];
    this._loadMatrix(s, t);
  }
  desaturate() {
    this.saturate(-1);
  }
  negative(e) {
    const t = [-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0];
    this._loadMatrix(t, e);
  }
  sepia(e) {
    const t = [
      0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999, 0.16799999, 0, 0,
      0.272, 0.5339999, 0.13099999, 0, 0, 0, 0, 0, 1, 0,
    ];
    this._loadMatrix(t, e);
  }
  technicolor(e) {
    const t = [
      1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0,
      11.793603434377337, -0.3087833385928097, 1.7658908555458428,
      -0.10601743074722245, 0, -70.35205161461398, -0.231103377548616,
      -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1,
      0,
    ];
    this._loadMatrix(t, e);
  }
  polaroid(e) {
    const t = [
      1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016,
      1.483, 0, 0, 0, 0, 0, 1, 0,
    ];
    this._loadMatrix(t, e);
  }
  toBGR(e) {
    const t = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0];
    this._loadMatrix(t, e);
  }
  kodachrome(e) {
    const t = [
      1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0,
      63.72958762196502, -0.16404339962244616, 1.0835251566291304,
      -0.05498805115633132, 0, 24.732407896706203, -0.16786010706155763,
      -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1,
      0,
    ];
    this._loadMatrix(t, e);
  }
  browni(e) {
    const t = [
      0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0,
      47.43192855600873, -0.037703249837783157, 0.8609577587992641,
      0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335,
      -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283, 0, 0, 0,
      1, 0,
    ];
    this._loadMatrix(t, e);
  }
  vintage(e) {
    const t = [
      0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0,
      9.651285835294123, 0.02578397704808868, 0.6441188644374771,
      0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719,
      -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1,
      0,
    ];
    this._loadMatrix(t, e);
  }
  colorTone(e, t, i, r, s) {
    ((e = e || 0.2), (t = t || 0.15), (i = i || 16770432), (r = r || 3375104));
    const o = Ln.shared,
      [a, l, c] = o.setValue(i).toArray(),
      [u, h, d] = o.setValue(r).toArray(),
      f = [
        0.3,
        0.59,
        0.11,
        0,
        0,
        a,
        l,
        c,
        e,
        0,
        u,
        h,
        d,
        t,
        0,
        a - u,
        l - h,
        c - d,
        0,
        0,
      ];
    this._loadMatrix(f, s);
  }
  night(e, t) {
    e = e || 0.1;
    const i = [
      e * -2,
      -e,
      0,
      0,
      0,
      -e,
      0,
      e,
      0,
      0,
      0,
      e,
      e * 2,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
    ];
    this._loadMatrix(i, t);
  }
  predator(e, t) {
    const i = [
      11.224130630493164 * e,
      -4.794486999511719 * e,
      -2.8746118545532227 * e,
      0 * e,
      0.40342438220977783 * e,
      -3.6330697536468506 * e,
      9.193157196044922 * e,
      -2.951810836791992 * e,
      0 * e,
      -1.316135048866272 * e,
      -3.2184197902679443 * e,
      -4.2375030517578125 * e,
      7.476448059082031 * e,
      0 * e,
      0.8044459223747253 * e,
      0,
      0,
      0,
      1,
      0,
    ];
    this._loadMatrix(i, t);
  }
  lsd(e) {
    const t = [
      2, -0.4, 0.5, 0, 0, -0.5, 2, -0.4, 0, 0, -0.4, -0.5, 3, 0, 0, 0, 0, 0, 1,
      0,
    ];
    this._loadMatrix(t, e);
  }
  reset() {
    const e = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];
    this._loadMatrix(e, !1);
  }
  get matrix() {
    return this.uniforms.m;
  }
  set matrix(e) {
    this.uniforms.m = e;
  }
  get alpha() {
    return this.uniforms.uAlpha;
  }
  set alpha(e) {
    this.uniforms.uAlpha = e;
  }
}
eb.prototype.grayscale = eb.prototype.greyscale;
var Yfe = `varying vec2 vFilterCoord;
varying vec2 vTextureCoord;

uniform vec2 scale;
uniform mat2 rotation;
uniform sampler2D uSampler;
uniform sampler2D mapSampler;

uniform highp vec4 inputSize;
uniform vec4 inputClamp;

void main(void)
{
  vec4 map =  texture2D(mapSampler, vFilterCoord);

  map -= 0.5;
  map.xy = scale * inputSize.zw * (rotation * map.xy);

  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));
}
`,
  Xfe = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;
uniform mat3 filterMatrix;

varying vec2 vTextureCoord;
varying vec2 vFilterCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
	gl_Position = filterVertexPosition();
	vTextureCoord = filterTextureCoord();
	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;
}
`;
class Kfe extends fr {
  constructor(e, t) {
    const i = new Rn();
    ((e.renderable = !1),
      super(Xfe, Yfe, {
        mapSampler: e._texture,
        filterMatrix: i,
        scale: { x: 1, y: 1 },
        rotation: new Float32Array([1, 0, 0, 1]),
      }),
      (this.maskSprite = e),
      (this.maskMatrix = i),
      t == null && (t = 20),
      (this.scale = new Qt(t, t)));
  }
  apply(e, t, i, r) {
    ((this.uniforms.filterMatrix = e.calculateSpriteMatrix(
      this.maskMatrix,
      this.maskSprite,
    )),
      (this.uniforms.scale.x = this.scale.x),
      (this.uniforms.scale.y = this.scale.y));
    const s = this.maskSprite.worldTransform,
      o = Math.sqrt(s.a * s.a + s.b * s.b),
      a = Math.sqrt(s.c * s.c + s.d * s.d);
    (o !== 0 &&
      a !== 0 &&
      ((this.uniforms.rotation[0] = s.a / o),
      (this.uniforms.rotation[1] = s.b / o),
      (this.uniforms.rotation[2] = s.c / a),
      (this.uniforms.rotation[3] = s.d / a)),
      e.applyFilter(this, t, i, r));
  }
  get map() {
    return this.uniforms.mapSampler;
  }
  set map(e) {
    this.uniforms.mapSampler = e;
  }
}
var jfe = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`,
  $fe = `
attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

void texcoords(vec2 fragCoord, vec2 inverseVP,
               out vec2 v_rgbNW, out vec2 v_rgbNE,
               out vec2 v_rgbSW, out vec2 v_rgbSE,
               out vec2 v_rgbM) {
    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
    v_rgbM = vec2(fragCoord * inverseVP);
}

void main(void) {

   gl_Position = filterVertexPosition();

   vFragCoord = aVertexPosition * outputFrame.zw;

   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
}
`;
class Jfe extends fr {
  constructor() {
    super($fe, jfe);
  }
}
var Qfe = `precision highp float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture2D(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) * uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    gl_FragColor = color;
}
`;
class qfe extends fr {
  constructor(e = 0.5, t = Math.random()) {
    (super(WP, Qfe, { uNoise: 0, uSeed: 0 }),
      (this.noise = e),
      (this.seed = t));
  }
  get noise() {
    return this.uniforms.uNoise;
  }
  set noise(e) {
    this.uniforms.uNoise = e;
  }
  get seed() {
    return this.uniforms.uSeed;
  }
  set seed(e) {
    this.uniforms.uSeed = e;
  }
}
const B6 = {
  AlphaFilter: kfe,
  BlurFilter: Zfe,
  BlurFilterPass: q3,
  ColorMatrixFilter: eb,
  DisplacementFilter: Kfe,
  FXAAFilter: Jfe,
  NoiseFilter: qfe,
};
Object.entries(B6).forEach(([n, e]) => {
  Object.defineProperty(B6, n, {
    get() {
      return (Ht("7.1.0", `filters.${n} has moved to ${n}`), e);
    },
  });
});
class ege {
  constructor() {
    ((this.interactionFrequency = 10),
      (this._deltaTime = 0),
      (this._didMove = !1),
      (this.tickerAdded = !1),
      (this._pauseUpdate = !0));
  }
  init(e) {
    (this.removeTickerListener(),
      (this.events = e),
      (this.interactionFrequency = 10),
      (this._deltaTime = 0),
      (this._didMove = !1),
      (this.tickerAdded = !1),
      (this._pauseUpdate = !0));
  }
  get pauseUpdate() {
    return this._pauseUpdate;
  }
  set pauseUpdate(e) {
    this._pauseUpdate = e;
  }
  addTickerListener() {
    this.tickerAdded ||
      !this.domElement ||
      (Er.system.add(this.tickerUpdate, this, Iu.INTERACTION),
      (this.tickerAdded = !0));
  }
  removeTickerListener() {
    this.tickerAdded &&
      (Er.system.remove(this.tickerUpdate, this), (this.tickerAdded = !1));
  }
  pointerMoved() {
    this._didMove = !0;
  }
  update() {
    if (!this.domElement || this._pauseUpdate) return;
    if (this._didMove) {
      this._didMove = !1;
      return;
    }
    const e = this.events.rootPointerEvent;
    (this.events.supportsTouchEvents && e.pointerType === "touch") ||
      globalThis.document.dispatchEvent(
        new PointerEvent("pointermove", {
          clientX: e.clientX,
          clientY: e.clientY,
        }),
      );
  }
  tickerUpdate(e) {
    ((this._deltaTime += e),
      !(this._deltaTime < this.interactionFrequency) &&
        ((this._deltaTime = 0), this.update()));
  }
}
const fl = new ege();
class Bp {
  constructor(e) {
    ((this.bubbles = !0),
      (this.cancelBubble = !0),
      (this.cancelable = !1),
      (this.composed = !1),
      (this.defaultPrevented = !1),
      (this.eventPhase = Bp.prototype.NONE),
      (this.propagationStopped = !1),
      (this.propagationImmediatelyStopped = !1),
      (this.layer = new Qt()),
      (this.page = new Qt()),
      (this.NONE = 0),
      (this.CAPTURING_PHASE = 1),
      (this.AT_TARGET = 2),
      (this.BUBBLING_PHASE = 3),
      (this.manager = e));
  }
  get layerX() {
    return this.layer.x;
  }
  get layerY() {
    return this.layer.y;
  }
  get pageX() {
    return this.page.x;
  }
  get pageY() {
    return this.page.y;
  }
  get data() {
    return this;
  }
  composedPath() {
    return (
      this.manager &&
        (!this.path || this.path[this.path.length - 1] !== this.target) &&
        (this.path = this.target
          ? this.manager.propagationPath(this.target)
          : []),
      this.path
    );
  }
  initEvent(e, t, i) {
    throw new Error(
      "initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.",
    );
  }
  initUIEvent(e, t, i, r, s) {
    throw new Error(
      "initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.",
    );
  }
  preventDefault() {
    (this.nativeEvent instanceof Event &&
      this.nativeEvent.cancelable &&
      this.nativeEvent.preventDefault(),
      (this.defaultPrevented = !0));
  }
  stopImmediatePropagation() {
    this.propagationImmediatelyStopped = !0;
  }
  stopPropagation() {
    this.propagationStopped = !0;
  }
}
class CC extends Bp {
  constructor() {
    (super(...arguments),
      (this.client = new Qt()),
      (this.movement = new Qt()),
      (this.offset = new Qt()),
      (this.global = new Qt()),
      (this.screen = new Qt()));
  }
  get clientX() {
    return this.client.x;
  }
  get clientY() {
    return this.client.y;
  }
  get x() {
    return this.clientX;
  }
  get y() {
    return this.clientY;
  }
  get movementX() {
    return this.movement.x;
  }
  get movementY() {
    return this.movement.y;
  }
  get offsetX() {
    return this.offset.x;
  }
  get offsetY() {
    return this.offset.y;
  }
  get globalX() {
    return this.global.x;
  }
  get globalY() {
    return this.global.y;
  }
  get screenX() {
    return this.screen.x;
  }
  get screenY() {
    return this.screen.y;
  }
  getLocalPosition(e, t, i) {
    return e.worldTransform.applyInverse(i || this.global, t);
  }
  getModifierState(e) {
    return (
      "getModifierState" in this.nativeEvent &&
      this.nativeEvent.getModifierState(e)
    );
  }
  initMouseEvent(e, t, i, r, s, o, a, l, c, u, h, d, f, g, p) {
    throw new Error("Method not implemented.");
  }
}
class Vs extends CC {
  constructor() {
    (super(...arguments),
      (this.width = 0),
      (this.height = 0),
      (this.isPrimary = !1));
  }
  getCoalescedEvents() {
    return this.type === "pointermove" ||
      this.type === "mousemove" ||
      this.type === "touchmove"
      ? [this]
      : [];
  }
  getPredictedEvents() {
    throw new Error("getPredictedEvents is not supported!");
  }
}
class zh extends CC {
  constructor() {
    (super(...arguments),
      (this.DOM_DELTA_PIXEL = 0),
      (this.DOM_DELTA_LINE = 1),
      (this.DOM_DELTA_PAGE = 2));
  }
}
((zh.DOM_DELTA_PIXEL = 0), (zh.DOM_DELTA_LINE = 1), (zh.DOM_DELTA_PAGE = 2));
const tge = 2048,
  nge = new Qt(),
  UA = new Qt();
class ige {
  constructor(e) {
    ((this.dispatch = new Lp()),
      (this.moveOnAll = !1),
      (this.enableGlobalMoveEvents = !0),
      (this.mappingState = { trackingData: {} }),
      (this.eventPool = new Map()),
      (this._allInteractiveElements = []),
      (this._hitElements = []),
      (this._isPointerMoveEvent = !1),
      (this.rootTarget = e),
      (this.hitPruneFn = this.hitPruneFn.bind(this)),
      (this.hitTestFn = this.hitTestFn.bind(this)),
      (this.mapPointerDown = this.mapPointerDown.bind(this)),
      (this.mapPointerMove = this.mapPointerMove.bind(this)),
      (this.mapPointerOut = this.mapPointerOut.bind(this)),
      (this.mapPointerOver = this.mapPointerOver.bind(this)),
      (this.mapPointerUp = this.mapPointerUp.bind(this)),
      (this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this)),
      (this.mapWheel = this.mapWheel.bind(this)),
      (this.mappingTable = {}),
      this.addEventMapping("pointerdown", this.mapPointerDown),
      this.addEventMapping("pointermove", this.mapPointerMove),
      this.addEventMapping("pointerout", this.mapPointerOut),
      this.addEventMapping("pointerleave", this.mapPointerOut),
      this.addEventMapping("pointerover", this.mapPointerOver),
      this.addEventMapping("pointerup", this.mapPointerUp),
      this.addEventMapping("pointerupoutside", this.mapPointerUpOutside),
      this.addEventMapping("wheel", this.mapWheel));
  }
  addEventMapping(e, t) {
    (this.mappingTable[e] || (this.mappingTable[e] = []),
      this.mappingTable[e].push({ fn: t, priority: 0 }),
      this.mappingTable[e].sort((i, r) => i.priority - r.priority));
  }
  dispatchEvent(e, t) {
    ((e.propagationStopped = !1),
      (e.propagationImmediatelyStopped = !1),
      this.propagate(e, t),
      this.dispatch.emit(t || e.type, e));
  }
  mapEvent(e) {
    if (!this.rootTarget) return;
    const t = this.mappingTable[e.type];
    if (t) for (let i = 0, r = t.length; i < r; i++) t[i].fn(e);
    else
      console.warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);
  }
  hitTest(e, t) {
    fl.pauseUpdate = !0;
    const i =
        this._isPointerMoveEvent && this.enableGlobalMoveEvents
          ? "hitTestMoveRecursive"
          : "hitTestRecursive",
      r = this[i](
        this.rootTarget,
        this.rootTarget.eventMode,
        nge.set(e, t),
        this.hitTestFn,
        this.hitPruneFn,
      );
    return r && r[0];
  }
  propagate(e, t) {
    if (!e.target) return;
    const i = e.composedPath();
    e.eventPhase = e.CAPTURING_PHASE;
    for (let r = 0, s = i.length - 1; r < s; r++)
      if (
        ((e.currentTarget = i[r]),
        this.notifyTarget(e, t),
        e.propagationStopped || e.propagationImmediatelyStopped)
      )
        return;
    if (
      ((e.eventPhase = e.AT_TARGET),
      (e.currentTarget = e.target),
      this.notifyTarget(e, t),
      !(e.propagationStopped || e.propagationImmediatelyStopped))
    ) {
      e.eventPhase = e.BUBBLING_PHASE;
      for (let r = i.length - 2; r >= 0; r--)
        if (
          ((e.currentTarget = i[r]),
          this.notifyTarget(e, t),
          e.propagationStopped || e.propagationImmediatelyStopped)
        )
          return;
    }
  }
  all(e, t, i = this._allInteractiveElements) {
    if (i.length === 0) return;
    e.eventPhase = e.BUBBLING_PHASE;
    const r = Array.isArray(t) ? t : [t];
    for (let s = i.length - 1; s >= 0; s--)
      r.forEach((o) => {
        ((e.currentTarget = i[s]), this.notifyTarget(e, o));
      });
  }
  propagationPath(e) {
    const t = [e];
    for (let i = 0; i < tge && e !== this.rootTarget; i++) {
      if (!e.parent)
        throw new Error("Cannot find propagation path to disconnected target");
      (t.push(e.parent), (e = e.parent));
    }
    return (t.reverse(), t);
  }
  hitTestMoveRecursive(e, t, i, r, s, o = !1) {
    let a = !1;
    if (this._interactivePrune(e)) return null;
    if (
      ((e.eventMode === "dynamic" || t === "dynamic") && (fl.pauseUpdate = !1),
      e.interactiveChildren && e.children)
    ) {
      const u = e.children;
      for (let h = u.length - 1; h >= 0; h--) {
        const d = u[h],
          f = this.hitTestMoveRecursive(
            d,
            this._isInteractive(t) ? t : d.eventMode,
            i,
            r,
            s,
            o || s(e, i),
          );
        if (f) {
          if (f.length > 0 && !f[f.length - 1].parent) continue;
          const g = e.isInteractive();
          ((f.length > 0 || g) &&
            (g && this._allInteractiveElements.push(e), f.push(e)),
            this._hitElements.length === 0 && (this._hitElements = f),
            (a = !0));
        }
      }
    }
    const l = this._isInteractive(t),
      c = e.isInteractive();
    return (
      c && c && this._allInteractiveElements.push(e),
      o || this._hitElements.length > 0
        ? null
        : a
          ? this._hitElements
          : l && !s(e, i) && r(e, i)
            ? c
              ? [e]
              : []
            : null
    );
  }
  hitTestRecursive(e, t, i, r, s) {
    if (this._interactivePrune(e) || s(e, i)) return null;
    if (
      ((e.eventMode === "dynamic" || t === "dynamic") && (fl.pauseUpdate = !1),
      e.interactiveChildren && e.children)
    ) {
      const l = e.children;
      for (let c = l.length - 1; c >= 0; c--) {
        const u = l[c],
          h = this.hitTestRecursive(
            u,
            this._isInteractive(t) ? t : u.eventMode,
            i,
            r,
            s,
          );
        if (h) {
          if (h.length > 0 && !h[h.length - 1].parent) continue;
          const d = e.isInteractive();
          return ((h.length > 0 || d) && h.push(e), h);
        }
      }
    }
    const o = this._isInteractive(t),
      a = e.isInteractive();
    return o && r(e, i) ? (a ? [e] : []) : null;
  }
  _isInteractive(e) {
    return e === "static" || e === "dynamic";
  }
  _interactivePrune(e) {
    return !!(
      !e ||
      e.isMask ||
      !e.visible ||
      !e.renderable ||
      e.eventMode === "none" ||
      (e.eventMode === "passive" && !e.interactiveChildren) ||
      e.isMask
    );
  }
  hitPruneFn(e, t) {
    if (
      e.hitArea &&
      (e.worldTransform.applyInverse(t, UA), !e.hitArea.contains(UA.x, UA.y))
    )
      return !0;
    if (e._mask) {
      const i = e._mask.isMaskData ? e._mask.maskObject : e._mask;
      if (i && !i.containsPoint?.(t)) return !0;
    }
    return !1;
  }
  hitTestFn(e, t) {
    return e.eventMode === "passive"
      ? !1
      : e.hitArea
        ? !0
        : e.containsPoint
          ? e.containsPoint(t)
          : !1;
  }
  notifyTarget(e, t) {
    t = t ?? e.type;
    const i = `on${t}`;
    e.currentTarget[i]?.(e);
    const r =
      e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET
        ? `${t}capture`
        : t;
    (this.notifyListeners(e, r),
      e.eventPhase === e.AT_TARGET && this.notifyListeners(e, t));
  }
  mapPointerDown(e) {
    if (!(e instanceof Vs)) {
      console.warn(
        "EventBoundary cannot map a non-pointer event as a pointer event",
      );
      return;
    }
    const t = this.createPointerEvent(e);
    if ((this.dispatchEvent(t, "pointerdown"), t.pointerType === "touch"))
      this.dispatchEvent(t, "touchstart");
    else if (t.pointerType === "mouse" || t.pointerType === "pen") {
      const r = t.button === 2;
      this.dispatchEvent(t, r ? "rightdown" : "mousedown");
    }
    const i = this.trackingData(e.pointerId);
    ((i.pressTargetsByButton[e.button] = t.composedPath()), this.freeEvent(t));
  }
  mapPointerMove(e) {
    if (!(e instanceof Vs)) {
      console.warn(
        "EventBoundary cannot map a non-pointer event as a pointer event",
      );
      return;
    }
    ((this._allInteractiveElements.length = 0),
      (this._hitElements.length = 0),
      (this._isPointerMoveEvent = !0));
    const t = this.createPointerEvent(e);
    this._isPointerMoveEvent = !1;
    const i = t.pointerType === "mouse" || t.pointerType === "pen",
      r = this.trackingData(e.pointerId),
      s = this.findMountedTarget(r.overTargets);
    if (r.overTargets?.length > 0 && s !== t.target) {
      const l = e.type === "mousemove" ? "mouseout" : "pointerout",
        c = this.createPointerEvent(e, l, s);
      if (
        (this.dispatchEvent(c, "pointerout"),
        i && this.dispatchEvent(c, "mouseout"),
        !t.composedPath().includes(s))
      ) {
        const u = this.createPointerEvent(e, "pointerleave", s);
        for (
          u.eventPhase = u.AT_TARGET;
          u.target && !t.composedPath().includes(u.target);
        )
          ((u.currentTarget = u.target),
            this.notifyTarget(u),
            i && this.notifyTarget(u, "mouseleave"),
            (u.target = u.target.parent));
        this.freeEvent(u);
      }
      this.freeEvent(c);
    }
    if (s !== t.target) {
      const l = e.type === "mousemove" ? "mouseover" : "pointerover",
        c = this.clonePointerEvent(t, l);
      (this.dispatchEvent(c, "pointerover"),
        i && this.dispatchEvent(c, "mouseover"));
      let u = s?.parent;
      for (; u && u !== this.rootTarget.parent && u !== t.target; )
        u = u.parent;
      if (!u || u === this.rootTarget.parent) {
        const h = this.clonePointerEvent(t, "pointerenter");
        for (
          h.eventPhase = h.AT_TARGET;
          h.target && h.target !== s && h.target !== this.rootTarget.parent;
        )
          ((h.currentTarget = h.target),
            this.notifyTarget(h),
            i && this.notifyTarget(h, "mouseenter"),
            (h.target = h.target.parent));
        this.freeEvent(h);
      }
      this.freeEvent(c);
    }
    const o = [],
      a = this.enableGlobalMoveEvents ?? !0;
    (this.moveOnAll
      ? o.push("pointermove")
      : this.dispatchEvent(t, "pointermove"),
      a && o.push("globalpointermove"),
      t.pointerType === "touch" &&
        (this.moveOnAll
          ? o.splice(1, 0, "touchmove")
          : this.dispatchEvent(t, "touchmove"),
        a && o.push("globaltouchmove")),
      i &&
        (this.moveOnAll
          ? o.splice(1, 0, "mousemove")
          : this.dispatchEvent(t, "mousemove"),
        a && o.push("globalmousemove"),
        (this.cursor = t.target?.cursor)),
      o.length > 0 && this.all(t, o),
      (this._allInteractiveElements.length = 0),
      (this._hitElements.length = 0),
      (r.overTargets = t.composedPath()),
      this.freeEvent(t));
  }
  mapPointerOver(e) {
    if (!(e instanceof Vs)) {
      console.warn(
        "EventBoundary cannot map a non-pointer event as a pointer event",
      );
      return;
    }
    const t = this.trackingData(e.pointerId),
      i = this.createPointerEvent(e),
      r = i.pointerType === "mouse" || i.pointerType === "pen";
    (this.dispatchEvent(i, "pointerover"),
      r && this.dispatchEvent(i, "mouseover"),
      i.pointerType === "mouse" && (this.cursor = i.target?.cursor));
    const s = this.clonePointerEvent(i, "pointerenter");
    for (
      s.eventPhase = s.AT_TARGET;
      s.target && s.target !== this.rootTarget.parent;
    )
      ((s.currentTarget = s.target),
        this.notifyTarget(s),
        r && this.notifyTarget(s, "mouseenter"),
        (s.target = s.target.parent));
    ((t.overTargets = i.composedPath()), this.freeEvent(i), this.freeEvent(s));
  }
  mapPointerOut(e) {
    if (!(e instanceof Vs)) {
      console.warn(
        "EventBoundary cannot map a non-pointer event as a pointer event",
      );
      return;
    }
    const t = this.trackingData(e.pointerId);
    if (t.overTargets) {
      const i = e.pointerType === "mouse" || e.pointerType === "pen",
        r = this.findMountedTarget(t.overTargets),
        s = this.createPointerEvent(e, "pointerout", r);
      (this.dispatchEvent(s), i && this.dispatchEvent(s, "mouseout"));
      const o = this.createPointerEvent(e, "pointerleave", r);
      for (
        o.eventPhase = o.AT_TARGET;
        o.target && o.target !== this.rootTarget.parent;
      )
        ((o.currentTarget = o.target),
          this.notifyTarget(o),
          i && this.notifyTarget(o, "mouseleave"),
          (o.target = o.target.parent));
      ((t.overTargets = null), this.freeEvent(s), this.freeEvent(o));
    }
    this.cursor = null;
  }
  mapPointerUp(e) {
    if (!(e instanceof Vs)) {
      console.warn(
        "EventBoundary cannot map a non-pointer event as a pointer event",
      );
      return;
    }
    const t = performance.now(),
      i = this.createPointerEvent(e);
    if ((this.dispatchEvent(i, "pointerup"), i.pointerType === "touch"))
      this.dispatchEvent(i, "touchend");
    else if (i.pointerType === "mouse" || i.pointerType === "pen") {
      const a = i.button === 2;
      this.dispatchEvent(i, a ? "rightup" : "mouseup");
    }
    const r = this.trackingData(e.pointerId),
      s = this.findMountedTarget(r.pressTargetsByButton[e.button]);
    let o = s;
    if (s && !i.composedPath().includes(s)) {
      let a = s;
      for (; a && !i.composedPath().includes(a); ) {
        if (
          ((i.currentTarget = a),
          this.notifyTarget(i, "pointerupoutside"),
          i.pointerType === "touch")
        )
          this.notifyTarget(i, "touchendoutside");
        else if (i.pointerType === "mouse" || i.pointerType === "pen") {
          const l = i.button === 2;
          this.notifyTarget(i, l ? "rightupoutside" : "mouseupoutside");
        }
        a = a.parent;
      }
      (delete r.pressTargetsByButton[e.button], (o = a));
    }
    if (o) {
      const a = this.clonePointerEvent(i, "click");
      ((a.target = o),
        (a.path = null),
        r.clicksByButton[e.button] ||
          (r.clicksByButton[e.button] = {
            clickCount: 0,
            target: a.target,
            timeStamp: t,
          }));
      const l = r.clicksByButton[e.button];
      if (
        (l.target === a.target && t - l.timeStamp < 200
          ? ++l.clickCount
          : (l.clickCount = 1),
        (l.target = a.target),
        (l.timeStamp = t),
        (a.detail = l.clickCount),
        a.pointerType === "mouse")
      ) {
        const c = a.button === 2;
        this.dispatchEvent(a, c ? "rightclick" : "click");
      } else a.pointerType === "touch" && this.dispatchEvent(a, "tap");
      (this.dispatchEvent(a, "pointertap"), this.freeEvent(a));
    }
    this.freeEvent(i);
  }
  mapPointerUpOutside(e) {
    if (!(e instanceof Vs)) {
      console.warn(
        "EventBoundary cannot map a non-pointer event as a pointer event",
      );
      return;
    }
    const t = this.trackingData(e.pointerId),
      i = this.findMountedTarget(t.pressTargetsByButton[e.button]),
      r = this.createPointerEvent(e);
    if (i) {
      let s = i;
      for (; s; )
        ((r.currentTarget = s),
          this.notifyTarget(r, "pointerupoutside"),
          r.pointerType === "touch"
            ? this.notifyTarget(r, "touchendoutside")
            : (r.pointerType === "mouse" || r.pointerType === "pen") &&
              this.notifyTarget(
                r,
                r.button === 2 ? "rightupoutside" : "mouseupoutside",
              ),
          (s = s.parent));
      delete t.pressTargetsByButton[e.button];
    }
    this.freeEvent(r);
  }
  mapWheel(e) {
    if (!(e instanceof zh)) {
      console.warn(
        "EventBoundary cannot map a non-wheel event as a wheel event",
      );
      return;
    }
    const t = this.createWheelEvent(e);
    (this.dispatchEvent(t), this.freeEvent(t));
  }
  findMountedTarget(e) {
    if (!e) return null;
    let t = e[0];
    for (let i = 1; i < e.length && e[i].parent === t; i++) t = e[i];
    return t;
  }
  createPointerEvent(e, t, i) {
    const r = this.allocateEvent(Vs);
    return (
      this.copyPointerData(e, r),
      this.copyMouseData(e, r),
      this.copyData(e, r),
      (r.nativeEvent = e.nativeEvent),
      (r.originalEvent = e),
      (r.target =
        i ?? this.hitTest(r.global.x, r.global.y) ?? this._hitElements[0]),
      typeof t == "string" && (r.type = t),
      r
    );
  }
  createWheelEvent(e) {
    const t = this.allocateEvent(zh);
    return (
      this.copyWheelData(e, t),
      this.copyMouseData(e, t),
      this.copyData(e, t),
      (t.nativeEvent = e.nativeEvent),
      (t.originalEvent = e),
      (t.target = this.hitTest(t.global.x, t.global.y)),
      t
    );
  }
  clonePointerEvent(e, t) {
    const i = this.allocateEvent(Vs);
    return (
      (i.nativeEvent = e.nativeEvent),
      (i.originalEvent = e.originalEvent),
      this.copyPointerData(e, i),
      this.copyMouseData(e, i),
      this.copyData(e, i),
      (i.target = e.target),
      (i.path = e.composedPath().slice()),
      (i.type = t ?? i.type),
      i
    );
  }
  copyWheelData(e, t) {
    ((t.deltaMode = e.deltaMode),
      (t.deltaX = e.deltaX),
      (t.deltaY = e.deltaY),
      (t.deltaZ = e.deltaZ));
  }
  copyPointerData(e, t) {
    e instanceof Vs &&
      t instanceof Vs &&
      ((t.pointerId = e.pointerId),
      (t.width = e.width),
      (t.height = e.height),
      (t.isPrimary = e.isPrimary),
      (t.pointerType = e.pointerType),
      (t.pressure = e.pressure),
      (t.tangentialPressure = e.tangentialPressure),
      (t.tiltX = e.tiltX),
      (t.tiltY = e.tiltY),
      (t.twist = e.twist));
  }
  copyMouseData(e, t) {
    e instanceof CC &&
      t instanceof CC &&
      ((t.altKey = e.altKey),
      (t.button = e.button),
      (t.buttons = e.buttons),
      t.client.copyFrom(e.client),
      (t.ctrlKey = e.ctrlKey),
      (t.metaKey = e.metaKey),
      t.movement.copyFrom(e.movement),
      t.screen.copyFrom(e.screen),
      (t.shiftKey = e.shiftKey),
      t.global.copyFrom(e.global));
  }
  copyData(e, t) {
    ((t.isTrusted = e.isTrusted),
      (t.srcElement = e.srcElement),
      (t.timeStamp = performance.now()),
      (t.type = e.type),
      (t.detail = e.detail),
      (t.view = e.view),
      (t.which = e.which),
      t.layer.copyFrom(e.layer),
      t.page.copyFrom(e.page));
  }
  trackingData(e) {
    return (
      this.mappingState.trackingData[e] ||
        (this.mappingState.trackingData[e] = {
          pressTargetsByButton: {},
          clicksByButton: {},
          overTarget: null,
        }),
      this.mappingState.trackingData[e]
    );
  }
  allocateEvent(e) {
    this.eventPool.has(e) || this.eventPool.set(e, []);
    const t = this.eventPool.get(e).pop() || new e(this);
    return (
      (t.eventPhase = t.NONE),
      (t.currentTarget = null),
      (t.path = null),
      (t.target = null),
      t
    );
  }
  freeEvent(e) {
    if (e.manager !== this)
      throw new Error(
        "It is illegal to free an event not managed by this EventBoundary!",
      );
    const t = e.constructor;
    (this.eventPool.has(t) || this.eventPool.set(t, []),
      this.eventPool.get(t).push(e));
  }
  notifyListeners(e, t) {
    const i = e.currentTarget._events[t];
    if (i && e.currentTarget.isInteractive())
      if ("fn" in i)
        (i.once && e.currentTarget.removeListener(t, i.fn, void 0, !0),
          i.fn.call(i.context, e));
      else
        for (
          let r = 0, s = i.length;
          r < s && !e.propagationImmediatelyStopped;
          r++
        )
          (i[r].once && e.currentTarget.removeListener(t, i[r].fn, void 0, !0),
            i[r].fn.call(i[r].context, e));
  }
}
const rge = 1,
  sge = {
    touchstart: "pointerdown",
    touchend: "pointerup",
    touchendoutside: "pointerupoutside",
    touchmove: "pointermove",
    touchcancel: "pointercancel",
  },
  tb = class nb {
    constructor(e) {
      ((this.supportsTouchEvents = "ontouchstart" in globalThis),
        (this.supportsPointerEvents = !!globalThis.PointerEvent),
        (this.domElement = null),
        (this.resolution = 1),
        (this.renderer = e),
        (this.rootBoundary = new ige(null)),
        fl.init(this),
        (this.autoPreventDefault = !0),
        (this.eventsAdded = !1),
        (this.rootPointerEvent = new Vs(null)),
        (this.rootWheelEvent = new zh(null)),
        (this.cursorStyles = { default: "inherit", pointer: "pointer" }),
        (this.features = new Proxy(
          { ...nb.defaultEventFeatures },
          {
            set: (t, i, r) => (
              i === "globalMove" &&
                (this.rootBoundary.enableGlobalMoveEvents = r),
              (t[i] = r),
              !0
            ),
          },
        )),
        (this.onPointerDown = this.onPointerDown.bind(this)),
        (this.onPointerMove = this.onPointerMove.bind(this)),
        (this.onPointerUp = this.onPointerUp.bind(this)),
        (this.onPointerOverOut = this.onPointerOverOut.bind(this)),
        (this.onWheel = this.onWheel.bind(this)));
    }
    static get defaultEventMode() {
      return this._defaultEventMode;
    }
    init(e) {
      const { view: t, resolution: i } = this.renderer;
      (this.setTargetElement(t),
        (this.resolution = i),
        (nb._defaultEventMode = e.eventMode ?? "auto"),
        Object.assign(this.features, e.eventFeatures ?? {}),
        (this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove));
    }
    resolutionChange(e) {
      this.resolution = e;
    }
    destroy() {
      (this.setTargetElement(null), (this.renderer = null));
    }
    setCursor(e) {
      e = e || "default";
      let t = !0;
      if (
        (globalThis.OffscreenCanvas &&
          this.domElement instanceof OffscreenCanvas &&
          (t = !1),
        this.currentCursor === e)
      )
        return;
      this.currentCursor = e;
      const i = this.cursorStyles[e];
      if (i)
        switch (typeof i) {
          case "string":
            t && (this.domElement.style.cursor = i);
            break;
          case "function":
            i(e);
            break;
          case "object":
            t && Object.assign(this.domElement.style, i);
            break;
        }
      else
        t &&
          typeof e == "string" &&
          !Object.prototype.hasOwnProperty.call(this.cursorStyles, e) &&
          (this.domElement.style.cursor = e);
    }
    get pointer() {
      return this.rootPointerEvent;
    }
    onPointerDown(e) {
      if (!this.features.click) return;
      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
      const t = this.normalizeToPointerData(e);
      this.autoPreventDefault &&
        t[0].isNormalized &&
        (e.cancelable || !("cancelable" in e)) &&
        e.preventDefault();
      for (let i = 0, r = t.length; i < r; i++) {
        const s = t[i],
          o = this.bootstrapEvent(this.rootPointerEvent, s);
        this.rootBoundary.mapEvent(o);
      }
      this.setCursor(this.rootBoundary.cursor);
    }
    onPointerMove(e) {
      if (!this.features.move) return;
      ((this.rootBoundary.rootTarget = this.renderer.lastObjectRendered),
        fl.pointerMoved());
      const t = this.normalizeToPointerData(e);
      for (let i = 0, r = t.length; i < r; i++) {
        const s = this.bootstrapEvent(this.rootPointerEvent, t[i]);
        this.rootBoundary.mapEvent(s);
      }
      this.setCursor(this.rootBoundary.cursor);
    }
    onPointerUp(e) {
      if (!this.features.click) return;
      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
      let t = e.target;
      e.composedPath &&
        e.composedPath().length > 0 &&
        (t = e.composedPath()[0]);
      const i = t !== this.domElement ? "outside" : "",
        r = this.normalizeToPointerData(e);
      for (let s = 0, o = r.length; s < o; s++) {
        const a = this.bootstrapEvent(this.rootPointerEvent, r[s]);
        ((a.type += i), this.rootBoundary.mapEvent(a));
      }
      this.setCursor(this.rootBoundary.cursor);
    }
    onPointerOverOut(e) {
      if (!this.features.click) return;
      this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
      const t = this.normalizeToPointerData(e);
      for (let i = 0, r = t.length; i < r; i++) {
        const s = this.bootstrapEvent(this.rootPointerEvent, t[i]);
        this.rootBoundary.mapEvent(s);
      }
      this.setCursor(this.rootBoundary.cursor);
    }
    onWheel(e) {
      if (!this.features.wheel) return;
      const t = this.normalizeWheelEvent(e);
      ((this.rootBoundary.rootTarget = this.renderer.lastObjectRendered),
        this.rootBoundary.mapEvent(t));
    }
    setTargetElement(e) {
      (this.removeEvents(),
        (this.domElement = e),
        (fl.domElement = e),
        this.addEvents());
    }
    addEvents() {
      if (this.eventsAdded || !this.domElement) return;
      fl.addTickerListener();
      const e = this.domElement.style;
      (e &&
        (globalThis.navigator.msPointerEnabled
          ? ((e.msContentZooming = "none"), (e.msTouchAction = "none"))
          : this.supportsPointerEvents && (e.touchAction = "none")),
        this.supportsPointerEvents
          ? (globalThis.document.addEventListener(
              "pointermove",
              this.onPointerMove,
              !0,
            ),
            this.domElement.addEventListener(
              "pointerdown",
              this.onPointerDown,
              !0,
            ),
            this.domElement.addEventListener(
              "pointerleave",
              this.onPointerOverOut,
              !0,
            ),
            this.domElement.addEventListener(
              "pointerover",
              this.onPointerOverOut,
              !0,
            ),
            globalThis.addEventListener("pointerup", this.onPointerUp, !0))
          : (globalThis.document.addEventListener(
              "mousemove",
              this.onPointerMove,
              !0,
            ),
            this.domElement.addEventListener(
              "mousedown",
              this.onPointerDown,
              !0,
            ),
            this.domElement.addEventListener(
              "mouseout",
              this.onPointerOverOut,
              !0,
            ),
            this.domElement.addEventListener(
              "mouseover",
              this.onPointerOverOut,
              !0,
            ),
            globalThis.addEventListener("mouseup", this.onPointerUp, !0),
            this.supportsTouchEvents &&
              (this.domElement.addEventListener(
                "touchstart",
                this.onPointerDown,
                !0,
              ),
              this.domElement.addEventListener(
                "touchend",
                this.onPointerUp,
                !0,
              ),
              this.domElement.addEventListener(
                "touchmove",
                this.onPointerMove,
                !0,
              ))),
        this.domElement.addEventListener("wheel", this.onWheel, {
          passive: !0,
          capture: !0,
        }),
        (this.eventsAdded = !0));
    }
    removeEvents() {
      if (!this.eventsAdded || !this.domElement) return;
      fl.removeTickerListener();
      const e = this.domElement.style;
      (globalThis.navigator.msPointerEnabled
        ? ((e.msContentZooming = ""), (e.msTouchAction = ""))
        : this.supportsPointerEvents && (e.touchAction = ""),
        this.supportsPointerEvents
          ? (globalThis.document.removeEventListener(
              "pointermove",
              this.onPointerMove,
              !0,
            ),
            this.domElement.removeEventListener(
              "pointerdown",
              this.onPointerDown,
              !0,
            ),
            this.domElement.removeEventListener(
              "pointerleave",
              this.onPointerOverOut,
              !0,
            ),
            this.domElement.removeEventListener(
              "pointerover",
              this.onPointerOverOut,
              !0,
            ),
            globalThis.removeEventListener("pointerup", this.onPointerUp, !0))
          : (globalThis.document.removeEventListener(
              "mousemove",
              this.onPointerMove,
              !0,
            ),
            this.domElement.removeEventListener(
              "mousedown",
              this.onPointerDown,
              !0,
            ),
            this.domElement.removeEventListener(
              "mouseout",
              this.onPointerOverOut,
              !0,
            ),
            this.domElement.removeEventListener(
              "mouseover",
              this.onPointerOverOut,
              !0,
            ),
            globalThis.removeEventListener("mouseup", this.onPointerUp, !0),
            this.supportsTouchEvents &&
              (this.domElement.removeEventListener(
                "touchstart",
                this.onPointerDown,
                !0,
              ),
              this.domElement.removeEventListener(
                "touchend",
                this.onPointerUp,
                !0,
              ),
              this.domElement.removeEventListener(
                "touchmove",
                this.onPointerMove,
                !0,
              ))),
        this.domElement.removeEventListener("wheel", this.onWheel, !0),
        (this.domElement = null),
        (this.eventsAdded = !1));
    }
    mapPositionToPoint(e, t, i) {
      const r = this.domElement.isConnected
          ? this.domElement.getBoundingClientRect()
          : {
              x: 0,
              y: 0,
              width: this.domElement.width,
              height: this.domElement.height,
              left: 0,
              top: 0,
            },
        s = 1 / this.resolution;
      ((e.x = (t - r.left) * (this.domElement.width / r.width) * s),
        (e.y = (i - r.top) * (this.domElement.height / r.height) * s));
    }
    normalizeToPointerData(e) {
      const t = [];
      if (this.supportsTouchEvents && e instanceof TouchEvent)
        for (let i = 0, r = e.changedTouches.length; i < r; i++) {
          const s = e.changedTouches[i];
          (typeof s.button > "u" && (s.button = 0),
            typeof s.buttons > "u" && (s.buttons = 1),
            typeof s.isPrimary > "u" &&
              (s.isPrimary = e.touches.length === 1 && e.type === "touchstart"),
            typeof s.width > "u" && (s.width = s.radiusX || 1),
            typeof s.height > "u" && (s.height = s.radiusY || 1),
            typeof s.tiltX > "u" && (s.tiltX = 0),
            typeof s.tiltY > "u" && (s.tiltY = 0),
            typeof s.pointerType > "u" && (s.pointerType = "touch"),
            typeof s.pointerId > "u" && (s.pointerId = s.identifier || 0),
            typeof s.pressure > "u" && (s.pressure = s.force || 0.5),
            typeof s.twist > "u" && (s.twist = 0),
            typeof s.tangentialPressure > "u" && (s.tangentialPressure = 0),
            typeof s.layerX > "u" && (s.layerX = s.offsetX = s.clientX),
            typeof s.layerY > "u" && (s.layerY = s.offsetY = s.clientY),
            (s.isNormalized = !0),
            (s.type = e.type),
            t.push(s));
        }
      else if (
        !globalThis.MouseEvent ||
        (e instanceof MouseEvent &&
          (!this.supportsPointerEvents ||
            !(e instanceof globalThis.PointerEvent)))
      ) {
        const i = e;
        (typeof i.isPrimary > "u" && (i.isPrimary = !0),
          typeof i.width > "u" && (i.width = 1),
          typeof i.height > "u" && (i.height = 1),
          typeof i.tiltX > "u" && (i.tiltX = 0),
          typeof i.tiltY > "u" && (i.tiltY = 0),
          typeof i.pointerType > "u" && (i.pointerType = "mouse"),
          typeof i.pointerId > "u" && (i.pointerId = rge),
          typeof i.pressure > "u" && (i.pressure = 0.5),
          typeof i.twist > "u" && (i.twist = 0),
          typeof i.tangentialPressure > "u" && (i.tangentialPressure = 0),
          (i.isNormalized = !0),
          t.push(i));
      } else t.push(e);
      return t;
    }
    normalizeWheelEvent(e) {
      const t = this.rootWheelEvent;
      return (
        this.transferMouseData(t, e),
        (t.deltaX = e.deltaX),
        (t.deltaY = e.deltaY),
        (t.deltaZ = e.deltaZ),
        (t.deltaMode = e.deltaMode),
        this.mapPositionToPoint(t.screen, e.clientX, e.clientY),
        t.global.copyFrom(t.screen),
        t.offset.copyFrom(t.screen),
        (t.nativeEvent = e),
        (t.type = e.type),
        t
      );
    }
    bootstrapEvent(e, t) {
      return (
        (e.originalEvent = null),
        (e.nativeEvent = t),
        (e.pointerId = t.pointerId),
        (e.width = t.width),
        (e.height = t.height),
        (e.isPrimary = t.isPrimary),
        (e.pointerType = t.pointerType),
        (e.pressure = t.pressure),
        (e.tangentialPressure = t.tangentialPressure),
        (e.tiltX = t.tiltX),
        (e.tiltY = t.tiltY),
        (e.twist = t.twist),
        this.transferMouseData(e, t),
        this.mapPositionToPoint(e.screen, t.clientX, t.clientY),
        e.global.copyFrom(e.screen),
        e.offset.copyFrom(e.screen),
        (e.isTrusted = t.isTrusted),
        e.type === "pointerleave" && (e.type = "pointerout"),
        e.type.startsWith("mouse") &&
          (e.type = e.type.replace("mouse", "pointer")),
        e.type.startsWith("touch") && (e.type = sge[e.type] || e.type),
        e
      );
    }
    transferMouseData(e, t) {
      ((e.isTrusted = t.isTrusted),
        (e.srcElement = t.srcElement),
        (e.timeStamp = performance.now()),
        (e.type = t.type),
        (e.altKey = t.altKey),
        (e.button = t.button),
        (e.buttons = t.buttons),
        (e.client.x = t.clientX),
        (e.client.y = t.clientY),
        (e.ctrlKey = t.ctrlKey),
        (e.metaKey = t.metaKey),
        (e.movement.x = t.movementX),
        (e.movement.y = t.movementY),
        (e.page.x = t.pageX),
        (e.page.y = t.pageY),
        (e.relatedTarget = null),
        (e.shiftKey = t.shiftKey));
    }
  };
((tb.extension = {
  name: "events",
  type: [De.RendererSystem, De.CanvasRendererSystem],
}),
  (tb.defaultEventFeatures = {
    move: !0,
    globalMove: !0,
    click: !0,
    wheel: !0,
  }));
let ib = tb;
je.add(ib);
function P6(n) {
  return n === "dynamic" || n === "static";
}
const oge = {
  onclick: null,
  onmousedown: null,
  onmouseenter: null,
  onmouseleave: null,
  onmousemove: null,
  onglobalmousemove: null,
  onmouseout: null,
  onmouseover: null,
  onmouseup: null,
  onmouseupoutside: null,
  onpointercancel: null,
  onpointerdown: null,
  onpointerenter: null,
  onpointerleave: null,
  onpointermove: null,
  onglobalpointermove: null,
  onpointerout: null,
  onpointerover: null,
  onpointertap: null,
  onpointerup: null,
  onpointerupoutside: null,
  onrightclick: null,
  onrightdown: null,
  onrightup: null,
  onrightupoutside: null,
  ontap: null,
  ontouchcancel: null,
  ontouchend: null,
  ontouchendoutside: null,
  ontouchmove: null,
  onglobaltouchmove: null,
  ontouchstart: null,
  onwheel: null,
  _internalInteractive: void 0,
  get interactive() {
    return this._internalInteractive ?? P6(ib.defaultEventMode);
  },
  set interactive(n) {
    (Ht(
      "7.2.0",
      "Setting interactive is deprecated, use eventMode = 'none'/'passive'/'auto'/'static'/'dynamic' instead.",
    ),
      (this._internalInteractive = n),
      (this.eventMode = n ? "static" : "auto"));
  },
  _internalEventMode: void 0,
  get eventMode() {
    return this._internalEventMode ?? ib.defaultEventMode;
  },
  set eventMode(n) {
    ((this._internalInteractive = P6(n)), (this._internalEventMode = n));
  },
  isInteractive() {
    return this.eventMode === "static" || this.eventMode === "dynamic";
  },
  interactiveChildren: !0,
  hitArea: null,
  addEventListener(n, e, t) {
    const i =
        (typeof t == "boolean" && t) || (typeof t == "object" && t.capture),
      r = typeof e == "function" ? void 0 : e;
    ((n = i ? `${n}capture` : n),
      (e = typeof e == "function" ? e : e.handleEvent),
      this.on(n, e, r));
  },
  removeEventListener(n, e, t) {
    const i =
        (typeof t == "boolean" && t) || (typeof t == "object" && t.capture),
      r = typeof e == "function" ? void 0 : e;
    ((n = i ? `${n}capture` : n),
      (e = typeof e == "function" ? e : e.handleEvent),
      this.off(n, e, r));
  },
  dispatchEvent(n) {
    if (!(n instanceof Bp))
      throw new Error(
        "DisplayObject cannot propagate events outside of the Federated Events API",
      );
    return (
      (n.defaultPrevented = !1),
      (n.path = null),
      (n.target = this),
      n.manager.dispatchEvent(n),
      !n.defaultPrevented
    );
  },
};
Wn.mixin(oge);
const age = {
  accessible: !1,
  accessibleTitle: null,
  accessibleHint: null,
  tabIndex: 0,
  _accessibleActive: !1,
  _accessibleDiv: null,
  accessibleType: "button",
  accessiblePointerEvents: "auto",
  accessibleChildren: !0,
  renderId: -1,
};
Wn.mixin(age);
const lge = 9,
  X1 = 100,
  cge = 0,
  uge = 0,
  N6 = 2,
  D6 = 1,
  hge = -1e3,
  dge = -1e3,
  fge = 2;
class JP {
  constructor(e) {
    ((this.debug = !1),
      (this._isActive = !1),
      (this._isMobileAccessibility = !1),
      (this.pool = []),
      (this.renderId = 0),
      (this.children = []),
      (this.androidUpdateCount = 0),
      (this.androidUpdateFrequency = 500),
      (this._hookDiv = null),
      (Ia.tablet || Ia.phone) && this.createTouchHook());
    const t = document.createElement("div");
    ((t.style.width = `${X1}px`),
      (t.style.height = `${X1}px`),
      (t.style.position = "absolute"),
      (t.style.top = `${cge}px`),
      (t.style.left = `${uge}px`),
      (t.style.zIndex = N6.toString()),
      (this.div = t),
      (this.renderer = e),
      (this._onKeyDown = this._onKeyDown.bind(this)),
      (this._onMouseMove = this._onMouseMove.bind(this)),
      globalThis.addEventListener("keydown", this._onKeyDown, !1));
  }
  get isActive() {
    return this._isActive;
  }
  get isMobileAccessibility() {
    return this._isMobileAccessibility;
  }
  createTouchHook() {
    const e = document.createElement("button");
    ((e.style.width = `${D6}px`),
      (e.style.height = `${D6}px`),
      (e.style.position = "absolute"),
      (e.style.top = `${hge}px`),
      (e.style.left = `${dge}px`),
      (e.style.zIndex = fge.toString()),
      (e.style.backgroundColor = "#FF0000"),
      (e.title = "select to enable accessibility for this content"),
      e.addEventListener("focus", () => {
        ((this._isMobileAccessibility = !0),
          this.activate(),
          this.destroyTouchHook());
      }),
      document.body.appendChild(e),
      (this._hookDiv = e));
  }
  destroyTouchHook() {
    this._hookDiv &&
      (document.body.removeChild(this._hookDiv), (this._hookDiv = null));
  }
  activate() {
    this._isActive ||
      ((this._isActive = !0),
      globalThis.document.addEventListener("mousemove", this._onMouseMove, !0),
      globalThis.removeEventListener("keydown", this._onKeyDown, !1),
      this.renderer.on("postrender", this.update, this),
      this.renderer.view.parentNode?.appendChild(this.div));
  }
  deactivate() {
    !this._isActive ||
      this._isMobileAccessibility ||
      ((this._isActive = !1),
      globalThis.document.removeEventListener(
        "mousemove",
        this._onMouseMove,
        !0,
      ),
      globalThis.addEventListener("keydown", this._onKeyDown, !1),
      this.renderer.off("postrender", this.update),
      this.div.parentNode?.removeChild(this.div));
  }
  updateAccessibleObjects(e) {
    if (!e.visible || !e.accessibleChildren) return;
    e.accessible &&
      e.isInteractive() &&
      (e._accessibleActive || this.addChild(e), (e.renderId = this.renderId));
    const t = e.children;
    if (t)
      for (let i = 0; i < t.length; i++) this.updateAccessibleObjects(t[i]);
  }
  update() {
    const e = performance.now();
    if (
      (Ia.android.device && e < this.androidUpdateCount) ||
      ((this.androidUpdateCount = e + this.androidUpdateFrequency),
      !this.renderer.renderingToScreen)
    )
      return;
    this.renderer.lastObjectRendered &&
      this.updateAccessibleObjects(this.renderer.lastObjectRendered);
    const {
        x: t,
        y: i,
        width: r,
        height: s,
      } = this.renderer.view.getBoundingClientRect(),
      { width: o, height: a, resolution: l } = this.renderer,
      c = (r / o) * l,
      u = (s / a) * l;
    let h = this.div;
    ((h.style.left = `${t}px`),
      (h.style.top = `${i}px`),
      (h.style.width = `${o}px`),
      (h.style.height = `${a}px`));
    for (let d = 0; d < this.children.length; d++) {
      const f = this.children[d];
      if (f.renderId !== this.renderId)
        ((f._accessibleActive = !1),
          Vh(this.children, d, 1),
          this.div.removeChild(f._accessibleDiv),
          this.pool.push(f._accessibleDiv),
          (f._accessibleDiv = null),
          d--);
      else {
        h = f._accessibleDiv;
        let g = f.hitArea;
        const p = f.worldTransform;
        (f.hitArea
          ? ((h.style.left = `${(p.tx + g.x * p.a) * c}px`),
            (h.style.top = `${(p.ty + g.y * p.d) * u}px`),
            (h.style.width = `${g.width * p.a * c}px`),
            (h.style.height = `${g.height * p.d * u}px`))
          : ((g = f.getBounds()),
            this.capHitArea(g),
            (h.style.left = `${g.x * c}px`),
            (h.style.top = `${g.y * u}px`),
            (h.style.width = `${g.width * c}px`),
            (h.style.height = `${g.height * u}px`),
            h.title !== f.accessibleTitle &&
              f.accessibleTitle !== null &&
              (h.title = f.accessibleTitle),
            h.getAttribute("aria-label") !== f.accessibleHint &&
              f.accessibleHint !== null &&
              h.setAttribute("aria-label", f.accessibleHint)),
          (f.accessibleTitle !== h.title || f.tabIndex !== h.tabIndex) &&
            ((h.title = f.accessibleTitle),
            (h.tabIndex = f.tabIndex),
            this.debug && this.updateDebugHTML(h)));
      }
    }
    this.renderId++;
  }
  updateDebugHTML(e) {
    e.innerHTML = `type: ${e.type}</br> title : ${e.title}</br> tabIndex: ${e.tabIndex}`;
  }
  capHitArea(e) {
    (e.x < 0 && ((e.width += e.x), (e.x = 0)),
      e.y < 0 && ((e.height += e.y), (e.y = 0)));
    const { width: t, height: i } = this.renderer;
    (e.x + e.width > t && (e.width = t - e.x),
      e.y + e.height > i && (e.height = i - e.y));
  }
  addChild(e) {
    let t = this.pool.pop();
    (t ||
      ((t = document.createElement("button")),
      (t.style.width = `${X1}px`),
      (t.style.height = `${X1}px`),
      (t.style.backgroundColor = this.debug
        ? "rgba(255,255,255,0.5)"
        : "transparent"),
      (t.style.position = "absolute"),
      (t.style.zIndex = N6.toString()),
      (t.style.borderStyle = "none"),
      navigator.userAgent.toLowerCase().includes("chrome")
        ? t.setAttribute("aria-live", "off")
        : t.setAttribute("aria-live", "polite"),
      navigator.userAgent.match(/rv:.*Gecko\//)
        ? t.setAttribute("aria-relevant", "additions")
        : t.setAttribute("aria-relevant", "text"),
      t.addEventListener("click", this._onClick.bind(this)),
      t.addEventListener("focus", this._onFocus.bind(this)),
      t.addEventListener("focusout", this._onFocusOut.bind(this))),
      (t.style.pointerEvents = e.accessiblePointerEvents),
      (t.type = e.accessibleType),
      e.accessibleTitle && e.accessibleTitle !== null
        ? (t.title = e.accessibleTitle)
        : (!e.accessibleHint || e.accessibleHint === null) &&
          (t.title = `displayObject ${e.tabIndex}`),
      e.accessibleHint &&
        e.accessibleHint !== null &&
        t.setAttribute("aria-label", e.accessibleHint),
      this.debug && this.updateDebugHTML(t),
      (e._accessibleActive = !0),
      (e._accessibleDiv = t),
      (t.displayObject = e),
      this.children.push(e),
      this.div.appendChild(e._accessibleDiv),
      (e._accessibleDiv.tabIndex = e.tabIndex));
  }
  _dispatchEvent(e, t) {
    const { displayObject: i } = e.target,
      r = this.renderer.events.rootBoundary,
      s = Object.assign(new Bp(r), { target: i });
    ((r.rootTarget = this.renderer.lastObjectRendered),
      t.forEach((o) => r.dispatchEvent(s, o)));
  }
  _onClick(e) {
    this._dispatchEvent(e, ["click", "pointertap", "tap"]);
  }
  _onFocus(e) {
    (e.target.getAttribute("aria-live") ||
      e.target.setAttribute("aria-live", "assertive"),
      this._dispatchEvent(e, ["mouseover"]));
  }
  _onFocusOut(e) {
    (e.target.getAttribute("aria-live") ||
      e.target.setAttribute("aria-live", "polite"),
      this._dispatchEvent(e, ["mouseout"]));
  }
  _onKeyDown(e) {
    e.keyCode === lge && this.activate();
  }
  _onMouseMove(e) {
    (e.movementX === 0 && e.movementY === 0) || this.deactivate();
  }
  destroy() {
    (this.destroyTouchHook(),
      (this.div = null),
      globalThis.document.removeEventListener(
        "mousemove",
        this._onMouseMove,
        !0,
      ),
      globalThis.removeEventListener("keydown", this._onKeyDown),
      (this.pool = null),
      (this.children = null),
      (this.renderer = null));
  }
}
JP.extension = {
  name: "accessibility",
  type: [De.RendererPlugin, De.CanvasRendererPlugin],
};
je.add(JP);
const QP = class rb {
  constructor(e) {
    ((this.stage = new Rs()),
      (e = Object.assign({ forceCanvas: !1 }, e)),
      (this.renderer = xfe(e)),
      rb._plugins.forEach((t) => {
        t.init.call(this, e);
      }));
  }
  render() {
    this.renderer.render(this.stage);
  }
  get view() {
    return this.renderer?.view;
  }
  get screen() {
    return this.renderer?.screen;
  }
  destroy(e, t) {
    const i = rb._plugins.slice(0);
    (i.reverse(),
      i.forEach((r) => {
        r.destroy.call(this);
      }),
      this.stage.destroy(t),
      (this.stage = null),
      this.renderer.destroy(e),
      (this.renderer = null));
  }
};
QP._plugins = [];
let T5 = QP;
je.handleByList(De.Application, T5._plugins);
class qP {
  static init(e) {
    (Object.defineProperty(this, "resizeTo", {
      set(t) {
        (globalThis.removeEventListener("resize", this.queueResize),
          (this._resizeTo = t),
          t &&
            (globalThis.addEventListener("resize", this.queueResize),
            this.resize()));
      },
      get() {
        return this._resizeTo;
      },
    }),
      (this.queueResize = () => {
        this._resizeTo &&
          (this.cancelResize(),
          (this._resizeId = requestAnimationFrame(() => this.resize())));
      }),
      (this.cancelResize = () => {
        this._resizeId &&
          (cancelAnimationFrame(this._resizeId), (this._resizeId = null));
      }),
      (this.resize = () => {
        if (!this._resizeTo) return;
        this.cancelResize();
        let t, i;
        if (this._resizeTo === globalThis.window)
          ((t = globalThis.innerWidth), (i = globalThis.innerHeight));
        else {
          const { clientWidth: r, clientHeight: s } = this._resizeTo;
          ((t = r), (i = s));
        }
        (this.renderer.resize(t, i), this.render());
      }),
      (this._resizeId = null),
      (this._resizeTo = null),
      (this.resizeTo = e.resizeTo || null));
  }
  static destroy() {
    (globalThis.removeEventListener("resize", this.queueResize),
      this.cancelResize(),
      (this.cancelResize = null),
      (this.queueResize = null),
      (this.resizeTo = null),
      (this.resize = null));
  }
}
qP.extension = De.Application;
je.add(qP);
const G6 = {
  loader: De.LoadParser,
  resolver: De.ResolveParser,
  cache: De.CacheParser,
  detection: De.DetectionParser,
};
je.handle(
  De.Asset,
  (n) => {
    const e = n.ref;
    Object.entries(G6)
      .filter(([t]) => !!e[t])
      .forEach(([t, i]) =>
        je.add(Object.assign(e[t], { extension: e[t].extension ?? i })),
      );
  },
  (n) => {
    const e = n.ref;
    Object.keys(G6)
      .filter((t) => !!e[t])
      .forEach((t) => je.remove(e[t]));
  },
);
class gge {
  constructor(e, t = !1) {
    ((this._loader = e),
      (this._assetList = []),
      (this._isLoading = !1),
      (this._maxConcurrent = 1),
      (this.verbose = t));
  }
  add(e) {
    (e.forEach((t) => {
      this._assetList.push(t);
    }),
      this.verbose &&
        console.log("[BackgroundLoader] assets: ", this._assetList),
      this._isActive && !this._isLoading && this._next());
  }
  async _next() {
    if (this._assetList.length && this._isActive) {
      this._isLoading = !0;
      const e = [],
        t = Math.min(this._assetList.length, this._maxConcurrent);
      for (let i = 0; i < t; i++) e.push(this._assetList.pop());
      (await this._loader.load(e), (this._isLoading = !1), this._next());
    }
  }
  get active() {
    return this._isActive;
  }
  set active(e) {
    this._isActive !== e &&
      ((this._isActive = e), e && !this._isLoading && this._next());
  }
}
function Jd(n, e) {
  if (Array.isArray(e)) {
    for (const t of e) if (n.startsWith(`data:${t}`)) return !0;
    return !1;
  }
  return n.startsWith(`data:${e}`);
}
function Xl(n, e) {
  const t = n.split("?")[0],
    i = mr.extname(t).toLowerCase();
  return Array.isArray(e) ? e.includes(i) : i === e;
}
const Xs = (n, e, t = !1) => (
    Array.isArray(n) || (n = [n]),
    e ? n.map((i) => (typeof i == "string" || t ? e(i) : i)) : n
  ),
  sb = (n, e) => {
    const t = e.split("?")[1];
    return (t && (n += `?${t}`), n);
  };
function eN(n, e, t, i, r) {
  const s = e[t];
  for (let o = 0; o < s.length; o++) {
    const a = s[o];
    t < e.length - 1
      ? eN(n.replace(i[t], a), e, t + 1, i, r)
      : r.push(n.replace(i[t], a));
  }
}
function pge(n) {
  const e = /\{(.*?)\}/g,
    t = n.match(e),
    i = [];
  if (t) {
    const r = [];
    (t.forEach((s) => {
      const o = s.substring(1, s.length - 1).split(",");
      r.push(o);
    }),
      eN(n, r, 0, t, i));
  } else i.push(n);
  return i;
}
const IC = (n) => !Array.isArray(n);
class mge {
  constructor() {
    ((this._parsers = []),
      (this._cache = new Map()),
      (this._cacheMap = new Map()));
  }
  reset() {
    (this._cacheMap.clear(), this._cache.clear());
  }
  has(e) {
    return this._cache.has(e);
  }
  get(e) {
    const t = this._cache.get(e);
    return (
      t || console.warn(`[Assets] Asset id ${e} was not found in the Cache`),
      t
    );
  }
  set(e, t) {
    const i = Xs(e);
    let r;
    for (let a = 0; a < this.parsers.length; a++) {
      const l = this.parsers[a];
      if (l.test(t)) {
        r = l.getCacheableAssets(i, t);
        break;
      }
    }
    r ||
      ((r = {}),
      i.forEach((a) => {
        r[a] = t;
      }));
    const s = Object.keys(r),
      o = { cacheKeys: s, keys: i };
    if (
      (i.forEach((a) => {
        this._cacheMap.set(a, o);
      }),
      s.forEach((a) => {
        (this._cache.has(a) &&
          this._cache.get(a) !== t &&
          console.warn("[Cache] already has key:", a),
          this._cache.set(a, r[a]));
      }),
      t instanceof Qe)
    ) {
      const a = t;
      i.forEach((l) => {
        (a.baseTexture !== Qe.EMPTY.baseTexture &&
          St.addToCache(a.baseTexture, l),
          Qe.addToCache(a, l));
      });
    }
  }
  remove(e) {
    if (!this._cacheMap.has(e)) {
      console.warn(`[Assets] Asset id ${e} was not found in the Cache`);
      return;
    }
    const t = this._cacheMap.get(e);
    (t.cacheKeys.forEach((i) => {
      this._cache.delete(i);
    }),
      t.keys.forEach((i) => {
        this._cacheMap.delete(i);
      }));
  }
  get parsers() {
    return this._parsers;
  }
}
const Uc = new mge();
class Cge {
  constructor() {
    ((this._parsers = []),
      (this._parsersValidated = !1),
      (this.parsers = new Proxy(this._parsers, {
        set: (e, t, i) => ((this._parsersValidated = !1), (e[t] = i), !0),
      })),
      (this.promiseCache = {}));
  }
  reset() {
    ((this._parsersValidated = !1), (this.promiseCache = {}));
  }
  _getLoadPromiseAndParser(e, t) {
    const i = { promise: null, parser: null };
    return (
      (i.promise = (async () => {
        let r = null,
          s = null;
        if (
          (t.loadParser &&
            ((s = this._parserHash[t.loadParser]),
            s ||
              console.warn(
                `[Assets] specified load parser "${t.loadParser}" not found while loading ${e}`,
              )),
          !s)
        ) {
          for (let o = 0; o < this.parsers.length; o++) {
            const a = this.parsers[o];
            if (a.load && a.test?.(e, t, this)) {
              s = a;
              break;
            }
          }
          if (!s)
            return (
              console.warn(
                `[Assets] ${e} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`,
              ),
              null
            );
        }
        ((r = await s.load(e, t, this)), (i.parser = s));
        for (let o = 0; o < this.parsers.length; o++) {
          const a = this.parsers[o];
          a.parse &&
            a.parse &&
            (await a.testParse?.(r, t, this)) &&
            ((r = (await a.parse(r, t, this)) || r), (i.parser = a));
        }
        return r;
      })()),
      i
    );
  }
  async load(e, t) {
    this._parsersValidated || this._validateParsers();
    let i = 0;
    const r = {},
      s = IC(e),
      o = Xs(e, (c) => ({ alias: [c], src: c })),
      a = o.length,
      l = o.map(async (c) => {
        const u = mr.toAbsolute(c.src);
        if (!r[c.src])
          try {
            (this.promiseCache[u] ||
              (this.promiseCache[u] = this._getLoadPromiseAndParser(u, c)),
              (r[c.src] = await this.promiseCache[u].promise),
              t && t(++i / a));
          } catch (h) {
            throw (
              delete this.promiseCache[u],
              delete r[c.src],
              new Error(`[Loader.load] Failed to load ${u}.
${h}`)
            );
          }
      });
    return (await Promise.all(l), s ? r[o[0].src] : r);
  }
  async unload(e) {
    const t = Xs(e, (i) => ({ alias: [i], src: i })).map(async (i) => {
      const r = mr.toAbsolute(i.src),
        s = this.promiseCache[r];
      if (s) {
        const o = await s.promise;
        (delete this.promiseCache[r], s.parser?.unload?.(o, i, this));
      }
    });
    await Promise.all(t);
  }
  _validateParsers() {
    ((this._parsersValidated = !0),
      (this._parserHash = this._parsers
        .filter((e) => e.name)
        .reduce(
          (e, t) => (
            e[t.name] &&
              console.warn(`[Assets] loadParser name conflict "${t.name}"`),
            { ...e, [t.name]: t }
          ),
          {},
        )));
  }
}
var oo = ((n) => (
  (n[(n.Low = 0)] = "Low"),
  (n[(n.Normal = 1)] = "Normal"),
  (n[(n.High = 2)] = "High"),
  n
))(oo || {});
const Ige = ".json",
  Age = "application/json",
  yge = {
    extension: { type: De.LoadParser, priority: oo.Low },
    name: "loadJson",
    test(n) {
      return Jd(n, Age) || Xl(n, Ige);
    },
    async load(n) {
      return await (await Oe.ADAPTER.fetch(n)).json();
    },
  };
je.add(yge);
const _ge = ".txt",
  bge = "text/plain",
  vge = {
    name: "loadTxt",
    extension: { type: De.LoadParser, priority: oo.Low },
    test(n) {
      return Jd(n, bge) || Xl(n, _ge);
    },
    async load(n) {
      return await (await Oe.ADAPTER.fetch(n)).text();
    },
  };
je.add(vge);
const xge = [
    "normal",
    "bold",
    "100",
    "200",
    "300",
    "400",
    "500",
    "600",
    "700",
    "800",
    "900",
  ],
  wge = [".ttf", ".otf", ".woff", ".woff2"],
  Sge = ["font/ttf", "font/otf", "font/woff", "font/woff2"],
  Tge = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
function Ege(n) {
  const e = mr.extname(n),
    t = mr
      .basename(n, e)
      .replace(/(-|_)/g, " ")
      .toLowerCase()
      .split(" ")
      .map((s) => s.charAt(0).toUpperCase() + s.slice(1));
  let i = t.length > 0;
  for (const s of t)
    if (!s.match(Tge)) {
      i = !1;
      break;
    }
  let r = t.join(" ");
  return (i || (r = `"${r.replace(/[\\"]/g, "\\$&")}"`), r);
}
const Mge = {
  extension: { type: De.LoadParser, priority: oo.Low },
  name: "loadWebFont",
  test(n) {
    return Jd(n, Sge) || Xl(n, wge);
  },
  async load(n, e) {
    const t = Oe.ADAPTER.getFontFaceSet();
    if (t) {
      const i = [],
        r = e.data?.family ?? Ege(n),
        s = e.data?.weights?.filter((a) => xge.includes(a)) ?? ["normal"],
        o = e.data ?? {};
      for (let a = 0; a < s.length; a++) {
        const l = s[a],
          c = new FontFace(r, `url(${encodeURI(n)})`, { ...o, weight: l });
        (await c.load(), t.add(c), i.push(c));
      }
      return i.length === 1 ? i[0] : i;
    }
    return (
      console.warn(
        "[loadWebFont] FontFace API is not supported. Skipping loading font",
      ),
      null
    );
  },
  unload(n) {
    (Array.isArray(n) ? n : [n]).forEach((e) =>
      Oe.ADAPTER.getFontFaceSet().delete(e),
    );
  },
};
je.add(Mge);
let F6 = 0,
  HA;
const Lge =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=",
  Rge = {
    id: "checkImageBitmap",
    code: `
    async function checkImageBitmap()
    {
        try
        {
            if (typeof createImageBitmap !== 'function') return false;

            const response = await fetch('${Lge}');
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);

            return imageBitmap.width === 1 && imageBitmap.height === 1;
        }
        catch (e)
        {
            return false;
        }
    }
    checkImageBitmap().then((result) => { self.postMessage(result); });
    `,
  },
  Bge = {
    id: "loadImageBitmap",
    code: `
    async function loadImageBitmap(url)
    {
        const response = await fetch(url);

        if (!response.ok)
        {
            throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \`
                + \`\${response.status} \${response.statusText}\`);
        }

        const imageBlob =  await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);

        return imageBitmap;
    }
    self.onmessage = async (event) =>
    {
        try
        {
            const imageBitmap = await loadImageBitmap(event.data.data[0]);

            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }
        catch(e)
        {
            self.postMessage({
                error: e,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        }
    };`,
  };
let WA;
class Pge {
  constructor() {
    ((this._initialized = !1),
      (this._createdWorkers = 0),
      (this.workerPool = []),
      (this.queue = []),
      (this.resolveHash = {}));
  }
  isImageBitmapSupported() {
    return this._isImageBitmapSupported !== void 0
      ? this._isImageBitmapSupported
      : ((this._isImageBitmapSupported = new Promise((e) => {
          const t = URL.createObjectURL(
              new Blob([Rge.code], { type: "application/javascript" }),
            ),
            i = new Worker(t);
          i.addEventListener("message", (r) => {
            (i.terminate(), URL.revokeObjectURL(t), e(r.data));
          });
        })),
        this._isImageBitmapSupported);
  }
  loadImageBitmap(e) {
    return this._run("loadImageBitmap", [e]);
  }
  async _initWorkers() {
    this._initialized || (this._initialized = !0);
  }
  getWorker() {
    HA === void 0 && (HA = navigator.hardwareConcurrency || 4);
    let e = this.workerPool.pop();
    return (
      !e &&
        this._createdWorkers < HA &&
        (WA ||
          (WA = URL.createObjectURL(
            new Blob([Bge.code], { type: "application/javascript" }),
          )),
        this._createdWorkers++,
        (e = new Worker(WA)),
        e.addEventListener("message", (t) => {
          (this.complete(t.data), this.returnWorker(t.target), this.next());
        })),
      e
    );
  }
  returnWorker(e) {
    this.workerPool.push(e);
  }
  complete(e) {
    (e.error !== void 0
      ? this.resolveHash[e.uuid].reject(e.error)
      : this.resolveHash[e.uuid].resolve(e.data),
      (this.resolveHash[e.uuid] = null));
  }
  async _run(e, t) {
    await this._initWorkers();
    const i = new Promise((r, s) => {
      this.queue.push({ id: e, arguments: t, resolve: r, reject: s });
    });
    return (this.next(), i);
  }
  next() {
    if (!this.queue.length) return;
    const e = this.getWorker();
    if (!e) return;
    const t = this.queue.pop(),
      i = t.id;
    ((this.resolveHash[F6] = { resolve: t.resolve, reject: t.reject }),
      e.postMessage({ data: t.arguments, uuid: F6++, id: i }));
  }
}
const k6 = new Pge();
function Pp(n, e, t) {
  n.resource.internal = !0;
  const i = new Qe(n),
    r = () => {
      (delete e.promiseCache[t], Uc.has(t) && Uc.remove(t));
    };
  return (
    i.baseTexture.once("destroyed", () => {
      t in e.promiseCache &&
        (console.warn(
          "[Assets] A BaseTexture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the BaseTexture.",
        ),
        r());
    }),
    i.once("destroyed", () => {
      n.destroyed ||
        (console.warn(
          "[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture.",
        ),
        r());
    }),
    i
  );
}
const Nge = [".jpeg", ".jpg", ".png", ".webp", ".avif"],
  Dge = ["image/jpeg", "image/png", "image/webp", "image/avif"];
async function Gge(n) {
  const e = await Oe.ADAPTER.fetch(n);
  if (!e.ok)
    throw new Error(
      `[loadImageBitmap] Failed to fetch ${n}: ${e.status} ${e.statusText}`,
    );
  const t = await e.blob();
  return await createImageBitmap(t);
}
const AI = {
  name: "loadTextures",
  extension: { type: De.LoadParser, priority: oo.High },
  config: {
    preferWorkers: !0,
    preferCreateImageBitmap: !0,
    crossOrigin: "anonymous",
  },
  test(n) {
    return Jd(n, Dge) || Xl(n, Nge);
  },
  async load(n, e, t) {
    const i =
      globalThis.createImageBitmap && this.config.preferCreateImageBitmap;
    let r;
    i
      ? this.config.preferWorkers && (await k6.isImageBitmapSupported())
        ? (r = await k6.loadImageBitmap(n))
        : (r = await Gge(n))
      : (r = await new Promise((a, l) => {
          const c = new Image();
          ((c.crossOrigin = this.config.crossOrigin),
            (c.src = n),
            c.complete
              ? a(c)
              : ((c.onload = () => a(c)), (c.onerror = (u) => l(u))));
        }));
    const s = { ...e.data };
    (s.resolution ?? (s.resolution = Ga(n)),
      i &&
        s.resourceOptions?.ownsImageBitmap === void 0 &&
        ((s.resourceOptions = { ...s.resourceOptions }),
        (s.resourceOptions.ownsImageBitmap = !0)));
    const o = new St(r, s);
    return ((o.resource.src = n), Pp(o, t, n));
  },
  unload(n) {
    n.destroy(!0);
  },
};
je.add(AI);
const Fge = ".svg",
  kge = "image/svg+xml",
  Oge = {
    extension: { type: De.LoadParser, priority: oo.High },
    name: "loadSVG",
    test(n) {
      return Jd(n, kge) || Xl(n, Fge);
    },
    async testParse(n) {
      return j3.test(n);
    },
    async parse(n, e, t) {
      const i = new j3(n, e?.data?.resourceOptions);
      await i.load();
      const r = new St(i, { resolution: Ga(n), ...e?.data });
      return ((r.resource.src = e.src), Pp(r, t, e.src));
    },
    async load(n, e) {
      return (await Oe.ADAPTER.fetch(n)).text();
    },
    unload: AI.unload,
  };
je.add(Oge);
const Uge = [".mp4", ".m4v", ".webm", ".ogv"],
  Hge = ["video/mp4", "video/webm", "video/ogg"],
  Wge = {
    name: "loadVideo",
    extension: { type: De.LoadParser, priority: oo.High },
    config: { defaultAutoPlay: !0 },
    test(n) {
      return Jd(n, Hge) || Xl(n, Uge);
    },
    async load(n, e, t) {
      let i;
      const r = await (await Oe.ADAPTER.fetch(n)).blob(),
        s = URL.createObjectURL(r);
      try {
        const o = {
            autoPlay: this.config.defaultAutoPlay,
            ...e?.data?.resourceOptions,
          },
          a = new KP(s, o);
        await a.load();
        const l = new St(a, {
          alphaMode: await $he(),
          resolution: Ga(n),
          ...e?.data,
        });
        ((l.resource.src = n),
          (i = Pp(l, t, n)),
          i.baseTexture.once("destroyed", () => {
            URL.revokeObjectURL(s);
          }));
      } catch (o) {
        throw (URL.revokeObjectURL(s), o);
      }
      return i;
    },
    unload(n) {
      n.destroy(!0);
    },
  };
je.add(Wge);
class Vge {
  constructor() {
    ((this._defaultBundleIdentifierOptions = {
      connector: "-",
      createBundleAssetId: (e, t) => `${e}${this._bundleIdConnector}${t}`,
      extractAssetIdFromBundle: (e, t) =>
        t.replace(`${e}${this._bundleIdConnector}`, ""),
    }),
      (this._bundleIdConnector =
        this._defaultBundleIdentifierOptions.connector),
      (this._createBundleAssetId =
        this._defaultBundleIdentifierOptions.createBundleAssetId),
      (this._extractAssetIdFromBundle =
        this._defaultBundleIdentifierOptions.extractAssetIdFromBundle),
      (this._assetMap = {}),
      (this._preferredOrder = []),
      (this._parsers = []),
      (this._resolverHash = {}),
      (this._bundles = {}));
  }
  setBundleIdentifier(e) {
    if (
      ((this._bundleIdConnector = e.connector ?? this._bundleIdConnector),
      (this._createBundleAssetId =
        e.createBundleAssetId ?? this._createBundleAssetId),
      (this._extractAssetIdFromBundle =
        e.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle),
      this._extractAssetIdFromBundle(
        "foo",
        this._createBundleAssetId("foo", "bar"),
      ) !== "bar")
    )
      throw new Error(
        "[Resolver] GenerateBundleAssetId are not working correctly",
      );
  }
  prefer(...e) {
    (e.forEach((t) => {
      (this._preferredOrder.push(t),
        t.priority || (t.priority = Object.keys(t.params)));
    }),
      (this._resolverHash = {}));
  }
  set basePath(e) {
    this._basePath = e;
  }
  get basePath() {
    return this._basePath;
  }
  set rootPath(e) {
    this._rootPath = e;
  }
  get rootPath() {
    return this._rootPath;
  }
  get parsers() {
    return this._parsers;
  }
  reset() {
    (this.setBundleIdentifier(this._defaultBundleIdentifierOptions),
      (this._assetMap = {}),
      (this._preferredOrder = []),
      (this._resolverHash = {}),
      (this._rootPath = null),
      (this._basePath = null),
      (this._manifest = null),
      (this._bundles = {}),
      (this._defaultSearchParams = null));
  }
  setDefaultSearchParams(e) {
    if (typeof e == "string") this._defaultSearchParams = e;
    else {
      const t = e;
      this._defaultSearchParams = Object.keys(t)
        .map((i) => `${encodeURIComponent(i)}=${encodeURIComponent(t[i])}`)
        .join("&");
    }
  }
  getAlias(e) {
    const { alias: t, name: i, src: r, srcs: s } = e;
    return Xs(
      t || i || r || s,
      (o) =>
        typeof o == "string"
          ? o
          : Array.isArray(o)
            ? o.map((a) => a?.src ?? a?.srcs ?? a)
            : o?.src || o?.srcs
              ? (o.src ?? o.srcs)
              : o,
      !0,
    );
  }
  addManifest(e) {
    (this._manifest &&
      console.warn(
        "[Resolver] Manifest already exists, this will be overwritten",
      ),
      (this._manifest = e),
      e.bundles.forEach((t) => {
        this.addBundle(t.name, t.assets);
      }));
  }
  addBundle(e, t) {
    const i = [];
    (Array.isArray(t)
      ? t.forEach((r) => {
          const s = r.src ?? r.srcs,
            o = r.alias ?? r.name;
          let a;
          if (typeof o == "string") {
            const l = this._createBundleAssetId(e, o);
            (i.push(l), (a = [o, l]));
          } else {
            const l = o.map((c) => this._createBundleAssetId(e, c));
            (i.push(...l), (a = [...o, ...l]));
          }
          this.add({ ...r, alias: a, src: s });
        })
      : Object.keys(t).forEach((r) => {
          const s = [r, this._createBundleAssetId(e, r)];
          if (typeof t[r] == "string") this.add({ alias: s, src: t[r] });
          else if (Array.isArray(t[r])) this.add({ alias: s, src: t[r] });
          else {
            const o = t[r],
              a = o.src ?? o.srcs;
            this.add({ ...o, alias: s, src: Array.isArray(a) ? a : [a] });
          }
          i.push(...s);
        }),
      (this._bundles[e] = i));
  }
  add(e, t, i, r, s) {
    const o = [];
    typeof e == "string" || (Array.isArray(e) && typeof e[0] == "string")
      ? (Ht(
          "7.2.0",
          `Assets.add now uses an object instead of individual parameters.
Please use Assets.add({ alias, src, data, format, loadParser }) instead.`,
        ),
        o.push({ alias: e, src: t, data: i, format: r, loadParser: s }))
      : Array.isArray(e)
        ? o.push(...e)
        : o.push(e);
    let a;
    ((a = (l) => {
      this.hasKey(l) &&
        console.warn(`[Resolver] already has key: ${l} overwriting`);
    }),
      Xs(o).forEach((l) => {
        const { src: c, srcs: u } = l;
        let { data: h, format: d, loadParser: f } = l;
        const g = Xs(c || u).map((C) =>
            typeof C == "string" ? pge(C) : Array.isArray(C) ? C : [C],
          ),
          p = this.getAlias(l);
        Array.isArray(p) ? p.forEach(a) : a(p);
        const m = [];
        (g.forEach((C) => {
          C.forEach((A) => {
            let I = {};
            if (typeof A != "object") {
              I.src = A;
              for (let y = 0; y < this._parsers.length; y++) {
                const x = this._parsers[y];
                if (x.test(A)) {
                  I = x.parse(A);
                  break;
                }
              }
            } else
              ((h = A.data ?? h),
                (d = A.format ?? d),
                (f = A.loadParser ?? f),
                (I = { ...I, ...A }));
            if (!p)
              throw new Error(
                `[Resolver] alias is undefined for this asset: ${I.src}`,
              );
            ((I = this.buildResolvedAsset(I, {
              aliases: p,
              data: h,
              format: d,
              loadParser: f,
            })),
              m.push(I));
          });
        }),
          p.forEach((C) => {
            this._assetMap[C] = m;
          }));
      }));
  }
  resolveBundle(e) {
    const t = IC(e);
    e = Xs(e);
    const i = {};
    return (
      e.forEach((r) => {
        const s = this._bundles[r];
        if (s) {
          const o = this.resolve(s),
            a = {};
          for (const l in o) {
            const c = o[l];
            a[this._extractAssetIdFromBundle(r, l)] = c;
          }
          i[r] = a;
        }
      }),
      t ? i[e[0]] : i
    );
  }
  resolveUrl(e) {
    const t = this.resolve(e);
    if (typeof e != "string") {
      const i = {};
      for (const r in t) i[r] = t[r].src;
      return i;
    }
    return t.src;
  }
  resolve(e) {
    const t = IC(e);
    e = Xs(e);
    const i = {};
    return (
      e.forEach((r) => {
        if (!this._resolverHash[r])
          if (this._assetMap[r]) {
            let s = this._assetMap[r];
            const o = s[0],
              a = this._getPreferredOrder(s);
            (a?.priority.forEach((l) => {
              a.params[l].forEach((c) => {
                const u = s.filter((h) => (h[l] ? h[l] === c : !1));
                u.length && (s = u);
              });
            }),
              (this._resolverHash[r] = s[0] ?? o));
          } else
            this._resolverHash[r] = this.buildResolvedAsset(
              { alias: [r], src: r },
              {},
            );
        i[r] = this._resolverHash[r];
      }),
      t ? i[e[0]] : i
    );
  }
  hasKey(e) {
    return !!this._assetMap[e];
  }
  hasBundle(e) {
    return !!this._bundles[e];
  }
  _getPreferredOrder(e) {
    for (let t = 0; t < e.length; t++) {
      const i = e[0],
        r = this._preferredOrder.find((s) =>
          s.params.format.includes(i.format),
        );
      if (r) return r;
    }
    return this._preferredOrder[0];
  }
  _appendDefaultSearchParams(e) {
    if (!this._defaultSearchParams) return e;
    const t = /\?/.test(e) ? "&" : "?";
    return `${e}${t}${this._defaultSearchParams}`;
  }
  buildResolvedAsset(e, t) {
    const { aliases: i, data: r, loadParser: s, format: o } = t;
    return (
      (this._basePath || this._rootPath) &&
        (e.src = mr.toAbsolute(e.src, this._basePath, this._rootPath)),
      (e.alias = i ?? e.alias ?? [e.src]),
      (e.src = this._appendDefaultSearchParams(e.src)),
      (e.data = { ...(r || {}), ...e.data }),
      (e.loadParser = s ?? e.loadParser),
      (e.format = o ?? e.src.split(".").pop()),
      (e.srcs = e.src),
      (e.name = e.alias),
      e
    );
  }
}
class Zge {
  constructor() {
    ((this._detections = []),
      (this._initialized = !1),
      (this.resolver = new Vge()),
      (this.loader = new Cge()),
      (this.cache = Uc),
      (this._backgroundLoader = new gge(this.loader)),
      (this._backgroundLoader.active = !0),
      this.reset());
  }
  async init(e = {}) {
    if (this._initialized) {
      console.warn(
        "[Assets]AssetManager already initialized, did you load before calling this Asset.init()?",
      );
      return;
    }
    if (
      ((this._initialized = !0),
      e.defaultSearchParams &&
        this.resolver.setDefaultSearchParams(e.defaultSearchParams),
      e.basePath && (this.resolver.basePath = e.basePath),
      e.bundleIdentifier &&
        this.resolver.setBundleIdentifier(e.bundleIdentifier),
      e.manifest)
    ) {
      let s = e.manifest;
      (typeof s == "string" && (s = await this.load(s)),
        this.resolver.addManifest(s));
    }
    const t = e.texturePreference?.resolution ?? 1,
      i = typeof t == "number" ? [t] : t,
      r = await this._detectFormats({
        preferredFormats: e.texturePreference?.format,
        skipDetections: e.skipDetections,
        detections: this._detections,
      });
    (this.resolver.prefer({ params: { format: r, resolution: i } }),
      e.preferences && this.setPreferences(e.preferences));
  }
  add(e, t, i, r, s) {
    this.resolver.add(e, t, i, r, s);
  }
  async load(e, t) {
    this._initialized || (await this.init());
    const i = IC(e),
      r = Xs(e).map((a) => {
        if (typeof a != "string") {
          const l = this.resolver.getAlias(a);
          return (
            l.some((c) => !this.resolver.hasKey(c)) && this.add(a),
            Array.isArray(l) ? l[0] : l
          );
        }
        return (this.resolver.hasKey(a) || this.add({ alias: a, src: a }), a);
      }),
      s = this.resolver.resolve(r),
      o = await this._mapLoadToResolve(s, t);
    return i ? o[r[0]] : o;
  }
  addBundle(e, t) {
    this.resolver.addBundle(e, t);
  }
  async loadBundle(e, t) {
    this._initialized || (await this.init());
    let i = !1;
    typeof e == "string" && ((i = !0), (e = [e]));
    const r = this.resolver.resolveBundle(e),
      s = {},
      o = Object.keys(r);
    let a = 0,
      l = 0;
    const c = () => {
        t?.(++a / l);
      },
      u = o.map((h) => {
        const d = r[h];
        return (
          (l += Object.keys(d).length),
          this._mapLoadToResolve(d, c).then((f) => {
            s[h] = f;
          })
        );
      });
    return (await Promise.all(u), i ? s[e[0]] : s);
  }
  async backgroundLoad(e) {
    (this._initialized || (await this.init()),
      typeof e == "string" && (e = [e]));
    const t = this.resolver.resolve(e);
    this._backgroundLoader.add(Object.values(t));
  }
  async backgroundLoadBundle(e) {
    (this._initialized || (await this.init()),
      typeof e == "string" && (e = [e]));
    const t = this.resolver.resolveBundle(e);
    Object.values(t).forEach((i) => {
      this._backgroundLoader.add(Object.values(i));
    });
  }
  reset() {
    (this.resolver.reset(),
      this.loader.reset(),
      this.cache.reset(),
      (this._initialized = !1));
  }
  get(e) {
    if (typeof e == "string") return Uc.get(e);
    const t = {};
    for (let i = 0; i < e.length; i++) t[i] = Uc.get(e[i]);
    return t;
  }
  async _mapLoadToResolve(e, t) {
    const i = Object.values(e),
      r = Object.keys(e);
    this._backgroundLoader.active = !1;
    const s = await this.loader.load(i, t);
    this._backgroundLoader.active = !0;
    const o = {};
    return (
      i.forEach((a, l) => {
        const c = s[a.src],
          u = [a.src];
        (a.alias && u.push(...a.alias), (o[r[l]] = c), Uc.set(u, c));
      }),
      o
    );
  }
  async unload(e) {
    this._initialized || (await this.init());
    const t = Xs(e).map((r) => (typeof r != "string" ? r.src : r)),
      i = this.resolver.resolve(t);
    await this._unloadFromResolved(i);
  }
  async unloadBundle(e) {
    (this._initialized || (await this.init()), (e = Xs(e)));
    const t = this.resolver.resolveBundle(e),
      i = Object.keys(t).map((r) => this._unloadFromResolved(t[r]));
    await Promise.all(i);
  }
  async _unloadFromResolved(e) {
    const t = Object.values(e);
    (t.forEach((i) => {
      Uc.remove(i.src);
    }),
      await this.loader.unload(t));
  }
  async _detectFormats(e) {
    let t = [];
    e.preferredFormats &&
      (t = Array.isArray(e.preferredFormats)
        ? e.preferredFormats
        : [e.preferredFormats]);
    for (const i of e.detections)
      e.skipDetections || (await i.test())
        ? (t = await i.add(t))
        : e.skipDetections || (t = await i.remove(t));
    return ((t = t.filter((i, r) => t.indexOf(i) === r)), t);
  }
  get detections() {
    return this._detections;
  }
  get preferWorkers() {
    return AI.config.preferWorkers;
  }
  set preferWorkers(e) {
    (Ht(
      "7.2.0",
      "Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead.",
    ),
      this.setPreferences({ preferWorkers: e }));
  }
  setPreferences(e) {
    this.loader.parsers.forEach((t) => {
      t.config &&
        Object.keys(t.config)
          .filter((i) => i in e)
          .forEach((i) => {
            t.config[i] = e[i];
          });
    });
  }
}
const K1 = new Zge();
je.handleByList(De.LoadParser, K1.loader.parsers)
  .handleByList(De.ResolveParser, K1.resolver.parsers)
  .handleByList(De.CacheParser, K1.cache.parsers)
  .handleByList(De.DetectionParser, K1.detections);
const zge = {
  extension: De.CacheParser,
  test: (n) => Array.isArray(n) && n.every((e) => e instanceof Qe),
  getCacheableAssets: (n, e) => {
    const t = {};
    return (
      n.forEach((i) => {
        e.forEach((r, s) => {
          t[i + (s === 0 ? "" : s + 1)] = r;
        });
      }),
      t
    );
  },
};
je.add(zge);
const Yge = {
  extension: { type: De.DetectionParser, priority: 1 },
  test: async () => {
    const n =
      "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=";
    return new Promise((e) => {
      const t = new Image();
      ((t.onload = () => {
        e(!0);
      }),
        (t.onerror = () => {
          e(!1);
        }),
        (t.src = n));
    });
  },
  add: async (n) => [...n, "avif"],
  remove: async (n) => n.filter((e) => e !== "avif"),
};
je.add(Yge);
const Xge = {
  extension: { type: De.DetectionParser, priority: 0 },
  test: async () => {
    const n =
      "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=";
    return new Promise((e) => {
      const t = new Image();
      ((t.onload = () => {
        e(!0);
      }),
        (t.onerror = () => {
          e(!1);
        }),
        (t.src = n));
    });
  },
  add: async (n) => [...n, "webp"],
  remove: async (n) => n.filter((e) => e !== "webp"),
};
je.add(Xge);
const O6 = ["png", "jpg", "jpeg"],
  Kge = {
    extension: { type: De.DetectionParser, priority: -1 },
    test: () => Promise.resolve(!0),
    add: async (n) => [...n, ...O6],
    remove: async (n) => n.filter((e) => !O6.includes(e)),
  };
je.add(Kge);
const jge =
  "WorkerGlobalScope" in globalThis &&
  globalThis instanceof globalThis.WorkerGlobalScope;
function E5(n) {
  return jge ? !1 : document.createElement("video").canPlayType(n) !== "";
}
const $ge = {
  extension: { type: De.DetectionParser, priority: 0 },
  test: async () => E5("video/webm"),
  add: async (n) => [...n, "webm"],
  remove: async (n) => n.filter((e) => e !== "webm"),
};
je.add($ge);
const Jge = {
  extension: { type: De.DetectionParser, priority: 0 },
  test: async () => E5("video/mp4"),
  add: async (n) => [...n, "mp4", "m4v"],
  remove: async (n) => n.filter((e) => e !== "mp4" && e !== "m4v"),
};
je.add(Jge);
const Qge = {
  extension: { type: De.DetectionParser, priority: 0 },
  test: async () => E5("video/ogg"),
  add: async (n) => [...n, "ogv"],
  remove: async (n) => n.filter((e) => e !== "ogv"),
};
je.add(Qge);
const qge = {
  extension: De.ResolveParser,
  test: AI.test,
  parse: (n) => ({
    resolution: parseFloat(Oe.RETINA_PREFIX.exec(n)?.[1] ?? "1"),
    format: n.split(".").pop(),
    src: n,
  }),
};
je.add(qge);
var Hr = ((n) => (
  (n[(n.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776)] =
    "COMPRESSED_RGB_S3TC_DXT1_EXT"),
  (n[(n.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777)] =
    "COMPRESSED_RGBA_S3TC_DXT1_EXT"),
  (n[(n.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778)] =
    "COMPRESSED_RGBA_S3TC_DXT3_EXT"),
  (n[(n.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779)] =
    "COMPRESSED_RGBA_S3TC_DXT5_EXT"),
  (n[(n.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917)] =
    "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"),
  (n[(n.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918)] =
    "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"),
  (n[(n.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919)] =
    "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"),
  (n[(n.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916)] =
    "COMPRESSED_SRGB_S3TC_DXT1_EXT"),
  (n[(n.COMPRESSED_R11_EAC = 37488)] = "COMPRESSED_R11_EAC"),
  (n[(n.COMPRESSED_SIGNED_R11_EAC = 37489)] = "COMPRESSED_SIGNED_R11_EAC"),
  (n[(n.COMPRESSED_RG11_EAC = 37490)] = "COMPRESSED_RG11_EAC"),
  (n[(n.COMPRESSED_SIGNED_RG11_EAC = 37491)] = "COMPRESSED_SIGNED_RG11_EAC"),
  (n[(n.COMPRESSED_RGB8_ETC2 = 37492)] = "COMPRESSED_RGB8_ETC2"),
  (n[(n.COMPRESSED_RGBA8_ETC2_EAC = 37496)] = "COMPRESSED_RGBA8_ETC2_EAC"),
  (n[(n.COMPRESSED_SRGB8_ETC2 = 37493)] = "COMPRESSED_SRGB8_ETC2"),
  (n[(n.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497)] =
    "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"),
  (n[(n.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494)] =
    "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"),
  (n[(n.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495)] =
    "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"),
  (n[(n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840)] =
    "COMPRESSED_RGB_PVRTC_4BPPV1_IMG"),
  (n[(n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842)] =
    "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"),
  (n[(n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841)] =
    "COMPRESSED_RGB_PVRTC_2BPPV1_IMG"),
  (n[(n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843)] =
    "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"),
  (n[(n.COMPRESSED_RGB_ETC1_WEBGL = 36196)] = "COMPRESSED_RGB_ETC1_WEBGL"),
  (n[(n.COMPRESSED_RGB_ATC_WEBGL = 35986)] = "COMPRESSED_RGB_ATC_WEBGL"),
  (n[(n.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986)] =
    "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"),
  (n[(n.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798)] =
    "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"),
  (n[(n.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808)] =
    "COMPRESSED_RGBA_ASTC_4x4_KHR"),
  n
))(Hr || {});
const AC = {
  33776: 0.5,
  33777: 0.5,
  33778: 1,
  33779: 1,
  35916: 0.5,
  35917: 0.5,
  35918: 1,
  35919: 1,
  37488: 0.5,
  37489: 0.5,
  37490: 1,
  37491: 1,
  37492: 0.5,
  37496: 1,
  37493: 0.5,
  37497: 1,
  37494: 0.5,
  37495: 0.5,
  35840: 0.5,
  35842: 0.5,
  35841: 0.25,
  35843: 0.25,
  36196: 0.5,
  35986: 0.5,
  35986: 1,
  34798: 1,
  37808: 1,
};
let oa, uh;
function U6() {
  uh = {
    s3tc: oa.getExtension("WEBGL_compressed_texture_s3tc"),
    s3tc_sRGB: oa.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
    etc: oa.getExtension("WEBGL_compressed_texture_etc"),
    etc1: oa.getExtension("WEBGL_compressed_texture_etc1"),
    pvrtc:
      oa.getExtension("WEBGL_compressed_texture_pvrtc") ||
      oa.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
    atc: oa.getExtension("WEBGL_compressed_texture_atc"),
    astc: oa.getExtension("WEBGL_compressed_texture_astc"),
  };
}
const epe = {
  extension: { type: De.DetectionParser, priority: 2 },
  test: async () => {
    const n = Oe.ADAPTER.createCanvas().getContext("webgl");
    return n
      ? ((oa = n), !0)
      : (console.warn("WebGL not available for compressed textures."), !1);
  },
  add: async (n) => {
    uh || U6();
    const e = [];
    for (const t in uh) uh[t] && e.push(t);
    return [...e, ...n];
  },
  remove: async (n) => (uh || U6(), n.filter((e) => !(e in uh))),
};
je.add(epe);
class tpe extends gI {
  constructor(e, t = { width: 1, height: 1, autoLoad: !0 }) {
    let i, r;
    (typeof e == "string"
      ? ((i = e), (r = new Uint8Array()))
      : ((i = null), (r = e)),
      super(r, t),
      (this.origin = i),
      (this.buffer = r ? new G3(r) : null),
      (this._load = null),
      (this.loaded = !1),
      this.origin !== null && t.autoLoad !== !1 && this.load(),
      this.origin === null &&
        this.buffer &&
        ((this._load = Promise.resolve(this)),
        (this.loaded = !0),
        this.onBlobLoaded(this.buffer.rawBinaryData)));
  }
  onBlobLoaded(e) {}
  load() {
    return this._load
      ? this._load
      : ((this._load = fetch(this.origin)
          .then((e) => e.blob())
          .then((e) => e.arrayBuffer())
          .then(
            (e) => (
              (this.data = new Uint32Array(e)),
              (this.buffer = new G3(e)),
              (this.loaded = !0),
              this.onBlobLoaded(e),
              this.update(),
              this
            ),
          )),
        this._load);
  }
}
class lu extends tpe {
  constructor(e, t) {
    (super(e, t),
      (this.format = t.format),
      (this.levels = t.levels || 1),
      (this._width = t.width),
      (this._height = t.height),
      (this._extension = lu._formatToExtension(this.format)),
      (t.levelBuffers || this.buffer) &&
        (this._levelBuffers =
          t.levelBuffers ||
          lu._createLevelBuffers(
            e instanceof Uint8Array ? e : this.buffer.uint8View,
            this.format,
            this.levels,
            4,
            4,
            this.width,
            this.height,
          )));
  }
  upload(e, t, i) {
    const r = e.gl;
    if (!e.context.extensions[this._extension])
      throw new Error(
        `${this._extension} textures are not supported on the current machine`,
      );
    if (!this._levelBuffers) return !1;
    r.pixelStorei(r.UNPACK_ALIGNMENT, 4);
    for (let s = 0, o = this.levels; s < o; s++) {
      const {
        levelID: a,
        levelWidth: l,
        levelHeight: c,
        levelBuffer: u,
      } = this._levelBuffers[s];
      r.compressedTexImage2D(r.TEXTURE_2D, a, this.format, l, c, 0, u);
    }
    return !0;
  }
  onBlobLoaded() {
    this._levelBuffers = lu._createLevelBuffers(
      this.buffer.uint8View,
      this.format,
      this.levels,
      4,
      4,
      this.width,
      this.height,
    );
  }
  static _formatToExtension(e) {
    if (e >= 33776 && e <= 33779) return "s3tc";
    if (e >= 37488 && e <= 37497) return "etc";
    if (e >= 35840 && e <= 35843) return "pvrtc";
    if (e >= 36196) return "etc1";
    if (e >= 35986 && e <= 34798) return "atc";
    throw new Error("Invalid (compressed) texture format given!");
  }
  static _createLevelBuffers(e, t, i, r, s, o, a) {
    const l = new Array(i);
    let c = e.byteOffset,
      u = o,
      h = a,
      d = (u + r - 1) & ~(r - 1),
      f = (h + s - 1) & ~(s - 1),
      g = d * f * AC[t];
    for (let p = 0; p < i; p++)
      ((l[p] = {
        levelID: p,
        levelWidth: i > 1 ? u : d,
        levelHeight: i > 1 ? h : f,
        levelBuffer: new Uint8Array(e.buffer, c, g),
      }),
        (c += g),
        (u = u >> 1 || 1),
        (h = h >> 1 || 1),
        (d = (u + r - 1) & ~(r - 1)),
        (f = (h + s - 1) & ~(s - 1)),
        (g = d * f * AC[t]));
    return l;
  }
}
const VA = 4,
  j1 = 124,
  npe = 32,
  H6 = 20,
  ipe = 542327876,
  $1 = {
    SIZE: 1,
    FLAGS: 2,
    HEIGHT: 3,
    WIDTH: 4,
    MIPMAP_COUNT: 7,
    PIXEL_FORMAT: 19,
  },
  rpe = {
    SIZE: 0,
    FLAGS: 1,
    FOURCC: 2,
    RGB_BITCOUNT: 3,
    R_BIT_MASK: 4,
    G_BIT_MASK: 5,
    B_BIT_MASK: 6,
    A_BIT_MASK: 7,
  },
  J1 = {
    DXGI_FORMAT: 0,
    RESOURCE_DIMENSION: 1,
    MISC_FLAG: 2,
    ARRAY_SIZE: 3,
    MISC_FLAGS2: 4,
  },
  spe = 1,
  ope = 2,
  ape = 4,
  lpe = 64,
  cpe = 512,
  upe = 131072,
  hpe = 827611204,
  dpe = 861165636,
  fpe = 894720068,
  gpe = 808540228,
  ppe = 4,
  mpe = {
    [hpe]: Hr.COMPRESSED_RGBA_S3TC_DXT1_EXT,
    [dpe]: Hr.COMPRESSED_RGBA_S3TC_DXT3_EXT,
    [fpe]: Hr.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  },
  Cpe = {
    70: Hr.COMPRESSED_RGBA_S3TC_DXT1_EXT,
    71: Hr.COMPRESSED_RGBA_S3TC_DXT1_EXT,
    73: Hr.COMPRESSED_RGBA_S3TC_DXT3_EXT,
    74: Hr.COMPRESSED_RGBA_S3TC_DXT3_EXT,
    76: Hr.COMPRESSED_RGBA_S3TC_DXT5_EXT,
    77: Hr.COMPRESSED_RGBA_S3TC_DXT5_EXT,
    72: Hr.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
    75: Hr.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
    78: Hr.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,
  };
function Ipe(n) {
  const e = new Uint32Array(n);
  if (e[0] !== ipe) throw new Error("Invalid DDS file magic word");
  const t = new Uint32Array(n, 0, j1 / Uint32Array.BYTES_PER_ELEMENT),
    i = t[$1.HEIGHT],
    r = t[$1.WIDTH],
    s = t[$1.MIPMAP_COUNT],
    o = new Uint32Array(
      n,
      $1.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT,
      npe / Uint32Array.BYTES_PER_ELEMENT,
    ),
    a = o[spe];
  if (a & ape) {
    const l = o[rpe.FOURCC];
    if (l !== gpe) {
      const A = mpe[l],
        I = VA + j1,
        y = new Uint8Array(n, I);
      return [new lu(y, { format: A, width: r, height: i, levels: s })];
    }
    const c = VA + j1,
      u = new Uint32Array(e.buffer, c, H6 / Uint32Array.BYTES_PER_ELEMENT),
      h = u[J1.DXGI_FORMAT],
      d = u[J1.RESOURCE_DIMENSION],
      f = u[J1.MISC_FLAG],
      g = u[J1.ARRAY_SIZE],
      p = Cpe[h];
    if (p === void 0)
      throw new Error(
        `DDSParser cannot parse texture data with DXGI format ${h}`,
      );
    if (f === ppe)
      throw new Error("DDSParser does not support cubemap textures");
    if (d === 6)
      throw new Error("DDSParser does not supported 3D texture data");
    const m = new Array(),
      C = VA + j1 + H6;
    if (g === 1) m.push(new Uint8Array(n, C));
    else {
      const A = AC[p];
      let I = 0,
        y = r,
        x = i;
      for (let S = 0; S < s; S++) {
        const E = Math.max(1, (y + 3) & -4),
          _ = Math.max(1, (x + 3) & -4),
          b = E * _ * A;
        ((I += b), (y = y >>> 1), (x = x >>> 1));
      }
      let T = C;
      for (let S = 0; S < g; S++) (m.push(new Uint8Array(n, T, I)), (T += I));
    }
    return m.map(
      (A) => new lu(A, { format: p, width: r, height: i, levels: s }),
    );
  }
  throw a & lpe
    ? new Error("DDSParser does not support uncompressed texture data.")
    : a & cpe
      ? new Error("DDSParser does not supported YUV uncompressed texture data.")
      : a & upe
        ? new Error(
            "DDSParser does not support single-channel (lumninance) texture data!",
          )
        : a & ope
          ? new Error(
              "DDSParser does not support single-channel (alpha) texture data!",
            )
          : new Error(
              "DDSParser failed to load a texture file due to an unknown reason!",
            );
}
const W6 = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10],
  Ape = 67305985,
  Us = {
    FILE_IDENTIFIER: 0,
    ENDIANNESS: 12,
    GL_TYPE: 16,
    GL_TYPE_SIZE: 20,
    GL_FORMAT: 24,
    GL_INTERNAL_FORMAT: 28,
    GL_BASE_INTERNAL_FORMAT: 32,
    PIXEL_WIDTH: 36,
    PIXEL_HEIGHT: 40,
    PIXEL_DEPTH: 44,
    NUMBER_OF_ARRAY_ELEMENTS: 48,
    NUMBER_OF_FACES: 52,
    NUMBER_OF_MIPMAP_LEVELS: 56,
    BYTES_OF_KEY_VALUE_DATA: 60,
  },
  ob = 64,
  V6 = {
    [et.UNSIGNED_BYTE]: 1,
    [et.UNSIGNED_SHORT]: 2,
    [et.INT]: 4,
    [et.UNSIGNED_INT]: 4,
    [et.FLOAT]: 4,
    [et.HALF_FLOAT]: 8,
  },
  ype = {
    [ve.RGBA]: 4,
    [ve.RGB]: 3,
    [ve.RG]: 2,
    [ve.RED]: 1,
    [ve.LUMINANCE]: 1,
    [ve.LUMINANCE_ALPHA]: 2,
    [ve.ALPHA]: 1,
  },
  _pe = {
    [et.UNSIGNED_SHORT_4_4_4_4]: 2,
    [et.UNSIGNED_SHORT_5_5_5_1]: 2,
    [et.UNSIGNED_SHORT_5_6_5]: 2,
  };
function bpe(n, e, t = !1) {
  const i = new DataView(e);
  if (!vpe(n, i)) return null;
  const r = i.getUint32(Us.ENDIANNESS, !0) === Ape,
    s = i.getUint32(Us.GL_TYPE, r),
    o = i.getUint32(Us.GL_FORMAT, r),
    a = i.getUint32(Us.GL_INTERNAL_FORMAT, r),
    l = i.getUint32(Us.PIXEL_WIDTH, r),
    c = i.getUint32(Us.PIXEL_HEIGHT, r) || 1,
    u = i.getUint32(Us.PIXEL_DEPTH, r) || 1,
    h = i.getUint32(Us.NUMBER_OF_ARRAY_ELEMENTS, r) || 1,
    d = i.getUint32(Us.NUMBER_OF_FACES, r),
    f = i.getUint32(Us.NUMBER_OF_MIPMAP_LEVELS, r),
    g = i.getUint32(Us.BYTES_OF_KEY_VALUE_DATA, r);
  if (c === 0 || u !== 1) throw new Error("Only 2D textures are supported");
  if (d !== 1)
    throw new Error("CubeTextures are not supported by KTXLoader yet!");
  if (h !== 1) throw new Error("WebGL does not support array textures");
  const p = 4,
    m = 4,
    C = (l + 3) & -4,
    A = (c + 3) & -4,
    I = new Array(h);
  let y = l * c;
  s === 0 && (y = C * A);
  let x;
  if (
    (s !== 0 ? (V6[s] ? (x = V6[s] * ype[o]) : (x = _pe[s])) : (x = AC[a]),
    x === void 0)
  )
    throw new Error(
      "Unable to resolve the pixel format stored in the *.ktx file!",
    );
  const T = t ? wpe(i, g, r) : null;
  let S = y * x,
    E = l,
    _ = c,
    b = C,
    R = A,
    M = ob + g;
  for (let L = 0; L < f; L++) {
    const P = i.getUint32(M, r);
    let U = M + 4;
    for (let O = 0; O < h; O++) {
      let V = I[O];
      (V || (V = I[O] = new Array(f)),
        (V[L] = {
          levelID: L,
          levelWidth: f > 1 || s !== 0 ? E : b,
          levelHeight: f > 1 || s !== 0 ? _ : R,
          levelBuffer: new Uint8Array(e, U, S),
        }),
        (U += S));
    }
    ((M += P + 4),
      (M = M % 4 !== 0 ? M + 4 - (M % 4) : M),
      (E = E >> 1 || 1),
      (_ = _ >> 1 || 1),
      (b = (E + p - 1) & ~(p - 1)),
      (R = (_ + m - 1) & ~(m - 1)),
      (S = b * R * x));
  }
  return s !== 0
    ? {
        uncompressed: I.map((L) => {
          let P = L[0].levelBuffer,
            U = !1;
          return (
            s === et.FLOAT
              ? (P = new Float32Array(
                  L[0].levelBuffer.buffer,
                  L[0].levelBuffer.byteOffset,
                  L[0].levelBuffer.byteLength / 4,
                ))
              : s === et.UNSIGNED_INT
                ? ((U = !0),
                  (P = new Uint32Array(
                    L[0].levelBuffer.buffer,
                    L[0].levelBuffer.byteOffset,
                    L[0].levelBuffer.byteLength / 4,
                  )))
                : s === et.INT &&
                  ((U = !0),
                  (P = new Int32Array(
                    L[0].levelBuffer.buffer,
                    L[0].levelBuffer.byteOffset,
                    L[0].levelBuffer.byteLength / 4,
                  ))),
            {
              resource: new gI(P, {
                width: L[0].levelWidth,
                height: L[0].levelHeight,
              }),
              type: s,
              format: U ? xpe(o) : o,
            }
          );
        }),
        kvData: T,
      }
    : {
        compressed: I.map(
          (L) =>
            new lu(null, {
              format: a,
              width: l,
              height: c,
              levels: f,
              levelBuffers: L,
            }),
        ),
        kvData: T,
      };
}
function vpe(n, e) {
  for (let t = 0; t < W6.length; t++)
    if (e.getUint8(t) !== W6[t])
      return (console.error(`${n} is not a valid *.ktx file!`), !1);
  return !0;
}
function xpe(n) {
  switch (n) {
    case ve.RGBA:
      return ve.RGBA_INTEGER;
    case ve.RGB:
      return ve.RGB_INTEGER;
    case ve.RG:
      return ve.RG_INTEGER;
    case ve.RED:
      return ve.RED_INTEGER;
    default:
      return n;
  }
}
function wpe(n, e, t) {
  const i = new Map();
  let r = 0;
  for (; r < e; ) {
    const s = n.getUint32(ob + r, t),
      o = ob + r + 4,
      a = 3 - ((s + 3) % 4);
    if (s === 0 || s > e - r) {
      console.error("KTXLoader: keyAndValueByteSize out of bounds");
      break;
    }
    let l = 0;
    for (; l < s && n.getUint8(o + l) !== 0; l++);
    if (l === -1) {
      console.error(
        "KTXLoader: Failed to find null byte terminating kvData key",
      );
      break;
    }
    const c = new TextDecoder().decode(new Uint8Array(n.buffer, o, l)),
      u = new DataView(n.buffer, o + l + 1, s - l - 1);
    (i.set(c, u), (r += 4 + s + a));
  }
  return i;
}
const Spe = {
  extension: { type: De.LoadParser, priority: oo.High },
  name: "loadDDS",
  test(n) {
    return Xl(n, ".dds");
  },
  async load(n, e, t) {
    const i = await (await Oe.ADAPTER.fetch(n)).arrayBuffer(),
      r = Ipe(i).map((s) => {
        const o = new St(s, {
          mipmap: Ho.OFF,
          alphaMode: Tr.NO_PREMULTIPLIED_ALPHA,
          resolution: Ga(n),
          ...e.data,
        });
        return Pp(o, t, n);
      });
    return r.length === 1 ? r[0] : r;
  },
  unload(n) {
    Array.isArray(n) ? n.forEach((e) => e.destroy(!0)) : n.destroy(!0);
  },
};
je.add(Spe);
const Tpe = {
  extension: { type: De.LoadParser, priority: oo.High },
  name: "loadKTX",
  test(n) {
    return Xl(n, ".ktx");
  },
  async load(n, e, t) {
    const i = await (await Oe.ADAPTER.fetch(n)).arrayBuffer(),
      { compressed: r, uncompressed: s, kvData: o } = bpe(n, i),
      a = r ?? s,
      l = {
        mipmap: Ho.OFF,
        alphaMode: Tr.NO_PREMULTIPLIED_ALPHA,
        resolution: Ga(n),
        ...e.data,
      },
      c = a.map((u) => {
        a === s && Object.assign(l, { type: u.type, format: u.format });
        const h = u.resource ?? u,
          d = new St(h, l);
        return ((d.ktxKeyValueData = o), Pp(d, t, n));
      });
    return c.length === 1 ? c[0] : c;
  },
  unload(n) {
    Array.isArray(n) ? n.forEach((e) => e.destroy(!0)) : n.destroy(!0);
  },
};
je.add(Tpe);
const Epe = {
  extension: De.ResolveParser,
  test: (n) => {
    const e = n.split("?")[0].split(".").pop();
    return ["basis", "ktx", "dds"].includes(e);
  },
  parse: (n) => {
    if (n.split("?")[0].split(".").pop() === "ktx") {
      const e = [
        ".s3tc.ktx",
        ".s3tc_sRGB.ktx",
        ".etc.ktx",
        ".etc1.ktx",
        ".pvrt.ktx",
        ".atc.ktx",
        ".astc.ktx",
      ];
      if (e.some((t) => n.endsWith(t)))
        return {
          resolution: parseFloat(Oe.RETINA_PREFIX.exec(n)?.[1] ?? "1"),
          format: e.find((t) => n.endsWith(t)),
          src: n,
        };
    }
    return {
      resolution: parseFloat(Oe.RETINA_PREFIX.exec(n)?.[1] ?? "1"),
      format: n.split(".").pop(),
      src: n,
    };
  },
};
je.add(Epe);
const Q1 = new Bt(),
  Mpe = 4,
  tN = class zf {
    constructor(e) {
      ((this.renderer = e), (this._rendererPremultipliedAlpha = !1));
    }
    contextChange() {
      const e = this.renderer?.gl.getContextAttributes();
      this._rendererPremultipliedAlpha = !!(
        e &&
        e.alpha &&
        e.premultipliedAlpha
      );
    }
    async image(e, t, i, r) {
      const s = new Image();
      return ((s.src = await this.base64(e, t, i, r)), s);
    }
    async base64(e, t, i, r) {
      const s = this.canvas(e, r);
      if (s.toBlob !== void 0)
        return new Promise((o, a) => {
          s.toBlob(
            (l) => {
              if (!l) {
                a(new Error("ICanvas.toBlob failed!"));
                return;
              }
              const c = new FileReader();
              ((c.onload = () => o(c.result)),
                (c.onerror = a),
                c.readAsDataURL(l));
            },
            t,
            i,
          );
        });
      if (s.toDataURL !== void 0) return s.toDataURL(t, i);
      if (s.convertToBlob !== void 0) {
        const o = await s.convertToBlob({ type: t, quality: i });
        return new Promise((a, l) => {
          const c = new FileReader();
          ((c.onload = () => a(c.result)), (c.onerror = l), c.readAsDataURL(o));
        });
      }
      throw new Error(
        "Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented",
      );
    }
    canvas(e, t) {
      const {
        pixels: i,
        width: r,
        height: s,
        flipY: o,
        premultipliedAlpha: a,
      } = this._rawPixels(e, t);
      (o && zf._flipY(i, r, s), a && zf._unpremultiplyAlpha(i));
      const l = new dde(r, s, 1),
        c = new ImageData(new Uint8ClampedArray(i.buffer), r, s);
      return (l.context.putImageData(c, 0, 0), l.canvas);
    }
    pixels(e, t) {
      const {
        pixels: i,
        width: r,
        height: s,
        flipY: o,
        premultipliedAlpha: a,
      } = this._rawPixels(e, t);
      return (o && zf._flipY(i, r, s), a && zf._unpremultiplyAlpha(i), i);
    }
    _rawPixels(e, t) {
      const i = this.renderer;
      if (!i) throw new Error("The Extract has already been destroyed");
      let r,
        s = !1,
        o = !1,
        a,
        l = !1;
      e &&
        (e instanceof Eu
          ? (a = e)
          : ((a = i.generateTexture(e, {
              region: t,
              resolution: i.resolution,
              multisample: i.multisample,
            })),
            (l = !0),
            t && ((Q1.width = t.width), (Q1.height = t.height), (t = Q1))));
      const c = i.gl;
      if (a) {
        if (
          ((r = a.baseTexture.resolution),
          (t = t ?? a.frame),
          (s = !1),
          (o = a.baseTexture.alphaMode > 0 && a.baseTexture.format === ve.RGBA),
          !l)
        ) {
          i.renderTexture.bind(a);
          const f = a.framebuffer.glFramebuffers[i.CONTEXT_UID];
          f.blitFramebuffer && i.framebuffer.bind(f.blitFramebuffer);
        }
      } else
        ((r = i.resolution),
          t || ((t = Q1), (t.width = i.width / r), (t.height = i.height / r)),
          (s = !0),
          (o = this._rendererPremultipliedAlpha),
          i.renderTexture.bind());
      const u = Math.max(Math.round(t.width * r), 1),
        h = Math.max(Math.round(t.height * r), 1),
        d = new Uint8Array(Mpe * u * h);
      return (
        c.readPixels(
          Math.round(t.x * r),
          Math.round(t.y * r),
          u,
          h,
          c.RGBA,
          c.UNSIGNED_BYTE,
          d,
        ),
        l && a?.destroy(!0),
        { pixels: d, width: u, height: h, flipY: s, premultipliedAlpha: o }
      );
    }
    destroy() {
      this.renderer = null;
    }
    static _flipY(e, t, i) {
      const r = t << 2,
        s = i >> 1,
        o = new Uint8Array(r);
      for (let a = 0; a < s; a++) {
        const l = a * r,
          c = (i - a - 1) * r;
        (o.set(e.subarray(l, l + r)), e.copyWithin(l, c, c + r), e.set(o, c));
      }
    }
    static _unpremultiplyAlpha(e) {
      e instanceof Uint8ClampedArray && (e = new Uint8Array(e.buffer));
      const t = e.length;
      for (let i = 0; i < t; i += 4) {
        const r = e[i + 3];
        if (r !== 0) {
          const s = 255.001 / r;
          ((e[i] = e[i] * s + 0.5),
            (e[i + 1] = e[i + 1] * s + 0.5),
            (e[i + 2] = e[i + 2] * s + 0.5));
        }
      }
    }
  };
tN.extension = { name: "extract", type: De.RendererSystem };
let Lpe = tN;
je.add(Lpe);
const yC = {
  build(n) {
    const e = n.points;
    let t, i, r, s, o, a;
    if (n.type === Fi.CIRC) {
      const g = n.shape;
      ((t = g.x), (i = g.y), (o = a = g.radius), (r = s = 0));
    } else if (n.type === Fi.ELIP) {
      const g = n.shape;
      ((t = g.x), (i = g.y), (o = g.width), (a = g.height), (r = s = 0));
    } else {
      const g = n.shape,
        p = g.width / 2,
        m = g.height / 2;
      ((t = g.x + p),
        (i = g.y + m),
        (o = a = Math.max(0, Math.min(g.radius, Math.min(p, m)))),
        (r = p - o),
        (s = m - a));
    }
    if (!(o >= 0 && a >= 0 && r >= 0 && s >= 0)) {
      e.length = 0;
      return;
    }
    const l = Math.ceil(2.3 * Math.sqrt(o + a)),
      c = l * 8 + (r ? 4 : 0) + (s ? 4 : 0);
    if (((e.length = c), c === 0)) return;
    if (l === 0) {
      ((e.length = 8),
        (e[0] = e[6] = t + r),
        (e[1] = e[3] = i + s),
        (e[2] = e[4] = t - r),
        (e[5] = e[7] = i - s));
      return;
    }
    let u = 0,
      h = l * 4 + (r ? 2 : 0) + 2,
      d = h,
      f = c;
    {
      const g = r + o,
        p = s,
        m = t + g,
        C = t - g,
        A = i + p;
      if (((e[u++] = m), (e[u++] = A), (e[--h] = A), (e[--h] = C), s)) {
        const I = i - p;
        ((e[d++] = C), (e[d++] = I), (e[--f] = I), (e[--f] = m));
      }
    }
    for (let g = 1; g < l; g++) {
      const p = (Math.PI / 2) * (g / l),
        m = r + Math.cos(p) * o,
        C = s + Math.sin(p) * a,
        A = t + m,
        I = t - m,
        y = i + C,
        x = i - C;
      ((e[u++] = A),
        (e[u++] = y),
        (e[--h] = y),
        (e[--h] = I),
        (e[d++] = I),
        (e[d++] = x),
        (e[--f] = x),
        (e[--f] = A));
    }
    {
      const g = r,
        p = s + a,
        m = t + g,
        C = t - g,
        A = i + p,
        I = i - p;
      ((e[u++] = m),
        (e[u++] = A),
        (e[--f] = I),
        (e[--f] = m),
        r && ((e[u++] = C), (e[u++] = A), (e[--f] = I), (e[--f] = C)));
    }
  },
  triangulate(n, e) {
    const t = n.points,
      i = e.points,
      r = e.indices;
    if (t.length === 0) return;
    let s = i.length / 2;
    const o = s;
    let a, l;
    if (n.type !== Fi.RREC) {
      const u = n.shape;
      ((a = u.x), (l = u.y));
    } else {
      const u = n.shape;
      ((a = u.x + u.width / 2), (l = u.y + u.height / 2));
    }
    const c = n.matrix;
    (i.push(
      n.matrix ? c.a * a + c.c * l + c.tx : a,
      n.matrix ? c.b * a + c.d * l + c.ty : l,
    ),
      s++,
      i.push(t[0], t[1]));
    for (let u = 2; u < t.length; u += 2)
      (i.push(t[u], t[u + 1]), r.push(s++, o, s));
    r.push(o + 1, o, s);
  },
};
function Z6(n, e = !1) {
  const t = n.length;
  if (t < 6) return;
  let i = 0;
  for (let r = 0, s = n[t - 2], o = n[t - 1]; r < t; r += 2) {
    const a = n[r],
      l = n[r + 1];
    ((i += (a - s) * (l + o)), (s = a), (o = l));
  }
  if ((!e && i > 0) || (e && i <= 0)) {
    const r = t / 2;
    for (let s = r + (r % 2); s < t; s += 2) {
      const o = t - s - 2,
        a = t - s - 1,
        l = s,
        c = s + 1;
      (([n[o], n[l]] = [n[l], n[o]]), ([n[a], n[c]] = [n[c], n[a]]));
    }
  }
}
const nN = {
    build(n) {
      n.points = n.shape.points.slice();
    },
    triangulate(n, e) {
      let t = n.points;
      const i = n.holes,
        r = e.points,
        s = e.indices;
      if (t.length >= 6) {
        Z6(t, !1);
        const o = [];
        for (let c = 0; c < i.length; c++) {
          const u = i[c];
          (Z6(u.points, !0), o.push(t.length / 2), (t = t.concat(u.points)));
        }
        const a = Zce(t, o, 2);
        if (!a) return;
        const l = r.length / 2;
        for (let c = 0; c < a.length; c += 3)
          (s.push(a[c] + l), s.push(a[c + 1] + l), s.push(a[c + 2] + l));
        for (let c = 0; c < t.length; c++) r.push(t[c]);
      }
    },
  },
  Rpe = {
    build(n) {
      const e = n.shape,
        t = e.x,
        i = e.y,
        r = e.width,
        s = e.height,
        o = n.points;
      ((o.length = 0),
        r >= 0 && s >= 0 && o.push(t, i, t + r, i, t + r, i + s, t, i + s));
    },
    triangulate(n, e) {
      const t = n.points,
        i = e.points;
      if (t.length === 0) return;
      const r = i.length / 2;
      (i.push(t[0], t[1], t[2], t[3], t[6], t[7], t[4], t[5]),
        e.indices.push(r, r + 1, r + 2, r + 1, r + 2, r + 3));
    },
  },
  Bpe = {
    build(n) {
      yC.build(n);
    },
    triangulate(n, e) {
      yC.triangulate(n, e);
    },
  };
var ps = ((n) => (
    (n.MITER = "miter"),
    (n.BEVEL = "bevel"),
    (n.ROUND = "round"),
    n
  ))(ps || {}),
  vl = ((n) => (
    (n.BUTT = "butt"),
    (n.ROUND = "round"),
    (n.SQUARE = "square"),
    n
  ))(vl || {});
const bd = {
  adaptive: !0,
  maxLength: 10,
  minSegments: 8,
  maxSegments: 2048,
  epsilon: 1e-4,
  _segmentsCount(n, e = 20) {
    if (!this.adaptive || !n || isNaN(n)) return e;
    let t = Math.ceil(n / this.maxLength);
    return (
      t < this.minSegments
        ? (t = this.minSegments)
        : t > this.maxSegments && (t = this.maxSegments),
      t
    );
  },
};
class z6 {
  static curveTo(e, t, i, r, s, o) {
    const a = o[o.length - 2],
      l = o[o.length - 1] - t,
      c = a - e,
      u = r - t,
      h = i - e,
      d = Math.abs(l * h - c * u);
    if (d < 1e-8 || s === 0)
      return (
        (o[o.length - 2] !== e || o[o.length - 1] !== t) && o.push(e, t),
        null
      );
    const f = l * l + c * c,
      g = u * u + h * h,
      p = l * u + c * h,
      m = (s * Math.sqrt(f)) / d,
      C = (s * Math.sqrt(g)) / d,
      A = (m * p) / f,
      I = (C * p) / g,
      y = m * h + C * c,
      x = m * u + C * l,
      T = c * (C + A),
      S = l * (C + A),
      E = h * (m + I),
      _ = u * (m + I),
      b = Math.atan2(S - x, T - y),
      R = Math.atan2(_ - x, E - y);
    return {
      cx: y + e,
      cy: x + t,
      radius: s,
      startAngle: b,
      endAngle: R,
      anticlockwise: c * u > h * l,
    };
  }
  static arc(e, t, i, r, s, o, a, l, c) {
    const u = a - o,
      h = bd._segmentsCount(Math.abs(u) * s, Math.ceil(Math.abs(u) / hC) * 40),
      d = u / (h * 2),
      f = d * 2,
      g = Math.cos(d),
      p = Math.sin(d),
      m = h - 1,
      C = (m % 1) / m;
    for (let A = 0; A <= m; ++A) {
      const I = A + C * A,
        y = d + o + f * I,
        x = Math.cos(y),
        T = -Math.sin(y);
      c.push((g * x + p * T) * s + i, (g * -T + p * x) * s + r);
    }
  }
}
class Ppe {
  constructor() {
    this.reset();
  }
  begin(e, t, i) {
    (this.reset(), (this.style = e), (this.start = t), (this.attribStart = i));
  }
  end(e, t) {
    ((this.attribSize = t - this.attribStart), (this.size = e - this.start));
  }
  reset() {
    ((this.style = null),
      (this.size = 0),
      (this.start = 0),
      (this.attribStart = 0),
      (this.attribSize = 0));
  }
}
class M5 {
  static curveLength(e, t, i, r, s, o, a, l) {
    let c = 0,
      u = 0,
      h = 0,
      d = 0,
      f = 0,
      g = 0,
      p = 0,
      m = 0,
      C = 0,
      A = 0,
      I = 0,
      y = e,
      x = t;
    for (let T = 1; T <= 10; ++T)
      ((u = T / 10),
        (h = u * u),
        (d = h * u),
        (f = 1 - u),
        (g = f * f),
        (p = g * f),
        (m = p * e + 3 * g * u * i + 3 * f * h * s + d * a),
        (C = p * t + 3 * g * u * r + 3 * f * h * o + d * l),
        (A = y - m),
        (I = x - C),
        (y = m),
        (x = C),
        (c += Math.sqrt(A * A + I * I)));
    return c;
  }
  static curveTo(e, t, i, r, s, o, a) {
    const l = a[a.length - 2],
      c = a[a.length - 1];
    a.length -= 2;
    const u = bd._segmentsCount(M5.curveLength(l, c, e, t, i, r, s, o));
    let h = 0,
      d = 0,
      f = 0,
      g = 0,
      p = 0;
    a.push(l, c);
    for (let m = 1, C = 0; m <= u; ++m)
      ((C = m / u),
        (h = 1 - C),
        (d = h * h),
        (f = d * h),
        (g = C * C),
        (p = g * C),
        a.push(
          f * l + 3 * d * C * e + 3 * h * g * i + p * s,
          f * c + 3 * d * C * t + 3 * h * g * r + p * o,
        ));
  }
}
function Y6(n, e, t, i, r, s, o, a) {
  const l = n - t * r,
    c = e - i * r,
    u = n + t * s,
    h = e + i * s;
  let d, f;
  o ? ((d = i), (f = -t)) : ((d = -i), (f = t));
  const g = l + d,
    p = c + f,
    m = u + d,
    C = h + f;
  return (a.push(g, p, m, C), 2);
}
function gc(n, e, t, i, r, s, o, a) {
  const l = t - n,
    c = i - e;
  let u = Math.atan2(l, c),
    h = Math.atan2(r - n, s - e);
  a && u < h ? (u += Math.PI * 2) : !a && u > h && (h += Math.PI * 2);
  let d = u;
  const f = h - u,
    g = Math.abs(f),
    p = Math.sqrt(l * l + c * c),
    m = (((15 * g * Math.sqrt(p)) / Math.PI) >> 0) + 1,
    C = f / m;
  if (((d += C), a)) {
    o.push(n, e, t, i);
    for (let A = 1, I = d; A < m; A++, I += C)
      o.push(n, e, n + Math.sin(I) * p, e + Math.cos(I) * p);
    o.push(n, e, r, s);
  } else {
    o.push(t, i, n, e);
    for (let A = 1, I = d; A < m; A++, I += C)
      o.push(n + Math.sin(I) * p, e + Math.cos(I) * p, n, e);
    o.push(r, s, n, e);
  }
  return m * 2;
}
function Npe(n, e) {
  const t = n.shape;
  let i = n.points || t.points.slice();
  const r = e.closePointEps;
  if (i.length === 0) return;
  const s = n.lineStyle,
    o = new Qt(i[0], i[1]),
    a = new Qt(i[i.length - 2], i[i.length - 1]),
    l = t.type !== Fi.POLY || t.closeStroke,
    c = Math.abs(o.x - a.x) < r && Math.abs(o.y - a.y) < r;
  if (l) {
    ((i = i.slice()),
      c && (i.pop(), i.pop(), a.set(i[i.length - 2], i[i.length - 1])));
    const V = (o.x + a.x) * 0.5,
      W = (a.y + o.y) * 0.5;
    (i.unshift(V, W), i.push(V, W));
  }
  const u = e.points,
    h = i.length / 2;
  let d = i.length;
  const f = u.length / 2,
    g = s.width / 2,
    p = g * g,
    m = s.miterLimit * s.miterLimit;
  let C = i[0],
    A = i[1],
    I = i[2],
    y = i[3],
    x = 0,
    T = 0,
    S = -(A - y),
    E = C - I,
    _ = 0,
    b = 0,
    R = Math.sqrt(S * S + E * E);
  ((S /= R), (E /= R), (S *= g), (E *= g));
  const M = s.alignment,
    L = (1 - M) * 2,
    P = M * 2;
  (l ||
    (s.cap === vl.ROUND
      ? (d +=
          gc(
            C - S * (L - P) * 0.5,
            A - E * (L - P) * 0.5,
            C - S * L,
            A - E * L,
            C + S * P,
            A + E * P,
            u,
            !0,
          ) + 2)
      : s.cap === vl.SQUARE && (d += Y6(C, A, S, E, L, P, !0, u))),
    u.push(C - S * L, A - E * L, C + S * P, A + E * P));
  for (let V = 1; V < h - 1; ++V) {
    ((C = i[(V - 1) * 2]),
      (A = i[(V - 1) * 2 + 1]),
      (I = i[V * 2]),
      (y = i[V * 2 + 1]),
      (x = i[(V + 1) * 2]),
      (T = i[(V + 1) * 2 + 1]),
      (S = -(A - y)),
      (E = C - I),
      (R = Math.sqrt(S * S + E * E)),
      (S /= R),
      (E /= R),
      (S *= g),
      (E *= g),
      (_ = -(y - T)),
      (b = I - x),
      (R = Math.sqrt(_ * _ + b * b)),
      (_ /= R),
      (b /= R),
      (_ *= g),
      (b *= g));
    const W = I - C,
      re = A - y,
      Z = I - x,
      te = T - y,
      ge = W * Z + re * te,
      be = re * Z - te * W,
      J = be < 0;
    if (Math.abs(be) < 0.001 * Math.abs(ge)) {
      (u.push(I - S * L, y - E * L, I + S * P, y + E * P),
        ge >= 0 &&
          (s.join === ps.ROUND
            ? (d +=
                gc(I, y, I - S * L, y - E * L, I - _ * L, y - b * L, u, !1) + 4)
            : (d += 2),
          u.push(I - _ * P, y - b * P, I + _ * L, y + b * L)));
      continue;
    }
    const se = (-S + C) * (-E + y) - (-S + I) * (-E + A),
      ce = (-_ + x) * (-b + y) - (-_ + I) * (-b + T),
      ae = (W * ce - Z * se) / be,
      Ce = (te * se - re * ce) / be,
      $e = (ae - I) * (ae - I) + (Ce - y) * (Ce - y),
      Te = I + (ae - I) * L,
      it = y + (Ce - y) * L,
      ct = I - (ae - I) * P,
      qe = y - (Ce - y) * P,
      H = Math.min(W * W + re * re, Z * Z + te * te),
      tn = J ? L : P,
      Mt = H + tn * tn * p,
      ot = $e <= Mt;
    let Ae = s.join;
    if ((Ae === ps.MITER && $e / p > m && (Ae = ps.BEVEL), ot))
      switch (Ae) {
        case ps.MITER: {
          u.push(Te, it, ct, qe);
          break;
        }
        case ps.BEVEL: {
          (J
            ? u.push(Te, it, I + S * P, y + E * P, Te, it, I + _ * P, y + b * P)
            : u.push(
                I - S * L,
                y - E * L,
                ct,
                qe,
                I - _ * L,
                y - b * L,
                ct,
                qe,
              ),
            (d += 2));
          break;
        }
        case ps.ROUND: {
          J
            ? (u.push(Te, it, I + S * P, y + E * P),
              (d +=
                gc(I, y, I + S * P, y + E * P, I + _ * P, y + b * P, u, !0) +
                4),
              u.push(Te, it, I + _ * P, y + b * P))
            : (u.push(I - S * L, y - E * L, ct, qe),
              (d +=
                gc(I, y, I - S * L, y - E * L, I - _ * L, y - b * L, u, !1) +
                4),
              u.push(I - _ * L, y - b * L, ct, qe));
          break;
        }
      }
    else {
      switch ((u.push(I - S * L, y - E * L, I + S * P, y + E * P), Ae)) {
        case ps.MITER: {
          (J ? u.push(ct, qe, ct, qe) : u.push(Te, it, Te, it), (d += 2));
          break;
        }
        case ps.ROUND: {
          J
            ? (d +=
                gc(I, y, I + S * P, y + E * P, I + _ * P, y + b * P, u, !0) + 2)
            : (d +=
                gc(I, y, I - S * L, y - E * L, I - _ * L, y - b * L, u, !1) +
                2);
          break;
        }
      }
      (u.push(I - _ * L, y - b * L, I + _ * P, y + b * P), (d += 2));
    }
  }
  ((C = i[(h - 2) * 2]),
    (A = i[(h - 2) * 2 + 1]),
    (I = i[(h - 1) * 2]),
    (y = i[(h - 1) * 2 + 1]),
    (S = -(A - y)),
    (E = C - I),
    (R = Math.sqrt(S * S + E * E)),
    (S /= R),
    (E /= R),
    (S *= g),
    (E *= g),
    u.push(I - S * L, y - E * L, I + S * P, y + E * P),
    l ||
      (s.cap === vl.ROUND
        ? (d +=
            gc(
              I - S * (L - P) * 0.5,
              y - E * (L - P) * 0.5,
              I - S * L,
              y - E * L,
              I + S * P,
              y + E * P,
              u,
              !1,
            ) + 2)
        : s.cap === vl.SQUARE && (d += Y6(I, y, S, E, L, P, !1, u))));
  const U = e.indices,
    O = bd.epsilon * bd.epsilon;
  for (let V = f; V < d + f - 2; ++V)
    ((C = u[V * 2]),
      (A = u[V * 2 + 1]),
      (I = u[(V + 1) * 2]),
      (y = u[(V + 1) * 2 + 1]),
      (x = u[(V + 2) * 2]),
      (T = u[(V + 2) * 2 + 1]),
      !(Math.abs(C * (y - T) + I * (T - A) + x * (A - y)) < O) &&
        U.push(V, V + 1, V + 2));
}
function Dpe(n, e) {
  let t = 0;
  const i = n.shape,
    r = n.points || i.points,
    s = i.type !== Fi.POLY || i.closeStroke;
  if (r.length === 0) return;
  const o = e.points,
    a = e.indices,
    l = r.length / 2,
    c = o.length / 2;
  let u = c;
  for (o.push(r[0], r[1]), t = 1; t < l; t++)
    (o.push(r[t * 2], r[t * 2 + 1]), a.push(u, u + 1), u++);
  s && a.push(u, c);
}
function X6(n, e) {
  n.lineStyle.native ? Dpe(n, e) : Npe(n, e);
}
class L5 {
  static curveLength(e, t, i, r, s, o) {
    const a = e - 2 * i + s,
      l = t - 2 * r + o,
      c = 2 * i - 2 * e,
      u = 2 * r - 2 * t,
      h = 4 * (a * a + l * l),
      d = 4 * (a * c + l * u),
      f = c * c + u * u,
      g = 2 * Math.sqrt(h + d + f),
      p = Math.sqrt(h),
      m = 2 * h * p,
      C = 2 * Math.sqrt(f),
      A = d / p;
    return (
      (m * g +
        p * d * (g - C) +
        (4 * f * h - d * d) * Math.log((2 * p + A + g) / (A + C))) /
      (4 * m)
    );
  }
  static curveTo(e, t, i, r, s) {
    const o = s[s.length - 2],
      a = s[s.length - 1],
      l = bd._segmentsCount(L5.curveLength(o, a, e, t, i, r));
    let c = 0,
      u = 0;
    for (let h = 1; h <= l; ++h) {
      const d = h / l;
      ((c = o + (e - o) * d),
        (u = a + (t - a) * d),
        s.push(c + (e + (i - e) * d - c) * d, u + (t + (r - t) * d - u) * d));
    }
  }
}
const ZA = {
    [Fi.POLY]: nN,
    [Fi.CIRC]: yC,
    [Fi.ELIP]: yC,
    [Fi.RECT]: Rpe,
    [Fi.RREC]: Bpe,
  },
  K6 = [],
  q1 = [];
class _C {
  constructor(e, t = null, i = null, r = null) {
    ((this.points = []),
      (this.holes = []),
      (this.shape = e),
      (this.lineStyle = i),
      (this.fillStyle = t),
      (this.matrix = r),
      (this.type = e.type));
  }
  clone() {
    return new _C(this.shape, this.fillStyle, this.lineStyle, this.matrix);
  }
  destroy() {
    ((this.shape = null),
      (this.holes.length = 0),
      (this.holes = null),
      (this.points.length = 0),
      (this.points = null),
      (this.lineStyle = null),
      (this.fillStyle = null));
  }
}
const eh = new Qt(),
  iN = class rN extends hP {
    constructor() {
      (super(),
        (this.closePointEps = 1e-4),
        (this.boundsPadding = 0),
        (this.uvsFloat32 = null),
        (this.indicesUint16 = null),
        (this.batchable = !1),
        (this.points = []),
        (this.colors = []),
        (this.uvs = []),
        (this.indices = []),
        (this.textureIds = []),
        (this.graphicsData = []),
        (this.drawCalls = []),
        (this.batchDirty = -1),
        (this.batches = []),
        (this.dirty = 0),
        (this.cacheDirty = -1),
        (this.clearDirty = 0),
        (this.shapeIndex = 0),
        (this._bounds = new mC()),
        (this.boundsDirty = -1));
    }
    get bounds() {
      return (
        this.updateBatches(),
        this.boundsDirty !== this.dirty &&
          ((this.boundsDirty = this.dirty), this.calculateBounds()),
        this._bounds
      );
    }
    invalidate() {
      ((this.boundsDirty = -1),
        this.dirty++,
        this.batchDirty++,
        (this.shapeIndex = 0),
        (this.points.length = 0),
        (this.colors.length = 0),
        (this.uvs.length = 0),
        (this.indices.length = 0),
        (this.textureIds.length = 0));
      for (let e = 0; e < this.drawCalls.length; e++)
        (this.drawCalls[e].texArray.clear(), q1.push(this.drawCalls[e]));
      this.drawCalls.length = 0;
      for (let e = 0; e < this.batches.length; e++) {
        const t = this.batches[e];
        (t.reset(), K6.push(t));
      }
      this.batches.length = 0;
    }
    clear() {
      return (
        this.graphicsData.length > 0 &&
          (this.invalidate(),
          this.clearDirty++,
          (this.graphicsData.length = 0)),
        this
      );
    }
    drawShape(e, t = null, i = null, r = null) {
      const s = new _C(e, t, i, r);
      return (this.graphicsData.push(s), this.dirty++, this);
    }
    drawHole(e, t = null) {
      if (!this.graphicsData.length) return null;
      const i = new _C(e, null, null, t),
        r = this.graphicsData[this.graphicsData.length - 1];
      return ((i.lineStyle = r.lineStyle), r.holes.push(i), this.dirty++, this);
    }
    destroy() {
      super.destroy();
      for (let e = 0; e < this.graphicsData.length; ++e)
        this.graphicsData[e].destroy();
      ((this.points.length = 0),
        (this.points = null),
        (this.colors.length = 0),
        (this.colors = null),
        (this.uvs.length = 0),
        (this.uvs = null),
        (this.indices.length = 0),
        (this.indices = null),
        this.indexBuffer.destroy(),
        (this.indexBuffer = null),
        (this.graphicsData.length = 0),
        (this.graphicsData = null),
        (this.drawCalls.length = 0),
        (this.drawCalls = null),
        (this.batches.length = 0),
        (this.batches = null),
        (this._bounds = null));
    }
    containsPoint(e) {
      const t = this.graphicsData;
      for (let i = 0; i < t.length; ++i) {
        const r = t[i];
        if (
          r.fillStyle.visible &&
          r.shape &&
          (r.matrix ? r.matrix.applyInverse(e, eh) : eh.copyFrom(e),
          r.shape.contains(eh.x, eh.y))
        ) {
          let s = !1;
          if (r.holes) {
            for (let o = 0; o < r.holes.length; o++)
              if (r.holes[o].shape.contains(eh.x, eh.y)) {
                s = !0;
                break;
              }
          }
          if (!s) return !0;
        }
      }
      return !1;
    }
    updateBatches() {
      if (!this.graphicsData.length) {
        this.batchable = !0;
        return;
      }
      if (!this.validateBatching()) return;
      this.cacheDirty = this.dirty;
      const e = this.uvs,
        t = this.graphicsData;
      let i = null,
        r = null;
      this.batches.length > 0 &&
        ((i = this.batches[this.batches.length - 1]), (r = i.style));
      for (let l = this.shapeIndex; l < t.length; l++) {
        this.shapeIndex++;
        const c = t[l],
          u = c.fillStyle,
          h = c.lineStyle;
        (ZA[c.type].build(c),
          c.matrix && this.transformPoints(c.points, c.matrix),
          (u.visible || h.visible) && this.processHoles(c.holes));
        for (let d = 0; d < 2; d++) {
          const f = d === 0 ? u : h;
          if (!f.visible) continue;
          const g = f.texture.baseTexture,
            p = this.indices.length,
            m = this.points.length / 2;
          ((g.wrapMode = Ll.REPEAT),
            d === 0 ? this.processFill(c) : this.processLine(c));
          const C = this.points.length / 2 - m;
          C !== 0 &&
            (i && !this._compareStyles(r, f) && (i.end(p, m), (i = null)),
            i ||
              ((i = K6.pop() || new Ppe()),
              i.begin(f, p, m),
              this.batches.push(i),
              (r = f)),
            this.addUvs(this.points, e, f.texture, m, C, f.matrix));
        }
      }
      const s = this.indices.length,
        o = this.points.length / 2;
      if ((i && i.end(s, o), this.batches.length === 0)) {
        this.batchable = !0;
        return;
      }
      const a = o > 65535;
      (this.indicesUint16 &&
      this.indices.length === this.indicesUint16.length &&
      a === this.indicesUint16.BYTES_PER_ELEMENT > 2
        ? this.indicesUint16.set(this.indices)
        : (this.indicesUint16 = a
            ? new Uint32Array(this.indices)
            : new Uint16Array(this.indices)),
        (this.batchable = this.isBatchable()),
        this.batchable ? this.packBatches() : this.buildDrawCalls());
    }
    _compareStyles(e, t) {
      return !(
        !e ||
        !t ||
        e.texture.baseTexture !== t.texture.baseTexture ||
        e.color + e.alpha !== t.color + t.alpha ||
        !!e.native != !!t.native
      );
    }
    validateBatching() {
      if (this.dirty === this.cacheDirty || !this.graphicsData.length)
        return !1;
      for (let e = 0, t = this.graphicsData.length; e < t; e++) {
        const i = this.graphicsData[e],
          r = i.fillStyle,
          s = i.lineStyle;
        if (
          (r && !r.texture.baseTexture.valid) ||
          (s && !s.texture.baseTexture.valid)
        )
          return !1;
      }
      return !0;
    }
    packBatches() {
      (this.batchDirty++, (this.uvsFloat32 = new Float32Array(this.uvs)));
      const e = this.batches;
      for (let t = 0, i = e.length; t < i; t++) {
        const r = e[t];
        for (let s = 0; s < r.size; s++) {
          const o = r.start + s;
          this.indicesUint16[o] = this.indicesUint16[o] - r.attribStart;
        }
      }
    }
    isBatchable() {
      if (this.points.length > 65535 * 2) return !1;
      const e = this.batches;
      for (let t = 0; t < e.length; t++) if (e[t].style.native) return !1;
      return this.points.length < rN.BATCHABLE_SIZE * 2;
    }
    buildDrawCalls() {
      let e = ++St._globalBatch;
      for (let h = 0; h < this.drawCalls.length; h++)
        (this.drawCalls[h].texArray.clear(), q1.push(this.drawCalls[h]));
      this.drawCalls.length = 0;
      const t = this.colors,
        i = this.textureIds;
      let r = q1.pop();
      (r || ((r = new O3()), (r.texArray = new V3())),
        (r.texArray.count = 0),
        (r.start = 0),
        (r.size = 0),
        (r.type = To.TRIANGLES));
      let s = 0,
        o = null,
        a = 0,
        l = !1,
        c = To.TRIANGLES,
        u = 0;
      this.drawCalls.push(r);
      for (let h = 0; h < this.batches.length; h++) {
        const d = this.batches[h],
          f = 8,
          g = d.style,
          p = g.texture.baseTexture;
        (l !== !!g.native &&
          ((l = !!g.native),
          (c = l ? To.LINES : To.TRIANGLES),
          (o = null),
          (s = f),
          e++),
          o !== p &&
            ((o = p),
            p._batchEnabled !== e &&
              (s === f &&
                (e++,
                (s = 0),
                r.size > 0 &&
                  ((r = q1.pop()),
                  r || ((r = new O3()), (r.texArray = new V3())),
                  this.drawCalls.push(r)),
                (r.start = u),
                (r.size = 0),
                (r.texArray.count = 0),
                (r.type = c)),
              (p.touched = 1),
              (p._batchEnabled = e),
              (p._batchLocation = s),
              (p.wrapMode = Ll.REPEAT),
              (r.texArray.elements[r.texArray.count++] = p),
              s++)),
          (r.size += d.size),
          (u += d.size),
          (a = p._batchLocation),
          this.addColors(t, g.color, g.alpha, d.attribSize, d.attribStart),
          this.addTextureIds(i, a, d.attribSize, d.attribStart));
      }
      ((St._globalBatch = e), this.packAttributes());
    }
    packAttributes() {
      const e = this.points,
        t = this.uvs,
        i = this.colors,
        r = this.textureIds,
        s = new ArrayBuffer(e.length * 3 * 4),
        o = new Float32Array(s),
        a = new Uint32Array(s);
      let l = 0;
      for (let c = 0; c < e.length / 2; c++)
        ((o[l++] = e[c * 2]),
          (o[l++] = e[c * 2 + 1]),
          (o[l++] = t[c * 2]),
          (o[l++] = t[c * 2 + 1]),
          (a[l++] = i[c]),
          (o[l++] = r[c]));
      (this._buffer.update(s), this._indexBuffer.update(this.indicesUint16));
    }
    processFill(e) {
      e.holes.length
        ? nN.triangulate(e, this)
        : ZA[e.type].triangulate(e, this);
    }
    processLine(e) {
      X6(e, this);
      for (let t = 0; t < e.holes.length; t++) X6(e.holes[t], this);
    }
    processHoles(e) {
      for (let t = 0; t < e.length; t++) {
        const i = e[t];
        (ZA[i.type].build(i),
          i.matrix && this.transformPoints(i.points, i.matrix));
      }
    }
    calculateBounds() {
      const e = this._bounds;
      (e.clear(),
        e.addVertexData(this.points, 0, this.points.length),
        e.pad(this.boundsPadding, this.boundsPadding));
    }
    transformPoints(e, t) {
      for (let i = 0; i < e.length / 2; i++) {
        const r = e[i * 2],
          s = e[i * 2 + 1];
        ((e[i * 2] = t.a * r + t.c * s + t.tx),
          (e[i * 2 + 1] = t.b * r + t.d * s + t.ty));
      }
    }
    addColors(e, t, i, r, s = 0) {
      const o = Ln.shared.setValue(t).toLittleEndianNumber(),
        a = Ln.shared.setValue(o).toPremultiplied(i);
      e.length = Math.max(e.length, s + r);
      for (let l = 0; l < r; l++) e[s + l] = a;
    }
    addTextureIds(e, t, i, r = 0) {
      e.length = Math.max(e.length, r + i);
      for (let s = 0; s < i; s++) e[r + s] = t;
    }
    addUvs(e, t, i, r, s, o = null) {
      let a = 0;
      const l = t.length,
        c = i.frame;
      for (; a < s; ) {
        let h = e[(r + a) * 2],
          d = e[(r + a) * 2 + 1];
        if (o) {
          const f = o.a * h + o.c * d + o.tx;
          ((d = o.b * h + o.d * d + o.ty), (h = f));
        }
        (a++, t.push(h / c.width, d / c.height));
      }
      const u = i.baseTexture;
      (c.width < u.width || c.height < u.height) && this.adjustUvs(t, i, l, s);
    }
    adjustUvs(e, t, i, r) {
      const s = t.baseTexture,
        o = 1e-6,
        a = i + r * 2,
        l = t.frame,
        c = l.width / s.width,
        u = l.height / s.height;
      let h = l.x / l.width,
        d = l.y / l.height,
        f = Math.floor(e[i] + o),
        g = Math.floor(e[i + 1] + o);
      for (let p = i + 2; p < a; p += 2)
        ((f = Math.min(f, Math.floor(e[p] + o))),
          (g = Math.min(g, Math.floor(e[p + 1] + o))));
      ((h -= f), (d -= g));
      for (let p = i; p < a; p += 2)
        ((e[p] = (e[p] + h) * c), (e[p + 1] = (e[p + 1] + d) * u));
    }
  };
iN.BATCHABLE_SIZE = 100;
let Gpe = iN;
class yI {
  constructor() {
    ((this.color = 16777215),
      (this.alpha = 1),
      (this.texture = Qe.WHITE),
      (this.matrix = null),
      (this.visible = !1),
      this.reset());
  }
  clone() {
    const e = new yI();
    return (
      (e.color = this.color),
      (e.alpha = this.alpha),
      (e.texture = this.texture),
      (e.matrix = this.matrix),
      (e.visible = this.visible),
      e
    );
  }
  reset() {
    ((this.color = 16777215),
      (this.alpha = 1),
      (this.texture = Qe.WHITE),
      (this.matrix = null),
      (this.visible = !1));
  }
  destroy() {
    ((this.texture = null), (this.matrix = null));
  }
}
class R5 extends yI {
  constructor() {
    (super(...arguments),
      (this.width = 0),
      (this.alignment = 0.5),
      (this.native = !1),
      (this.cap = vl.BUTT),
      (this.join = ps.MITER),
      (this.miterLimit = 10));
  }
  clone() {
    const e = new R5();
    return (
      (e.color = this.color),
      (e.alpha = this.alpha),
      (e.texture = this.texture),
      (e.matrix = this.matrix),
      (e.visible = this.visible),
      (e.width = this.width),
      (e.alignment = this.alignment),
      (e.native = this.native),
      (e.cap = this.cap),
      (e.join = this.join),
      (e.miterLimit = this.miterLimit),
      e
    );
  }
  reset() {
    (super.reset(),
      (this.color = 0),
      (this.alignment = 0.5),
      (this.width = 0),
      (this.native = !1),
      (this.cap = vl.BUTT),
      (this.join = ps.MITER),
      (this.miterLimit = 10));
  }
}
const zA = {},
  ab = class tm extends Rs {
    constructor(e = null) {
      (super(),
        (this.shader = null),
        (this.pluginName = "batch"),
        (this.currentPath = null),
        (this.batches = []),
        (this.batchTint = -1),
        (this.batchDirty = -1),
        (this.vertexData = null),
        (this._fillStyle = new yI()),
        (this._lineStyle = new R5()),
        (this._matrix = null),
        (this._holeMode = !1),
        (this.state = Yo.for2d()),
        (this._geometry = e || new Gpe()),
        this._geometry.refCount++,
        (this._transformID = -1),
        (this._tintColor = new Ln(16777215)),
        (this.blendMode = dt.NORMAL));
    }
    get geometry() {
      return this._geometry;
    }
    clone() {
      return (this.finishPoly(), new tm(this._geometry));
    }
    set blendMode(e) {
      this.state.blendMode = e;
    }
    get blendMode() {
      return this.state.blendMode;
    }
    get tint() {
      return this._tintColor.value;
    }
    set tint(e) {
      this._tintColor.setValue(e);
    }
    get fill() {
      return this._fillStyle;
    }
    get line() {
      return this._lineStyle;
    }
    lineStyle(e = null, t = 0, i, r = 0.5, s = !1) {
      return (
        typeof e == "number" &&
          (e = { width: e, color: t, alpha: i, alignment: r, native: s }),
        this.lineTextureStyle(e)
      );
    }
    lineTextureStyle(e) {
      const t = {
        width: 0,
        texture: Qe.WHITE,
        color: e?.texture ? 16777215 : 0,
        matrix: null,
        alignment: 0.5,
        native: !1,
        cap: vl.BUTT,
        join: ps.MITER,
        miterLimit: 10,
      };
      ((e = Object.assign(t, e)),
        this.normalizeColor(e),
        this.currentPath && this.startPoly());
      const i = e.width > 0 && e.alpha > 0;
      return (
        i
          ? (e.matrix && ((e.matrix = e.matrix.clone()), e.matrix.invert()),
            Object.assign(this._lineStyle, { visible: i }, e))
          : this._lineStyle.reset(),
        this
      );
    }
    startPoly() {
      if (this.currentPath) {
        const e = this.currentPath.points,
          t = this.currentPath.points.length;
        t > 2 &&
          (this.drawShape(this.currentPath),
          (this.currentPath = new au()),
          (this.currentPath.closeStroke = !1),
          this.currentPath.points.push(e[t - 2], e[t - 1]));
      } else
        ((this.currentPath = new au()), (this.currentPath.closeStroke = !1));
    }
    finishPoly() {
      this.currentPath &&
        (this.currentPath.points.length > 2
          ? (this.drawShape(this.currentPath), (this.currentPath = null))
          : (this.currentPath.points.length = 0));
    }
    moveTo(e, t) {
      return (
        this.startPoly(),
        (this.currentPath.points[0] = e),
        (this.currentPath.points[1] = t),
        this
      );
    }
    lineTo(e, t) {
      this.currentPath || this.moveTo(0, 0);
      const i = this.currentPath.points,
        r = i[i.length - 2],
        s = i[i.length - 1];
      return ((r !== e || s !== t) && i.push(e, t), this);
    }
    _initCurve(e = 0, t = 0) {
      this.currentPath
        ? this.currentPath.points.length === 0 &&
          (this.currentPath.points = [e, t])
        : this.moveTo(e, t);
    }
    quadraticCurveTo(e, t, i, r) {
      this._initCurve();
      const s = this.currentPath.points;
      return (
        s.length === 0 && this.moveTo(0, 0),
        L5.curveTo(e, t, i, r, s),
        this
      );
    }
    bezierCurveTo(e, t, i, r, s, o) {
      return (
        this._initCurve(),
        M5.curveTo(e, t, i, r, s, o, this.currentPath.points),
        this
      );
    }
    arcTo(e, t, i, r, s) {
      this._initCurve(e, t);
      const o = this.currentPath.points,
        a = z6.curveTo(e, t, i, r, s, o);
      if (a) {
        const {
          cx: l,
          cy: c,
          radius: u,
          startAngle: h,
          endAngle: d,
          anticlockwise: f,
        } = a;
        this.arc(l, c, u, h, d, f);
      }
      return this;
    }
    arc(e, t, i, r, s, o = !1) {
      if (r === s) return this;
      if ((!o && s <= r ? (s += hC) : o && r <= s && (r += hC), s - r === 0))
        return this;
      const a = e + Math.cos(r) * i,
        l = t + Math.sin(r) * i,
        c = this._geometry.closePointEps;
      let u = this.currentPath ? this.currentPath.points : null;
      if (u) {
        const h = Math.abs(u[u.length - 2] - a),
          d = Math.abs(u[u.length - 1] - l);
        (h < c && d < c) || u.push(a, l);
      } else (this.moveTo(a, l), (u = this.currentPath.points));
      return (z6.arc(a, l, e, t, i, r, s, o, u), this);
    }
    beginFill(e = 0, t) {
      return this.beginTextureFill({ texture: Qe.WHITE, color: e, alpha: t });
    }
    normalizeColor(e) {
      const t = Ln.shared.setValue(e.color ?? 0);
      ((e.color = t.toNumber()), e.alpha ?? (e.alpha = t.alpha));
    }
    beginTextureFill(e) {
      const t = { texture: Qe.WHITE, color: 16777215, matrix: null };
      ((e = Object.assign(t, e)),
        this.normalizeColor(e),
        this.currentPath && this.startPoly());
      const i = e.alpha > 0;
      return (
        i
          ? (e.matrix && ((e.matrix = e.matrix.clone()), e.matrix.invert()),
            Object.assign(this._fillStyle, { visible: i }, e))
          : this._fillStyle.reset(),
        this
      );
    }
    endFill() {
      return (this.finishPoly(), this._fillStyle.reset(), this);
    }
    drawRect(e, t, i, r) {
      return this.drawShape(new Bt(e, t, i, r));
    }
    drawRoundedRect(e, t, i, r, s) {
      return this.drawShape(new CI(e, t, i, r, s));
    }
    drawCircle(e, t, i) {
      return this.drawShape(new pI(e, t, i));
    }
    drawEllipse(e, t, i, r) {
      return this.drawShape(new mI(e, t, i, r));
    }
    drawPolygon(...e) {
      let t,
        i = !0;
      const r = e[0];
      r.points
        ? ((i = r.closeStroke), (t = r.points))
        : Array.isArray(e[0])
          ? (t = e[0])
          : (t = e);
      const s = new au(t);
      return ((s.closeStroke = i), this.drawShape(s), this);
    }
    drawShape(e) {
      return (
        this._holeMode
          ? this._geometry.drawHole(e, this._matrix)
          : this._geometry.drawShape(
              e,
              this._fillStyle.clone(),
              this._lineStyle.clone(),
              this._matrix,
            ),
        this
      );
    }
    clear() {
      return (
        this._geometry.clear(),
        this._lineStyle.reset(),
        this._fillStyle.reset(),
        this._boundsID++,
        (this._matrix = null),
        (this._holeMode = !1),
        (this.currentPath = null),
        this
      );
    }
    isFastRect() {
      const e = this._geometry.graphicsData;
      return (
        e.length === 1 &&
        e[0].shape.type === Fi.RECT &&
        !e[0].matrix &&
        !e[0].holes.length &&
        !(e[0].lineStyle.visible && e[0].lineStyle.width)
      );
    }
    _render(e) {
      this.finishPoly();
      const t = this._geometry;
      (t.updateBatches(),
        t.batchable
          ? (this.batchDirty !== t.batchDirty && this._populateBatches(),
            this._renderBatched(e))
          : (e.batch.flush(), this._renderDirect(e)));
    }
    _populateBatches() {
      const e = this._geometry,
        t = this.blendMode,
        i = e.batches.length;
      ((this.batchTint = -1),
        (this._transformID = -1),
        (this.batchDirty = e.batchDirty),
        (this.batches.length = i),
        (this.vertexData = new Float32Array(e.points)));
      for (let r = 0; r < i; r++) {
        const s = e.batches[r],
          o = s.style.color,
          a = new Float32Array(
            this.vertexData.buffer,
            s.attribStart * 4 * 2,
            s.attribSize * 2,
          ),
          l = new Float32Array(
            e.uvsFloat32.buffer,
            s.attribStart * 4 * 2,
            s.attribSize * 2,
          ),
          c = new Uint16Array(e.indicesUint16.buffer, s.start * 2, s.size),
          u = {
            vertexData: a,
            blendMode: t,
            indices: c,
            uvs: l,
            _batchRGB: Ln.shared.setValue(o).toRgbArray(),
            _tintRGB: o,
            _texture: s.style.texture,
            alpha: s.style.alpha,
            worldAlpha: 1,
          };
        this.batches[r] = u;
      }
    }
    _renderBatched(e) {
      if (this.batches.length) {
        (e.batch.setObjectRenderer(e.plugins[this.pluginName]),
          this.calculateVertices(),
          this.calculateTints());
        for (let t = 0, i = this.batches.length; t < i; t++) {
          const r = this.batches[t];
          ((r.worldAlpha = this.worldAlpha * r.alpha),
            e.plugins[this.pluginName].render(r));
        }
      }
    }
    _renderDirect(e) {
      const t = this._resolveDirectShader(e),
        i = this._geometry,
        r = this.worldAlpha,
        s = t.uniforms,
        o = i.drawCalls;
      ((s.translationMatrix = this.transform.worldTransform),
        Ln.shared.setValue(this._tintColor).premultiply(r).toArray(s.tint),
        e.shader.bind(t),
        e.geometry.bind(i, t),
        e.state.set(this.state));
      for (let a = 0, l = o.length; a < l; a++)
        this._renderDrawCallDirect(e, i.drawCalls[a]);
    }
    _renderDrawCallDirect(e, t) {
      const { texArray: i, type: r, size: s, start: o } = t,
        a = i.count;
      for (let l = 0; l < a; l++) e.texture.bind(i.elements[l], l);
      e.geometry.draw(r, s, o);
    }
    _resolveDirectShader(e) {
      let t = this.shader;
      const i = this.pluginName;
      if (!t) {
        if (!zA[i]) {
          const { maxTextures: r } = e.plugins[i],
            s = new Int32Array(r);
          for (let l = 0; l < r; l++) s[l] = l;
          const o = {
              tint: new Float32Array([1, 1, 1, 1]),
              translationMatrix: new Rn(),
              default: eo.from({ uSamplers: s }, !0),
            },
            a = e.plugins[i]._shader.program;
          zA[i] = new Bo(a, o);
        }
        t = zA[i];
      }
      return t;
    }
    _calculateBounds() {
      this.finishPoly();
      const e = this._geometry;
      if (!e.graphicsData.length) return;
      const { minX: t, minY: i, maxX: r, maxY: s } = e.bounds;
      this._bounds.addFrame(this.transform, t, i, r, s);
    }
    containsPoint(e) {
      return (
        this.worldTransform.applyInverse(e, tm._TEMP_POINT),
        this._geometry.containsPoint(tm._TEMP_POINT)
      );
    }
    calculateTints() {
      if (this.batchTint !== this.tint) {
        this.batchTint = this._tintColor.toNumber();
        for (let e = 0; e < this.batches.length; e++) {
          const t = this.batches[e];
          t._tintRGB = Ln.shared
            .setValue(this._tintColor)
            .multiply(t._batchRGB)
            .toLittleEndianNumber();
        }
      }
    }
    calculateVertices() {
      const e = this.transform._worldID;
      if (this._transformID === e) return;
      this._transformID = e;
      const t = this.transform.worldTransform,
        i = t.a,
        r = t.b,
        s = t.c,
        o = t.d,
        a = t.tx,
        l = t.ty,
        c = this._geometry.points,
        u = this.vertexData;
      let h = 0;
      for (let d = 0; d < c.length; d += 2) {
        const f = c[d],
          g = c[d + 1];
        ((u[h++] = i * f + s * g + a), (u[h++] = o * g + r * f + l));
      }
    }
    closePath() {
      const e = this.currentPath;
      return (e && ((e.closeStroke = !0), this.finishPoly()), this);
    }
    setMatrix(e) {
      return ((this._matrix = e), this);
    }
    beginHole() {
      return (this.finishPoly(), (this._holeMode = !0), this);
    }
    endHole() {
      return (this.finishPoly(), (this._holeMode = !1), this);
    }
    destroy(e) {
      (this._geometry.refCount--,
        this._geometry.refCount === 0 && this._geometry.dispose(),
        (this._matrix = null),
        (this.currentPath = null),
        this._lineStyle.destroy(),
        (this._lineStyle = null),
        this._fillStyle.destroy(),
        (this._fillStyle = null),
        (this._geometry = null),
        (this.shader = null),
        (this.vertexData = null),
        (this.batches.length = 0),
        (this.batches = null),
        super.destroy(e));
    }
  };
((ab.curves = bd), (ab._TEMP_POINT = new Qt()));
let bC = ab;
class Fpe {
  constructor(e, t) {
    ((this.uvBuffer = e),
      (this.uvMatrix = t),
      (this.data = null),
      (this._bufferUpdateId = -1),
      (this._textureUpdateId = -1),
      (this._updateID = 0));
  }
  update(e) {
    if (
      !e &&
      this._bufferUpdateId === this.uvBuffer._updateID &&
      this._textureUpdateId === this.uvMatrix._updateID
    )
      return;
    ((this._bufferUpdateId = this.uvBuffer._updateID),
      (this._textureUpdateId = this.uvMatrix._updateID));
    const t = this.uvBuffer.data;
    ((!this.data || this.data.length !== t.length) &&
      (this.data = new Float32Array(t.length)),
      this.uvMatrix.multiplyUvs(t, this.data),
      this._updateID++);
  }
}
const YA = new Qt(),
  j6 = new au(),
  sN = class oN extends Rs {
    constructor(e, t, i, r = To.TRIANGLES) {
      (super(),
        (this.geometry = e),
        (this.shader = t),
        (this.state = i || Yo.for2d()),
        (this.drawMode = r),
        (this.start = 0),
        (this.size = 0),
        (this.uvs = null),
        (this.indices = null),
        (this.vertexData = new Float32Array(1)),
        (this.vertexDirty = -1),
        (this._transformID = -1),
        (this._roundPixels = Oe.ROUND_PIXELS),
        (this.batchUvs = null));
    }
    get geometry() {
      return this._geometry;
    }
    set geometry(e) {
      this._geometry !== e &&
        (this._geometry &&
          (this._geometry.refCount--,
          this._geometry.refCount === 0 && this._geometry.dispose()),
        (this._geometry = e),
        this._geometry && this._geometry.refCount++,
        (this.vertexDirty = -1));
    }
    get uvBuffer() {
      return this.geometry.buffers[1];
    }
    get verticesBuffer() {
      return this.geometry.buffers[0];
    }
    set material(e) {
      this.shader = e;
    }
    get material() {
      return this.shader;
    }
    set blendMode(e) {
      this.state.blendMode = e;
    }
    get blendMode() {
      return this.state.blendMode;
    }
    set roundPixels(e) {
      (this._roundPixels !== e && (this._transformID = -1),
        (this._roundPixels = e));
    }
    get roundPixels() {
      return this._roundPixels;
    }
    get tint() {
      return "tint" in this.shader ? this.shader.tint : null;
    }
    set tint(e) {
      this.shader.tint = e;
    }
    get tintValue() {
      return this.shader.tintValue;
    }
    get texture() {
      return "texture" in this.shader ? this.shader.texture : null;
    }
    set texture(e) {
      this.shader.texture = e;
    }
    _render(e) {
      const t = this.geometry.buffers[0].data;
      this.shader.batchable &&
      this.drawMode === To.TRIANGLES &&
      t.length < oN.BATCHABLE_SIZE * 2
        ? this._renderToBatch(e)
        : this._renderDefault(e);
    }
    _renderDefault(e) {
      const t = this.shader;
      ((t.alpha = this.worldAlpha),
        t.update && t.update(),
        e.batch.flush(),
        (t.uniforms.translationMatrix =
          this.transform.worldTransform.toArray(!0)),
        e.shader.bind(t),
        e.state.set(this.state),
        e.geometry.bind(this.geometry, t),
        e.geometry.draw(
          this.drawMode,
          this.size,
          this.start,
          this.geometry.instanceCount,
        ));
    }
    _renderToBatch(e) {
      const t = this.geometry,
        i = this.shader;
      (i.uvMatrix && (i.uvMatrix.update(), this.calculateUvs()),
        this.calculateVertices(),
        (this.indices = t.indexBuffer.data),
        (this._tintRGB = i._tintRGB),
        (this._texture = i.texture));
      const r = this.material.pluginName;
      (e.batch.setObjectRenderer(e.plugins[r]), e.plugins[r].render(this));
    }
    calculateVertices() {
      const e = this.geometry.buffers[0],
        t = e.data,
        i = e._updateID;
      if (
        i === this.vertexDirty &&
        this._transformID === this.transform._worldID
      )
        return;
      ((this._transformID = this.transform._worldID),
        this.vertexData.length !== t.length &&
          (this.vertexData = new Float32Array(t.length)));
      const r = this.transform.worldTransform,
        s = r.a,
        o = r.b,
        a = r.c,
        l = r.d,
        c = r.tx,
        u = r.ty,
        h = this.vertexData;
      for (let d = 0; d < h.length / 2; d++) {
        const f = t[d * 2],
          g = t[d * 2 + 1];
        ((h[d * 2] = s * f + a * g + c), (h[d * 2 + 1] = o * f + l * g + u));
      }
      if (this._roundPixels) {
        const d = Oe.RESOLUTION;
        for (let f = 0; f < h.length; ++f) h[f] = Math.round(h[f] * d) / d;
      }
      this.vertexDirty = i;
    }
    calculateUvs() {
      const e = this.geometry.buffers[1],
        t = this.shader;
      t.uvMatrix.isSimple
        ? (this.uvs = e.data)
        : (this.batchUvs || (this.batchUvs = new Fpe(e, t.uvMatrix)),
          this.batchUvs.update(),
          (this.uvs = this.batchUvs.data));
    }
    _calculateBounds() {
      (this.calculateVertices(),
        this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length));
    }
    containsPoint(e) {
      if (!this.getBounds().contains(e.x, e.y)) return !1;
      this.worldTransform.applyInverse(e, YA);
      const t = this.geometry.getBuffer("aVertexPosition").data,
        i = j6.points,
        r = this.geometry.getIndex().data,
        s = r.length,
        o = this.drawMode === 4 ? 3 : 1;
      for (let a = 0; a + 2 < s; a += o) {
        const l = r[a] * 2,
          c = r[a + 1] * 2,
          u = r[a + 2] * 2;
        if (
          ((i[0] = t[l]),
          (i[1] = t[l + 1]),
          (i[2] = t[c]),
          (i[3] = t[c + 1]),
          (i[4] = t[u]),
          (i[5] = t[u + 1]),
          j6.contains(YA.x, YA.y))
        )
          return !0;
      }
      return !1;
    }
    destroy(e) {
      (super.destroy(e),
        this._cachedTexture &&
          (this._cachedTexture.destroy(), (this._cachedTexture = null)),
        (this.geometry = null),
        (this.shader = null),
        (this.state = null),
        (this.uvs = null),
        (this.indices = null),
        (this.vertexData = null));
    }
  };
sN.BATCHABLE_SIZE = 100;
let $6 = sN;
class kpe extends kl {
  constructor(e, t, i) {
    super();
    const r = new fi(e),
      s = new fi(t, !0),
      o = new fi(i, !0, !0);
    (this.addAttribute("aVertexPosition", r, 2, !1, et.FLOAT)
      .addAttribute("aTextureCoord", s, 2, !1, et.FLOAT)
      .addIndex(o),
      (this._updateId = -1));
  }
  get vertexDirtyId() {
    return this.buffers[0]._updateID;
  }
}
var Ope = `varying vec2 vTextureCoord;
uniform vec4 uColor;

uniform sampler2D uSampler;

void main(void)
{
    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;
}
`,
  Upe = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTextureMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;
}
`;
class J6 extends Bo {
  constructor(e, t) {
    const i = {
      uSampler: e,
      alpha: 1,
      uTextureMatrix: Rn.IDENTITY,
      uColor: new Float32Array([1, 1, 1, 1]),
    };
    ((t = Object.assign({ tint: 16777215, alpha: 1, pluginName: "batch" }, t)),
      t.uniforms && Object.assign(i, t.uniforms),
      super(t.program || ya.from(Upe, Ope), i),
      (this._colorDirty = !1),
      (this.uvMatrix = new wP(e)),
      (this.batchable = t.program === void 0),
      (this.pluginName = t.pluginName),
      (this._tintColor = new Ln(t.tint)),
      (this._tintRGB = this._tintColor.toLittleEndianNumber()),
      (this._colorDirty = !0),
      (this.alpha = t.alpha));
  }
  get texture() {
    return this.uniforms.uSampler;
  }
  set texture(e) {
    this.uniforms.uSampler !== e &&
      (!this.uniforms.uSampler.baseTexture.alphaMode !=
        !e.baseTexture.alphaMode && (this._colorDirty = !0),
      (this.uniforms.uSampler = e),
      (this.uvMatrix.texture = e));
  }
  set alpha(e) {
    e !== this._alpha && ((this._alpha = e), (this._colorDirty = !0));
  }
  get alpha() {
    return this._alpha;
  }
  set tint(e) {
    e !== this.tint &&
      (this._tintColor.setValue(e),
      (this._tintRGB = this._tintColor.toLittleEndianNumber()),
      (this._colorDirty = !0));
  }
  get tint() {
    return this._tintColor.value;
  }
  get tintValue() {
    return this._tintColor.toNumber();
  }
  update() {
    if (this._colorDirty) {
      this._colorDirty = !1;
      const e = this.texture.baseTexture.alphaMode;
      Ln.shared
        .setValue(this._tintColor)
        .premultiply(this._alpha, e)
        .toArray(this.uniforms.uColor);
    }
    this.uvMatrix.update() &&
      (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);
  }
}
class Q6 {
  constructor(e, t, i) {
    ((this.geometry = new kl()),
      (this.indexBuffer = null),
      (this.size = i),
      (this.dynamicProperties = []),
      (this.staticProperties = []));
    for (let r = 0; r < e.length; ++r) {
      let s = e[r];
      ((s = {
        attributeName: s.attributeName,
        size: s.size,
        uploadFunction: s.uploadFunction,
        type: s.type || et.FLOAT,
        offset: s.offset,
      }),
        t[r] ? this.dynamicProperties.push(s) : this.staticProperties.push(s));
    }
    ((this.staticStride = 0),
      (this.staticBuffer = null),
      (this.staticData = null),
      (this.staticDataUint32 = null),
      (this.dynamicStride = 0),
      (this.dynamicBuffer = null),
      (this.dynamicData = null),
      (this.dynamicDataUint32 = null),
      (this._updateID = 0),
      this.initBuffers());
  }
  initBuffers() {
    const e = this.geometry;
    let t = 0;
    ((this.indexBuffer = new fi(ude(this.size), !0, !0)),
      e.addIndex(this.indexBuffer),
      (this.dynamicStride = 0));
    for (let o = 0; o < this.dynamicProperties.length; ++o) {
      const a = this.dynamicProperties[o];
      ((a.offset = t), (t += a.size), (this.dynamicStride += a.size));
    }
    const i = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
    ((this.dynamicData = new Float32Array(i)),
      (this.dynamicDataUint32 = new Uint32Array(i)),
      (this.dynamicBuffer = new fi(this.dynamicData, !1, !1)));
    let r = 0;
    this.staticStride = 0;
    for (let o = 0; o < this.staticProperties.length; ++o) {
      const a = this.staticProperties[o];
      ((a.offset = r), (r += a.size), (this.staticStride += a.size));
    }
    const s = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
    ((this.staticData = new Float32Array(s)),
      (this.staticDataUint32 = new Uint32Array(s)),
      (this.staticBuffer = new fi(this.staticData, !0, !1)));
    for (let o = 0; o < this.dynamicProperties.length; ++o) {
      const a = this.dynamicProperties[o];
      e.addAttribute(
        a.attributeName,
        this.dynamicBuffer,
        0,
        a.type === et.UNSIGNED_BYTE,
        a.type,
        this.dynamicStride * 4,
        a.offset * 4,
      );
    }
    for (let o = 0; o < this.staticProperties.length; ++o) {
      const a = this.staticProperties[o];
      e.addAttribute(
        a.attributeName,
        this.staticBuffer,
        0,
        a.type === et.UNSIGNED_BYTE,
        a.type,
        this.staticStride * 4,
        a.offset * 4,
      );
    }
  }
  uploadDynamic(e, t, i) {
    for (let r = 0; r < this.dynamicProperties.length; r++) {
      const s = this.dynamicProperties[r];
      s.uploadFunction(
        e,
        t,
        i,
        s.type === et.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData,
        this.dynamicStride,
        s.offset,
      );
    }
    this.dynamicBuffer._updateID++;
  }
  uploadStatic(e, t, i) {
    for (let r = 0; r < this.staticProperties.length; r++) {
      const s = this.staticProperties[r];
      s.uploadFunction(
        e,
        t,
        i,
        s.type === et.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData,
        this.staticStride,
        s.offset,
      );
    }
    this.staticBuffer._updateID++;
  }
  destroy() {
    ((this.indexBuffer = null),
      (this.dynamicProperties = null),
      (this.dynamicBuffer = null),
      (this.dynamicData = null),
      (this.dynamicDataUint32 = null),
      (this.staticProperties = null),
      (this.staticBuffer = null),
      (this.staticData = null),
      (this.staticDataUint32 = null),
      this.geometry.destroy());
  }
}
var Hpe = `varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uSampler;

void main(void){
    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
    gl_FragColor = color;
}`,
  Wpe = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;

attribute vec2 aPositionCoord;
attribute float aRotation;

uniform mat3 translationMatrix;
uniform vec4 uColor;

varying vec2 vTextureCoord;
varying vec4 vColor;

void main(void){
    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);
    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);

    vec2 v = vec2(x, y);
    v = v + aPositionCoord;

    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vColor = aColor * uColor;
}
`;
class aN extends II {
  constructor(e) {
    (super(e),
      (this.shader = null),
      (this.properties = null),
      (this.tempMatrix = new Rn()),
      (this.properties = [
        {
          attributeName: "aVertexPosition",
          size: 2,
          uploadFunction: this.uploadVertices,
          offset: 0,
        },
        {
          attributeName: "aPositionCoord",
          size: 2,
          uploadFunction: this.uploadPosition,
          offset: 0,
        },
        {
          attributeName: "aRotation",
          size: 1,
          uploadFunction: this.uploadRotation,
          offset: 0,
        },
        {
          attributeName: "aTextureCoord",
          size: 2,
          uploadFunction: this.uploadUvs,
          offset: 0,
        },
        {
          attributeName: "aColor",
          size: 1,
          type: et.UNSIGNED_BYTE,
          uploadFunction: this.uploadTint,
          offset: 0,
        },
      ]),
      (this.shader = Bo.from(Wpe, Hpe, {})),
      (this.state = Yo.for2d()));
  }
  render(e) {
    const t = e.children,
      i = e._maxSize,
      r = e._batchSize,
      s = this.renderer;
    let o = t.length;
    if (o === 0) return;
    o > i && !e.autoResize && (o = i);
    let a = e._buffers;
    a || (a = e._buffers = this.generateBuffers(e));
    const l = t[0]._texture.baseTexture,
      c = l.alphaMode > 0;
    ((this.state.blendMode = aP(e.blendMode, c)), s.state.set(this.state));
    const u = s.gl,
      h = e.worldTransform.copyTo(this.tempMatrix);
    (h.prepend(s.globalUniforms.uniforms.projectionMatrix),
      (this.shader.uniforms.translationMatrix = h.toArray(!0)),
      (this.shader.uniforms.uColor = Ln.shared
        .setValue(e.tintRgb)
        .premultiply(e.worldAlpha, c)
        .toArray(this.shader.uniforms.uColor)),
      (this.shader.uniforms.uSampler = l),
      this.renderer.shader.bind(this.shader));
    let d = !1;
    for (let f = 0, g = 0; f < o; f += r, g += 1) {
      let p = o - f;
      (p > r && (p = r),
        g >= a.length && a.push(this._generateOneMoreBuffer(e)));
      const m = a[g];
      m.uploadDynamic(t, f, p);
      const C = e._bufferUpdateIDs[g] || 0;
      ((d = d || m._updateID < C),
        d && ((m._updateID = e._updateID), m.uploadStatic(t, f, p)),
        s.geometry.bind(m.geometry),
        u.drawElements(u.TRIANGLES, p * 6, u.UNSIGNED_SHORT, 0));
    }
  }
  generateBuffers(e) {
    const t = [],
      i = e._maxSize,
      r = e._batchSize,
      s = e._properties;
    for (let o = 0; o < i; o += r) t.push(new Q6(this.properties, s, r));
    return t;
  }
  _generateOneMoreBuffer(e) {
    const t = e._batchSize,
      i = e._properties;
    return new Q6(this.properties, i, t);
  }
  uploadVertices(e, t, i, r, s, o) {
    let a = 0,
      l = 0,
      c = 0,
      u = 0;
    for (let h = 0; h < i; ++h) {
      const d = e[t + h],
        f = d._texture,
        g = d.scale.x,
        p = d.scale.y,
        m = f.trim,
        C = f.orig;
      (m
        ? ((l = m.x - d.anchor.x * C.width),
          (a = l + m.width),
          (u = m.y - d.anchor.y * C.height),
          (c = u + m.height))
        : ((a = C.width * (1 - d.anchor.x)),
          (l = C.width * -d.anchor.x),
          (c = C.height * (1 - d.anchor.y)),
          (u = C.height * -d.anchor.y)),
        (r[o] = l * g),
        (r[o + 1] = u * p),
        (r[o + s] = a * g),
        (r[o + s + 1] = u * p),
        (r[o + s * 2] = a * g),
        (r[o + s * 2 + 1] = c * p),
        (r[o + s * 3] = l * g),
        (r[o + s * 3 + 1] = c * p),
        (o += s * 4));
    }
  }
  uploadPosition(e, t, i, r, s, o) {
    for (let a = 0; a < i; a++) {
      const l = e[t + a].position;
      ((r[o] = l.x),
        (r[o + 1] = l.y),
        (r[o + s] = l.x),
        (r[o + s + 1] = l.y),
        (r[o + s * 2] = l.x),
        (r[o + s * 2 + 1] = l.y),
        (r[o + s * 3] = l.x),
        (r[o + s * 3 + 1] = l.y),
        (o += s * 4));
    }
  }
  uploadRotation(e, t, i, r, s, o) {
    for (let a = 0; a < i; a++) {
      const l = e[t + a].rotation;
      ((r[o] = l),
        (r[o + s] = l),
        (r[o + s * 2] = l),
        (r[o + s * 3] = l),
        (o += s * 4));
    }
  }
  uploadUvs(e, t, i, r, s, o) {
    for (let a = 0; a < i; ++a) {
      const l = e[t + a]._texture._uvs;
      l
        ? ((r[o] = l.x0),
          (r[o + 1] = l.y0),
          (r[o + s] = l.x1),
          (r[o + s + 1] = l.y1),
          (r[o + s * 2] = l.x2),
          (r[o + s * 2 + 1] = l.y2),
          (r[o + s * 3] = l.x3),
          (r[o + s * 3 + 1] = l.y3),
          (o += s * 4))
        : ((r[o] = 0),
          (r[o + 1] = 0),
          (r[o + s] = 0),
          (r[o + s + 1] = 0),
          (r[o + s * 2] = 0),
          (r[o + s * 2 + 1] = 0),
          (r[o + s * 3] = 0),
          (r[o + s * 3 + 1] = 0),
          (o += s * 4));
    }
  }
  uploadTint(e, t, i, r, s, o) {
    for (let a = 0; a < i; ++a) {
      const l = e[t + a],
        c = Ln.shared
          .setValue(l._tintRGB)
          .toPremultiplied(l.alpha, l.texture.baseTexture.alphaMode > 0);
      ((r[o] = c),
        (r[o + s] = c),
        (r[o + s * 2] = c),
        (r[o + s * 3] = c),
        (o += s * 4));
    }
  }
  destroy() {
    (super.destroy(),
      this.shader && (this.shader.destroy(), (this.shader = null)),
      (this.tempMatrix = null));
  }
}
aN.extension = { name: "particle", type: De.RendererPlugin };
je.add(aN);
var _I = ((n) => (
  (n[(n.LINEAR_VERTICAL = 0)] = "LINEAR_VERTICAL"),
  (n[(n.LINEAR_HORIZONTAL = 1)] = "LINEAR_HORIZONTAL"),
  n
))(_I || {});
const e0 = { willReadFrequently: !0 },
  ho = class Je {
    static get experimentalLetterSpacingSupported() {
      let e = Je._experimentalLetterSpacingSupported;
      if (e !== void 0) {
        const t = Oe.ADAPTER.getCanvasRenderingContext2D().prototype;
        e = Je._experimentalLetterSpacingSupported =
          "letterSpacing" in t || "textLetterSpacing" in t;
      }
      return e;
    }
    constructor(e, t, i, r, s, o, a, l, c) {
      ((this.text = e),
        (this.style = t),
        (this.width = i),
        (this.height = r),
        (this.lines = s),
        (this.lineWidths = o),
        (this.lineHeight = a),
        (this.maxLineWidth = l),
        (this.fontProperties = c));
    }
    static measureText(e, t, i, r = Je._canvas) {
      i = i ?? t.wordWrap;
      const s = t.toFontString(),
        o = Je.measureFont(s);
      o.fontSize === 0 && ((o.fontSize = t.fontSize), (o.ascent = t.fontSize));
      const a = r.getContext("2d", e0);
      a.font = s;
      const l = (i ? Je.wordWrap(e, t, r) : e).split(/(?:\r\n|\r|\n)/),
        c = new Array(l.length);
      let u = 0;
      for (let g = 0; g < l.length; g++) {
        const p = Je._measureText(l[g], t.letterSpacing, a);
        ((c[g] = p), (u = Math.max(u, p)));
      }
      let h = u + t.strokeThickness;
      t.dropShadow && (h += t.dropShadowDistance);
      const d = t.lineHeight || o.fontSize + t.strokeThickness;
      let f =
        Math.max(d, o.fontSize + t.strokeThickness * 2) +
        t.leading +
        (l.length - 1) * (d + t.leading);
      return (
        t.dropShadow && (f += t.dropShadowDistance),
        new Je(e, t, h, f, l, c, d + t.leading, u, o)
      );
    }
    static _measureText(e, t, i) {
      let r = !1;
      Je.experimentalLetterSpacingSupported &&
        (Je.experimentalLetterSpacing
          ? ((i.letterSpacing = `${t}px`),
            (i.textLetterSpacing = `${t}px`),
            (r = !0))
          : ((i.letterSpacing = "0px"), (i.textLetterSpacing = "0px")));
      let s = i.measureText(e).width;
      return (
        s > 0 &&
          (r ? (s -= t) : (s += (Je.graphemeSegmenter(e).length - 1) * t)),
        s
      );
    }
    static wordWrap(e, t, i = Je._canvas) {
      const r = i.getContext("2d", e0);
      let s = 0,
        o = "",
        a = "";
      const l = Object.create(null),
        { letterSpacing: c, whiteSpace: u } = t,
        h = Je.collapseSpaces(u),
        d = Je.collapseNewlines(u);
      let f = !h;
      const g = t.wordWrapWidth + c,
        p = Je.tokenize(e);
      for (let m = 0; m < p.length; m++) {
        let C = p[m];
        if (Je.isNewline(C)) {
          if (!d) {
            ((a += Je.addLine(o)), (f = !h), (o = ""), (s = 0));
            continue;
          }
          C = " ";
        }
        if (h) {
          const I = Je.isBreakingSpace(C),
            y = Je.isBreakingSpace(o[o.length - 1]);
          if (I && y) continue;
        }
        const A = Je.getFromCache(C, c, l, r);
        if (A > g)
          if (
            (o !== "" && ((a += Je.addLine(o)), (o = ""), (s = 0)),
            Je.canBreakWords(C, t.breakWords))
          ) {
            const I = Je.wordWrapSplit(C);
            for (let y = 0; y < I.length; y++) {
              let x = I[y],
                T = x,
                S = 1;
              for (; I[y + S]; ) {
                const _ = I[y + S];
                if (!Je.canBreakChars(T, _, C, y, t.breakWords)) x += _;
                else break;
                ((T = _), S++);
              }
              y += S - 1;
              const E = Je.getFromCache(x, c, l, r);
              (E + s > g && ((a += Je.addLine(o)), (f = !1), (o = ""), (s = 0)),
                (o += x),
                (s += E));
            }
          } else {
            o.length > 0 && ((a += Je.addLine(o)), (o = ""), (s = 0));
            const I = m === p.length - 1;
            ((a += Je.addLine(C, !I)), (f = !1), (o = ""), (s = 0));
          }
        else
          (A + s > g && ((f = !1), (a += Je.addLine(o)), (o = ""), (s = 0)),
            (o.length > 0 || !Je.isBreakingSpace(C) || f) &&
              ((o += C), (s += A)));
      }
      return ((a += Je.addLine(o, !1)), a);
    }
    static addLine(e, t = !0) {
      return (
        (e = Je.trimRight(e)),
        (e = t
          ? `${e}
`
          : e),
        e
      );
    }
    static getFromCache(e, t, i, r) {
      let s = i[e];
      return (
        typeof s != "number" &&
          ((s = Je._measureText(e, t, r) + t), (i[e] = s)),
        s
      );
    }
    static collapseSpaces(e) {
      return e === "normal" || e === "pre-line";
    }
    static collapseNewlines(e) {
      return e === "normal";
    }
    static trimRight(e) {
      if (typeof e != "string") return "";
      for (let t = e.length - 1; t >= 0; t--) {
        const i = e[t];
        if (!Je.isBreakingSpace(i)) break;
        e = e.slice(0, -1);
      }
      return e;
    }
    static isNewline(e) {
      return typeof e != "string" ? !1 : Je._newlines.includes(e.charCodeAt(0));
    }
    static isBreakingSpace(e, t) {
      return typeof e != "string"
        ? !1
        : Je._breakingSpaces.includes(e.charCodeAt(0));
    }
    static tokenize(e) {
      const t = [];
      let i = "";
      if (typeof e != "string") return t;
      for (let r = 0; r < e.length; r++) {
        const s = e[r],
          o = e[r + 1];
        if (Je.isBreakingSpace(s, o) || Je.isNewline(s)) {
          (i !== "" && (t.push(i), (i = "")), t.push(s));
          continue;
        }
        i += s;
      }
      return (i !== "" && t.push(i), t);
    }
    static canBreakWords(e, t) {
      return t;
    }
    static canBreakChars(e, t, i, r, s) {
      return !0;
    }
    static wordWrapSplit(e) {
      return Je.graphemeSegmenter(e);
    }
    static measureFont(e) {
      if (Je._fonts[e]) return Je._fonts[e];
      const t = { ascent: 0, descent: 0, fontSize: 0 },
        i = Je._canvas,
        r = Je._context;
      r.font = e;
      const s = Je.METRICS_STRING + Je.BASELINE_SYMBOL,
        o = Math.ceil(r.measureText(s).width);
      let a = Math.ceil(r.measureText(Je.BASELINE_SYMBOL).width);
      const l = Math.ceil(Je.HEIGHT_MULTIPLIER * a);
      if (((a = (a * Je.BASELINE_MULTIPLIER) | 0), o === 0 || l === 0))
        return ((Je._fonts[e] = t), t);
      ((i.width = o),
        (i.height = l),
        (r.fillStyle = "#f00"),
        r.fillRect(0, 0, o, l),
        (r.font = e),
        (r.textBaseline = "alphabetic"),
        (r.fillStyle = "#000"),
        r.fillText(s, 0, a));
      const c = r.getImageData(0, 0, o, l).data,
        u = c.length,
        h = o * 4;
      let d = 0,
        f = 0,
        g = !1;
      for (d = 0; d < a; ++d) {
        for (let p = 0; p < h; p += 4)
          if (c[f + p] !== 255) {
            g = !0;
            break;
          }
        if (!g) f += h;
        else break;
      }
      for (t.ascent = a - d, f = u - h, g = !1, d = l; d > a; --d) {
        for (let p = 0; p < h; p += 4)
          if (c[f + p] !== 255) {
            g = !0;
            break;
          }
        if (!g) f -= h;
        else break;
      }
      return (
        (t.descent = d - a),
        (t.fontSize = t.ascent + t.descent),
        (Je._fonts[e] = t),
        t
      );
    }
    static clearMetrics(e = "") {
      e ? delete Je._fonts[e] : (Je._fonts = {});
    }
    static get _canvas() {
      if (!Je.__canvas) {
        let e;
        try {
          const t = new OffscreenCanvas(0, 0);
          if (t.getContext("2d", e0)?.measureText)
            return ((Je.__canvas = t), t);
          e = Oe.ADAPTER.createCanvas();
        } catch {
          e = Oe.ADAPTER.createCanvas();
        }
        ((e.width = e.height = 10), (Je.__canvas = e));
      }
      return Je.__canvas;
    }
    static get _context() {
      return (
        Je.__context || (Je.__context = Je._canvas.getContext("2d", e0)),
        Je.__context
      );
    }
  };
((ho.METRICS_STRING = "|q"),
  (ho.BASELINE_SYMBOL = "M"),
  (ho.BASELINE_MULTIPLIER = 1.4),
  (ho.HEIGHT_MULTIPLIER = 2),
  (ho.graphemeSegmenter = (() => {
    if (typeof Intl?.Segmenter == "function") {
      const n = new Intl.Segmenter();
      return (e) => [...n.segment(e)].map((t) => t.segment);
    }
    return (n) => [...n];
  })()),
  (ho.experimentalLetterSpacing = !1),
  (ho._fonts = {}),
  (ho._newlines = [10, 13]),
  (ho._breakingSpaces = [
    9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287,
    12288,
  ]));
let ul = ho;
const Vpe = [
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui",
  ],
  lN = class Yf {
    constructor(e) {
      ((this.styleID = 0), this.reset(), KA(this, e, e));
    }
    clone() {
      const e = {};
      return (KA(e, this, Yf.defaultStyle), new Yf(e));
    }
    reset() {
      KA(this, Yf.defaultStyle, Yf.defaultStyle);
    }
    get align() {
      return this._align;
    }
    set align(e) {
      this._align !== e && ((this._align = e), this.styleID++);
    }
    get breakWords() {
      return this._breakWords;
    }
    set breakWords(e) {
      this._breakWords !== e && ((this._breakWords = e), this.styleID++);
    }
    get dropShadow() {
      return this._dropShadow;
    }
    set dropShadow(e) {
      this._dropShadow !== e && ((this._dropShadow = e), this.styleID++);
    }
    get dropShadowAlpha() {
      return this._dropShadowAlpha;
    }
    set dropShadowAlpha(e) {
      this._dropShadowAlpha !== e &&
        ((this._dropShadowAlpha = e), this.styleID++);
    }
    get dropShadowAngle() {
      return this._dropShadowAngle;
    }
    set dropShadowAngle(e) {
      this._dropShadowAngle !== e &&
        ((this._dropShadowAngle = e), this.styleID++);
    }
    get dropShadowBlur() {
      return this._dropShadowBlur;
    }
    set dropShadowBlur(e) {
      this._dropShadowBlur !== e &&
        ((this._dropShadowBlur = e), this.styleID++);
    }
    get dropShadowColor() {
      return this._dropShadowColor;
    }
    set dropShadowColor(e) {
      const t = XA(e);
      this._dropShadowColor !== t &&
        ((this._dropShadowColor = t), this.styleID++);
    }
    get dropShadowDistance() {
      return this._dropShadowDistance;
    }
    set dropShadowDistance(e) {
      this._dropShadowDistance !== e &&
        ((this._dropShadowDistance = e), this.styleID++);
    }
    get fill() {
      return this._fill;
    }
    set fill(e) {
      const t = XA(e);
      this._fill !== t && ((this._fill = t), this.styleID++);
    }
    get fillGradientType() {
      return this._fillGradientType;
    }
    set fillGradientType(e) {
      this._fillGradientType !== e &&
        ((this._fillGradientType = e), this.styleID++);
    }
    get fillGradientStops() {
      return this._fillGradientStops;
    }
    set fillGradientStops(e) {
      Zpe(this._fillGradientStops, e) ||
        ((this._fillGradientStops = e), this.styleID++);
    }
    get fontFamily() {
      return this._fontFamily;
    }
    set fontFamily(e) {
      this.fontFamily !== e && ((this._fontFamily = e), this.styleID++);
    }
    get fontSize() {
      return this._fontSize;
    }
    set fontSize(e) {
      this._fontSize !== e && ((this._fontSize = e), this.styleID++);
    }
    get fontStyle() {
      return this._fontStyle;
    }
    set fontStyle(e) {
      this._fontStyle !== e && ((this._fontStyle = e), this.styleID++);
    }
    get fontVariant() {
      return this._fontVariant;
    }
    set fontVariant(e) {
      this._fontVariant !== e && ((this._fontVariant = e), this.styleID++);
    }
    get fontWeight() {
      return this._fontWeight;
    }
    set fontWeight(e) {
      this._fontWeight !== e && ((this._fontWeight = e), this.styleID++);
    }
    get letterSpacing() {
      return this._letterSpacing;
    }
    set letterSpacing(e) {
      this._letterSpacing !== e && ((this._letterSpacing = e), this.styleID++);
    }
    get lineHeight() {
      return this._lineHeight;
    }
    set lineHeight(e) {
      this._lineHeight !== e && ((this._lineHeight = e), this.styleID++);
    }
    get leading() {
      return this._leading;
    }
    set leading(e) {
      this._leading !== e && ((this._leading = e), this.styleID++);
    }
    get lineJoin() {
      return this._lineJoin;
    }
    set lineJoin(e) {
      this._lineJoin !== e && ((this._lineJoin = e), this.styleID++);
    }
    get miterLimit() {
      return this._miterLimit;
    }
    set miterLimit(e) {
      this._miterLimit !== e && ((this._miterLimit = e), this.styleID++);
    }
    get padding() {
      return this._padding;
    }
    set padding(e) {
      this._padding !== e && ((this._padding = e), this.styleID++);
    }
    get stroke() {
      return this._stroke;
    }
    set stroke(e) {
      const t = XA(e);
      this._stroke !== t && ((this._stroke = t), this.styleID++);
    }
    get strokeThickness() {
      return this._strokeThickness;
    }
    set strokeThickness(e) {
      this._strokeThickness !== e &&
        ((this._strokeThickness = e), this.styleID++);
    }
    get textBaseline() {
      return this._textBaseline;
    }
    set textBaseline(e) {
      this._textBaseline !== e && ((this._textBaseline = e), this.styleID++);
    }
    get trim() {
      return this._trim;
    }
    set trim(e) {
      this._trim !== e && ((this._trim = e), this.styleID++);
    }
    get whiteSpace() {
      return this._whiteSpace;
    }
    set whiteSpace(e) {
      this._whiteSpace !== e && ((this._whiteSpace = e), this.styleID++);
    }
    get wordWrap() {
      return this._wordWrap;
    }
    set wordWrap(e) {
      this._wordWrap !== e && ((this._wordWrap = e), this.styleID++);
    }
    get wordWrapWidth() {
      return this._wordWrapWidth;
    }
    set wordWrapWidth(e) {
      this._wordWrapWidth !== e && ((this._wordWrapWidth = e), this.styleID++);
    }
    toFontString() {
      const e =
        typeof this.fontSize == "number" ? `${this.fontSize}px` : this.fontSize;
      let t = this.fontFamily;
      Array.isArray(this.fontFamily) || (t = this.fontFamily.split(","));
      for (let i = t.length - 1; i >= 0; i--) {
        let r = t[i].trim();
        (!/([\"\'])[^\'\"]+\1/.test(r) && !Vpe.includes(r) && (r = `"${r}"`),
          (t[i] = r));
      }
      return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${e} ${t.join(",")}`;
    }
  };
lN.defaultStyle = {
  align: "left",
  breakWords: !1,
  dropShadow: !1,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fillGradientType: _I.LINEAR_VERTICAL,
  fillGradientStops: [],
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  leading: 0,
  letterSpacing: 0,
  lineHeight: 0,
  lineJoin: "miter",
  miterLimit: 10,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  textBaseline: "alphabetic",
  trim: !1,
  whiteSpace: "pre",
  wordWrap: !1,
  wordWrapWidth: 100,
};
let Ul = lN;
function XA(n) {
  const e = Ln.shared,
    t = (i) => {
      const r = e.setValue(i);
      return r.alpha === 1 ? r.toHex() : r.toRgbaString();
    };
  return Array.isArray(n) ? n.map(t) : t(n);
}
function Zpe(n, e) {
  if (!Array.isArray(n) || !Array.isArray(e) || n.length !== e.length)
    return !1;
  for (let t = 0; t < n.length; ++t) if (n[t] !== e[t]) return !1;
  return !0;
}
function KA(n, e, t) {
  for (const i in t)
    Array.isArray(e[i]) ? (n[i] = e[i].slice()) : (n[i] = e[i]);
}
const zpe = { texture: !0, children: !1, baseTexture: !0 },
  cN = class lb extends $d {
    constructor(e, t, i) {
      let r = !1;
      (i || ((i = Oe.ADAPTER.createCanvas()), (r = !0)),
        (i.width = 3),
        (i.height = 3));
      const s = Qe.from(i);
      ((s.orig = new Bt()),
        (s.trim = new Bt()),
        super(s),
        (this._ownCanvas = r),
        (this.canvas = i),
        (this.context = i.getContext("2d", { willReadFrequently: !0 })),
        (this._resolution = lb.defaultResolution ?? Oe.RESOLUTION),
        (this._autoResolution = lb.defaultAutoResolution),
        (this._text = null),
        (this._style = null),
        (this._styleListener = null),
        (this._font = ""),
        (this.text = e),
        (this.style = t),
        (this.localStyleID = -1));
    }
    static get experimentalLetterSpacing() {
      return ul.experimentalLetterSpacing;
    }
    static set experimentalLetterSpacing(e) {
      (Ht(
        "7.1.0",
        "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing",
      ),
        (ul.experimentalLetterSpacing = e));
    }
    updateText(e) {
      const t = this._style;
      if (
        (this.localStyleID !== t.styleID &&
          ((this.dirty = !0), (this.localStyleID = t.styleID)),
        !this.dirty && e)
      )
        return;
      this._font = this._style.toFontString();
      const i = this.context,
        r = ul.measureText(
          this._text || " ",
          this._style,
          this._style.wordWrap,
          this.canvas,
        ),
        s = r.width,
        o = r.height,
        a = r.lines,
        l = r.lineHeight,
        c = r.lineWidths,
        u = r.maxLineWidth,
        h = r.fontProperties;
      ((this.canvas.width = Math.ceil(
        Math.ceil(Math.max(1, s) + t.padding * 2) * this._resolution,
      )),
        (this.canvas.height = Math.ceil(
          Math.ceil(Math.max(1, o) + t.padding * 2) * this._resolution,
        )),
        i.scale(this._resolution, this._resolution),
        i.clearRect(0, 0, this.canvas.width, this.canvas.height),
        (i.font = this._font),
        (i.lineWidth = t.strokeThickness),
        (i.textBaseline = t.textBaseline),
        (i.lineJoin = t.lineJoin),
        (i.miterLimit = t.miterLimit));
      let d, f;
      const g = t.dropShadow ? 2 : 1;
      for (let p = 0; p < g; ++p) {
        const m = t.dropShadow && p === 0,
          C = m ? Math.ceil(Math.max(1, o) + t.padding * 2) : 0,
          A = C * this._resolution;
        if (m) {
          ((i.fillStyle = "black"), (i.strokeStyle = "black"));
          const y = t.dropShadowColor,
            x = t.dropShadowBlur * this._resolution,
            T = t.dropShadowDistance * this._resolution;
          ((i.shadowColor = Ln.shared
            .setValue(y)
            .setAlpha(t.dropShadowAlpha)
            .toRgbaString()),
            (i.shadowBlur = x),
            (i.shadowOffsetX = Math.cos(t.dropShadowAngle) * T),
            (i.shadowOffsetY = Math.sin(t.dropShadowAngle) * T + A));
        } else
          ((i.fillStyle = this._generateFillStyle(t, a, r)),
            (i.strokeStyle = t.stroke),
            (i.shadowColor = "black"),
            (i.shadowBlur = 0),
            (i.shadowOffsetX = 0),
            (i.shadowOffsetY = 0));
        let I = (l - h.fontSize) / 2;
        l - h.fontSize < 0 && (I = 0);
        for (let y = 0; y < a.length; y++)
          ((d = t.strokeThickness / 2),
            (f = t.strokeThickness / 2 + y * l + h.ascent + I),
            t.align === "right"
              ? (d += u - c[y])
              : t.align === "center" && (d += (u - c[y]) / 2),
            t.stroke &&
              t.strokeThickness &&
              this.drawLetterSpacing(
                a[y],
                d + t.padding,
                f + t.padding - C,
                !0,
              ),
            t.fill &&
              this.drawLetterSpacing(a[y], d + t.padding, f + t.padding - C));
      }
      this.updateTexture();
    }
    drawLetterSpacing(e, t, i, r = !1) {
      const s = this._style.letterSpacing;
      let o = !1;
      if (
        (ul.experimentalLetterSpacingSupported &&
          (ul.experimentalLetterSpacing
            ? ((this.context.letterSpacing = `${s}px`),
              (this.context.textLetterSpacing = `${s}px`),
              (o = !0))
            : ((this.context.letterSpacing = "0px"),
              (this.context.textLetterSpacing = "0px"))),
        s === 0 || o)
      ) {
        r ? this.context.strokeText(e, t, i) : this.context.fillText(e, t, i);
        return;
      }
      let a = t;
      const l = ul.graphemeSegmenter(e);
      let c = this.context.measureText(e).width,
        u = 0;
      for (let h = 0; h < l.length; ++h) {
        const d = l[h];
        r ? this.context.strokeText(d, a, i) : this.context.fillText(d, a, i);
        let f = "";
        for (let g = h + 1; g < l.length; ++g) f += l[g];
        ((u = this.context.measureText(f).width), (a += c - u + s), (c = u));
      }
    }
    updateTexture() {
      const e = this.canvas;
      if (this._style.trim) {
        const o = gde(e);
        o.data &&
          ((e.width = o.width),
          (e.height = o.height),
          this.context.putImageData(o.data, 0, 0));
      }
      const t = this._texture,
        i = this._style,
        r = i.trim ? 0 : i.padding,
        s = t.baseTexture;
      ((t.trim.width = t._frame.width = e.width / this._resolution),
        (t.trim.height = t._frame.height = e.height / this._resolution),
        (t.trim.x = -r),
        (t.trim.y = -r),
        (t.orig.width = t._frame.width - r * 2),
        (t.orig.height = t._frame.height - r * 2),
        this._onTextureUpdate(),
        s.setRealSize(e.width, e.height, this._resolution),
        t.updateUvs(),
        (this.dirty = !1));
    }
    _render(e) {
      (this._autoResolution &&
        this._resolution !== e.resolution &&
        ((this._resolution = e.resolution), (this.dirty = !0)),
        this.updateText(!0),
        super._render(e));
    }
    updateTransform() {
      (this.updateText(!0), super.updateTransform());
    }
    getBounds(e, t) {
      return (
        this.updateText(!0),
        this._textureID === -1 && (e = !1),
        super.getBounds(e, t)
      );
    }
    getLocalBounds(e) {
      return (this.updateText(!0), super.getLocalBounds.call(this, e));
    }
    _calculateBounds() {
      (this.calculateVertices(), this._bounds.addQuad(this.vertexData));
    }
    _generateFillStyle(e, t, i) {
      const r = e.fill;
      if (Array.isArray(r)) {
        if (r.length === 1) return r[0];
      } else return r;
      let s;
      const o = e.dropShadow ? e.dropShadowDistance : 0,
        a = e.padding || 0,
        l = this.canvas.width / this._resolution - o - a * 2,
        c = this.canvas.height / this._resolution - o - a * 2,
        u = r.slice(),
        h = e.fillGradientStops.slice();
      if (!h.length) {
        const d = u.length + 1;
        for (let f = 1; f < d; ++f) h.push(f / d);
      }
      if (
        (u.unshift(r[0]),
        h.unshift(0),
        u.push(r[r.length - 1]),
        h.push(1),
        e.fillGradientType === _I.LINEAR_VERTICAL)
      ) {
        s = this.context.createLinearGradient(l / 2, a, l / 2, c + a);
        const d = i.fontProperties.fontSize + e.strokeThickness;
        for (let f = 0; f < t.length; f++) {
          const g = i.lineHeight * (f - 1) + d,
            p = i.lineHeight * f;
          let m = p;
          f > 0 && g > p && (m = (p + g) / 2);
          const C = p + d,
            A = i.lineHeight * (f + 1);
          let I = C;
          f + 1 < t.length && A < C && (I = (C + A) / 2);
          const y = (I - m) / c;
          for (let x = 0; x < u.length; x++) {
            let T = 0;
            typeof h[x] == "number" ? (T = h[x]) : (T = x / u.length);
            let S = Math.min(1, Math.max(0, m / c + T * y));
            ((S = Number(S.toFixed(5))), s.addColorStop(S, u[x]));
          }
        }
      } else {
        s = this.context.createLinearGradient(a, c / 2, l + a, c / 2);
        const d = u.length + 1;
        let f = 1;
        for (let g = 0; g < u.length; g++) {
          let p;
          (typeof h[g] == "number" ? (p = h[g]) : (p = f / d),
            s.addColorStop(p, u[g]),
            f++);
        }
      }
      return s;
    }
    destroy(e) {
      (typeof e == "boolean" && (e = { children: e }),
        (e = Object.assign({}, zpe, e)),
        super.destroy(e),
        this._ownCanvas && (this.canvas.height = this.canvas.width = 0),
        (this.context = null),
        (this.canvas = null),
        (this._style = null));
    }
    get width() {
      return (
        this.updateText(!0),
        Math.abs(this.scale.x) * this._texture.orig.width
      );
    }
    set width(e) {
      this.updateText(!0);
      const t = bl(this.scale.x) || 1;
      ((this.scale.x = (t * e) / this._texture.orig.width), (this._width = e));
    }
    get height() {
      return (
        this.updateText(!0),
        Math.abs(this.scale.y) * this._texture.orig.height
      );
    }
    set height(e) {
      this.updateText(!0);
      const t = bl(this.scale.y) || 1;
      ((this.scale.y = (t * e) / this._texture.orig.height),
        (this._height = e));
    }
    get style() {
      return this._style;
    }
    set style(e) {
      ((e = e || {}),
        e instanceof Ul ? (this._style = e) : (this._style = new Ul(e)),
        (this.localStyleID = -1),
        (this.dirty = !0));
    }
    get text() {
      return this._text;
    }
    set text(e) {
      ((e = String(e ?? "")),
        this._text !== e && ((this._text = e), (this.dirty = !0)));
    }
    get resolution() {
      return this._resolution;
    }
    set resolution(e) {
      ((this._autoResolution = !1),
        this._resolution !== e && ((this._resolution = e), (this.dirty = !0)));
    }
  };
cN.defaultAutoResolution = !0;
let B5 = cN;
class Ype {
  constructor(e) {
    ((this.maxItemsPerFrame = e), (this.itemsLeft = 0));
  }
  beginFrame() {
    this.itemsLeft = this.maxItemsPerFrame;
  }
  allowedToUpload() {
    return this.itemsLeft-- > 0;
  }
}
function Xpe(n, e) {
  let t = !1;
  if (n?._textures?.length) {
    for (let i = 0; i < n._textures.length; i++)
      if (n._textures[i] instanceof Qe) {
        const r = n._textures[i].baseTexture;
        e.includes(r) || (e.push(r), (t = !0));
      }
  }
  return t;
}
function Kpe(n, e) {
  if (n.baseTexture instanceof St) {
    const t = n.baseTexture;
    return (e.includes(t) || e.push(t), !0);
  }
  return !1;
}
function jpe(n, e) {
  if (n._texture && n._texture instanceof Qe) {
    const t = n._texture.baseTexture;
    return (e.includes(t) || e.push(t), !0);
  }
  return !1;
}
function $pe(n, e) {
  return e instanceof B5 ? (e.updateText(!0), !0) : !1;
}
function Jpe(n, e) {
  if (e instanceof Ul) {
    const t = e.toFontString();
    return (ul.measureFont(t), !0);
  }
  return !1;
}
function Qpe(n, e) {
  if (n instanceof B5) {
    (e.includes(n.style) || e.push(n.style), e.includes(n) || e.push(n));
    const t = n._texture.baseTexture;
    return (e.includes(t) || e.push(t), !0);
  }
  return !1;
}
function qpe(n, e) {
  return n instanceof Ul ? (e.includes(n) || e.push(n), !0) : !1;
}
const uN = class hN {
  constructor(e) {
    ((this.limiter = new Ype(hN.uploadsPerFrame)),
      (this.renderer = e),
      (this.uploadHookHelper = null),
      (this.queue = []),
      (this.addHooks = []),
      (this.uploadHooks = []),
      (this.completes = []),
      (this.ticking = !1),
      (this.delayedTick = () => {
        this.queue && this.prepareItems();
      }),
      this.registerFindHook(Qpe),
      this.registerFindHook(qpe),
      this.registerFindHook(Xpe),
      this.registerFindHook(Kpe),
      this.registerFindHook(jpe),
      this.registerUploadHook($pe),
      this.registerUploadHook(Jpe));
  }
  upload(e) {
    return new Promise((t) => {
      (e && this.add(e),
        this.queue.length
          ? (this.completes.push(t),
            this.ticking ||
              ((this.ticking = !0),
              Er.system.addOnce(this.tick, this, Iu.UTILITY)))
          : t());
    });
  }
  tick() {
    setTimeout(this.delayedTick, 0);
  }
  prepareItems() {
    for (
      this.limiter.beginFrame();
      this.queue.length && this.limiter.allowedToUpload();
    ) {
      const e = this.queue[0];
      let t = !1;
      if (e && !e._destroyed) {
        for (let i = 0, r = this.uploadHooks.length; i < r; i++)
          if (this.uploadHooks[i](this.uploadHookHelper, e)) {
            (this.queue.shift(), (t = !0));
            break;
          }
      }
      t || this.queue.shift();
    }
    if (this.queue.length) Er.system.addOnce(this.tick, this, Iu.UTILITY);
    else {
      this.ticking = !1;
      const e = this.completes.slice(0);
      this.completes.length = 0;
      for (let t = 0, i = e.length; t < i; t++) e[t]();
    }
  }
  registerFindHook(e) {
    return (e && this.addHooks.push(e), this);
  }
  registerUploadHook(e) {
    return (e && this.uploadHooks.push(e), this);
  }
  add(e) {
    for (
      let t = 0, i = this.addHooks.length;
      t < i && !this.addHooks[t](e, this.queue);
      t++
    );
    if (e instanceof Rs)
      for (let t = e.children.length - 1; t >= 0; t--) this.add(e.children[t]);
    return this;
  }
  destroy() {
    (this.ticking && Er.system.remove(this.tick, this),
      (this.ticking = !1),
      (this.addHooks = null),
      (this.uploadHooks = null),
      (this.renderer = null),
      (this.completes = null),
      (this.queue = null),
      (this.limiter = null),
      (this.uploadHookHelper = null));
  }
};
uN.uploadsPerFrame = 4;
let cb = uN;
Object.defineProperties(Oe, {
  UPLOADS_PER_FRAME: {
    get() {
      return cb.uploadsPerFrame;
    },
    set(n) {
      (Ht(
        "7.1.0",
        "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame",
      ),
        (cb.uploadsPerFrame = n));
    },
  },
});
function dN(n, e) {
  return e instanceof St
    ? (e._glTextures[n.CONTEXT_UID] || n.texture.bind(e), !0)
    : !1;
}
function e1e(n, e) {
  if (!(e instanceof bC)) return !1;
  const { geometry: t } = e;
  (e.finishPoly(), t.updateBatches());
  const { batches: i } = t;
  for (let r = 0; r < i.length; r++) {
    const { texture: s } = i[r].style;
    s && dN(n, s.baseTexture);
  }
  return (t.batchable || n.geometry.bind(t, e._resolveDirectShader(n)), !0);
}
function t1e(n, e) {
  return n instanceof bC ? (e.push(n), !0) : !1;
}
class fN extends cb {
  constructor(e) {
    (super(e),
      (this.uploadHookHelper = this.renderer),
      this.registerFindHook(t1e),
      this.registerUploadHook(dN),
      this.registerUploadHook(e1e));
  }
}
fN.extension = { name: "prepare", type: De.RendererSystem };
je.add(fN);
var n1e = `#version 300 es
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

in vec2 vTextureCoord;

out vec4 fragmentColor;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0

    fragmentColor = texSample * uColor;
}
`,
  i1e = `#version 300 es
#define SHADER_NAME Tiling-Sprite-300

precision lowp float;

in vec2 aVertexPosition;
in vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

out vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`,
  r1e = `#version 100
#ifdef GL_EXT_shader_texture_lod
    #extension GL_EXT_shader_texture_lod : enable
#endif
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    #ifdef GL_EXT_shader_texture_lod
        vec4 texSample = unclamped == coord
            ? texture2D(uSampler, coord) 
            : texture2DLodEXT(uSampler, coord, 0);
    #else
        vec4 texSample = texture2D(uSampler, coord);
    #endif

    gl_FragColor = texSample * uColor;
}
`,
  q6 = `#version 100
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`,
  s1e = `#version 100
#define SHADER_NAME Tiling-Sprite-Simple-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;

void main(void)
{
    vec4 texSample = texture2D(uSampler, vTextureCoord);
    gl_FragColor = texSample * uColor;
}
`;
const t0 = new Rn();
class gN extends II {
  constructor(e) {
    (super(e),
      e.runners.contextChange.add(this),
      (this.quad = new _P()),
      (this.state = Yo.for2d()));
  }
  contextChange() {
    const e = this.renderer,
      t = { globals: e.globalUniforms };
    ((this.simpleShader = Bo.from(q6, s1e, t)),
      (this.shader =
        e.context.webGLVersion > 1
          ? Bo.from(i1e, n1e, t)
          : Bo.from(q6, r1e, t)));
  }
  render(e) {
    const t = this.renderer,
      i = this.quad;
    let r = i.vertices;
    ((r[0] = r[6] = e._width * -e.anchor.x),
      (r[1] = r[3] = e._height * -e.anchor.y),
      (r[2] = r[4] = e._width * (1 - e.anchor.x)),
      (r[5] = r[7] = e._height * (1 - e.anchor.y)));
    const s = e.uvRespectAnchor ? e.anchor.x : 0,
      o = e.uvRespectAnchor ? e.anchor.y : 0;
    ((r = i.uvs),
      (r[0] = r[6] = -s),
      (r[1] = r[3] = -o),
      (r[2] = r[4] = 1 - s),
      (r[5] = r[7] = 1 - o),
      i.invalidate());
    const a = e._texture,
      l = a.baseTexture,
      c = l.alphaMode > 0,
      u = e.tileTransform.localTransform,
      h = e.uvMatrix;
    let d =
      l.isPowerOfTwo &&
      a.frame.width === l.width &&
      a.frame.height === l.height;
    d &&
      (l._glTextures[t.CONTEXT_UID]
        ? (d = l.wrapMode !== Ll.CLAMP)
        : l.wrapMode === Ll.CLAMP && (l.wrapMode = Ll.REPEAT));
    const f = d ? this.simpleShader : this.shader,
      g = a.width,
      p = a.height,
      m = e._width,
      C = e._height;
    (t0.set(
      (u.a * g) / m,
      (u.b * g) / C,
      (u.c * p) / m,
      (u.d * p) / C,
      u.tx / m,
      u.ty / C,
    ),
      t0.invert(),
      d
        ? t0.prepend(h.mapCoord)
        : ((f.uniforms.uMapCoord = h.mapCoord.toArray(!0)),
          (f.uniforms.uClampFrame = h.uClampFrame),
          (f.uniforms.uClampOffset = h.uClampOffset)),
      (f.uniforms.uTransform = t0.toArray(!0)),
      (f.uniforms.uColor = Ln.shared
        .setValue(e.tint)
        .premultiply(e.worldAlpha, c)
        .toArray(f.uniforms.uColor)),
      (f.uniforms.translationMatrix = e.transform.worldTransform.toArray(!0)),
      (f.uniforms.uSampler = a),
      t.shader.bind(f),
      t.geometry.bind(i),
      (this.state.blendMode = aP(e.blendMode, c)),
      t.state.set(this.state),
      t.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0));
  }
}
gN.extension = { name: "tilingSprite", type: De.RendererPlugin };
je.add(gN);
const pN = class Xf {
  constructor(e, t, i = null) {
    ((this.linkedSheets = []),
      (this._texture = e instanceof Qe ? e : null),
      (this.baseTexture = e instanceof St ? e : this._texture.baseTexture),
      (this.textures = {}),
      (this.animations = {}),
      (this.data = t));
    const r = this.baseTexture.resource;
    ((this.resolution = this._updateResolution(i || (r ? r.url : null))),
      (this._frames = this.data.frames),
      (this._frameKeys = Object.keys(this._frames)),
      (this._batchIndex = 0),
      (this._callback = null));
  }
  _updateResolution(e = null) {
    const { scale: t } = this.data.meta;
    let i = Ga(e, null);
    return (
      i === null && (i = parseFloat(t ?? "1")),
      i !== 1 && this.baseTexture.setResolution(i),
      i
    );
  }
  parse() {
    return new Promise((e) => {
      ((this._callback = e),
        (this._batchIndex = 0),
        this._frameKeys.length <= Xf.BATCH_SIZE
          ? (this._processFrames(0),
            this._processAnimations(),
            this._parseComplete())
          : this._nextBatch());
    });
  }
  _processFrames(e) {
    let t = e;
    const i = Xf.BATCH_SIZE;
    for (; t - e < i && t < this._frameKeys.length; ) {
      const r = this._frameKeys[t],
        s = this._frames[r],
        o = s.frame;
      if (o) {
        let a = null,
          l = null;
        const c = s.trimmed !== !1 && s.sourceSize ? s.sourceSize : s.frame,
          u = new Bt(
            0,
            0,
            Math.floor(c.w) / this.resolution,
            Math.floor(c.h) / this.resolution,
          );
        (s.rotated
          ? (a = new Bt(
              Math.floor(o.x) / this.resolution,
              Math.floor(o.y) / this.resolution,
              Math.floor(o.h) / this.resolution,
              Math.floor(o.w) / this.resolution,
            ))
          : (a = new Bt(
              Math.floor(o.x) / this.resolution,
              Math.floor(o.y) / this.resolution,
              Math.floor(o.w) / this.resolution,
              Math.floor(o.h) / this.resolution,
            )),
          s.trimmed !== !1 &&
            s.spriteSourceSize &&
            (l = new Bt(
              Math.floor(s.spriteSourceSize.x) / this.resolution,
              Math.floor(s.spriteSourceSize.y) / this.resolution,
              Math.floor(o.w) / this.resolution,
              Math.floor(o.h) / this.resolution,
            )),
          (this.textures[r] = new Qe(
            this.baseTexture,
            a,
            u,
            l,
            s.rotated ? 2 : 0,
            s.anchor,
            s.borders,
          )),
          Qe.addToCache(this.textures[r], r.toString()));
      }
      t++;
    }
  }
  _processAnimations() {
    const e = this.data.animations || {};
    for (const t in e) {
      this.animations[t] = [];
      for (let i = 0; i < e[t].length; i++) {
        const r = e[t][i];
        this.animations[t].push(this.textures[r]);
      }
    }
  }
  _parseComplete() {
    const e = this._callback;
    ((this._callback = null),
      (this._batchIndex = 0),
      e.call(this, this.textures));
  }
  _nextBatch() {
    (this._processFrames(this._batchIndex * Xf.BATCH_SIZE),
      this._batchIndex++,
      setTimeout(() => {
        this._batchIndex * Xf.BATCH_SIZE < this._frameKeys.length
          ? this._nextBatch()
          : (this._processAnimations(), this._parseComplete());
      }, 0));
  }
  destroy(e = !1) {
    for (const t in this.textures) this.textures[t].destroy();
    ((this._frames = null),
      (this._frameKeys = null),
      (this.data = null),
      (this.textures = null),
      e && (this._texture?.destroy(), this.baseTexture.destroy()),
      (this._texture = null),
      (this.baseTexture = null),
      (this.linkedSheets = []));
  }
};
pN.BATCH_SIZE = 1e3;
let e7 = pN;
const o1e = ["jpg", "png", "jpeg", "avif", "webp"];
function mN(n, e, t) {
  const i = {};
  if (
    (n.forEach((r) => {
      i[r] = e;
    }),
    Object.keys(e.textures).forEach((r) => {
      i[r] = e.textures[r];
    }),
    !t)
  ) {
    const r = mr.dirname(n[0]);
    e.linkedSheets.forEach((s, o) => {
      const a = mN([`${r}/${e.data.meta.related_multi_packs[o]}`], s, !0);
      Object.assign(i, a);
    });
  }
  return i;
}
const a1e = {
  extension: De.Asset,
  cache: {
    test: (n) => n instanceof e7,
    getCacheableAssets: (n, e) => mN(n, e, !1),
  },
  resolver: {
    test: (n) => {
      const e = n.split("?")[0].split("."),
        t = e.pop(),
        i = e.pop();
      return t === "json" && o1e.includes(i);
    },
    parse: (n) => {
      const e = n.split(".");
      return {
        resolution: parseFloat(Oe.RETINA_PREFIX.exec(n)?.[1] ?? "1"),
        format: e[e.length - 2],
        src: n,
      };
    },
  },
  loader: {
    name: "spritesheetLoader",
    extension: { type: De.LoadParser, priority: oo.Normal },
    async testParse(n, e) {
      return mr.extname(e.src).toLowerCase() === ".json" && !!n.frames;
    },
    async parse(n, e, t) {
      let i = mr.dirname(e.src);
      i && i.lastIndexOf("/") !== i.length - 1 && (i += "/");
      let r = i + n.meta.image;
      r = sb(r, e.src);
      const s = (await t.load([r]))[r],
        o = new e7(s.baseTexture, n, e.src);
      await o.parse();
      const a = n?.meta?.related_multi_packs;
      if (Array.isArray(a)) {
        const l = [];
        for (const u of a) {
          if (typeof u != "string") continue;
          let h = i + u;
          e.data?.ignoreMultiPack ||
            ((h = sb(h, e.src)),
            l.push(t.load({ src: h, data: { ignoreMultiPack: !0 } })));
        }
        const c = await Promise.all(l);
        ((o.linkedSheets = c),
          c.forEach((u) => {
            u.linkedSheets = [o].concat(o.linkedSheets.filter((h) => h !== u));
          }));
      }
      return o;
    },
    unload(n) {
      n.destroy(!0);
    },
  },
};
je.add(a1e);
class vC {
  constructor() {
    ((this.info = []),
      (this.common = []),
      (this.page = []),
      (this.char = []),
      (this.kerning = []),
      (this.distanceField = []));
  }
}
class nm {
  static test(e) {
    return typeof e == "string" && e.startsWith("info face=");
  }
  static parse(e) {
    const t = e.match(/^[a-z]+\s+.+$/gm),
      i = {
        info: [],
        common: [],
        page: [],
        char: [],
        chars: [],
        kerning: [],
        kernings: [],
        distanceField: [],
      };
    for (const s in t) {
      const o = t[s].match(/^[a-z]+/gm)[0],
        a = t[s].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),
        l = {};
      for (const c in a) {
        const u = a[c].split("="),
          h = u[0],
          d = u[1].replace(/"/gm, ""),
          f = parseFloat(d),
          g = isNaN(f) ? d : f;
        l[h] = g;
      }
      i[o].push(l);
    }
    const r = new vC();
    return (
      i.info.forEach((s) =>
        r.info.push({ face: s.face, size: parseInt(s.size, 10) }),
      ),
      i.common.forEach((s) =>
        r.common.push({ lineHeight: parseInt(s.lineHeight, 10) }),
      ),
      i.page.forEach((s) =>
        r.page.push({ id: parseInt(s.id, 10), file: s.file }),
      ),
      i.char.forEach((s) =>
        r.char.push({
          id: parseInt(s.id, 10),
          page: parseInt(s.page, 10),
          x: parseInt(s.x, 10),
          y: parseInt(s.y, 10),
          width: parseInt(s.width, 10),
          height: parseInt(s.height, 10),
          xoffset: parseInt(s.xoffset, 10),
          yoffset: parseInt(s.yoffset, 10),
          xadvance: parseInt(s.xadvance, 10),
        }),
      ),
      i.kerning.forEach((s) =>
        r.kerning.push({
          first: parseInt(s.first, 10),
          second: parseInt(s.second, 10),
          amount: parseInt(s.amount, 10),
        }),
      ),
      i.distanceField.forEach((s) =>
        r.distanceField.push({
          distanceRange: parseInt(s.distanceRange, 10),
          fieldType: s.fieldType,
        }),
      ),
      r
    );
  }
}
class ub {
  static test(e) {
    const t = e;
    return (
      typeof e != "string" &&
      "getElementsByTagName" in e &&
      t.getElementsByTagName("page").length &&
      t.getElementsByTagName("info")[0].getAttribute("face") !== null
    );
  }
  static parse(e) {
    const t = new vC(),
      i = e.getElementsByTagName("info"),
      r = e.getElementsByTagName("common"),
      s = e.getElementsByTagName("page"),
      o = e.getElementsByTagName("char"),
      a = e.getElementsByTagName("kerning"),
      l = e.getElementsByTagName("distanceField");
    for (let c = 0; c < i.length; c++)
      t.info.push({
        face: i[c].getAttribute("face"),
        size: parseInt(i[c].getAttribute("size"), 10),
      });
    for (let c = 0; c < r.length; c++)
      t.common.push({
        lineHeight: parseInt(r[c].getAttribute("lineHeight"), 10),
      });
    for (let c = 0; c < s.length; c++)
      t.page.push({
        id: parseInt(s[c].getAttribute("id"), 10) || 0,
        file: s[c].getAttribute("file"),
      });
    for (let c = 0; c < o.length; c++) {
      const u = o[c];
      t.char.push({
        id: parseInt(u.getAttribute("id"), 10),
        page: parseInt(u.getAttribute("page"), 10) || 0,
        x: parseInt(u.getAttribute("x"), 10),
        y: parseInt(u.getAttribute("y"), 10),
        width: parseInt(u.getAttribute("width"), 10),
        height: parseInt(u.getAttribute("height"), 10),
        xoffset: parseInt(u.getAttribute("xoffset"), 10),
        yoffset: parseInt(u.getAttribute("yoffset"), 10),
        xadvance: parseInt(u.getAttribute("xadvance"), 10),
      });
    }
    for (let c = 0; c < a.length; c++)
      t.kerning.push({
        first: parseInt(a[c].getAttribute("first"), 10),
        second: parseInt(a[c].getAttribute("second"), 10),
        amount: parseInt(a[c].getAttribute("amount"), 10),
      });
    for (let c = 0; c < l.length; c++)
      t.distanceField.push({
        fieldType: l[c].getAttribute("fieldType"),
        distanceRange: parseInt(l[c].getAttribute("distanceRange"), 10),
      });
    return t;
  }
}
class hb {
  static test(e) {
    return typeof e == "string" && e.includes("<font>")
      ? ub.test(Oe.ADAPTER.parseXML(e))
      : !1;
  }
  static parse(e) {
    return ub.parse(Oe.ADAPTER.parseXML(e));
  }
}
const jA = [nm, ub, hb];
function l1e(n) {
  for (let e = 0; e < jA.length; e++) if (jA[e].test(n)) return jA[e];
  return null;
}
function c1e(n, e, t, i, r, s) {
  const o = t.fill;
  if (Array.isArray(o)) {
    if (o.length === 1) return o[0];
  } else return o;
  let a;
  const l = t.dropShadow ? t.dropShadowDistance : 0,
    c = t.padding || 0,
    u = n.width / i - l - c * 2,
    h = n.height / i - l - c * 2,
    d = o.slice(),
    f = t.fillGradientStops.slice();
  if (!f.length) {
    const g = d.length + 1;
    for (let p = 1; p < g; ++p) f.push(p / g);
  }
  if (
    (d.unshift(o[0]),
    f.unshift(0),
    d.push(o[o.length - 1]),
    f.push(1),
    t.fillGradientType === _I.LINEAR_VERTICAL)
  ) {
    a = e.createLinearGradient(u / 2, c, u / 2, h + c);
    let g = 0;
    const p = (s.fontProperties.fontSize + t.strokeThickness) / h;
    for (let m = 0; m < r.length; m++) {
      const C = s.lineHeight * m;
      for (let A = 0; A < d.length; A++) {
        let I = 0;
        typeof f[A] == "number" ? (I = f[A]) : (I = A / d.length);
        const y = C / h + I * p;
        let x = Math.max(g, y);
        ((x = Math.min(x, 1)), a.addColorStop(x, d[A]), (g = x));
      }
    }
  } else {
    a = e.createLinearGradient(c, h / 2, u + c, h / 2);
    const g = d.length + 1;
    let p = 1;
    for (let m = 0; m < d.length; m++) {
      let C;
      (typeof f[m] == "number" ? (C = f[m]) : (C = p / g),
        a.addColorStop(C, d[m]),
        p++);
    }
  }
  return a;
}
function u1e(n, e, t, i, r, s, o) {
  const a = t.text,
    l = t.fontProperties;
  (e.translate(i, r), e.scale(s, s));
  const c = o.strokeThickness / 2,
    u = -(o.strokeThickness / 2);
  if (
    ((e.font = o.toFontString()),
    (e.lineWidth = o.strokeThickness),
    (e.textBaseline = o.textBaseline),
    (e.lineJoin = o.lineJoin),
    (e.miterLimit = o.miterLimit),
    (e.fillStyle = c1e(n, e, o, s, [a], t)),
    (e.strokeStyle = o.stroke),
    o.dropShadow)
  ) {
    const h = o.dropShadowColor,
      d = o.dropShadowBlur * s,
      f = o.dropShadowDistance * s;
    ((e.shadowColor = Ln.shared
      .setValue(h)
      .setAlpha(o.dropShadowAlpha)
      .toRgbaString()),
      (e.shadowBlur = d),
      (e.shadowOffsetX = Math.cos(o.dropShadowAngle) * f),
      (e.shadowOffsetY = Math.sin(o.dropShadowAngle) * f));
  } else
    ((e.shadowColor = "black"),
      (e.shadowBlur = 0),
      (e.shadowOffsetX = 0),
      (e.shadowOffsetY = 0));
  (o.stroke &&
    o.strokeThickness &&
    e.strokeText(a, c, u + t.lineHeight - l.descent),
    o.fill && e.fillText(a, c, u + t.lineHeight - l.descent),
    e.setTransform(1, 0, 0, 1, 0, 0),
    (e.fillStyle = "rgba(0, 0, 0, 0)"));
}
function im(n) {
  return n.codePointAt ? n.codePointAt(0) : n.charCodeAt(0);
}
function CN(n) {
  return Array.from ? Array.from(n) : n.split("");
}
function h1e(n) {
  typeof n == "string" && (n = [n]);
  const e = [];
  for (let t = 0, i = n.length; t < i; t++) {
    const r = n[t];
    if (Array.isArray(r)) {
      if (r.length !== 2)
        throw new Error(
          `[BitmapFont]: Invalid character range length, expecting 2 got ${r.length}.`,
        );
      const s = r[0].charCodeAt(0),
        o = r[1].charCodeAt(0);
      if (o < s) throw new Error("[BitmapFont]: Invalid character range.");
      for (let a = s, l = o; a <= l; a++) e.push(String.fromCharCode(a));
    } else e.push(...CN(r));
  }
  if (e.length === 0)
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  return e;
}
const rl = class fo {
  constructor(e, t, i) {
    const [r] = e.info,
      [s] = e.common,
      [o] = e.page,
      [a] = e.distanceField,
      l = Ga(o.file),
      c = {};
    ((this._ownsTextures = i),
      (this.font = r.face),
      (this.size = r.size),
      (this.lineHeight = s.lineHeight / l),
      (this.chars = {}),
      (this.pageTextures = c));
    for (let u = 0; u < e.page.length; u++) {
      const { id: h, file: d } = e.page[u];
      ((c[h] = t instanceof Array ? t[u] : t[d]),
        a?.fieldType &&
          a.fieldType !== "none" &&
          ((c[h].baseTexture.alphaMode = Tr.NO_PREMULTIPLIED_ALPHA),
          (c[h].baseTexture.mipmap = Ho.OFF)));
    }
    for (let u = 0; u < e.char.length; u++) {
      const { id: h, page: d } = e.char[u];
      let {
        x: f,
        y: g,
        width: p,
        height: m,
        xoffset: C,
        yoffset: A,
        xadvance: I,
      } = e.char[u];
      ((f /= l), (g /= l), (p /= l), (m /= l), (C /= l), (A /= l), (I /= l));
      const y = new Bt(f + c[d].frame.x / l, g + c[d].frame.y / l, p, m);
      this.chars[h] = {
        xOffset: C,
        yOffset: A,
        xAdvance: I,
        kerning: {},
        texture: new Qe(c[d].baseTexture, y),
        page: d,
      };
    }
    for (let u = 0; u < e.kerning.length; u++) {
      let { first: h, second: d, amount: f } = e.kerning[u];
      ((h /= l),
        (d /= l),
        (f /= l),
        this.chars[d] && (this.chars[d].kerning[h] = f));
    }
    ((this.distanceFieldRange = a?.distanceRange),
      (this.distanceFieldType = a?.fieldType?.toLowerCase() ?? "none"));
  }
  destroy() {
    for (const e in this.chars)
      (this.chars[e].texture.destroy(), (this.chars[e].texture = null));
    for (const e in this.pageTextures)
      (this._ownsTextures && this.pageTextures[e].destroy(!0),
        (this.pageTextures[e] = null));
    ((this.chars = null), (this.pageTextures = null));
  }
  static install(e, t, i) {
    let r;
    if (e instanceof vC) r = e;
    else {
      const o = l1e(e);
      if (!o) throw new Error("Unrecognized data format for font.");
      r = o.parse(e);
    }
    t instanceof Qe && (t = [t]);
    const s = new fo(r, t, i);
    return ((fo.available[s.font] = s), s);
  }
  static uninstall(e) {
    const t = fo.available[e];
    if (!t) throw new Error(`No font found named '${e}'`);
    (t.destroy(), delete fo.available[e]);
  }
  static from(e, t, i) {
    if (!e) throw new Error("[BitmapFont] Property `name` is required.");
    const {
        chars: r,
        padding: s,
        resolution: o,
        textureWidth: a,
        textureHeight: l,
        ...c
      } = Object.assign({}, fo.defaultOptions, i),
      u = h1e(r),
      h = t instanceof Ul ? t : new Ul(t),
      d = a,
      f = new vC();
    ((f.info[0] = { face: h.fontFamily, size: h.fontSize }),
      (f.common[0] = { lineHeight: h.fontSize }));
    let g = 0,
      p = 0,
      m,
      C,
      A,
      I = 0;
    const y = [];
    for (let T = 0; T < u.length; T++) {
      m ||
        ((m = Oe.ADAPTER.createCanvas()),
        (m.width = a),
        (m.height = l),
        (C = m.getContext("2d")),
        (A = new St(m, { resolution: o, ...c })),
        y.push(new Qe(A)),
        f.page.push({ id: y.length - 1, file: "" }));
      const S = u[T],
        E = ul.measureText(S, h, !1, m),
        _ = E.width,
        b = Math.ceil(E.height),
        R = Math.ceil((h.fontStyle === "italic" ? 2 : 1) * _);
      if (p >= l - b * o) {
        if (p === 0)
          throw new Error(
            `[BitmapFont] textureHeight ${l}px is too small (fontFamily: '${h.fontFamily}', fontSize: ${h.fontSize}px, char: '${S}')`,
          );
        (--T, (m = null), (C = null), (A = null), (p = 0), (g = 0), (I = 0));
        continue;
      }
      if (((I = Math.max(b + E.fontProperties.descent, I)), R * o + g >= d)) {
        if (g === 0)
          throw new Error(
            `[BitmapFont] textureWidth ${a}px is too small (fontFamily: '${h.fontFamily}', fontSize: ${h.fontSize}px, char: '${S}')`,
          );
        (--T, (p += I * o), (p = Math.ceil(p)), (g = 0), (I = 0));
        continue;
      }
      u1e(m, C, E, g, p, o, h);
      const M = im(E.text);
      (f.char.push({
        id: M,
        page: y.length - 1,
        x: g / o,
        y: p / o,
        width: R,
        height: b,
        xoffset: 0,
        yoffset: 0,
        xadvance:
          _ -
          (h.dropShadow ? h.dropShadowDistance : 0) -
          (h.stroke ? h.strokeThickness : 0),
      }),
        (g += (R + 2 * s) * o),
        (g = Math.ceil(g)));
    }
    if (!i?.skipKerning)
      for (let T = 0, S = u.length; T < S; T++) {
        const E = u[T];
        for (let _ = 0; _ < S; _++) {
          const b = u[_],
            R = C.measureText(E).width,
            M = C.measureText(b).width,
            L = C.measureText(E + b).width - (R + M);
          L && f.kerning.push({ first: im(E), second: im(b), amount: L });
        }
      }
    const x = new fo(f, y, !0);
    return (
      fo.available[e] !== void 0 && fo.uninstall(e),
      (fo.available[e] = x),
      x
    );
  }
};
((rl.ALPHA = [["a", "z"], ["A", "Z"], " "]),
  (rl.NUMERIC = [["0", "9"]]),
  (rl.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "]),
  (rl.ASCII = [[" ", "~"]]),
  (rl.defaultOptions = {
    resolution: 1,
    textureWidth: 512,
    textureHeight: 512,
    padding: 4,
    chars: rl.ALPHANUMERIC,
  }),
  (rl.available = {}));
let sl = rl;
var d1e = `// Pixi texture info\r
varying vec2 vTextureCoord;\r
uniform sampler2D uSampler;\r
\r
// Tint\r
uniform vec4 uColor;\r
\r
// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r
uniform float uFWidth;\r
\r
void main(void) {\r
\r
  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r
  vec4 texColor = texture2D(uSampler, vTextureCoord);\r
\r
  // MSDF\r
  float median = texColor.r + texColor.g + texColor.b -\r
                  min(texColor.r, min(texColor.g, texColor.b)) -\r
                  max(texColor.r, max(texColor.g, texColor.b));\r
  // SDF\r
  median = min(median, texColor.a);\r
\r
  float screenPxDistance = uFWidth * (median - 0.5);\r
  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r
  if (median < 0.01) {\r
    alpha = 0.0;\r
  } else if (median > 0.99) {\r
    alpha = 1.0;\r
  }\r
\r
  // Gamma correction for coverage-like alpha\r
  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\r
  float gamma = mix(1.0, 1.0 / 2.2, luma);\r
  float coverage = pow(uColor.a * alpha, gamma);  \r
\r
  // NPM Textures, NPM outputs\r
  gl_FragColor = vec4(uColor.rgb, coverage);\r
}\r
`,
  f1e = `// Mesh material default fragment\r
attribute vec2 aVertexPosition;\r
attribute vec2 aTextureCoord;\r
\r
uniform mat3 projectionMatrix;\r
uniform mat3 translationMatrix;\r
uniform mat3 uTextureMatrix;\r
\r
varying vec2 vTextureCoord;\r
\r
void main(void)\r
{\r
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r
\r
    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r
}\r
`;
const t7 = [],
  n7 = [],
  i7 = [],
  g1e = class IN extends Rs {
    constructor(e, t = {}) {
      super();
      const {
        align: i,
        tint: r,
        maxWidth: s,
        letterSpacing: o,
        fontName: a,
        fontSize: l,
      } = Object.assign({}, IN.styleDefaults, t);
      if (!sl.available[a]) throw new Error(`Missing BitmapFont "${a}"`);
      ((this._activePagesMeshData = []),
        (this._textWidth = 0),
        (this._textHeight = 0),
        (this._align = i),
        (this._tintColor = new Ln(r)),
        (this._font = void 0),
        (this._fontName = a),
        (this._fontSize = l),
        (this.text = e),
        (this._maxWidth = s),
        (this._maxLineHeight = 0),
        (this._letterSpacing = o),
        (this._anchor = new Aa(
          () => {
            this.dirty = !0;
          },
          this,
          0,
          0,
        )),
        (this._roundPixels = Oe.ROUND_PIXELS),
        (this.dirty = !0),
        (this._resolution = Oe.RESOLUTION),
        (this._autoResolution = !0),
        (this._textureCache = {}));
    }
    updateText() {
      const e = sl.available[this._fontName],
        t = this.fontSize,
        i = t / e.size,
        r = new Qt(),
        s = [],
        o = [],
        a = [],
        l =
          this._text.replace(
            /(?:\r\n|\r)/g,
            `
`,
          ) || " ",
        c = CN(l),
        u = (this._maxWidth * e.size) / t,
        h = e.distanceFieldType === "none" ? t7 : n7;
      let d = null,
        f = 0,
        g = 0,
        p = 0,
        m = -1,
        C = 0,
        A = 0,
        I = 0,
        y = 0;
      for (let R = 0; R < c.length; R++) {
        const M = c[R],
          L = im(M);
        if (
          (/(?:\s)/.test(M) && ((m = R), (C = f), y++),
          M === "\r" ||
            M ===
              `
`)
        ) {
          (o.push(f),
            a.push(-1),
            (g = Math.max(g, f)),
            ++p,
            ++A,
            (r.x = 0),
            (r.y += e.lineHeight),
            (d = null),
            (y = 0));
          continue;
        }
        const P = e.chars[L];
        if (!P) continue;
        d && P.kerning[d] && (r.x += P.kerning[d]);
        const U = i7.pop() || {
          texture: Qe.EMPTY,
          line: 0,
          charCode: 0,
          prevSpaces: 0,
          position: new Qt(),
        };
        ((U.texture = P.texture),
          (U.line = p),
          (U.charCode = L),
          (U.position.x = Math.round(
            r.x + P.xOffset + this._letterSpacing / 2,
          )),
          (U.position.y = Math.round(r.y + P.yOffset)),
          (U.prevSpaces = y),
          s.push(U),
          (f =
            U.position.x +
            Math.max(P.xAdvance - P.xOffset, P.texture.orig.width)),
          (r.x += P.xAdvance + this._letterSpacing),
          (I = Math.max(I, P.yOffset + P.texture.height)),
          (d = L),
          m !== -1 &&
            u > 0 &&
            r.x > u &&
            (++A,
            Vh(s, 1 + m - A, 1 + R - m),
            (R = m),
            (m = -1),
            o.push(C),
            a.push(s.length > 0 ? s[s.length - 1].prevSpaces : 0),
            (g = Math.max(g, C)),
            p++,
            (r.x = 0),
            (r.y += e.lineHeight),
            (d = null),
            (y = 0)));
      }
      const x = c[c.length - 1];
      x !== "\r" &&
        x !==
          `
` &&
        (/(?:\s)/.test(x) && (f = C),
        o.push(f),
        (g = Math.max(g, f)),
        a.push(-1));
      const T = [];
      for (let R = 0; R <= p; R++) {
        let M = 0;
        (this._align === "right"
          ? (M = g - o[R])
          : this._align === "center"
            ? (M = (g - o[R]) / 2)
            : this._align === "justify" &&
              (M = a[R] < 0 ? 0 : (g - o[R]) / a[R]),
          T.push(M));
      }
      const S = s.length,
        E = {},
        _ = [],
        b = this._activePagesMeshData;
      h.push(...b);
      for (let R = 0; R < S; R++) {
        const M = s[R].texture,
          L = M.baseTexture.uid;
        if (!E[L]) {
          let P = h.pop();
          if (!P) {
            const O = new kpe();
            let V, W;
            e.distanceFieldType === "none"
              ? ((V = new J6(Qe.EMPTY)), (W = dt.NORMAL))
              : ((V = new J6(Qe.EMPTY, {
                  program: ya.from(f1e, d1e),
                  uniforms: { uFWidth: 0 },
                })),
                (W = dt.NORMAL_NPM));
            const re = new $6(O, V);
            ((re.blendMode = W),
              (P = {
                index: 0,
                indexCount: 0,
                vertexCount: 0,
                uvsCount: 0,
                total: 0,
                mesh: re,
                vertices: null,
                uvs: null,
                indices: null,
              }));
          }
          ((P.index = 0),
            (P.indexCount = 0),
            (P.vertexCount = 0),
            (P.uvsCount = 0),
            (P.total = 0));
          const { _textureCache: U } = this;
          ((U[L] = U[L] || new Qe(M.baseTexture)),
            (P.mesh.texture = U[L]),
            (P.mesh.tint = this._tintColor.value),
            _.push(P),
            (E[L] = P));
        }
        E[L].total++;
      }
      for (let R = 0; R < b.length; R++)
        _.includes(b[R]) || this.removeChild(b[R].mesh);
      for (let R = 0; R < _.length; R++)
        _[R].mesh.parent !== this && this.addChild(_[R].mesh);
      this._activePagesMeshData = _;
      for (const R in E) {
        const M = E[R],
          L = M.total;
        if (
          !(M.indices?.length > 6 * L) ||
          M.vertices.length < $6.BATCHABLE_SIZE * 2
        )
          ((M.vertices = new Float32Array(4 * 2 * L)),
            (M.uvs = new Float32Array(4 * 2 * L)),
            (M.indices = new Uint16Array(6 * L)));
        else {
          const P = M.total,
            U = M.vertices;
          for (let O = P * 4 * 2; O < U.length; O++) U[O] = 0;
        }
        M.mesh.size = 6 * L;
      }
      for (let R = 0; R < S; R++) {
        const M = s[R];
        let L =
          M.position.x +
          T[M.line] * (this._align === "justify" ? M.prevSpaces : 1);
        this._roundPixels && (L = Math.round(L));
        const P = L * i,
          U = M.position.y * i,
          O = M.texture,
          V = E[O.baseTexture.uid],
          W = O.frame,
          re = O._uvs,
          Z = V.index++;
        ((V.indices[Z * 6 + 0] = 0 + Z * 4),
          (V.indices[Z * 6 + 1] = 1 + Z * 4),
          (V.indices[Z * 6 + 2] = 2 + Z * 4),
          (V.indices[Z * 6 + 3] = 0 + Z * 4),
          (V.indices[Z * 6 + 4] = 2 + Z * 4),
          (V.indices[Z * 6 + 5] = 3 + Z * 4),
          (V.vertices[Z * 8 + 0] = P),
          (V.vertices[Z * 8 + 1] = U),
          (V.vertices[Z * 8 + 2] = P + W.width * i),
          (V.vertices[Z * 8 + 3] = U),
          (V.vertices[Z * 8 + 4] = P + W.width * i),
          (V.vertices[Z * 8 + 5] = U + W.height * i),
          (V.vertices[Z * 8 + 6] = P),
          (V.vertices[Z * 8 + 7] = U + W.height * i),
          (V.uvs[Z * 8 + 0] = re.x0),
          (V.uvs[Z * 8 + 1] = re.y0),
          (V.uvs[Z * 8 + 2] = re.x1),
          (V.uvs[Z * 8 + 3] = re.y1),
          (V.uvs[Z * 8 + 4] = re.x2),
          (V.uvs[Z * 8 + 5] = re.y2),
          (V.uvs[Z * 8 + 6] = re.x3),
          (V.uvs[Z * 8 + 7] = re.y3));
      }
      ((this._textWidth = g * i),
        (this._textHeight = (r.y + e.lineHeight) * i));
      for (const R in E) {
        const M = E[R];
        if (this.anchor.x !== 0 || this.anchor.y !== 0) {
          let O = 0;
          const V = this._textWidth * this.anchor.x,
            W = this._textHeight * this.anchor.y;
          for (let re = 0; re < M.total; re++)
            ((M.vertices[O++] -= V),
              (M.vertices[O++] -= W),
              (M.vertices[O++] -= V),
              (M.vertices[O++] -= W),
              (M.vertices[O++] -= V),
              (M.vertices[O++] -= W),
              (M.vertices[O++] -= V),
              (M.vertices[O++] -= W));
        }
        this._maxLineHeight = I * i;
        const L = M.mesh.geometry.getBuffer("aVertexPosition"),
          P = M.mesh.geometry.getBuffer("aTextureCoord"),
          U = M.mesh.geometry.getIndex();
        ((L.data = M.vertices),
          (P.data = M.uvs),
          (U.data = M.indices),
          L.update(),
          P.update(),
          U.update());
      }
      for (let R = 0; R < s.length; R++) i7.push(s[R]);
      ((this._font = e), (this.dirty = !1));
    }
    updateTransform() {
      (this.validate(), this.containerUpdateTransform());
    }
    _render(e) {
      this._autoResolution &&
        this._resolution !== e.resolution &&
        ((this._resolution = e.resolution), (this.dirty = !0));
      const {
        distanceFieldRange: t,
        distanceFieldType: i,
        size: r,
      } = sl.available[this._fontName];
      if (i !== "none") {
        const { a: s, b: o, c: a, d: l } = this.worldTransform,
          c = Math.sqrt(s * s + o * o),
          u = Math.sqrt(a * a + l * l),
          h = (Math.abs(c) + Math.abs(u)) / 2,
          d = this.fontSize / r,
          f = e._view.resolution;
        for (const g of this._activePagesMeshData)
          g.mesh.shader.uniforms.uFWidth = h * t * d * f;
      }
      super._render(e);
    }
    getLocalBounds() {
      return (this.validate(), super.getLocalBounds());
    }
    validate() {
      const e = sl.available[this._fontName];
      if (!e) throw new Error(`Missing BitmapFont "${this._fontName}"`);
      (this._font !== e && (this.dirty = !0), this.dirty && this.updateText());
    }
    get tint() {
      return this._tintColor.value;
    }
    set tint(e) {
      if (this.tint !== e) {
        this._tintColor.setValue(e);
        for (let t = 0; t < this._activePagesMeshData.length; t++)
          this._activePagesMeshData[t].mesh.tint = e;
      }
    }
    get align() {
      return this._align;
    }
    set align(e) {
      this._align !== e && ((this._align = e), (this.dirty = !0));
    }
    get fontName() {
      return this._fontName;
    }
    set fontName(e) {
      if (!sl.available[e]) throw new Error(`Missing BitmapFont "${e}"`);
      this._fontName !== e && ((this._fontName = e), (this.dirty = !0));
    }
    get fontSize() {
      return this._fontSize ?? sl.available[this._fontName].size;
    }
    set fontSize(e) {
      this._fontSize !== e && ((this._fontSize = e), (this.dirty = !0));
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(e) {
      typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e);
    }
    get text() {
      return this._text;
    }
    set text(e) {
      ((e = String(e ?? "")),
        this._text !== e && ((this._text = e), (this.dirty = !0)));
    }
    get maxWidth() {
      return this._maxWidth;
    }
    set maxWidth(e) {
      this._maxWidth !== e && ((this._maxWidth = e), (this.dirty = !0));
    }
    get maxLineHeight() {
      return (this.validate(), this._maxLineHeight);
    }
    get textWidth() {
      return (this.validate(), this._textWidth);
    }
    get letterSpacing() {
      return this._letterSpacing;
    }
    set letterSpacing(e) {
      this._letterSpacing !== e &&
        ((this._letterSpacing = e), (this.dirty = !0));
    }
    get roundPixels() {
      return this._roundPixels;
    }
    set roundPixels(e) {
      e !== this._roundPixels && ((this._roundPixels = e), (this.dirty = !0));
    }
    get textHeight() {
      return (this.validate(), this._textHeight);
    }
    get resolution() {
      return this._resolution;
    }
    set resolution(e) {
      ((this._autoResolution = !1),
        this._resolution !== e && ((this._resolution = e), (this.dirty = !0)));
    }
    destroy(e) {
      const { _textureCache: t } = this,
        i = sl.available[this._fontName].distanceFieldType === "none" ? t7 : n7;
      i.push(...this._activePagesMeshData);
      for (const r of this._activePagesMeshData) this.removeChild(r.mesh);
      ((this._activePagesMeshData = []),
        i
          .filter((r) => t[r.mesh.texture.baseTexture.uid])
          .forEach((r) => {
            r.mesh.texture = Qe.EMPTY;
          }));
      for (const r in t) (t[r].destroy(), delete t[r]);
      ((this._font = null),
        (this._tintColor = null),
        (this._textureCache = null),
        super.destroy(e));
    }
  };
g1e.styleDefaults = {
  align: "left",
  tint: 16777215,
  maxWidth: 0,
  letterSpacing: 0,
};
const p1e = [".xml", ".fnt"],
  m1e = {
    extension: { type: De.LoadParser, priority: oo.Normal },
    name: "loadBitmapFont",
    test(n) {
      return p1e.includes(mr.extname(n).toLowerCase());
    },
    async testParse(n) {
      return nm.test(n) || hb.test(n);
    },
    async parse(n, e, t) {
      const i = nm.test(n) ? nm.parse(n) : hb.parse(n),
        { src: r } = e,
        { page: s } = i,
        o = [];
      for (let c = 0; c < s.length; ++c) {
        const u = s[c].file;
        let h = mr.join(mr.dirname(r), u);
        ((h = sb(h, r)), o.push(h));
      }
      const a = await t.load(o),
        l = o.map((c) => a[c]);
      return sl.install(i, l, !0);
    },
    async load(n, e) {
      return (await Oe.ADAPTER.fetch(n)).text();
    },
    unload(n) {
      n.destroy();
    },
  };
je.add(m1e);
const db = class hh extends Ul {
  constructor() {
    (super(...arguments),
      (this._fonts = []),
      (this._overrides = []),
      (this._stylesheet = ""),
      (this.fontsDirty = !1));
  }
  static from(e) {
    return new hh(
      Object.keys(hh.defaultOptions).reduce(
        (t, i) => ({ ...t, [i]: e[i] }),
        {},
      ),
    );
  }
  cleanFonts() {
    this._fonts.length > 0 &&
      (this._fonts.forEach((e) => {
        (URL.revokeObjectURL(e.src),
          e.refs--,
          e.refs === 0 &&
            (e.fontFace && document.fonts.delete(e.fontFace),
            delete hh.availableFonts[e.originalUrl]));
      }),
      (this.fontFamily = "Arial"),
      (this._fonts.length = 0),
      this.styleID++,
      (this.fontsDirty = !0));
  }
  loadFont(e, t = {}) {
    const { availableFonts: i } = hh;
    if (i[e]) {
      const r = i[e];
      return (
        this._fonts.push(r),
        r.refs++,
        this.styleID++,
        (this.fontsDirty = !0),
        Promise.resolve()
      );
    }
    return Oe.ADAPTER.fetch(e)
      .then((r) => r.blob())
      .then(
        async (r) =>
          new Promise((s, o) => {
            const a = URL.createObjectURL(r),
              l = new FileReader();
            ((l.onload = () => s([a, l.result])),
              (l.onerror = o),
              l.readAsDataURL(r));
          }),
      )
      .then(async ([r, s]) => {
        const o = Object.assign(
          {
            family: mr.basename(e, mr.extname(e)),
            weight: "normal",
            style: "normal",
            display: "auto",
            src: r,
            dataSrc: s,
            refs: 1,
            originalUrl: e,
            fontFace: null,
          },
          t,
        );
        ((i[e] = o), this._fonts.push(o), this.styleID++);
        const a = new FontFace(o.family, `url(${o.src})`, {
          weight: o.weight,
          style: o.style,
          display: o.display,
        });
        ((o.fontFace = a),
          await a.load(),
          document.fonts.add(a),
          await document.fonts.ready,
          this.styleID++,
          (this.fontsDirty = !0));
      });
  }
  addOverride(...e) {
    const t = e.filter((i) => !this._overrides.includes(i));
    t.length > 0 && (this._overrides.push(...t), this.styleID++);
  }
  removeOverride(...e) {
    const t = e.filter((i) => this._overrides.includes(i));
    t.length > 0 &&
      ((this._overrides = this._overrides.filter((i) => !t.includes(i))),
      this.styleID++);
  }
  toCSS(e) {
    return [
      `transform: scale(${e})`,
      "transform-origin: top left",
      "display: inline-block",
      `color: ${this.normalizeColor(this.fill)}`,
      `font-size: ${this.fontSize}px`,
      `font-family: ${this.fontFamily}`,
      `font-weight: ${this.fontWeight}`,
      `font-style: ${this.fontStyle}`,
      `font-variant: ${this.fontVariant}`,
      `letter-spacing: ${this.letterSpacing}px`,
      `text-align: ${this.align}`,
      `padding: ${this.padding}px`,
      `white-space: ${this.whiteSpace}`,
      ...(this.lineHeight ? [`line-height: ${this.lineHeight}px`] : []),
      ...(this.wordWrap
        ? [
            `word-wrap: ${this.breakWords ? "break-all" : "break-word"}`,
            `max-width: ${this.wordWrapWidth}px`,
          ]
        : []),
      ...(this.strokeThickness
        ? [
            `-webkit-text-stroke-width: ${this.strokeThickness}px`,
            `-webkit-text-stroke-color: ${this.normalizeColor(this.stroke)}`,
            `text-stroke-width: ${this.strokeThickness}px`,
            `text-stroke-color: ${this.normalizeColor(this.stroke)}`,
            "paint-order: stroke",
          ]
        : []),
      ...(this.dropShadow ? [this.dropShadowToCSS()] : []),
      ...this._overrides,
    ].join(";");
  }
  toGlobalCSS() {
    return this._fonts.reduce(
      (e, t) => `${e}
            @font-face {
                font-family: "${t.family}";
                src: url('${t.dataSrc}');
                font-weight: ${t.weight};
                font-style: ${t.style};
                font-display: ${t.display};
            }`,
      this._stylesheet,
    );
  }
  get stylesheet() {
    return this._stylesheet;
  }
  set stylesheet(e) {
    this._stylesheet !== e && ((this._stylesheet = e), this.styleID++);
  }
  normalizeColor(e) {
    return (
      Array.isArray(e) && (e = lde(e)),
      typeof e == "number" ? ade(e) : e
    );
  }
  dropShadowToCSS() {
    let e = this.normalizeColor(this.dropShadowColor);
    const t = this.dropShadowAlpha,
      i = Math.round(Math.cos(this.dropShadowAngle) * this.dropShadowDistance),
      r = Math.round(Math.sin(this.dropShadowAngle) * this.dropShadowDistance);
    e.startsWith("#") &&
      t < 1 &&
      (e += ((t * 255) | 0).toString(16).padStart(2, "0"));
    const s = `${i}px ${r}px`;
    return this.dropShadowBlur > 0
      ? `text-shadow: ${s} ${this.dropShadowBlur}px ${e}`
      : `text-shadow: ${s} ${e}`;
  }
  reset() {
    Object.assign(this, hh.defaultOptions);
  }
  onBeforeDraw() {
    const { fontsDirty: e } = this;
    return (
      (this.fontsDirty = !1),
      this.isSafari && this._fonts.length > 0 && e
        ? new Promise((t) => setTimeout(t, 100))
        : Promise.resolve()
    );
  }
  get isSafari() {
    const { userAgent: e } = Oe.ADAPTER.getNavigator();
    return /^((?!chrome|android).)*safari/i.test(e);
  }
  set fillGradientStops(e) {
    console.warn(
      "[HTMLTextStyle] fillGradientStops is not supported by HTMLText",
    );
  }
  get fillGradientStops() {
    return super.fillGradientStops;
  }
  set fillGradientType(e) {
    console.warn(
      "[HTMLTextStyle] fillGradientType is not supported by HTMLText",
    );
  }
  get fillGradientType() {
    return super.fillGradientType;
  }
  set miterLimit(e) {
    console.warn("[HTMLTextStyle] miterLimit is not supported by HTMLText");
  }
  get miterLimit() {
    return super.miterLimit;
  }
  set trim(e) {
    console.warn("[HTMLTextStyle] trim is not supported by HTMLText");
  }
  get trim() {
    return super.trim;
  }
  set textBaseline(e) {
    console.warn("[HTMLTextStyle] textBaseline is not supported by HTMLText");
  }
  get textBaseline() {
    return super.textBaseline;
  }
  set leading(e) {
    console.warn("[HTMLTextStyle] leading is not supported by HTMLText");
  }
  get leading() {
    return super.leading;
  }
  set lineJoin(e) {
    console.warn("[HTMLTextStyle] lineJoin is not supported by HTMLText");
  }
  get lineJoin() {
    return super.lineJoin;
  }
};
((db.availableFonts = {}),
  (db.defaultOptions = {
    align: "left",
    breakWords: !1,
    dropShadow: !1,
    dropShadowAlpha: 1,
    dropShadowAngle: Math.PI / 6,
    dropShadowBlur: 0,
    dropShadowColor: "black",
    dropShadowDistance: 5,
    fill: "black",
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    letterSpacing: 0,
    lineHeight: 0,
    padding: 0,
    stroke: "black",
    strokeThickness: 0,
    whiteSpace: "normal",
    wordWrap: !1,
    wordWrapWidth: 100,
  }));
let $A = db;
const n0 = class dh extends $d {
  constructor(e = "", t = {}) {
    (super(Qe.EMPTY),
      (this._text = null),
      (this._style = null),
      (this._autoResolution = !0),
      (this.localStyleID = -1),
      (this.dirty = !1),
      (this._updateID = 0),
      (this.ownsStyle = !1));
    const i = new Image(),
      r = Qe.from(i, {
        scaleMode: Oe.SCALE_MODE,
        resourceOptions: { autoLoad: !1 },
      });
    ((r.orig = new Bt()), (r.trim = new Bt()), (this.texture = r));
    const s = "http://www.w3.org/2000/svg",
      o = "http://www.w3.org/1999/xhtml",
      a = document.createElementNS(s, "svg"),
      l = document.createElementNS(s, "foreignObject"),
      c = document.createElementNS(o, "div"),
      u = document.createElementNS(o, "style");
    (l.setAttribute("width", "10000"),
      l.setAttribute("height", "10000"),
      (l.style.overflow = "hidden"),
      a.appendChild(l),
      (this.maxWidth = dh.defaultMaxWidth),
      (this.maxHeight = dh.defaultMaxHeight),
      (this._domElement = c),
      (this._styleElement = u),
      (this._svgRoot = a),
      (this._foreignObject = l),
      this._foreignObject.appendChild(u),
      this._foreignObject.appendChild(c),
      (this._image = i),
      (this._loadImage = new Image()),
      (this._autoResolution = dh.defaultAutoResolution),
      (this._resolution = dh.defaultResolution ?? Oe.RESOLUTION),
      (this.text = e),
      (this.style = t));
  }
  measureText(e) {
    const {
      text: t,
      style: i,
      resolution: r,
    } = Object.assign(
      { text: this._text, style: this._style, resolution: this._resolution },
      e,
    );
    (Object.assign(this._domElement, { innerHTML: t, style: i.toCSS(r) }),
      (this._styleElement.textContent = i.toGlobalCSS()),
      document.body.appendChild(this._svgRoot));
    const s = this._domElement.getBoundingClientRect();
    this._svgRoot.remove();
    const { width: o, height: a } = s;
    (o > this.maxWidth || a > this.maxHeight) &&
      console.warn(
        "[HTMLText] Large expanse of text, increase HTMLText.maxWidth or HTMLText.maxHeight property.",
      );
    const l = Math.min(this.maxWidth, Math.ceil(o)),
      c = Math.min(this.maxHeight, Math.ceil(a));
    return (
      this._svgRoot.setAttribute("width", l.toString()),
      this._svgRoot.setAttribute("height", c.toString()),
      t !== this._text && (this._domElement.innerHTML = this._text),
      i !== this._style &&
        (Object.assign(this._domElement, { style: this._style?.toCSS(r) }),
        (this._styleElement.textContent = this._style?.toGlobalCSS())),
      { width: l + i.padding * 2, height: c + i.padding * 2 }
    );
  }
  async updateText(e = !0) {
    const { style: t, _image: i, _loadImage: r } = this;
    if (
      (this.localStyleID !== t.styleID &&
        ((this.dirty = !0), (this.localStyleID = t.styleID)),
      !this.dirty && e)
    )
      return;
    const { width: s, height: o } = this.measureText();
    ((i.width = r.width = Math.ceil(Math.max(1, s))),
      (i.height = r.height = Math.ceil(Math.max(1, o))),
      this._updateID++);
    const a = this._updateID;
    await new Promise((l) => {
      r.onload = async () => {
        if (a < this._updateID) {
          l();
          return;
        }
        (await t.onBeforeDraw(),
          (i.src = r.src),
          (r.onload = null),
          (r.src = ""),
          this.updateTexture(),
          l());
      };
      const c = new XMLSerializer().serializeToString(this._svgRoot);
      r.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(c)}`;
    });
  }
  get source() {
    return this._image;
  }
  updateTexture() {
    const { style: e, texture: t, _image: i, resolution: r } = this,
      { padding: s } = e,
      { baseTexture: o } = t;
    ((t.trim.width = t._frame.width = i.width / r),
      (t.trim.height = t._frame.height = i.height / r),
      (t.trim.x = -s),
      (t.trim.y = -s),
      (t.orig.width = t._frame.width - s * 2),
      (t.orig.height = t._frame.height - s * 2),
      this._onTextureUpdate(),
      o.setRealSize(i.width, i.height, r),
      (this.dirty = !1));
  }
  _render(e) {
    (this._autoResolution &&
      this._resolution !== e.resolution &&
      ((this._resolution = e.resolution), (this.dirty = !0)),
      this.updateText(!0),
      super._render(e));
  }
  _renderCanvas(e) {
    (this._autoResolution &&
      this._resolution !== e.resolution &&
      ((this._resolution = e.resolution), (this.dirty = !0)),
      this.updateText(!0),
      super._renderCanvas(e));
  }
  getLocalBounds(e) {
    return (this.updateText(!0), super.getLocalBounds(e));
  }
  _calculateBounds() {
    (this.updateText(!0),
      this.calculateVertices(),
      this._bounds.addQuad(this.vertexData));
  }
  _onStyleChange() {
    this.dirty = !0;
  }
  destroy(e) {
    (typeof e == "boolean" && (e = { children: e }),
      (e = Object.assign({}, dh.defaultDestroyOptions, e)),
      super.destroy(e));
    const t = null;
    (this.ownsStyle && this._style?.cleanFonts(),
      (this._style = t),
      this._svgRoot?.remove(),
      (this._svgRoot = t),
      this._domElement?.remove(),
      (this._domElement = t),
      this._foreignObject?.remove(),
      (this._foreignObject = t),
      this._styleElement?.remove(),
      (this._styleElement = t),
      (this._loadImage.src = ""),
      (this._loadImage.onload = null),
      (this._loadImage = t),
      (this._image.src = ""),
      (this._image = t));
  }
  get width() {
    return (
      this.updateText(!0),
      (Math.abs(this.scale.x) * this._image.width) / this.resolution
    );
  }
  set width(e) {
    this.updateText(!0);
    const t = bl(this.scale.x) || 1;
    ((this.scale.x = (t * e) / this._image.width / this.resolution),
      (this._width = e));
  }
  get height() {
    return (
      this.updateText(!0),
      (Math.abs(this.scale.y) * this._image.height) / this.resolution
    );
  }
  set height(e) {
    this.updateText(!0);
    const t = bl(this.scale.y) || 1;
    ((this.scale.y = (t * e) / this._image.height / this.resolution),
      (this._height = e));
  }
  get style() {
    return this._style;
  }
  set style(e) {
    this._style !== e &&
      ((e = e || {}),
      e instanceof $A
        ? ((this.ownsStyle = !1), (this._style = e))
        : e instanceof Ul
          ? (console.warn(
              "[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle",
            ),
            (this.ownsStyle = !0),
            (this._style = $A.from(e)))
          : ((this.ownsStyle = !0), (this._style = new $A(e))),
      (this.localStyleID = -1),
      (this.dirty = !0));
  }
  get text() {
    return this._text;
  }
  set text(e) {
    ((e = String(e === "" || e === null || e === void 0 ? " " : e)),
      (e = this.sanitiseText(e)),
      this._text !== e && ((this._text = e), (this.dirty = !0)));
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(e) {
    ((this._autoResolution = !1),
      this._resolution !== e && ((this._resolution = e), (this.dirty = !0)));
  }
  sanitiseText(e) {
    return e
      .replace(/<br>/gi, "<br/>")
      .replace(/<hr>/gi, "<hr/>")
      .replace(/&nbsp;/gi, "&#160;");
  }
};
((n0.defaultDestroyOptions = { texture: !0, children: !1, baseTexture: !0 }),
  (n0.defaultMaxWidth = 2024),
  (n0.defaultMaxHeight = 2024),
  (n0.defaultAutoResolution = !0));
Er.system.autoStart = !1;
const C1e = (n) => {
    const [e, t] = Dr(n, ["ref"]);
    let i = null,
      r = null;
    Ct(() => {
      try {
        r = new T5({
          autoStart: !1,
          resolution: window.devicePixelRatio,
          autoDensity: !0,
          sharedTicker: !1,
          view: i,
          preserveDrawingBuffer: !0,
          resizeTo: i,
        });
      } catch (o) {
        if (o.message === "Unable to auto-detect a suitable renderer.") {
          console.error(o);
          return;
        }
        throw o;
      }
      dn(() => {
        r.destroy();
      });
    });
    let s;
    return (
      Ct(() => {
        r?.renderer.resize(window.innerWidth, window.innerHeight);
        const o = [
          {
            str: " ",
            xOffset: 0,
            yOffset: 0,
            xOffsetMobile: 0,
            yOffsetMobile: 0,
          },
        ];
        s = new Rs();
        for (let {
          str: a,
          xOffset: l,
          xOffsetMobile: c,
          yOffsetMobile: u,
          yOffset: h,
        } of o) {
          const d = new B5(a);
          (d.anchor.set(0.5),
            (d.x = Wc(nh({ [Si.XL]: l, [Si.MD]: c - 30 }))),
            (d.y = Wc(nh({ [Si.XL]: h, [Si.MD]: u }))),
            (d.style.fill = 16777215),
            (d.style.fontFamily = "Sohne Breit"),
            (d.style.fontSize = Wc(nh({ [Si.XL]: 175, [Si.MD]: 95 * 0.4 }))),
            (d.style.letterSpacing = Wc(nh({ [Si.XL]: -1.5, [Si.MD]: -0.8 }))),
            s.addChild(d));
        }
        ((s.x = (r?.screen.width ?? 0) / 2),
          (s.y = (r?.screen.height ?? 0) / 2),
          (s.rotation = nh({ [Si.XL]: 0, [Si.MD]: Math.PI / 2 })),
          r?.stage.addChild(s),
          r?.render(),
          dn(() => {
            r?.stage.removeChildren();
          }));
      }),
      Ct(() => {
        (s.scale.set(0.5 + 0.5 * la()), r?.render());
      }),
      G(
        $.Generic,
        jn(
          {
            css: { position: "fixed", inset: "0px" },
            as: "canvas",
            ref(o) {
              const a = Kq((l) => {
                i = l;
              }, e.ref);
              typeof a == "function" && a(o);
            },
          },
          t,
        ),
      )
    );
  },
  I1e = (n) =>
    gb(
      () =>
        new Promise((e) => {
          new fae().load(n, (i) => {
            const r = {};
            (i.scene.traverse((s) => {
              s.name && (r[s.name] = s);
            }),
              e({ ...i, nodes: r }));
          });
        }),
    ),
  A1e = xt("<canvas>"),
  y1e = (n) => {
    let e = null;
    const [t, i] = Dr(n, ["children", "resources", "isPlaying"]);
    return (
      Ct(() => {
        let r = new Ri(75, window.innerWidth / window.innerHeight, 0.1, 1e3);
        (r.position.set(0, 0, 17), (r.zoom = 6.59), r.updateProjectionMatrix());
        let s = new Hv(),
          o = null;
        try {
          o = new Jv({ antialias: !0, canvas: e, alpha: !0 });
        } catch (c) {
          if (c.message === "Error creating WebGL context.") {
            console.error(c);
            return;
          }
          throw c;
        }
        const a = t.resources.map((c) => c[0]);
        let l;
        Ct(
          gr(a, () => {
            let c = [];
            for (const p of a) {
              let m = p();
              if (m == null) return;
              c.push(m);
            }
            let u,
              h = 0;
            function d(p) {
              (l && (l(p, (p - h) / 1e3), (h = p)), o?.render(s, r));
            }
            function f(p) {
              (d(p), (u = requestAnimationFrame(f)));
            }
            let g = null;
            (Ct(
              gr(In, () => {
                (o?.setSize(e.clientWidth, e.clientHeight),
                  o?.setViewport(0, 0, e.clientWidth, e.clientHeight),
                  (r.aspect = e.clientWidth / e.clientHeight),
                  r.updateProjectionMatrix(),
                  g?.());
              }),
            ),
              o &&
                t.children(
                  {
                    scene: s,
                    renderer: o,
                    camera: r,
                    renderFrame: d,
                    onFrame: (p) => {
                      l = p;
                    },
                    onResize: (p) => {
                      g = p;
                    },
                  },
                  c,
                ),
              g?.(),
              Ct(() => {
                t.isPlaying
                  ? ((u = requestAnimationFrame(f)),
                    dn(() => {
                      cancelAnimationFrame(u);
                    }))
                  : requestAnimationFrame(d);
              }));
          }),
        );
      }),
      (() => {
        const r = ft(A1e),
          s = e;
        return (
          typeof s == "function" ? ry(s, r) : (e = r),
          fn(r, i, !1, !1),
          An(),
          r
        );
      })()
    );
  };
var r7 = `varying vec3 worldNormal;

attribute vec3 morphTargetPosition;
attribute vec3 morphTargetNormal;

uniform float morphTargetInfluence;

void main() {
  vec3 mixedNormal = normal + (morphTargetNormal * morphTargetInfluence);
  worldNormal = normalize(mat3(modelMatrix) * mixedNormal);
  vec3 transformed = vec3(position);
  transformed += morphTargetPosition * morphTargetInfluence;

  gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);
}`,
  s7 = `varying vec3 worldNormal;

void main() {
  gl_FragColor = vec4(worldNormal, 1.0);
}`,
  o7 = `varying vec3 worldNormal;
varying vec3 eyeVector;

attribute vec3 morphTargetPosition;
attribute vec3 morphTargetNormal;

uniform float morphTargetInfluence;

void main() {
  vec3 transformed = vec3( position );

  vec4 worldPosition = modelMatrix * vec4(transformed, 1.0);
  eyeVector = normalize(worldPosition.xyz - cameraPosition);

  
  vec3 mixedNormal = normal + (morphTargetNormal * morphTargetInfluence);

  
  worldNormal = normalize(mat3(modelMatrix) * mixedNormal);

  vec3 worldCameraToVertex = worldPosition.xyz - cameraPosition;

  
  transformed += morphTargetPosition * morphTargetInfluence;

  gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);
}`,
  a7 = `uniform sampler2D uTexture;
uniform sampler2D uBackfaceTexture;
uniform vec2 winResolution;

uniform bool isTransparent;

varying vec3 worldNormal;
varying vec3 eyeVector;

float a = 0.33;

float noise(vec2 p) {
  vec2 ip = floor(p);
  vec2 u = fract(p);
  u = u * u * (3.0 - 2.0 * u);
  float res = mix(
    mix(dot(ip, vec2(127.1, 311.7)),
        dot(ip + vec2(1.0, 0.0), vec2(127.1, 311.7)), u.x),
    mix(dot(ip + vec2(0.0, 1.0), vec2(127.1, 311.7)),
        dot(ip + vec2(1.0, 1.0), vec2(127.1, 311.7)), u.x), u.y);
  return fract(sin(res) * 43758.5453123);
}

float fresnel(vec3 I, vec3 N, float refIndex) {
  float F0 = ((1.0 - refIndex) / (1.0 + refIndex)) * ((1.0 - refIndex) / (1.0 + refIndex));
  float cosAlpha = dot(-I, N);
  return F0 + (1.0 - F0) * pow(1.0 - cosAlpha, 5.0);
}

vec2 refraction(vec2 uv, vec3 normal, float iqr) {
  float noiseValue = noise(uv * 25.0);

  float angle = noiseValue * 2.0 * 3.14159;
  float magnitudeFactor = 0.07;
  if (isTransparent) {
    magnitudeFactor = 0.1;
  }

  float magnitude = noise(vec2(angle, iqr)) * magnitudeFactor;

  vec3 noisyNormal = worldNormal + vec3(cos(angle) * magnitude, sin(angle) * magnitude, 0.0);
  vec3 backfaceNormal = texture2D(uBackfaceTexture, uv).rgb;
  noisyNormal *= (1.0 - a) - backfaceNormal * a;

  return refract(eyeVector / 2.0, noisyNormal, 1.0 / iqr).xy;
}

vec4 withFresnelTerm(vec2 uv, vec3 normal, float iqr) {
  if (isTransparent) {
    float fresnelTerm = fresnel(eyeVector, worldNormal, iqr * 1.3);

    return texture2D(uTexture, mix(uv, uv + refraction(uv, normal, iqr), fresnelTerm));
  }

  return texture2D(uTexture, uv + refraction(uv, normal, iqr));
}

vec4 splitRefraction(vec3 normal, vec2 uv) {
  return vec4(
    withFresnelTerm(uv, normal, 1.4).r,
    withFresnelTerm(uv, normal, 1.43).g,
    withFresnelTerm(uv, normal, 1.46).b,
    1.0
  );
}

vec4 applyGaussianBlur(vec3 normal, vec2 uv, float blurAmount) {
  vec2 pixel = vec2(.0001);

  
  float weights[10];
  weights[0] = 0.002956596480241978;
  weights[1] = 0.017493275444828427;
  weights[2] = 0.0663636774278952;
  weights[3] = 0.1614246982157177;
  weights[4] = 0.25176175243131665;
  weights[5] = 0.25176175243131665;
  weights[6] = 0.1614246982157177;
  weights[7] = 0.0663636774278952;
  weights[8] = 0.017493275444828427;
  weights[9] = 0.002956596480241978;

  float weightSum = weights[0] + weights[1] + weights[2] + weights[3] + weights[4];

  vec4 sum = vec4(0.0);

  for (int x = -5; x <= 5; x++) {
    for (int y = -5; y <= 5; y++) {
      vec2 offset = vec2(float(x), float(y)) * pixel * blurAmount;
      sum += splitRefraction(normal, uv + offset) * weights[abs(x)] * weights[abs(y)];
    }
  }

  return sum / (weightSum * weightSum) / 3.5;
}

void main() {
  vec2 uv = gl_FragCoord.xy / winResolution;
  vec3 backfaceNormal = texture2D(uBackfaceTexture, uv).rgb;
  vec3 normal = worldNormal * (1.0 - a) - backfaceNormal * a;

  vec4 color = applyGaussianBlur(normal, uv, 10.0);

  gl_FragColor = vec4(color.rgb, 1.0);

}`;
const fb = Dn(!1),
  _1e = Hd(0.16, 1, 0.3, 1),
  b1e = (n) => {
    const [e, t] = Dr(n, ["backgroundCanvas", "isPlaying"]),
      i = Dn(null),
      r = Dn([0, 0]),
      s = pe(() => R9(0, In().height, ph()));
    return (
      dn(() => {
        fb(!1);
      }),
      [
        G(Wd, {
          onPointerUp: () => {
            i(null);
          },
        }),
        G(
          $.Generic,
          jn(
            {
              css: {
                height: "100% !important",
                width: "100% !important",
                touchAction: "pan-y",
              },
              as: y1e,
              get isPlaying() {
                return e.isPlaying;
              },
              get resources() {
                return [I1e("/f.glb")];
              },
              onPointerDown: (o) => {
                i([o.clientX, o.clientY]);
              },
              onPointerMove: (o) => {
                i() &&
                  (r([
                    r()[0] + (o.clientX - i()[0]) * 0.01,
                    (r()[1] + (o.clientY - i()[1]) * 0.01) % (Math.PI * 2),
                  ]),
                  i([o.clientX, o.clientY]));
              },
            },
            t,
            {
              children: (
                { scene: o, renderer: a, camera: l, onFrame: c, onResize: u },
                [
                  {
                    nodes: { Top_F: h, Bottom_F: d },
                    animations: f,
                  },
                ],
              ) => {
                const g = iv();
                (h.geometry.setAttribute(
                  "morphTargetPosition",
                  h.geometry.morphAttributes.position[0],
                ),
                  h.geometry.setAttribute(
                    "morphTargetNormal",
                    h.geometry.morphAttributes.normal[0],
                  ));
                const p = new ww(h),
                  m = new ww(d),
                  C = p.clipAction(f[2]);
                ((C.loop = X_), (C.clampWhenFinished = !0));
                const A = m.clipAction(f[0]);
                ((A.loop = X_), (A.clampWhenFinished = !0));
                const I = Dn(!1);
                Ct(
                  gr(
                    I,
                    (V) => {
                      V
                        ? ((C.paused = !1),
                          (C.timeScale = 1),
                          C.play(),
                          (A.paused = !1),
                          (A.timeScale = 1),
                          A.play())
                        : ((C.timeScale = -1),
                          (C.paused = !1),
                          (A.timeScale = -1),
                          (A.paused = !1));
                    },
                    { defer: !0 },
                  ),
                );
                const y = new Qi({
                    vertexShader: r7,
                    fragmentShader: s7,
                    side: er,
                    uniforms: { morphTargetInfluence: { value: 0 } },
                  }),
                  x = new Qi({
                    vertexShader: r7,
                    fragmentShader: s7,
                    side: er,
                    uniforms: { morphTargetInfluence: { value: 0 } },
                  });
                let T = new fR(e.backgroundCanvas);
                const S = new ko(),
                  E = new ko(),
                  _ = {
                    uTexture: { value: S.texture },
                    uBackfaceTexture: { value: E.texture },
                    winResolution: { value: null },
                    morphTargetInfluence: { value: 0 },
                  },
                  b = new Qi({
                    vertexShader: o7,
                    fragmentShader: a7,
                    uniforms: _,
                  }),
                  R = new Qi({
                    vertexShader: o7,
                    fragmentShader: a7,
                    uniforms: _,
                  });
                let M = new Is();
                ((h.onAfterRender = () => {
                  (fb(!0), (h.onAfterRender = () => {}));
                }),
                  M.add(h),
                  (h.position.z = 0),
                  M.add(d),
                  (d.position.z = 0),
                  o.add(M),
                  u(() => {
                    (S.setSize(
                      75 *
                        (g()
                          ? window.innerHeight / window.innerWidth
                          : window.innerWidth / window.innerHeight),
                      75,
                    ),
                      E.setSize(window.innerWidth, window.innerHeight),
                      T?.dispose(),
                      (_.winResolution.value = new Gt(
                        window.innerWidth,
                        window.innerHeight,
                      )),
                      requestAnimationFrame(() => {
                        ((M.visible = !1),
                          (o.background = T),
                          a.setRenderTarget(S),
                          a.render(o, l),
                          (o.background = null),
                          (M.visible = !0),
                          a.setRenderTarget(null));
                      }));
                  }));
                let L = 0,
                  P = !1,
                  U = 0;
                Ct(() => {
                  let V = (0.344827586 + 0.655172414 * la()) * (g() ? 0.5 : 1);
                  ((L = _1e(R9(0.9, 2, Vc())) * 0.3),
                    L > 0 && (P = !0),
                    (T.needsUpdate = !0),
                    (o.background = T),
                    M.scale.set(V, V, V),
                    (M.visible = !1),
                    a.setRenderTarget(S),
                    a.render(o, l),
                    (M.visible = !0),
                    a.setRenderTarget(null),
                    (o.background = null));
                });
                let O = [0, 0];
                c((V, W) => {
                  (m.update(W),
                    p.update(W),
                    (O[0] += (r()[0] - O[0]) * 0.1),
                    (O[1] += (r()[1] - O[1]) * 0.1),
                    r([r()[0], r()[1] * 0.99]),
                    (M.rotation.y = L + O[0]),
                    (M.rotation.x = O[1]),
                    P &&
                      (U === 0 ? (U = V) : (M.rotation.y += (V - U) * 1e-4)));
                  let re = s();
                  if (
                    ((M.rotation.x =
                      M.rotation.x * (1 - re) - re * (Math.PI / 2)),
                    (M.rotation.y = M.rotation.y % (Math.PI * 2)),
                    (M.position.y = re + (g() ? 0.28 : 0)),
                    re)
                  ) {
                    let te = (1 + re * 0.5) * (g() ? 0.5 : 1);
                    M.scale.set(te, te, te);
                  }
                  let Z = Math.abs(M.rotation.y);
                  (I(Z > Math.PI / 2 && Z < Math.PI * 1.5),
                    (h.material = y),
                    (d.material = x),
                    (b.uniforms.morphTargetInfluence.value =
                      h.morphTargetInfluences[0]),
                    (y.uniforms.morphTargetInfluence.value =
                      h.morphTargetInfluences[0]),
                    a.setRenderTarget(E),
                    a.render(o, l),
                    (h.material = b),
                    (d.material = R),
                    a.setRenderTarget(null));
                });
              },
            },
          ),
        ),
      ]
    );
  },
  v1e = xt("<br>"),
  x1e = xt("<div>"),
  AN = Di(!1),
  hme = () => {
    const n = ll(),
      e = nI();
    let t = null;
    const i = xE();
    let r = null;
    const s = HC(() => r),
      o = iv(),
      a = pe(() => (o() ? !s() : AN()));
    return G(iI, {
      get type() {
        return xi.ScrollDown;
      },
      children: (l) =>
        G(
          $.Generic,
          jn(
            {
              ref(c) {
                const u = r;
                typeof u == "function" ? u(c) : (r = c);
              },
              get css() {
                return [
                  {
                    position: "sticky",
                    top: "0px",
                    height: "100vh",
                    transitionProperty: "opacity",
                    transitionTimingFunction: "cubic-bezier(0.4, 0, 0.2, 1)",
                    transitionDuration: "500ms",
                    "@media (max-width: 767px)": {
                      marginTop: "-72rem",
                      display: "flex",
                      alignItems: "flex-end",
                      justifyContent: "center",
                      paddingBottom: "24rem",
                    },
                  },
                  {
                    ...(a() && { visibility: "hidden" }),
                    ...(n && !e() && { opacity: "0" }),
                    "&": { height: "100svh" },
                  },
                ];
              },
              as: "section",
            },
            l,
            {
              get children() {
                return [
                  G($.Generic, {
                    css: [
                      {
                        pointerEvents: "none",
                        position: "fixed",
                        top: "0px",
                        zIndex: "10",
                        display: "flex",
                        height: "100vh",
                        width: "100%",
                        userSelect: "none",
                        flexDirection: "column",
                        justifyContent: "flex-end",
                        paddingBottom: "64rem",
                        paddingTop: "96rem",
                        fontFamily: "Sohne, sans-serif",
                        fontSize: "16rem",
                        lineHeight: "1.2",
                        letterSpacing: "-0.03em",
                        "@media (max-width: 767px)": {
                          paddingBottom: "16rem",
                          paddingTop: "0px",
                        },
                      },
                      va,
                      { "&": { height: "100svh" } },
                    ],
                    as: "div",
                    get children() {
                      return G($.Generic, {
                        css: {
                          display: "flex",
                          alignItems: "flex-end",
                          justifyContent: "space-between",
                          "@media (max-width: 767px)": {
                            justifyContent: "center",
                            textAlign: "center",
                          },
                        },
                        as: "div",
                        get children() {
                          return [
                            G($.Generic, {
                              css: {
                                maxWidth: "516rem",
                                "@media (max-width: 767px)": {
                                  maxWidth: "none",
                                },
                              },
                              as: "div",
                              get children() {
                                return [
                                  G($.Generic, {
                                    get css() {
                                      return [
                                        { marginBottom: "16rem" },
                                        nt.sohne.h4,
                                        nt.m.sohne.body1,
                                      ];
                                    },
                                    as: "h1",
                                    get children() {
                                      return [
                                        "Your Strategic Digital",
                                        ft(v1e),
                                        "Product Agency Partner",
                                      ];
                                    },
                                  }),
                                  G($.Generic, {
                                    get css() {
                                      return [
                                        {
                                          "--tw-text-opacity": "0.4",
                                          color:
                                            "rgb(255 255 255 / var(--tw-text-opacity))",
                                        },
                                        nt.sohne.body3,
                                        nt.m.sohne.body3,
                                      ];
                                    },
                                    as: "p",
                                    children:
                                      "Na Fokus, entregamos solues completas em audiovisual e marketing. Da estratgia e pr-produo,  captao e entrega final. Somos parceiros de marcas, transformando ideias em histrias que geram impacto e fortalecem a presena digital.",
                                  }),
                                  G($.Generic, {
                                    css: {
                                      marginTop: "24rem",
                                      display: "none",
                                      flexDirection: "column",
                                      alignItems: "center",
                                      "@media (max-width: 767px)": {
                                        display: "flex",
                                      },
                                    },
                                    as: "div",
                                    get children() {
                                      return ft(x1e);
                                    },
                                  }),
                                ];
                              },
                            }),
                            G($.Generic, {
                              href: "https://wa.me/5511912768263?text=Quero%20saber%20mais%20sobre%20a%20Fokus...",
                              target: "_blank",
                              rel: "noopener",
                              css: {
                                pointerEvents: "auto",
                                "@media (max-width: 767px)": {
                                  display: "none",
                                },
                              },
                              as: zr,
                              get children() {
                                return G($.Generic, {
                                  css: {
                                    display: "flex",
                                    height: "64rem",
                                    width: "271rem",
                                    cursor: "pointer",
                                    alignItems: "center",
                                    justifyContent: "space-between",
                                    borderRadius: "9999px",
                                    "--tw-bg-opacity": "1",
                                    backgroundColor:
                                      "rgb(255 255 255 / var(--tw-bg-opacity))",
                                    paddingLeft: "32rem",
                                    paddingRight: "32rem",
                                    paddingTop: "16rem",
                                    paddingBottom: "16rem",
                                    "--tw-text-opacity": "1",
                                    color:
                                      "rgb(0 0 0 / var(--tw-text-opacity))",
                                  },
                                  as: "div",
                                  get children() {
                                    return [
                                      G($.Generic, {
                                        css: {},
                                        as: "p",
                                        children: "Vamos Conversar?",
                                      }),
                                      G($.Generic, {
                                        css: {
                                          height: "24rem",
                                          width: "24rem",
                                        },
                                        as: vce,
                                      }),
                                    ];
                                  },
                                });
                              },
                            }),
                          ];
                        },
                      });
                    },
                  }),
                  pe(
                    () =>
                      pe(() => !!i())() && [
                        G(C1e, {
                          ref(c) {
                            const u = t;
                            typeof u == "function" ? u(c) : (t = c);
                          },
                        }),
                        G($.Generic, {
                          get isPlaying() {
                            return !a();
                          },
                          backgroundCanvas: t,
                          get css() {
                            return [
                              {
                                position: "fixed",
                                inset: "0px",
                                height: "100%",
                                width: "100%",
                                opacity: "0",
                                transitionProperty: "opacity",
                                transitionTimingFunction:
                                  "cubic-bezier(0.4, 0, 0.2, 1)",
                                transitionDuration: "500ms",
                                "@media (max-width: 767px)": {
                                  position: "absolute",
                                },
                              },
                              { ...(fb() && { opacity: "1" }) },
                            ];
                          },
                          as: b1e,
                        }),
                      ],
                  ),
                ];
              },
            },
          ),
        ),
    });
  },
  w1e = xt(
    '<svg width="32" height="32" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M3.06066 0.93934C2.47487 0.353553 1.52513 0.353553 0.93934 0.93934C0.353553 1.52513 0.353553 2.47487 0.93934 3.06066L29.2236 31.3449C29.8094 31.9307 30.7591 31.9307 31.3449 31.3449C31.9307 30.7591 31.9307 29.8094 31.3449 29.2236L3.06066 0.93934ZM5.98567 13.1012C6.75579 13.104 7.49976 12.8266 8.07952 12.3222L17.5403 21.7829C17.2868 23.0207 16.474 24.0897 15.4378 24.7643C14.411 25.4299 13.1422 25.2943 12.3377 24.4582C10.9974 23.0612 9.55067 21.6605 8.07108 20.2582C7.48013 19.7069 6.70116 19.4018 5.893 19.4051H4.91649C3.89762 19.4051 3.03231 18.6304 3.01325 17.6745C2.99577 16.7271 2.99419 15.7866 3.01696 14.8313C3.03973 13.876 3.90556 13.1012 4.92337 13.1012H5.98567ZM19.7113 24.3496C19.5236 24.1433 19.4056 23.8857 19.3702 23.6128L20.5384 24.781C20.2214 24.7399 19.9279 24.5876 19.7113 24.3496ZM21.8659 17.6233L24.1551 19.9125C24.1791 19.8276 24.2023 19.7425 24.2244 19.657C24.5301 18.4663 24.6819 17.2414 24.6761 16.0121C24.6815 14.7815 24.5292 13.5553 24.2228 12.3634C23.9874 11.4542 23.6471 10.5754 23.2087 9.74472C22.4673 8.34774 21.7011 7.63071 21.6163 7.55393C21.3518 7.31123 21.0017 7.18357 20.643 7.19901C20.2844 7.21445 19.9465 7.37174 19.7038 7.63627C19.4611 7.90081 19.3335 8.25092 19.3489 8.60958C19.3644 8.96825 19.5216 9.30609 19.7862 9.54878C19.899 9.65469 21.969 11.6977 21.969 16.0121C21.9719 16.5514 21.9374 17.0898 21.8659 17.6233ZM26.3151 22.0725L28.3675 24.1248C28.8377 23.1496 29.2118 22.1302 29.484 21.0813C29.9095 19.4271 30.1209 17.7251 30.1131 16.0171C30.1206 14.3075 29.9092 12.604 29.484 10.9481C29.1591 9.69189 28.689 8.47773 28.0833 7.33018C27.0671 5.42006 26.0424 4.45785 25.9296 4.35617C25.7986 4.236 25.6452 4.14281 25.4782 4.08191C25.3112 4.02101 25.1339 3.99361 24.9563 4.00125C24.7787 4.0089 24.6044 4.05145 24.4432 4.12648C24.2821 4.2015 24.1373 4.30754 24.0171 4.43852C23.8969 4.5695 23.8037 4.72287 23.7428 4.88987C23.6819 5.05688 23.6545 5.23424 23.6622 5.41183C23.6776 5.77049 23.8349 6.10833 24.0994 6.35103C24.1296 6.37962 24.925 7.14537 25.7114 8.63608C26.2135 9.59556 26.6031 10.6099 26.8722 11.6588C27.2341 13.0831 27.4135 14.5476 27.406 16.0171C27.4137 17.4844 27.2343 18.9466 26.8722 20.3685C26.7232 20.9484 26.5371 21.5175 26.3151 22.0725ZM12.409 8.1664L17.8682 13.6256C17.7928 12.6151 17.682 11.7781 17.5687 11.0857C17.35 9.77928 16.5096 8.64655 15.4219 7.94648C14.4297 7.30889 13.2163 7.40726 12.409 8.1664Z" fill="white" style="fill:white;fill-opacity:1;">',
  ),
  yN = (n = {}) =>
    (() => {
      const e = ft(w1e);
      return (fn(e, n, !0, !0), An(), e);
    })(),
  S1e = xt(
    '<svg width="28" height="24" viewBox="0 0 28 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M25.0833 3.33018C25.689 4.47773 26.1591 5.69189 26.484 6.94814C26.9092 8.60401 27.1206 10.3075 27.1131 12.0171C27.1209 13.7251 26.9095 15.4271 26.484 17.0813C26.1589 18.3342 25.6884 19.5449 25.0823 20.6886C24.0639 22.5898 23.0371 23.5462 22.9232 23.6489C22.6574 23.8901 22.3066 24.0158 21.948 23.9984C21.5894 23.981 21.2525 23.8218 21.0113 23.556C20.7701 23.2901 20.6443 22.9393 20.6618 22.5807C20.6792 22.2221 20.8383 21.8852 21.1042 21.644C21.1376 21.6122 21.9293 20.8539 22.7125 19.379C23.2145 18.4239 23.6037 17.4136 23.8722 16.3685C24.2343 14.9466 24.4137 13.4844 24.406 12.0171C24.4135 10.5476 24.2341 9.08308 23.8722 7.65881C23.6031 6.60987 23.2135 5.59556 22.7114 4.63608C21.925 3.14537 21.1296 2.37962 21.0994 2.35103C20.8349 2.10833 20.6776 1.77049 20.6622 1.41183C20.6545 1.23424 20.6819 1.05688 20.7428 0.889875C20.8037 0.722874 20.8969 0.569504 21.0171 0.43852C21.1373 0.307535 21.2821 0.201504 21.4432 0.126476C21.6044 0.0514506 21.7787 0.00889956 21.9563 0.001253C22.1339 -0.00639356 22.3112 0.021015 22.4782 0.081911C22.6452 0.142809 22.7986 0.236002 22.9296 0.356172C23.0424 0.457847 24.0671 1.42006 25.0833 3.33018ZM21.6761 12.0121C21.6815 10.7815 21.5292 9.55526 21.2228 8.3634C20.9874 7.45416 20.6471 6.57537 20.2087 5.74472C19.4673 4.34774 18.7011 3.63071 18.6163 3.55393C18.3518 3.31123 18.0017 3.18357 17.643 3.19901C17.2844 3.21445 16.9465 3.37174 16.7038 3.63627C16.4611 3.90081 16.3335 4.25092 16.3489 4.60958C16.3644 4.96825 16.5216 5.30609 16.7862 5.54878C16.899 5.65469 18.969 7.69774 18.969 12.0121C18.9743 13.0011 18.8538 13.9867 18.6105 14.9453C18.4313 15.6449 18.1717 16.3214 17.8368 16.9613C17.3603 17.861 16.882 18.3535 16.8014 18.4364L16.7909 18.4473C16.5298 18.69 16.375 19.0259 16.3601 19.3821C16.3452 19.7382 16.4714 20.0859 16.7113 20.3496C16.9512 20.6133 17.2854 20.7717 17.6414 20.7904C17.9974 20.8091 18.3464 20.6866 18.6126 20.4496C18.6974 20.3733 19.4642 19.6616 20.2087 18.2688C20.6481 17.4409 20.989 16.5643 21.2244 15.657C21.5301 14.4663 21.6819 13.2414 21.6761 12.0121ZM1.91649 15.4051H2.893C3.70116 15.4018 4.48013 15.7069 5.07108 16.2582C6.55067 17.6605 7.99743 19.0612 9.33775 20.4582C10.1422 21.2943 11.411 21.4299 12.4378 20.7643C13.5149 20.0631 14.3506 18.9357 14.5677 17.6356C14.771 16.3964 14.9622 14.6928 14.9643 12.3607C14.9664 10.0285 14.7716 8.32541 14.5687 7.08571C14.35 5.77928 13.5096 4.64655 12.4219 3.94648C11.4025 3.29141 10.1496 3.41321 9.34357 4.23032C8.01967 5.5754 6.59304 6.92366 5.13357 8.27404C4.54639 8.80891 3.77994 9.10408 2.98567 9.10122H1.92337C0.90556 9.10122 0.0397286 9.87596 0.0169568 10.8313C-0.00581506 11.7866 -0.00422624 12.7271 0.0132508 13.6745C0.0323147 14.6304 0.897616 15.4051 1.91649 15.4051Z" fill="white" style="fill:white;fill-opacity:1;">',
  ),
  _N = (n = {}) =>
    (() => {
      const e = ft(S1e);
      return (fn(e, n, !0, !0), An(), e);
    })(),
  T1e = Hd(0.25, 0.25, 0, 1),
  dme = (n) => {
    const [e, t] = Dr(n, ["shouldTrimMargin", "src", "noMarginBottom"]),
      i = Qn;
    let r = null;
    const s = In,
      o = Ki(() => r),
      a = pe(() =>
        T1e(Cr((i() - o().y + s().height - 32) / (o().height - 32), 0, 1)),
      );
    Ct(() => {
      AN(a() === 1);
    });
    const l = iv();
    let c = null;
    const u = HC(() => r);
    Ct(() => {
      c[u() ? "play" : "pause"]();
    });
    const h = Dn(!0);
    return G(
      $.Generic,
      jn(
        {
          ref(d) {
            const f = r;
            typeof f == "function" ? f(d) : (r = d);
          },
          get css() {
            return [
              {
                position: "relative",
                marginBottom: "220rem",
                marginTop: "-32rem",
                height: "100vh",
                paddingTop: "32rem",
                paddingBottom: "32rem",
                "@media (max-width: 767px)": {
                  position: "static",
                  marginBottom: "0px",
                  marginTop: "0px",
                  height: "auto",
                  paddingLeft: "0px !important",
                  paddingRight: "0px !important",
                  paddingTop: "16rem",
                  paddingBottom: "16rem",
                },
              },
              va,
              {
                "&": {
                  height: "100lvh",
                  "@media (max-width: 767px)": { height: "auto" },
                },
                ...(e.shouldTrimMargin && {
                  marginBottom: "256rem",
                  "@media (max-width: 767px)": { marginBottom: "80rem" },
                }),
                ...(e.noMarginBottom && { marginBottom: "0px" }),
              },
            ];
          },
          as: "section",
        },
        t,
        {
          get children() {
            return G($.Generic, {
              css: {
                position: "relative",
                zIndex: "10",
                height: "100%",
                transformOrigin: "top",
                "--tw-bg-opacity": "1",
                backgroundColor: "rgb(0 0 0 / var(--tw-bg-opacity))",
              },
              as: "div",
              get style() {
                return pe(() => !!l())()
                  ? {}
                  : { transform: `scale(${0.5 + a() / 2})` };
              },
              get children() {
                return [
                  G($.Generic, {
                    ref(d) {
                      const f = c;
                      typeof f == "function" ? f(d) : (c = d);
                    },
                    get src() {
                      return e.src;
                    },
                    autoplay: !0,
                    width: "1920",
                    height: "1080",
                    playsinline: !0,
                    loop: !0,
                    muted: !0,
                    css: {
                      position: "absolute",
                      inset: "0px",
                      height: "100%",
                      width: "100%",
                      objectFit: "cover",
                      "@media (max-width: 767px)": { position: "static" },
                    },
                    as: "video",
                  }),
                  G($.Generic, {
                    css: {
                      position: "absolute",
                      bottom: "44rem",
                      right: "44rem",
                      display: "flex",
                      height: "72rem",
                      width: "72rem",
                      alignItems: "center",
                      justifyContent: "center",
                      borderRadius: "9999px",
                      "--tw-bg-opacity": "1",
                      backgroundColor: "rgb(0 0 0 / var(--tw-bg-opacity))",
                      "@media (max-width: 767px)": {
                        bottom: "16rem",
                        right: "16rem",
                        height: "32rem",
                        width: "32rem",
                      },
                    },
                    as: "button",
                    onClick: () => {
                      ((c.muted = !h()), h(!h()));
                    },
                    get children() {
                      return pe(() => !!h())()
                        ? G($.Generic, {
                            css: {
                              height: "auto",
                              "@media (max-width: 767px)": { width: "12rem" },
                            },
                            as: yN,
                          })
                        : G($.Generic, {
                            css: {
                              marginLeft: "1.5rem",
                              height: "auto",
                              "@media (max-width: 767px)": {
                                marginLeft: "0px",
                                width: "11rem",
                              },
                            },
                            as: _N,
                          });
                    },
                  }),
                ];
              },
            });
          },
        },
      ),
    );
  },
  E1e = () =>
    is(() =>
      rs({
        "*[_type == 'about'][0]": {
          seo: Bs,
          heroSection: { title: !0, copy: !0, cursorImages: [Ye()] },
          teamSection: {
            title: !0,
            copy: !0,
            members: [{ ...Ye(), name: !0, title: !0 }],
          },
          globeSection: {
            title: !0,
            copy: !0,
            list: !0,
            coordinates: [
              {
                isClickable: !0,
                latitude: !0,
                longitude: !0,
                city: !0,
                country: !0,
                address: !0,
                description: !0,
                color: !0,
                avatars: [Ye()],
              },
            ],
          },
          '"reel": *[_type == "about"][0].reel.asset->url': !0,
          advisorsSection: {
            title: !0,
            copy: !0,
            advisors: [{ ...Ye(), name: !0, title: !0 }],
          },
          "...*[_type == 'home'][0]": {
            awardsSection: {
              title: !0,
              copy: !0,
              awards: [{ year: !0, issuer: !0, award: !0, image: Ye() }],
            },
            clientsSection: {
              title: !0,
              copy: !0,
              logos: [{ ...Ye(), mobileWidth: !0, displayOnMobile: !0 }],
            },
          },
          collaborationSection: { title: !0, copy: !0 },
          servicesSection: {
            title: !0,
            copy: !0,
            button: Ji,
            services: [
              { title: !0, button: Ji, subServices: [{ label: !0, copy: !0 }] },
            ],
          },
          statisticsSection: {
            title: !0,
            statistics: [{ label: !0, suffix: !0, value: !0 }],
            video: { '"src": asset->url': !0 },
          },
          '"featuredArticles": *[_type == "article"] | order(publishedAt desc)':
            {
              thumbnail: Ye(),
              '"slug": slug.current': !0,
              '"categories": categories[]->label': !0,
              title: !0,
              excerpt: !0,
            },
        },
      }),
    ),
  M1e = xt(
    '<svg width="342" height="119" viewBox="0 0 342 119" fill="none" xmlns="http://www.w3.org/2000/svg"><g clip-path="url(#clip0_2264_11640)"><rect width="543" height="41" transform="translate(-99.2461 92.6973) rotate(-11.3134)" fill="white" style="fill:white;fill:white;fill-opacity:1;"></rect><path d="M-82.9939 110.835C-83.5844 107.884 -81.539 105.262 -78.258 104.605C-75.6909 104.092 -73.585 104.984 -72.4976 106.779L-73.4805 107.576C-74.3921 106.088 -75.9764 105.377 -78.0081 105.783C-80.5752 106.297 -82.1264 108.249 -81.6622 110.569C-81.1981 112.889 -79.0152 114.094 -76.4481 113.581C-74.4164 113.174 -73.2276 111.908 -72.9586 110.184L-71.745 110.541C-72.0579 112.617 -73.6585 114.25 -76.2257 114.764C-79.5066 115.42 -82.4034 113.787 -82.9939 110.835ZM-66.8098 102.315C-63.5151 101.656 -60.6595 103.297 -60.069 106.249C-59.4785 109.2 -61.4827 111.814 -64.7774 112.474C-68.0721 113.133 -70.9277 111.491 -71.5181 108.539C-72.1086 105.588 -70.1045 102.974 -66.8098 102.315ZM-66.5736 103.495C-69.1544 104.012 -70.6507 105.953 -70.1865 108.273C-69.7224 110.593 -67.5944 111.809 -65.0136 111.293C-62.4327 110.777 -60.9502 108.838 -61.4144 106.518C-61.8785 104.198 -63.9927 102.979 -66.5736 103.495ZM-51.0701 109.574L-52.1683 109.794L-58.1707 101.986L-56.4377 110.648L-57.7144 110.903L-59.6864 101.047L-57.6409 100.638L-51.9186 108.116L-49.5002 99.0089L-47.5097 98.6106L-45.5377 108.467L-46.8144 108.723L-48.5474 100.06L-51.0701 109.574ZM-44.1847 97.9454L-42.2128 107.802L-43.5307 108.066L-45.5026 98.2091L-44.1847 97.9454ZM-32.2937 95.5665L-30.3218 105.423L-31.4887 105.657L-40.5936 98.8974L-38.9429 107.148L-40.2059 107.401L-42.1779 97.5439L-40.7776 97.2638L-31.961 103.795L-33.5567 95.8192L-32.2937 95.5665ZM-25.1688 93.984C-22.6154 93.4731 -20.482 94.3598 -19.3974 96.1417L-20.3912 96.9545C-21.3029 95.4664 -22.9009 94.7581 -24.9326 95.1646C-27.5272 95.6837 -29.0536 97.6167 -28.5895 99.9367C-28.1226 102.27 -25.9809 103.484 -23.4275 102.973C-21.2173 102.531 -19.603 100.966 -19.8969 99.2113L-24.7291 100.178L-24.9598 99.0249L-18.9607 97.8247L-17.9363 102.945L-19.1718 103.192L-19.5151 101.476C-19.9104 102.641 -21.2584 103.753 -23.1913 104.154C-26.4998 104.816 -29.3416 103.171 -29.9348 100.206C-30.5281 97.2406 -28.491 94.6486 -25.1688 93.984ZM-14.3642 99.6892L-13.5736 98.6459C-12.2666 100.112 -10.2458 100.364 -8.52976 100.021C-6.58039 99.6311 -5.30922 98.6344 -5.52894 97.5361C-5.76789 96.3418 -6.76455 96.3556 -9.77923 96.6303C-12.3985 96.8831 -14.2601 96.8558 -14.6391 94.9613C-14.9824 93.2453 -13.4751 91.6445 -10.8668 91.1227C-8.57426 90.664 -6.54247 91.1856 -5.49906 92.3332L-6.30621 93.2942C-7.21233 92.3333 -8.76913 91.9023 -10.691 92.2868C-12.6953 92.6878 -13.5986 93.668 -13.4146 94.5878C-13.2058 95.6311 -12.2037 95.6448 -9.59809 95.3948C-6.44339 95.1063 -4.66696 95.1364 -4.26598 97.1407C-3.87598 99.0901 -5.66329 100.647 -8.32651 101.18C-10.7564 101.666 -13.1533 101.103 -14.3642 99.6892ZM0.824565 88.7837C4.11927 88.1245 6.97483 89.7662 7.56532 92.7177C8.15581 95.6692 6.15166 98.2832 2.85695 98.9423C-0.437761 99.6015 -3.29331 97.9598 -3.8838 95.0083C-4.47429 92.0568 -2.47015 89.4428 0.824565 88.7837ZM1.06076 89.9643C-1.5201 90.4806 -3.01634 92.4218 -2.55219 94.7419C-2.08804 97.0619 0.0398971 98.2781 2.62075 97.7617C5.20161 97.2454 6.68413 95.3069 6.21998 92.9869C5.75582 90.6669 3.64162 89.4479 1.06076 89.9643ZM13.2253 86.3027C16.52 85.6436 19.3756 87.2853 19.9661 90.2368C20.5566 93.1883 18.5524 95.8023 15.2577 96.4614C11.963 97.1206 9.10743 95.4789 8.51694 92.5273C7.92645 89.5758 9.9306 86.9619 13.2253 86.3027ZM13.4615 87.4833C10.8806 87.9997 9.3844 89.9409 9.84856 92.2609C10.3127 94.581 12.4406 95.7971 15.0215 95.2808C17.6024 94.7645 19.0849 92.826 18.6207 90.5059C18.1566 88.1859 16.0424 86.967 13.4615 87.4833ZM30.2328 83.0572L32.2048 92.9139L31.0379 93.1473L21.933 86.3881L23.5836 94.6386L22.3207 94.8913L20.3487 85.0346L21.7489 84.7545L30.5656 91.2858L28.9699 83.3099L30.2328 83.0572ZM38.1656 85.4393C39.3187 85.2086 40.3978 85.8921 40.6422 87.1139C40.8839 88.322 40.1509 89.3681 38.9977 89.5988C37.8309 89.8323 36.7243 89.1542 36.4826 87.9461C36.2382 86.7243 36.9987 85.6727 38.1656 85.4393ZM44.9014 85.2481C44.3109 82.2966 46.3562 79.6744 49.6372 79.018C52.2044 78.5044 54.3103 79.3966 55.3977 81.1922L54.4148 81.9885C53.5032 80.5004 51.9189 79.7894 49.8871 80.1959C47.32 80.7095 45.7689 82.6617 46.233 84.9817C46.6972 87.3017 48.88 88.5069 51.4471 87.9934C53.4789 87.5869 54.6677 86.3211 54.9366 84.5968L56.1502 84.9537C55.8373 87.0294 54.2367 88.6631 51.6696 89.1767C48.3886 89.8331 45.4919 88.1996 44.9014 85.2481ZM61.0855 76.7276C64.3802 76.0685 67.2357 77.7102 67.8262 80.6617C68.4167 83.6132 66.4126 86.2272 63.1179 86.8863C59.8232 87.5455 56.9676 85.9038 56.3771 82.9523C55.7866 80.0007 57.7908 77.3868 61.0855 76.7276ZM61.3217 77.9082C58.7408 78.4246 57.2446 80.3658 57.7087 82.6858C58.1729 85.0059 60.3008 86.2221 62.8817 85.7057C65.4625 85.1894 66.9451 83.2509 66.4809 80.9309C66.0167 78.6108 63.9025 77.3919 61.3217 77.9082ZM76.8252 83.9869L75.7269 84.2067L69.7245 76.3985L71.4575 85.0608L70.1808 85.3162L68.2089 75.4596L70.2543 75.0503L75.9767 82.5291L78.395 73.4217L80.3856 73.0234L82.3575 82.8801L81.0808 83.1355L79.3478 74.4732L76.8252 83.9869ZM83.7105 72.3582L85.6825 82.2149L84.3646 82.4786L82.3926 72.6219L83.7105 72.3582ZM95.6015 69.9793L97.5735 79.836L96.4066 80.0694L87.3017 73.3102L88.9523 81.5607L87.6893 81.8134L85.7174 71.9567L87.1176 71.6766L95.9342 78.2079L94.3385 70.232L95.6015 69.9793ZM102.726 68.3968C105.28 67.8859 107.413 68.7726 108.498 70.5545L107.504 71.3673C106.592 69.8792 104.994 69.1709 102.963 69.5774C100.368 70.0965 98.8416 72.0295 99.3058 74.3495C99.7727 76.6833 101.914 77.8967 104.468 77.3859C106.678 76.9437 108.292 75.3786 107.998 73.6241L103.166 74.5909L102.935 73.4377L108.935 72.2375L109.959 77.3581L108.723 77.6052L108.38 75.8892C107.985 77.0534 106.637 78.1655 104.704 78.5665C101.396 79.2284 98.5537 77.5839 97.9604 74.6187C97.3672 71.6534 99.4043 69.0614 102.726 68.3968ZM113.531 74.102L114.322 73.0587C115.629 74.5247 117.65 74.7772 119.366 74.4339C121.315 74.0439 122.586 73.0472 122.366 71.9489C122.127 70.7546 121.131 70.7684 118.116 71.0431C115.497 71.2959 113.635 71.2686 113.256 69.3741C112.913 67.6581 114.42 66.0573 117.028 65.5355C119.321 65.0768 121.353 65.5984 122.396 66.746L121.589 67.707C120.683 66.7461 119.126 66.3151 117.204 66.6996C115.2 67.1006 114.297 68.0808 114.481 69.0006C114.689 70.0439 115.692 70.0576 118.297 69.8076C121.452 69.5191 123.228 69.5492 123.629 71.5535C124.019 73.5029 122.232 75.0597 119.569 75.5926C117.139 76.0787 114.742 75.516 113.531 74.102ZM128.72 63.1965C132.015 62.5373 134.87 64.179 135.461 67.1305C136.051 70.082 134.047 72.696 130.752 73.3551C127.458 74.0143 124.602 72.3726 124.011 69.4211C123.421 66.4696 125.425 63.8556 128.72 63.1965ZM128.956 64.3771C126.375 64.8934 124.879 66.8346 125.343 69.1547C125.807 71.4747 127.935 72.6909 130.516 72.1745C133.097 71.6582 134.579 69.7197 134.115 67.3997C133.651 65.0797 131.537 63.8607 128.956 64.3771ZM141.121 60.7155C144.415 60.0564 147.271 61.6981 147.861 64.6496C148.452 67.6011 146.448 70.2151 143.153 70.8742C139.858 71.5334 137.003 69.8916 136.412 66.9401C135.822 63.9886 137.826 61.3747 141.121 60.7155ZM141.357 61.8961C138.776 62.4125 137.28 64.3537 137.744 66.6737C138.208 68.9938 140.336 70.2099 142.917 69.6936C145.498 69.1773 146.98 67.2388 146.516 64.9187C146.052 62.5987 143.938 61.3798 141.357 61.8961ZM158.128 57.47L160.1 67.3267L158.933 67.5601L149.828 60.8009L151.479 69.0514L150.216 69.3041L148.244 59.4474L149.644 59.1673L158.461 65.6986L156.865 57.7227L158.128 57.47ZM166.061 59.8521C167.214 59.6213 168.293 60.3049 168.537 61.5267C168.779 62.7348 168.046 63.7809 166.893 64.0116C165.726 64.2451 164.62 63.567 164.378 62.3589C164.133 61.1371 164.894 60.0855 166.061 59.8521ZM172.797 59.6609C172.206 56.7094 174.252 54.0872 177.532 53.4308C180.1 52.9172 182.206 53.8094 183.293 55.605L182.31 56.4013C181.398 54.9132 179.814 54.2022 177.782 54.6087C175.215 55.1223 173.664 57.0745 174.128 59.3945C174.592 61.7145 176.775 62.9197 179.342 62.4062C181.374 61.9997 182.563 60.7339 182.832 59.0096L184.045 59.3665C183.733 61.4422 182.132 63.0759 179.565 63.5895C176.284 64.2459 173.387 62.6124 172.797 59.6609ZM188.981 51.1404C192.275 50.4813 195.131 52.123 195.722 55.0745C196.312 58.026 194.308 60.64 191.013 61.2991C187.718 61.9583 184.863 60.3166 184.272 57.3651C183.682 54.4135 185.686 51.7996 188.981 51.1404ZM189.217 52.321C186.636 52.8374 185.14 54.7786 185.604 57.0986C186.068 59.4187 188.196 60.6349 190.777 60.1185C193.358 59.6022 194.84 57.6637 194.376 55.3437C193.912 53.0236 191.798 51.8047 189.217 52.321ZM204.72 58.3997L203.622 58.6195L197.62 50.8113L199.353 59.4736L198.076 59.729L196.104 49.8723L198.15 49.4631L203.872 56.9419L206.29 47.8345L208.281 47.4362L210.253 57.2929L208.976 57.5483L207.243 48.886L204.72 58.3997ZM211.606 46.771L213.578 56.6277L212.26 56.8914L210.288 47.0347L211.606 46.771ZM223.497 44.3921L225.469 54.2488L224.302 54.4822L215.197 47.723L216.848 55.9735L215.585 56.2262L213.613 46.3695L215.013 46.0894L223.83 52.6207L222.234 44.6448L223.497 44.3921ZM230.622 42.8096C233.175 42.2987 235.309 43.1854 236.393 44.9673L235.399 45.7801C234.488 44.292 232.89 43.5837 230.858 43.9902C228.263 44.5093 226.737 46.4423 227.201 48.7623C227.668 51.0961 229.81 52.3095 232.363 51.7987C234.573 51.3565 236.188 49.7914 235.894 48.0369L231.061 49.0037L230.831 47.8505L236.83 46.6503L237.854 51.7709L236.619 52.018L236.275 50.302C235.88 51.4662 234.532 52.5783 232.599 52.9793C229.291 53.6412 226.449 51.9967 225.856 49.0315C225.262 46.0662 227.3 43.4742 230.622 42.8096ZM241.426 48.5148L242.217 47.4715C243.524 48.9375 245.545 49.19 247.261 48.8467C249.21 48.4567 250.481 47.46 250.262 46.3617C250.023 45.1674 249.026 45.1812 246.011 45.4559C243.392 45.7087 241.53 45.6814 241.151 43.7869C240.808 42.0709 242.315 40.4701 244.924 39.9483C247.216 39.4896 249.248 40.0112 250.291 41.1588L249.484 42.1198C248.578 41.1589 247.021 40.7279 245.099 41.1124C243.095 41.5134 242.192 42.4936 242.376 43.4134C242.585 44.4567 243.587 44.4704 246.192 44.2204C249.347 43.9319 251.124 43.962 251.525 45.9663C251.915 47.9157 250.127 49.4725 247.464 50.0053C245.034 50.4915 242.637 49.9288 241.426 48.5148ZM256.615 37.6093C259.91 36.9501 262.765 38.5918 263.356 41.5433C263.946 44.4948 261.942 47.1088 258.647 47.7679C255.353 48.4271 252.497 46.7854 251.907 43.8339C251.316 40.8824 253.32 38.2684 256.615 37.6093ZM256.851 38.7899C254.27 39.3062 252.774 41.2474 253.238 43.5675C253.702 45.8875 255.83 47.1037 258.411 46.5873C260.992 46.071 262.475 44.1325 262.011 41.8125C261.546 39.4924 259.432 38.2735 256.851 38.7899ZM269.016 35.1283C272.311 34.4692 275.166 36.1109 275.757 39.0624C276.347 42.0139 274.343 44.6279 271.048 45.287C267.754 45.9462 264.898 44.3044 264.307 41.3529C263.717 38.4014 265.721 35.7875 269.016 35.1283ZM269.252 36.3089C266.671 36.8253 265.175 38.7665 265.639 41.0865C266.103 43.4066 268.231 44.6227 270.812 44.1064C273.393 43.5901 274.875 41.6516 274.411 39.3315C273.947 37.0115 271.833 35.7926 269.252 36.3089ZM286.023 31.8828L287.995 41.7395L286.828 41.9729L277.724 35.2137L279.374 43.4642L278.111 43.7169L276.139 33.8602L277.539 33.5801L286.356 40.1114L284.76 32.1355L286.023 31.8828ZM293.956 34.2649C295.109 34.0341 296.188 34.7177 296.433 35.9395C296.674 37.1476 295.941 38.1937 294.788 38.4244C293.621 38.6579 292.515 37.9798 292.273 36.7717C292.029 35.5499 292.789 34.4983 293.956 34.2649ZM300.692 34.0737C300.101 31.1222 302.147 28.5 305.428 27.8436C307.995 27.33 310.101 28.2222 311.188 30.0178L310.205 30.8141C309.294 29.326 307.709 28.615 305.678 29.0215C303.111 29.5351 301.559 31.4873 302.024 33.8073C302.488 36.1273 304.671 37.3325 307.238 36.8189C309.269 36.4125 310.458 35.1467 310.727 33.4224L311.941 33.7793C311.628 35.855 310.027 37.4887 307.46 38.0023C304.179 38.6587 301.282 37.0252 300.692 34.0737ZM316.876 25.5532C320.171 24.8941 323.026 26.5358 323.617 29.4873C324.207 32.4388 322.203 35.0528 318.908 35.7119C315.614 36.3711 312.758 34.7294 312.168 31.7778C311.577 28.8263 313.581 26.2124 316.876 25.5532ZM317.112 26.7338C314.531 27.2502 313.035 29.1914 313.499 31.5114C313.963 33.8315 316.091 35.0476 318.672 34.5313C321.253 34.015 322.736 32.0765 322.271 29.7564C321.807 27.4364 319.693 26.2175 317.112 26.7338ZM332.616 32.8125L331.517 33.0323L325.515 25.2241L327.248 33.8864L325.971 34.1418L323.999 24.2851L326.045 23.8759L331.767 31.3547L334.186 22.2473L336.176 21.849L338.148 31.7057L336.871 31.9611L335.138 23.2988L332.616 32.8125ZM339.501 21.1838L341.473 31.0405L340.155 31.3042L338.183 21.4475L339.501 21.1838ZM351.392 18.8049L353.364 28.6615L352.197 28.895L343.092 22.1358L344.743 30.3863L343.48 30.639L341.508 20.7823L342.908 20.5022L351.725 27.0335L350.129 19.0575L351.392 18.8049ZM358.517 17.2224C361.07 16.7115 363.204 17.5982 364.288 19.3801L363.295 20.1929C362.383 18.7048 360.785 17.9965 358.753 18.403C356.159 18.9221 354.632 20.8551 355.096 23.1751C355.563 25.5089 357.705 26.7223 360.258 26.2114C362.468 25.7693 364.083 24.2042 363.789 22.4497L358.957 23.4165L358.726 22.2633L364.725 21.0631L365.75 26.1837L364.514 26.4308L364.171 24.7148C363.775 25.879 362.427 26.9911 360.494 27.3921C357.186 28.054 354.344 26.4095 353.751 23.4443C353.158 20.479 355.195 17.887 358.517 17.2224ZM369.322 22.9276L370.112 21.8843C371.419 23.3503 373.44 23.6028 375.156 23.2595C377.105 22.8695 378.377 21.8728 378.157 20.7745C377.918 19.5802 376.921 19.594 373.907 19.8687C371.287 20.1215 369.426 20.0941 369.047 18.1997C368.703 16.4837 370.211 14.8829 372.819 14.3611C375.112 13.9024 377.143 14.424 378.187 15.5716L377.38 16.5326C376.473 15.5717 374.917 15.1407 372.995 15.5252C370.99 15.9262 370.087 16.9064 370.271 17.8262C370.48 18.8695 371.482 18.8832 374.088 18.6332C377.242 18.3447 379.019 18.3748 379.42 20.3791C379.81 22.3285 378.022 23.8853 375.359 24.4181C372.929 24.9043 370.532 24.3416 369.322 22.9276ZM384.51 12.022C387.805 11.3629 390.661 13.0046 391.251 15.9561C391.842 18.9076 389.837 21.5216 386.543 22.1807C383.248 22.8399 380.392 21.1982 379.802 18.2467C379.211 15.2952 381.216 12.6812 384.51 12.022ZM384.747 13.2027C382.166 13.719 380.669 15.6602 381.134 17.9803C381.598 20.3003 383.726 21.5165 386.307 21.0001C388.887 20.4838 390.37 18.5453 389.906 16.2253C389.442 13.9052 387.327 12.6863 384.747 13.2027ZM396.911 9.54111C400.206 8.88196 403.061 10.5237 403.652 13.4752C404.242 16.4267 402.238 19.0406 398.943 19.6998C395.649 20.359 392.793 18.7172 392.203 15.7657C391.612 12.8142 393.616 10.2003 396.911 9.54111ZM397.147 10.7217C394.566 11.238 393.07 13.1793 393.534 15.4993C393.998 17.8193 396.126 19.0355 398.707 18.5192C401.288 18.0029 402.771 16.0644 402.307 13.7443C401.842 11.4243 399.728 10.2054 397.147 10.7217ZM413.919 6.29557L415.891 16.1523L414.724 16.3857L405.619 9.62653L407.269 17.877L406.006 18.1297L404.034 8.27303L405.435 7.99289L414.251 14.5242L412.656 6.54825L413.919 6.29557ZM421.851 8.67765C423.004 8.44694 424.084 9.13054 424.328 10.3523C424.57 11.5604 423.837 12.6065 422.684 12.8372C421.517 13.0707 420.41 12.3926 420.168 11.1845C419.924 9.96272 420.684 8.9111 421.851 8.67765Z" fill="black" style="fill:black;fill:black;fill-opacity:1;"></path><rect width="543" height="41" transform="translate(-96.1016 6.73047) rotate(6.86517)" fill="#5553E2" style="fill:#5553E2;fill:color(display-p3 0.4314 0.1961 0.8824);fill-opacity:1;"></rect><path d="M-86.3185 29.0335C-85.9587 26.045 -83.1974 24.1918 -79.8754 24.5918C-77.2761 24.9047 -75.5537 26.4094 -75.0807 28.4546L-76.263 28.9045C-76.6649 27.2063 -77.9482 26.0365 -80.0054 25.7888C-82.6046 25.4759 -84.6874 26.8467 -84.9702 29.1958C-85.253 31.5448 -83.5551 33.3709 -80.9559 33.6838C-78.8988 33.9315 -77.3744 33.0997 -76.5809 31.5454L-75.5393 32.2631C-76.4841 34.1376 -78.5145 35.1904 -81.1137 34.8775C-84.4357 34.4775 -86.6783 32.0219 -86.3185 29.0335ZM-68.284 25.9873C-64.948 26.389 -62.7472 28.8396 -63.107 31.828C-63.4668 34.8165 -66.1864 36.6747 -69.5223 36.2731C-72.8582 35.8714 -75.0591 33.4208 -74.6993 30.4324C-74.3395 27.4439 -71.6199 25.5857 -68.284 25.9873ZM-68.4279 27.1827C-71.041 26.8681 -73.0682 28.2457 -73.351 30.5947C-73.6338 32.9437 -71.9915 34.7631 -69.3784 35.0777C-66.7653 35.3923 -64.752 34.0131 -64.4692 31.664C-64.1863 29.315 -65.8147 27.4973 -68.4279 27.1827ZM-55.5946 37.7948L-56.7066 37.6609L-59.9734 28.3698L-61.0294 37.1405L-62.322 36.9848L-61.1205 27.0049L-59.0494 27.2543L-55.9459 36.145L-50.807 28.2466L-48.7915 28.4893L-49.9931 38.4692L-51.2857 38.3136L-50.2298 29.5429L-55.5946 37.7948ZM-45.425 28.8946L-46.6265 38.8745L-47.9609 38.7139L-46.7594 28.7339L-45.425 28.8946ZM-33.3853 30.3441L-34.5869 40.3241L-35.7683 40.1818L-42.3101 30.9194L-43.3158 39.2731L-44.5946 39.1192L-43.393 29.1392L-41.9753 29.3099L-35.6364 38.2658L-34.6641 30.1902L-33.3853 30.3441ZM-26.1223 31.0635C-23.5369 31.3747 -21.7867 32.8828 -21.3121 34.914L-22.5099 35.3762C-22.9118 33.678 -24.209 32.5065 -26.2662 32.2588C-28.8932 31.9425 -30.9465 33.3029 -31.2294 35.6519C-31.5138 38.0148 -29.8576 39.8359 -27.2723 40.1471C-25.0345 40.4165 -23.0124 39.4332 -22.7443 37.6746L-27.637 37.0856L-27.4964 35.918L-21.4223 36.6493L-22.0465 41.8339L-23.2974 41.6833L-23.0883 39.9458C-23.827 40.9285 -25.4547 41.5645 -27.4162 41.3425C-30.766 40.9392 -32.953 38.4902 -32.5915 35.4879C-32.2301 32.4856 -29.486 30.6585 -26.1223 31.0635ZM-17.6369 39.8548L-16.5602 39.1101C-15.7758 40.9108 -13.9346 41.7811 -12.1972 41.9903C-10.2234 42.2279 -8.70475 41.6775 -8.57087 40.5656C-8.42528 39.3563 -9.3765 39.0585 -12.3264 38.379C-14.8939 37.8019 -16.654 37.1952 -16.423 35.2771C-16.2138 33.5396 -14.2824 32.4889 -11.6415 32.8069C-9.32023 33.0864 -7.55256 34.2158 -6.91926 35.6316L-7.98595 36.2928C-8.54705 35.0972 -9.89169 34.2021 -11.8376 33.9678C-13.867 33.7234 -15.031 34.373 -15.1431 35.3042C-15.2703 36.3606 -14.3224 36.6862 -11.7689 37.2616C-8.68162 37.9717 -7.00325 38.5545 -7.24757 40.5839C-7.48521 42.5576 -9.66902 43.4792 -12.3655 43.1545C-14.8258 42.8583 -16.9276 41.5759 -17.6369 39.8548ZM0.196123 34.2321C3.53203 34.6337 5.73288 37.0844 5.37308 40.0728C5.01329 43.0612 2.29367 44.9195 -1.04224 44.5178C-4.37815 44.1162 -6.579 41.6655 -6.2192 38.6771C-5.85941 35.6887 -3.13979 33.8305 0.196123 34.2321ZM0.0522048 35.4275C-2.56092 35.1129 -4.58812 36.4904 -4.87094 38.8395C-5.15375 41.1885 -3.51145 43.0078 -0.898324 43.3225C1.71481 43.6371 3.7281 42.2578 4.01092 39.9088C4.29374 37.5598 2.66533 35.7421 0.0522048 35.4275ZM12.7519 35.7438C16.0878 36.1454 18.2887 38.5961 17.9289 41.5845C17.5691 44.5729 14.8495 46.4311 11.5136 46.0295C8.17766 45.6279 5.97681 43.1772 6.33661 40.1888C6.6964 37.2004 9.41602 35.3421 12.7519 35.7438ZM12.608 36.9391C9.99489 36.6245 7.96769 38.0021 7.68487 40.3511C7.40206 42.7002 9.04436 44.5195 11.6575 44.8341C14.2706 45.1487 16.2839 43.7695 16.5667 41.4205C16.8495 39.0714 15.2211 37.2538 12.608 36.9391ZM29.9231 37.9662L28.7216 47.9462L27.5401 47.8039L20.9984 38.5416L19.9926 46.8952L18.7138 46.7413L19.9154 36.7613L21.3332 36.932L27.6721 45.888L28.6444 37.8123L29.9231 37.9662ZM36.7168 42.7043C37.8843 42.8448 38.6963 43.831 38.5473 45.068C38.4001 46.2912 37.3773 47.0564 36.2097 46.9159C35.0282 46.7736 34.1885 45.7841 34.3358 44.561C34.4847 43.3239 35.5353 42.562 36.7168 42.7043ZM43.176 44.6241C43.5358 41.6357 46.2972 39.7825 49.6192 40.1825C52.2184 40.4954 53.9409 42.0001 54.4138 44.0453L53.2316 44.4952C52.8297 42.797 51.5463 41.6272 49.4891 41.3795C46.8899 41.0666 44.8071 42.4374 44.5243 44.7865C44.2415 47.1355 45.9394 48.9615 48.5386 49.2745C50.5958 49.5222 52.1201 48.6904 52.9136 47.1361L53.9553 47.8538C53.0104 49.7283 50.98 50.7811 48.3808 50.4682C45.0588 50.0682 42.8162 47.6126 43.176 44.6241ZM61.2106 41.578C64.5465 41.9797 66.7473 44.4303 66.3875 47.4187C66.0277 50.4071 63.3081 52.2654 59.9722 51.8637C56.6363 51.4621 54.4355 49.0115 54.7953 46.0231C55.1551 43.0346 57.8747 41.1764 61.2106 41.578ZM61.0667 42.7734C58.4535 42.4588 56.4263 43.8363 56.1435 46.1854C55.8607 48.5344 57.503 50.3538 60.1161 50.6684C62.7293 50.983 64.7426 49.6038 65.0254 47.2547C65.3082 44.9057 63.6798 43.088 61.0667 42.7734ZM73.8999 53.3855L72.7879 53.2516L69.5211 43.9605L68.4652 52.7312L67.1725 52.5755L68.374 42.5956L70.4451 42.8449L73.5486 51.7357L78.6876 43.8373L80.703 44.08L79.5015 54.0599L78.2088 53.9043L79.2648 45.1336L73.8999 53.3855ZM84.0695 44.4853L82.868 54.4652L81.5336 54.3046L82.7352 44.3246L84.0695 44.4853ZM96.1092 45.9348L94.9077 55.9147L93.7262 55.7725L87.1845 46.5101L86.1787 54.8638L84.8999 54.7098L86.1015 44.7299L87.5193 44.9006L93.8582 53.8565L94.8305 45.7809L96.1092 45.9348ZM103.372 46.6541C105.958 46.9654 107.708 48.4734 108.182 50.5047L106.985 50.9669C106.583 49.2686 105.285 48.0972 103.228 47.8495C100.601 47.5332 98.548 48.8935 98.2652 51.2426C97.9807 53.6055 99.6369 55.4265 102.222 55.7378C104.46 56.0072 106.482 55.0239 106.75 53.2653L101.858 52.6763L101.998 51.5087L108.072 52.24L107.448 57.4246L106.197 57.2739L106.406 55.5365C105.668 56.5192 104.04 57.1552 102.078 56.9332C98.7285 56.5299 96.5415 54.0809 96.903 51.0786C97.2645 48.0763 100.009 46.2492 103.372 46.6541ZM111.858 55.4455L112.934 54.7008C113.719 56.5015 115.56 57.3718 117.297 57.581C119.271 57.8186 120.79 57.2682 120.924 56.1562C121.069 54.947 120.118 54.6491 117.168 53.9697C114.601 53.3926 112.841 52.7859 113.072 50.8677C113.281 49.1303 115.212 48.0796 117.853 48.3976C120.174 48.677 121.942 49.8064 122.575 51.2223L121.509 51.8835C120.947 50.6879 119.603 49.7927 117.657 49.5585C115.628 49.3141 114.464 49.9636 114.351 50.8949C114.224 51.9513 115.172 52.2769 117.726 52.8523C120.813 53.5624 122.491 54.1452 122.247 56.1746C122.009 58.1483 119.826 59.0699 117.129 58.7452C114.669 58.449 112.567 57.1666 111.858 55.4455ZM129.691 49.8228C133.027 50.2244 135.227 52.6751 134.868 55.6635C134.508 58.6519 131.788 60.5101 128.452 60.1085C125.116 59.7069 122.916 57.2562 123.275 54.2678C123.635 51.2794 126.355 49.4212 129.691 49.8228ZM129.547 51.0182C126.934 50.7035 124.906 52.0811 124.624 54.4301C124.341 56.7792 125.983 58.5985 128.596 58.9131C131.209 59.2277 133.223 57.8485 133.505 55.4995C133.788 53.1504 132.16 51.3328 129.547 51.0182ZM142.246 51.3345C145.582 51.7361 147.783 54.1867 147.423 57.1752C147.064 60.1636 144.344 62.0218 141.008 61.6202C137.672 61.2185 135.471 58.7679 135.831 55.7795C136.191 52.7911 138.911 50.9328 142.246 51.3345ZM142.103 52.5298C139.489 52.2152 137.462 53.5928 137.179 55.9418C136.897 58.2908 138.539 60.1102 141.152 60.4248C143.765 60.7394 145.778 59.3602 146.061 57.0112C146.344 54.6621 144.716 52.8444 142.103 52.5298ZM159.418 53.5569L158.216 63.5369L157.035 63.3946L150.493 54.1322L149.487 62.4859L148.208 62.332L149.41 52.352L150.828 52.5227L157.167 61.4786L158.139 53.403L159.418 53.5569ZM166.211 58.295C167.379 58.4355 168.191 59.4217 168.042 60.6587C167.895 61.8819 166.872 62.6471 165.704 62.5065C164.523 62.3643 163.683 61.3748 163.83 60.1517C163.979 58.9146 165.03 58.1527 166.211 58.295ZM172.671 60.2148C173.03 57.2264 175.792 55.3732 179.114 55.7731C181.713 56.0861 183.435 57.5908 183.908 59.636L182.726 60.0859C182.324 58.3876 181.041 57.2179 178.984 56.9702C176.384 56.6572 174.302 58.0281 174.019 60.3771C173.736 62.7262 175.434 64.5522 178.033 64.8652C180.09 65.1128 181.615 64.2811 182.408 62.7268L183.45 63.4445C182.505 65.319 180.475 66.3718 177.875 66.0589C174.553 65.6589 172.311 63.2032 172.671 60.2148ZM190.705 57.1687C194.041 57.5703 196.242 60.021 195.882 63.0094C195.522 65.9978 192.803 67.8561 189.467 67.4544C186.131 67.0528 183.93 64.6022 184.29 61.6137C184.65 58.6253 187.369 56.7671 190.705 57.1687ZM190.561 58.3641C187.948 58.0495 185.921 59.427 185.638 61.7761C185.355 64.1251 186.998 65.9445 189.611 66.2591C192.224 66.5737 194.237 65.1944 194.52 62.8454C194.803 60.4964 193.174 58.6787 190.561 58.3641ZM203.394 68.9762L202.282 68.8423L199.016 59.5512L197.96 68.3218L196.667 68.1662L197.869 58.1863L199.94 58.4356L203.043 67.3263L208.182 59.428L210.198 59.6706L208.996 69.6506L207.703 69.4949L208.759 60.7243L203.394 68.9762ZM213.564 60.076L212.363 70.0559L211.028 69.8952L212.23 59.9153L213.564 60.076ZM225.604 61.5255L224.402 71.5054L223.221 71.3632L216.679 62.1008L215.673 70.4545L214.394 70.3005L215.596 60.3206L217.014 60.4913L223.353 69.4472L224.325 61.3715L225.604 61.5255ZM232.867 62.2448C235.452 62.5561 237.202 64.0641 237.677 66.0954L236.479 66.5575C236.077 64.8593 234.78 63.6879 232.723 63.4402C230.096 63.1239 228.043 64.4842 227.76 66.8333C227.475 69.1962 229.131 71.0172 231.717 71.3285C233.955 71.5979 235.977 70.6146 236.245 68.856L231.352 68.2669L231.493 67.0994L237.567 67.8307L236.943 73.0152L235.692 72.8646L235.901 71.1272C235.162 72.1099 233.534 72.7459 231.573 72.5239C228.223 72.1205 226.036 69.6716 226.398 66.6693C226.759 63.6669 229.503 61.8398 232.867 62.2448ZM241.352 71.0361L242.429 70.2915C243.213 72.0922 245.054 72.9625 246.792 73.1717C248.766 73.4093 250.284 72.8589 250.418 71.7469C250.564 70.5377 249.613 70.2398 246.663 69.5603C244.095 68.9833 242.335 68.3766 242.566 66.4584C242.775 64.721 244.707 63.6703 247.348 63.9883C249.669 64.2677 251.437 65.3971 252.07 66.813L251.003 67.4742C250.442 66.2786 249.097 65.3834 247.151 65.1491C245.122 64.9048 243.958 65.5543 243.846 66.4856C243.719 67.542 244.667 67.8676 247.22 68.443C250.307 69.1531 251.986 69.7359 251.741 71.7652C251.504 73.739 249.32 74.6606 246.624 74.3359C244.163 74.0397 242.062 72.7573 241.352 71.0361ZM259.185 65.4135C262.521 65.8151 264.722 68.2657 264.362 71.2542C264.002 74.2426 261.283 76.1008 257.947 75.6992C254.611 75.2976 252.41 72.8469 252.77 69.8585C253.13 66.8701 255.849 65.0118 259.185 65.4135ZM259.041 66.6088C256.428 66.2942 254.401 67.6718 254.118 70.0208C253.835 72.3699 255.478 74.1892 258.091 74.5038C260.704 74.8184 262.717 73.4392 263 71.0902C263.283 68.7411 261.654 66.9234 259.041 66.6088ZM271.741 66.9251C275.077 67.3268 277.278 69.7774 276.918 72.7658C276.558 75.7543 273.839 77.6125 270.503 77.2109C267.167 76.8092 264.966 74.3586 265.326 71.3702C265.685 68.3817 268.405 66.5235 271.741 66.9251ZM271.597 68.1205C268.984 67.8059 266.957 69.1835 266.674 71.5325C266.391 73.8815 268.033 75.7009 270.647 76.0155C273.26 76.3301 275.273 74.9509 275.556 72.6018C275.839 70.2528 274.21 68.4351 271.597 68.1205ZM288.912 69.1476L287.711 79.1275L286.529 78.9853L279.987 69.7229L278.982 78.0766L277.703 77.9226L278.904 67.9427L280.322 68.1134L286.661 77.0693L287.633 68.9936L288.912 69.1476ZM295.706 73.8856C296.873 74.0262 297.685 75.0123 297.536 76.2494C297.389 77.4726 296.366 78.2378 295.199 78.0972C294.017 77.955 293.178 76.9655 293.325 75.7423C293.474 74.5053 294.524 73.7434 295.706 73.8856ZM302.165 75.8055C302.525 72.8171 305.286 70.9639 308.608 71.3638C311.207 71.6768 312.93 73.1814 313.403 75.2266L312.221 75.6765C311.819 73.9783 310.535 72.8085 308.478 72.5609C305.879 72.2479 303.796 73.6188 303.513 75.9678C303.231 78.3169 304.928 80.1429 307.528 80.4559C309.585 80.7035 311.109 79.8718 311.903 78.3175L312.944 79.0351C312 80.9096 309.969 81.9625 307.37 81.6495C304.048 81.2496 301.805 78.7939 302.165 75.8055ZM320.2 72.7594C323.536 73.161 325.736 75.6117 325.377 78.6001C325.017 81.5885 322.297 83.4467 318.961 83.0451C315.625 82.6435 313.425 80.1928 313.784 77.2044C314.144 74.216 316.864 72.3578 320.2 72.7594ZM320.056 73.9548C317.443 73.6401 315.415 75.0177 315.133 77.3667C314.85 79.7158 316.492 81.5351 319.105 81.8497C321.718 82.1644 323.732 80.7851 324.014 78.4361C324.297 76.0871 322.669 74.2694 320.056 73.9548ZM332.889 84.5668L331.777 84.433L328.51 75.1419L327.454 83.9125L326.162 83.7569L327.363 73.777L329.434 74.0263L332.538 82.917L337.677 75.0187L339.692 75.2613L338.491 85.2413L337.198 85.0856L338.254 76.315L332.889 84.5668ZM343.059 75.6666L341.857 85.6466L340.523 85.4859L341.724 75.506L343.059 75.6666ZM355.098 77.1162L353.897 87.0961L352.715 86.9539L346.174 77.6915L345.168 86.0452L343.889 85.8912L345.091 75.9113L346.508 76.082L352.847 85.0379L353.82 76.9622L355.098 77.1162ZM362.361 77.8355C364.947 78.1468 366.697 79.6548 367.172 81.6861L365.974 82.1482C365.572 80.45 364.275 79.2785 362.217 79.0309C359.59 78.7146 357.537 80.0749 357.254 82.4239C356.97 84.7869 358.626 86.6079 361.211 86.9192C363.449 87.1886 365.471 86.2052 365.739 84.4467L360.847 83.8576L360.987 82.6901L367.061 83.4214L366.437 88.6059L365.186 88.4553L365.395 86.7179C364.657 87.7006 363.029 88.3366 361.067 88.1145C357.718 87.7112 355.531 85.2623 355.892 82.2599C356.254 79.2576 358.998 77.4305 362.361 77.8355ZM370.847 86.6268L371.923 85.8822C372.708 87.6829 374.549 88.5532 376.286 88.7624C378.26 89 379.779 88.4496 379.913 87.3376C380.058 86.1283 379.107 85.8305 376.157 85.151C373.59 84.574 371.83 83.9673 372.061 82.0491C372.27 80.3116 374.201 79.261 376.842 79.5789C379.163 79.8584 380.931 80.9878 381.564 82.4037L380.498 83.0649C379.937 81.8693 378.592 80.9741 376.646 80.7398C374.617 80.4955 373.453 81.145 373.341 82.0763C373.213 83.1327 374.161 83.4583 376.715 84.0337C379.802 84.7438 381.48 85.3266 381.236 87.3559C380.998 89.3297 378.815 90.2512 376.118 89.9266C373.658 89.6304 371.556 88.348 370.847 86.6268ZM388.68 81.0042C392.016 81.4058 394.216 83.8564 393.857 86.8448C393.497 89.8333 390.777 91.6915 387.441 91.2899C384.105 90.8882 381.905 88.4376 382.264 85.4492C382.624 82.4608 385.344 80.6025 388.68 81.0042ZM388.536 82.1995C385.923 81.8849 383.895 83.2625 383.613 85.6115C383.33 87.9605 384.972 89.7799 387.585 90.0945C390.198 90.4091 392.212 89.0299 392.495 86.6808C392.777 84.3318 391.149 82.5141 388.536 82.1995ZM401.236 82.5158C404.571 82.9175 406.772 85.3681 406.413 88.3565C406.053 91.3449 403.333 93.2032 399.997 92.8015C396.661 92.3999 394.46 89.9493 394.82 86.9609C395.18 83.9724 397.9 82.1142 401.236 82.5158ZM401.092 83.7112C398.478 83.3966 396.451 84.7741 396.168 87.1232C395.886 89.4722 397.528 91.2916 400.141 91.6062C402.754 91.9208 404.768 90.5416 405.05 88.1925C405.333 85.8435 403.705 84.0258 401.092 83.7112ZM418.407 84.7383L417.205 94.7182L416.024 94.576L409.482 85.3136L408.476 93.6673L407.197 93.5133L408.399 83.5334L409.817 83.7041L416.156 92.66L417.128 84.5843L418.407 84.7383ZM425.2 89.4763C426.368 89.6169 427.18 90.603 427.031 91.8401C426.884 93.0633 425.861 93.8285 424.693 93.6879C423.512 93.5457 422.672 92.5562 422.819 91.333C422.968 90.096 424.019 89.3341 425.2 89.4763Z" fill="white" style="fill:white;fill:white;fill-opacity:1;"></path></g><defs><clipPath id="clip0_2264_11640"><rect width="342" height="119" fill="white" style="fill:white;fill:white;fill-opacity:1;">',
  ),
  L1e = (n = {}) =>
    (() => {
      const e = ft(M1e);
      return (fn(e, n, !0, !0), An(), e);
    })(),
  bN = (n) => {
    const [e, t] = Dr(n, [
      "title",
      "opacity",
      "slug",
      "isEager",
      "tags",
      "media",
      "isComingSoon",
      "excerpt",
      "shouldBlendDifference",
      "isList",
      "fixedAspectRatio",
      "shouldDisableWebGL",
      "isHome",
      "hideTags",
    ]);
    let i = null;
    const r = Ki(() => i),
      s = pe(() =>
        In().width > Si.MD
          ? Cr(
              (Qn() - r().y + In().height * 1.4) /
                (In().height * 2 - In().height),
              0,
              1,
            )
          : 1,
      );
    return G(iI, {
      get type() {
        return e.isComingSoon ? xi.ComingSoon : xi.CaseStudy;
      },
      children: (o) =>
        G(
          $.Generic,
          jn(
            {
              get as() {
                return e.isComingSoon ? "div" : zr;
              },
              get href() {
                return `/work/${e.slug}`;
              },
              get css() {
                return [
                  {
                    ...(e.isList && { alignItems: "flex-start", gap: "32rem" }),
                    ...(e.isList && Im),
                    ...(e.isComingSoon
                      ? {}
                      : {
                          "&:hover": {
                            "ul li": {
                              "--tw-bg-opacity": "1",
                              backgroundColor:
                                "rgb(255 255 255 / var(--tw-bg-opacity))",
                              "--tw-text-opacity": "1",
                              color: "rgb(0 0 0 / var(--tw-text-opacity))",
                            },
                            img: {
                              "--tw-scale-x": "1.05",
                              "--tw-scale-y": "1.05",
                              transform:
                                "translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))",
                            },
                            h3: {
                              "&::after": {
                                content: "var(--tw-content)",
                                "--tw-scale-x": "1",
                                transform:
                                  "translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))",
                              },
                            },
                          },
                        }),
                  },
                  {
                    "@media (max-width: 767px)": {
                      "--tw-scale-x": "1",
                      "--tw-scale-y": "1",
                      transform:
                        "translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))",
                    },
                  },
                ];
              },
              get style() {
                return { transform: e.isHome && `scale(${s()})` };
              },
              ref(a) {
                const l = i;
                typeof l == "function" ? l(a) : (i = a);
              },
            },
            o,
            t,
            {
              get children() {
                return [
                  G($.Generic, {
                    get css() {
                      return [
                        {
                          position: "relative",
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                        },
                        { ...(e.isList && { gridColumn: "span 8 / span 8" }) },
                      ];
                    },
                    as: "div",
                    get children() {
                      return [
                        G($.Generic, {
                          css: { width: "100%", overflow: "hidden" },
                          as: "div",
                          get children() {
                            return G(
                              $.Generic,
                              jn(
                                {
                                  get sizes() {
                                    return { [-1]: "50vw", [Si.MD]: "100vw" };
                                  },
                                  get isEager() {
                                    return e.isEager;
                                  },
                                  get css() {
                                    return [
                                      {
                                        width: "100%",
                                        objectFit: "cover",
                                        transitionProperty:
                                          "transform !important",
                                        transitionTimingFunction:
                                          "cubic-bezier(0.4, 0, 0.2, 1) !important",
                                        transitionDuration: "500ms !important",
                                        "@media (max-width: 767px)": {
                                          aspectRatio: "342 / 272",
                                        },
                                      },
                                      {
                                        ...(e.fixedAspectRatio && {
                                          aspectRatio: "640 / 542",
                                        }),
                                        ...(e.isList && {
                                          aspectRatio: "864 / 488",
                                        }),
                                        ...(e.isComingSoon && {
                                          opacity: "0.3 !important",
                                        }),
                                      },
                                    ];
                                  },
                                  as: nee,
                                },
                                () => e.media,
                                {
                                  get alt() {
                                    return e.title;
                                  },
                                  get style() {
                                    return {
                                      "aspect-ratio": e.isHome
                                        ? "16 / 9"
                                        : void 0,
                                      "object-fit": "cover",
                                      "object-position": "center",
                                    };
                                  },
                                },
                              ),
                            );
                          },
                        }),
                        pe(
                          () =>
                            pe(() => !!e.isComingSoon)() &&
                            G($.Generic, {
                              css: {
                                position: "absolute",
                                display: "block",
                                height: "auto",
                                width: "100%",
                              },
                              as: L1e,
                            }),
                        ),
                      ];
                    },
                  }),
                  G($.Generic, {
                    get css() {
                      return [
                        {
                          gridColumn: "span 4 / span 4",
                          display: "flex",
                          flexDirection: "column",
                        },
                        {
                          ...(e.shouldBlendDifference && {
                            mixBlendMode: "difference",
                          }),
                        },
                      ];
                    },
                    as: "div",
                    get children() {
                      return [
                        G($.Generic, {
                          get css() {
                            return [
                              {
                                marginTop: "16rem",
                                marginBottom: "16rem",
                                display: "flex",
                                justifyContent: "space-between",
                                "@media (max-width: 767px)": {
                                  marginBottom: "8rem",
                                  flexDirection: "column",
                                },
                              },
                              nt.sohne.body1,
                              {
                                ...(e.isList && nt.sohne.h3),
                                ...(e.isList && {
                                  order: "1",
                                  marginTop: "0px",
                                  flexDirection: "column",
                                  gap: "16rem",
                                }),
                              },
                            ];
                          },
                          as: "div",
                          get children() {
                            return [
                              G($.Generic, {
                                get css() {
                                  return [
                                    {
                                      display: "flex",
                                      alignItems: "center",
                                      justifyContent: "space-between",
                                      "@media (max-width: 767px)": {
                                        order: "1",
                                        marginTop: "16rem",
                                      },
                                    },
                                    { ...(e.isList && { order: "1" }) },
                                  ];
                                },
                                as: "div",
                                get children() {
                                  return G($.Generic, {
                                    get css() {
                                      return [
                                        {
                                          position: "relative",
                                          fontFamily: "Sohne Breit, sans-serif",
                                          fontSize: "24rem",
                                          lineHeight: "1.4",
                                          "&::after": {
                                            content: "var(--tw-content)",
                                            position: "absolute",
                                            bottom: "0px",
                                            display: "block",
                                            width: "100%",
                                            transformOrigin: "left",
                                            "--tw-scale-x": "0",
                                            transform:
                                              "translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))",
                                            borderBottomWidth: "1px",
                                            transitionProperty: "transform",
                                            transitionTimingFunction:
                                              "cubic-bezier(0.4, 0, 0.2, 1)",
                                            transitionDuration: "500ms",
                                          },
                                        },
                                        {
                                          ...(e.isList && {
                                            marginRight: "auto",
                                          }),
                                          ...(e.isList && nt.breit.h5),
                                        },
                                      ];
                                    },
                                    as: "h3",
                                    get children() {
                                      return e.title;
                                    },
                                  });
                                },
                              }),
                              pe(
                                () =>
                                  pe(() => !!e.tags)() &&
                                  G($.Generic, {
                                    get css() {
                                      return [
                                        nt.sohne.body3,
                                        {
                                          display: "flex",
                                          flexShrink: "0",
                                          gap: "8rem",
                                        },
                                      ];
                                    },
                                    as: "ul",
                                    get style() {
                                      return {
                                        display: e.hideTags ? "none" : void 0,
                                      };
                                    },
                                    get children() {
                                      return G(Yn, {
                                        get each() {
                                          return e.tags;
                                        },
                                        children: (a) =>
                                          G($.Generic, {
                                            css: [
                                              bT,
                                              {
                                                transitionProperty:
                                                  "color, background-color, border-color, text-decoration-color, fill, stroke",
                                                transitionTimingFunction:
                                                  "cubic-bezier(0.4, 0, 0.2, 1)",
                                                transitionDuration: "500ms",
                                              },
                                            ],
                                            as: "li",
                                            children: a,
                                          }),
                                      });
                                    },
                                  }),
                              ),
                            ];
                          },
                        }),
                        pe(
                          () =>
                            pe(() => !!e.excerpt)() &&
                            G($.Generic, {
                              get css() {
                                return [
                                  nt.sohne.body3,
                                  {
                                    order: "1",
                                    letterSpacing: "-0.03em",
                                    "--tw-text-opacity": "0.5",
                                    color:
                                      "rgb(255 255 255 / var(--tw-text-opacity))",
                                  },
                                ];
                              },
                              as: "p",
                              get children() {
                                return e.excerpt;
                              },
                            }),
                        ),
                      ];
                    },
                  }),
                ];
              },
            },
          ),
        ),
    });
  },
  R1e = (n) =>
    G($.Generic, {
      css: {
        marginLeft: "auto",
        marginRight: "auto",
        width: "100%",
        maxWidth: "914rem",
        textAlign: "center",
      },
      as: "h2",
      get children() {
        return G(Yn, {
          get each() {
            return n.parts;
          },
          children: (e, t) =>
            t() === 1
              ? G($.Generic, {
                  css: {
                    position: "relative",
                    marginBottom: "8rem",
                    display: "block",
                    overflow: "hidden",
                    paddingLeft: "16rem",
                    paddingRight: "16rem",
                    paddingTop: "24rem",
                    paddingBottom: "24rem",
                  },
                  as: "span",
                  get children() {
                    return [
                      G($.Generic, {
                        css: {
                          position: "absolute",
                          inset: "0px",
                          height: "100%",
                          width: "100%",
                          willChange: "transform",
                        },
                        as: "div",
                        get style() {
                          return {
                            "background-color": e.backgroundColor,
                            transform: `translate3d(${Cr(n.progress + 95, -100, 0)}%, 0, 0)`,
                          };
                        },
                      }),
                      G(Yn, {
                        get each() {
                          return e.text.split("");
                        },
                        children: (i, r) =>
                          G($.Generic, {
                            css: { position: "relative", zIndex: "1" },
                            as: "span",
                            get style() {
                              return {
                                color: e.textColor,
                                opacity: Cr(n.progress + (120 + -r()), 0, 1),
                              };
                            },
                            children: i,
                          }),
                      }),
                    ];
                  },
                })
              : G($.Generic, {
                  get css() {
                    return [
                      { marginBottom: "8rem", display: "block" },
                      {
                        backgroundColor: e.backgroundColor,
                        color: e.textColor,
                      },
                    ];
                  },
                  as: "span",
                  get children() {
                    return e.text;
                  },
                }),
        });
      },
    }),
  B1e = (n) =>
    G($.Generic, {
      isEager: !0,
      get slug() {
        return n.project.slug;
      },
      get excerpt() {
        return n.project.excerpt;
      },
      get isComingSoon() {
        return n.project.isComingSoon;
      },
      get css() {
        return [
          {
            "margin-top": n.offset ? (No() ? "56rem" : "250rem") : "0",
            transform: n.offset
              ? `translate3d(0,${Cr(n.offsetTop, 0, 250)}rem, 0)`
              : "0",
          },
          {
            gridColumn: "span 6 / span 6",
            willChange: "transform",
            "@media (max-width: 767px)": { gridColumn: "span 12 / span 12" },
          },
        ];
      },
      as: bN,
      shouldBlendDifference: !0,
      get title() {
        return n.project.title;
      },
      get media() {
        return n.project.thumbnail;
      },
      hideTags: !0,
    }),
  P1e = (n) =>
    G($.Generic, {
      css: {
        position: "relative",
        zIndex: "1",
        marginTop: "120rem",
        display: "grid",
        gridTemplateColumns: "repeat(12, minmax(0, 1fr))",
        columnGap: "30rem",
        paddingBottom: "250rem",
        "@media (max-width: 767px)": {
          marginTop: "48rem",
          paddingBottom: "0px",
        },
      },
      as: "div",
      get children() {
        return G(Yn, {
          get each() {
            return n.projects;
          },
          children: (e, t) =>
            G(B1e, {
              project: e,
              get offset() {
                return t() === 1;
              },
              get offsetTop() {
                return n.offsetTop;
              },
            }),
        });
      },
    }),
  N1e = Hd(0.32, 0, 0.67, 0),
  fme = (n) => {
    let e = null,
      t = Ki(() => e),
      i = Ki(() => e.parentElement);
    const r = Dn(!1);
    Ct(() => {
      Qn() > t().y - In().height / 1.5 && r(!0);
    });
    const s = pe(() => Cr((Qn() - t().y + In().height) / In().height, 0, 1)),
      o = pe(() => Cr(Qn() - i().y, 0, i().height) / 3);
    return (
      rr(() => {
        ((t = Ki(() => e)), (i = Ki(() => e.parentElement)));
      }),
      G($.Generic, {
        css: {
          position: "relative",
          boxSizing: "border-box",
          "--tw-bg-opacity": "1",
          backgroundColor: "rgb(0 0 0 / var(--tw-bg-opacity))",
          paddingLeft: "64rem",
          paddingRight: "64rem",
          paddingBottom: "100rem",
          paddingTop: "200rem",
          "@media (max-width: 767px)": {
            paddingLeft: "24rem",
            paddingRight: "24rem",
            paddingBottom: "32rem",
            paddingTop: "160rem",
          },
        },
        as: "section",
        get children() {
          return [
            G($.Generic, {
              ref(a) {
                const l = e;
                typeof l == "function" ? l(a) : (e = a);
              },
              get style() {
                return {
                  transform: `translateY(${-300 + N1e(s()) * 300 - o()}px)`,
                };
              },
              get css() {
                return [
                  {
                    position: "sticky",
                    top: "0px",
                    marginLeft: "auto",
                    marginRight: "auto",
                    marginBottom: "-450rem",
                    display: "flex",
                    height: "100lvh",
                    width: "calc(100vw - 128rem)",
                    alignItems: "center",
                    justifyContent: "center",
                    "@media (max-width: 767px)": {
                      marginBottom: "-420rem",
                      width: "calc(100vw - 72rem)",
                    },
                  },
                  nt.breit.h4,
                  nt.m.breit.h2,
                ];
              },
              as: "div",
              get children() {
                return G(R1e, {
                  get parts() {
                    return n.parts;
                  },
                  get progress() {
                    return (Qn() - t().y) * 0.2;
                  },
                });
              },
            }),
            G(P1e, {
              get projects() {
                return n.projects;
              },
              get offsetTop() {
                return pe(() => !!No())() ? 0 : (Qn() - t().y) * 0.3;
              },
            }),
          ];
        },
      })
    );
  },
  D1e = () =>
    is(() =>
      rs({
        "*[_type == 'ai'][0]": {
          seo: Bs,
          heroSection: {
            header: !0,
            subheader: !0,
            text: !0,
            media: Ye(),
            button: Ji,
          },
          partnersSection: { logos: [Ye()] },
          offeringsSection: {
            offerings: !0,
            aiBenefits: [
              {
                title: !0,
                media: Ye(),
                description: !0,
                backgroundColor: !0,
                textColor: !0,
              },
            ],
          },
          industryLeaders: {
            header: !0,
            subHeader: !0,
            button: Ji,
            video: Ye(),
            images: [Ye()],
            mediaLink: Ji,
          },
          projectsSection: {
            heading: [{ text: !0, backgroundColor: !0, textColor: !0 }],
            '"projects": projects[]->': {
              description: !0,
              excerpt: !0,
              isComingSoon: !0,
              logo: Ye(),
              '"slug": slug.current': !0,
              thumbnail: Ye(),
              title: !0,
            },
          },
          blobbySection: {
            cursors: [{ name: !0, text: !0, color: !0, textColor: !0 }],
          },
          '"articles": articles[]->': {
            thumbnail: Ye(),
            '"slug": slug.current': !0,
            '"categories": categories[]->label': !0,
            title: !0,
            excerpt: !0,
          },
          scheduleACallSection: { textContent: !0, button: Ji },
        },
      }),
    ),
  G1e = () =>
    is(() =>
      rs({
        "*[_type == 'contact'][0]": {
          seo: Bs,
          heroSection: { title: !0, subtitle: !0, copy: !0 },
          contactFormSection: {
            title: !0,
            contactForm: { title: !0, topics: !0 },
          },
          hearUsTalkSection: { title: !0, copy: !0 },
          faqSection: {
            title: !0,
            copy: !0,
            questions: [{ question: !0, answer: !0 }],
          },
        },
      }),
    ),
  F1e = ({ params: n }) =>
    is(() =>
      rs(
        {
          "*[_type == 'article' && slug.current == $slug][0]": {
            '"category": categories[0]->label': !0,
            publishedAt: !0,
            body: [{ "...": !0, '_type == "media" =>': { image: Ye() } }],
            thumbnailCaption: !0,
            thumbnail: Ye(),
            title: !0,
            eta: !0,
            '"author": author->': {
              fullName: !0,
              role: !0,
              profilePicture: Ye(),
            },
            '"related": *[_type == "article" && slug.current != ^.slug.current][0..1] | order(publishedAt desc)':
              {
                thumbnail: Ye(),
                '"slug": slug.current': !0,
                title: !0,
                excerpt: !0,
              },
          },
        },
        { slug: n.slug },
      ),
    ),
  k1e = () =>
    is(() =>
      rs({
        "*[_type == 'blog'][0]": {
          seo: Bs,
          '"articles": *[_type == "article"] | order(publishedAt desc)': {
            title: !0,
            '"slug": slug.current': !0,
            thumbnail: Ye(),
            publishedAt: !0,
            "author->": { fullName: !0, profilePicture: Ye() },
            excerpt: !0,
            '"categories": categories[]->label': !0,
          },
        },
      }),
    ),
  O1e = (n) => {
    const e = "Work",
      [t, i] = Dr(n, ["shouldShow"]);
    return G(
      $.Generic,
      jn(
        {
          get css() {
            return [
              nt.breit.h1,
              nt.m.breit.h0,
              {
                userSelect: "none",
                overflow: "hidden",
                textTransform: "uppercase",
              },
            ];
          },
          as: "h2",
        },
        i,
        {
          get children() {
            return G(Yn, {
              get each() {
                return e.split("");
              },
              children: (r, s) =>
                G($.Generic, {
                  css: {
                    display: "inline-block",
                    "--tw-translate-y": "100%",
                    transform:
                      "translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))",
                    transitionProperty: "transform",
                    transitionTimingFunction: "cubic-bezier(0.25, 0, 0.1, 1)",
                    transitionDuration: "1s",
                  },
                  as: "span",
                  get style() {
                    return {
                      ...(t.shouldShow && { transform: "translateY(0)" }),
                      "transition-delay": `${s() * 0.04}s`,
                    };
                  },
                  children: r,
                }),
            });
          },
        },
      ),
    );
  },
  U1e = Hd(0.32, 0, 0.67, 0),
  gme = () => {
    let n = null,
      e = null;
    const t = Ki(() => n),
      i = Ki(() => n.parentElement),
      r = Dn(!1);
    Ct(() => {
      Qn() > t().y - In().height / 1.5 && r(!0);
    });
    const s = pe(() => Cr((Qn() - t().y + In().height) / In().height, 0, 1)),
      o = pe(() => Cr(Qn() - i().y, 0, i().height) / 7);
    return G($.Generic, {
      ref(a) {
        const l = n;
        typeof l == "function" ? l(a) : (n = a);
      },
      get style() {
        return { transform: `translateY(${-300 + U1e(s()) * 300 - o()}px)` };
      },
      css: [
        {
          position: "sticky",
          top: "0px",
          marginBottom: "-200rem",
          display: "flex",
          height: "100vh",
          alignItems: "center",
          justifyContent: "center",
          willChange: "transform",
          "@media (max-width: 767px)": {
            position: "static",
            marginBottom: "0px",
            height: "auto",
            transform: "none !important",
            paddingBottom: "64rem",
            paddingTop: "0rem",
          },
        },
        {
          "&": {
            height: "100lvh",
            "@media (max-width: 767px)": { height: "auto" },
          },
        },
      ],
      as: "div",
      get children() {
        return G(O1e, {
          ref(a) {
            const l = e;
            typeof l == "function" ? l(a) : (e = a);
          },
          get shouldShow() {
            return r();
          },
        });
      },
    });
  },
  H1e = Hd(0.6, 0, 1, 1),
  pme = () => {
    let n = null,
      e = null;
    const t = Ki(() => e),
      i = HC(void 0, t),
      r = pe(() =>
        Cr((ph() - t().y + In().height) / (In().height * 1.5), 0, 1),
      );
    return (
      rr(() => {
        try {
          n = new T5({
            resizeTo: e,
            backgroundAlpha: 0,
            antialias: !0,
            view: e,
            autoDensity: !0,
            autoStart: !1,
            resolution: window.devicePixelRatio,
          });
        } catch (a) {
          if (a.message === "Unable to auto-detect a suitable renderer.") {
            console.error(a);
            return;
          }
        }
        const s = new bC();
        (s.beginFill(0), s.drawRect(0, 0, n.screen.width, n.screen.height));
        const o = new bC();
        ((o.blendMode = dt.SRC_OUT),
          n.stage.addChild(s),
          n.stage.addChild(o),
          n.ticker.add(() => {
            let { width: a } = n.screen,
              { height: l } = n.screen;
            (s.clear(),
              s.beginFill(0),
              s.drawRect(0, 0, a, l),
              o.clear(),
              o.beginFill(16777215),
              o.drawCircle(
                a / 2,
                l / 2,
                0.5 * Math.sqrt(a * a + l * l) * H1e(r()),
              ));
          }),
          n.render(),
          dn(() => {
            n.destroy();
          }));
      }),
      Ct(() => {
        n?.[i() || r() < 1 ? "start" : "stop"]();
      }),
      G($.Generic, {
        ref(s) {
          const o = e;
          typeof o == "function" ? o(s) : (e = s);
        },
        css: [
          {
            pointerEvents: "none",
            position: "sticky",
            top: "0px",
            zIndex: "11",
            marginBottom: "-100vh",
            height: "100vh !important",
            width: "100% !important",
          },
          { "&": { height: "100lvh !important" } },
        ],
        as: "canvas",
        get style() {
          return { visibility: r() === 1 ? "hidden" : void 0 };
        },
      })
    );
  };
function W1e() {
  return is(() =>
    rs({
      "*[_type == 'home'][0]": {
        seo: Bs,
        '"reel": *[_type == "global"][0].reel.asset->url': !0,
        introSection: { title: !0, greetings: !0 },
        creatingFutureSection: {
          title: !0,
          copy: !0,
          button: Ji,
          sections: [{ title: !0, copy: !0 }],
          media: Ye(),
        },
        workSection: {
          "featuredCaseStudies[]->": {
            isComingSoon: !0,
            title: !0,
            excerpt: !0,
            '"slug": slug.current': !0,
            tags: !0,
            thumbnail: Ye(),
          },
          copy: !0,
          button: Ji,
        },
        whoWeAreSection: { title: !0, copy: !0, button: Ji, images: [Ye()] },
        clientsSection: {
          title: !0,
          copy: !0,
          logos: [{ ...Ye(), mobileWidth: !0, displayOnMobile: !0 }],
        },
        awardsSection: {
          title: !0,
          copy: !0,
          awards: [{ year: !0, issuer: !0, award: !0, image: Ye() }],
        },
        '"featuredArticles": *[_type == "article"] | order(publishedAt desc)': {
          thumbnail: Ye(),
          '"slug": slug.current': !0,
          '"categories": categories[]->label': !0,
          title: !0,
          excerpt: !0,
        },
      },
    }),
  );
}
const V1e = ({ params: n }) =>
    is(
      () =>
        rs(
          {
            "*[_type == 'industriesPage' && slug.current == $slug][0]": {
              title: !0,
              '"slug": slug.current': !0,
              seo: Bs,
              heroSection: { title: !0, subtitle: !0, heroImage: Ye() },
              aboutSection: { title: !0, description: !0 },
              projectsSection: {
                title: !0,
                '"projects": projects[]->': {
                  title: !0,
                  description: !0,
                  excerpt: !0,
                  isComingSoon: !0,
                  '"slug": slug.current': !0,
                  thumbnail: Ye(),
                },
              },
              insightsSection: {
                title: !0,
                ctaButton: Ji,
                '"articles": articles[]->': {
                  title: !0,
                  excerpt: !0,
                  '"slug": slug.current': !0,
                  thumbnail: Ye(),
                  '"categories": categories[]->label': !0,
                },
              },
              ctaSection: { title: !0 },
              cardVideo: Ye(),
            },
          },
          { slug: n.slug },
        ),
      { key: () => n.slug },
    ),
  Z1e = ({ params: n }) =>
    is(() =>
      rs(
        {
          "*[_type == 'legal' && slug.current == $slug][0]": {
            seo: Bs,
            title: !0,
            content: !0,
          },
        },
        { slug: n.slug },
      ),
    ),
  z1e = ({ params: n }) =>
    is(
      () =>
        rs(
          {
            "*[_type == 'offeringsPage' && slug.current == $slug][0]": {
              title: !0,
              '"slug": slug.current': !0,
              seo: Bs,
              heroSection: {
                title: !0,
                subtitle: !0,
                ctaButton: Ji,
                heroImage: Ye(),
                heroOverlayImage: Ye(),
              },
              problemsSection: {
                problems: [{ label: !0, title: !0, description: !0 }],
                sideImage: Ye(),
              },
              posterImageSection: { posterImage: Ye() },
              howWeHelpSection: {
                title: !0,
                subtitle: !0,
                services: [{ image: Ye(), title: !0, description: !0 }],
              },
              portfolioSection: {
                title: !0,
                '"projects": projects[]->': {
                  title: !0,
                  description: !0,
                  excerpt: !0,
                  isComingSoon: !0,
                  '"slug": slug.current': !0,
                  thumbnail: Ye(),
                },
              },
              testimonialsSection: {
                title: !0,
                testimonials: [
                  {
                    clientLogo: Ye(),
                    quote: !0,
                    authorImage: Ye(),
                    authorName: !0,
                    authorTitle: !0,
                  },
                ],
              },
              ctaSection: { title: !0, ctaButton: Ji },
            },
          },
          { slug: n.slug },
        ),
      { key: () => n.slug },
    ),
  Y1e = () =>
    is(() =>
      rs({
        "*[_type == 'servicesV2'][0]": {
          seo: Bs,
          servicesSection: {
            servicesTop: {
              '"reel": *[_type == "servicesV2"][0].servicesSection.servicesTop.reel.asset->url':
                !0,
              ourServices: [{ service: !0 }],
              description: !0,
            },
            '"recentWork": *[_type == "servicesV2"][0].servicesSection.recentWork->':
              {
                title: !0,
                description: !0,
                excerpt: !0,
                '"slug": slug.current': !0,
                thumbnail: Ye(),
              },
          },
          howWeWorkSection: {
            title: !0,
            button: Ji,
            image: Ye(),
            items: [{ title: !0, description: !0 }],
          },
          AISection: { button: Ji, description: !0, title: !0 },
          successStoriesSection: [
            {
              backgroundImage: Ye(),
              mobileBackgroundImage: Ye(),
              logo: Ye(),
              description: !0,
              stats: [{ stat: !0, unit: !0, text: !0 }],
              companyRep: { name: !0, title: !0, image: Ye() },
            },
          ],
          industryExpertiseSection: {
            title: !0,
            '"industries": industries[]->': {
              title: !0,
              '"slug": slug.current': !0,
              cardVideo: Ye(),
            },
          },
          offeringsSection: {
            '"offerings": offerings[]->': {
              title: !0,
              description: !0,
              '"href": "/offerings/" + slug.current': !0,
            },
          },
          projectsSection: {
            heading: [{ text: !0, backgroundColor: !0, textColor: !0 }],
            '"projects": *[_type == "servicesV2"][0].projectsSection.projects[]->':
              {
                title: !0,
                description: !0,
                excerpt: !0,
                '"slug": slug.current': !0,
                thumbnail: Ye(),
              },
          },
          "...*[_type == 'home'][0]": {
            clientsSection: {
              title: !0,
              copy: !0,
              logos: [{ ...Ye(), mobileWidth: !0, displayOnMobile: !0 }],
            },
          },
          discoverySection: { header: !0, bubbleImages: [Ye()], button: Ji },
          milestonesSection: {
            header: !0,
            milestones: [{ quantity: !0, title: !0, description: !0 }],
          },
          '"featuredArticles": *[_type == "article"] | order(publishedAt desc)':
            {
              thumbnail: Ye(),
              '"slug": slug.current': !0,
              '"categories": categories[]->label': !0,
              title: !0,
              excerpt: !0,
            },
          '"projects": *[_type == "project"] | order(orderRank asc)': {
            description: !0,
            excerpt: !0,
            isComingSoon: !0,
            logo: Ye(),
            '"slug": slug.current': !0,
            thumbnail: Ye(),
            title: !0,
          },
        },
      }),
    );
var X1e = `precision mediump float;

uniform mat4 projectionMatrix;  
uniform mat4 viewMatrix;
uniform mat4 modelMatrix;
uniform float uMultiplier;      
uniform vec2 uHoveredUV;        
uniform float uHoverRadius;     

attribute vec3 position;        
attribute vec2 uv;              

varying vec2 vUv;               
varying vec2 vHoveredUV;        

void main() {
    
    vec4 modelPosition = modelMatrix * vec4(position, 1.0);

    
    modelPosition.z += (modelPosition.x * modelPosition.x) * uMultiplier;
    modelPosition.z += (modelPosition.y * modelPosition.y) * uMultiplier;
    
    
    vec4 viewPosition = viewMatrix * modelPosition;
    vec4 projectedPosition = projectionMatrix * viewPosition;
    
    
    gl_Position = projectedPosition;

    
    vUv = uv;
}`,
  K1e = `precision mediump float;

uniform sampler2D uTexture;

varying vec2 vUv;
void main() {
    vec2 uv = vUv;

    
    vec4 textureColor = texture2D(uTexture, uv);

    
    gl_FragColor = textureColor;
}`;
const j1e = xt("<p>Vault"),
  $1e = (n) => {
    const e = JSON.parse(n?.item?.userData?.data);
    let t = null,
      i = null,
      r = null;
    const s = () => {
      const a = () => {
        (n.setModalOpen(!1),
          n.setSelectedItem(null),
          (document.body.style.cursor = "pointer"),
          t.removeEventListener("animationend", a));
      };
      (t.addEventListener("animationend", a),
        t.classList.remove("animate-slideIn"),
        t.classList.add("animate-slideOut"));
    };
    rr(() => {
      document.body.style.cursor = "auto";
      const a = new URL(window.location.href);
      (a.searchParams.set("project", encodeURI(e.title)),
        window.history.pushState({}, "", a),
        dn(() => {
          const l = new URL(window.location.href);
          (l.searchParams.delete("project"),
            window.history.pushState({}, "", l));
        }),
        i.classList.add("animate-fadeIn"),
        t.classList.add("animate-slideIn"));
    });
    const o = Dn(!0);
    return G($.Generic, {
      ref(a) {
        const l = i;
        typeof l == "function" ? l(a) : (i = a);
      },
      css: {
        position: "fixed",
        left: "0px",
        top: "0px",
        zIndex: "1000",
        height: "100%",
        width: "100%",
        "--tw-bg-opacity": "0.5",
        backgroundColor: "rgb(0 0 0 / var(--tw-bg-opacity))",
        opacity: "0",
      },
      as: "main",
      style: {
        "backdrop-filter": "blur(7.5px)",
        "-webkit-backdrop-filter": "blur(7.5px)",
      },
      get children() {
        return G($.Generic, {
          ref(a) {
            const l = t;
            typeof l == "function" ? l(a) : (t = a);
          },
          class: "hide-scrollbars",
          css: {
            display: "flex",
            height: "100%",
            width: "100%",
            maxWidth: "1036rem",
            "--tw-translate-x": "-100%",
            transform:
              "translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))",
            flexDirection: "column",
            gap: "64rem",
            overflowY: "scroll",
            "--tw-bg-opacity": "1",
            backgroundColor: "rgb(13 13 13 / var(--tw-bg-opacity))",
            padding: "64rem",
            "@media (max-width: 767px)": { gap: "24rem", padding: "24rem" },
          },
          as: "div",
          get children() {
            return [
              G($.Generic, {
                css: {
                  display: "flex",
                  width: "100%",
                  alignItems: "center",
                  justifyContent: "space-between",
                },
                as: "div",
                get children() {
                  return [
                    ft(j1e),
                    G($.Generic, {
                      css: {
                        margin: "-16rem",
                        cursor: "pointer",
                        padding: "16rem",
                        "--tw-text-opacity": "1",
                        color: "rgb(255 255 255 / var(--tw-text-opacity))",
                      },
                      as: "p",
                      onClick: s,
                      children: "Close",
                    }),
                  ];
                },
              }),
              G($.Generic, {
                get css() {
                  return [
                    nt.sohne.body3,
                    { display: "flex", flexShrink: "0", gap: "8rem" },
                  ];
                },
                as: "ul",
                get children() {
                  return G(Yn, {
                    get each() {
                      return e?.tags;
                    },
                    children: (a) =>
                      G($.Generic, {
                        css: [
                          bT,
                          {
                            transitionProperty:
                              "color, background-color, border-color, text-decoration-color, fill, stroke",
                            transitionTimingFunction:
                              "cubic-bezier(0.4, 0, 0.2, 1)",
                            transitionDuration: "500ms",
                          },
                        ],
                        as: "li",
                        get children() {
                          return a.label;
                        },
                      }),
                  });
                },
              }),
              G($.Generic, {
                get css() {
                  return [nt.breit.h4, nt.m.breit.h4];
                },
                as: "h1",
                get children() {
                  return e?.title;
                },
              }),
              G($.Generic, {
                get css() {
                  return [
                    nt.sohne.body4,
                    {
                      "--tw-text-opacity": "0.5",
                      color: "rgb(255 255 255 / var(--tw-text-opacity))",
                    },
                  ];
                },
                as: "p",
                get children() {
                  return e?.description;
                },
              }),
              G($.Generic, {
                get css() {
                  return [
                    nt.sohne.body3,
                    {
                      display: "flex",
                      flexShrink: "0",
                      flexDirection: "column",
                      gap: "64rem",
                      "@media (max-width: 767px)": { gap: "24rem" },
                    },
                  ];
                },
                as: "ul",
                get children() {
                  return G(Yn, {
                    get each() {
                      return e?.blocks;
                    },
                    children: (a) =>
                      a?.images &&
                      G($.Generic, {
                        css: { width: "100%" },
                        as: "li",
                        get children() {
                          return pe(() => a?.images[0]?.type === "image")()
                            ? G($.Generic, {
                                css: { width: "100%" },
                                as: "img",
                                get src() {
                                  return `${a?.images[0]?.src}?fm=webp`;
                                },
                                get alt() {
                                  return e?.title;
                                },
                              })
                            : G($.Generic, {
                                css: {
                                  position: "relative",
                                  zIndex: "10",
                                  height: "100%",
                                  width: "100%",
                                },
                                as: "div",
                                get children() {
                                  return [
                                    G($.Generic, {
                                      ref(l) {
                                        const c = r;
                                        typeof c == "function" ? c(l) : (r = l);
                                      },
                                      get src() {
                                        return a?.images[0]?.video?.src;
                                      },
                                      controls: !1,
                                      autoplay: !0,
                                      get muted() {
                                        return o();
                                      },
                                      playsinline: !0,
                                      loop: !0,
                                      css: {
                                        height: "100%",
                                        width: "100%",
                                        objectFit: "cover",
                                        "@media (max-width: 767px)": {
                                          position: "static",
                                        },
                                      },
                                      as: "video",
                                    }),
                                    G($.Generic, {
                                      css: {
                                        position: "absolute",
                                        bottom: "44rem",
                                        right: "44rem",
                                        display: "flex",
                                        height: "72rem",
                                        width: "72rem",
                                        alignItems: "center",
                                        justifyContent: "center",
                                        borderRadius: "9999px",
                                        "--tw-bg-opacity": "1",
                                        backgroundColor:
                                          "rgb(0 0 0 / var(--tw-bg-opacity))",
                                        "@media (max-width: 767px)": {
                                          bottom: "16rem",
                                          right: "16rem",
                                          height: "32rem",
                                          width: "32rem",
                                        },
                                      },
                                      as: "button",
                                      onClick: () => {
                                        ((r.muted = !o()), o(!o()));
                                      },
                                      get children() {
                                        return pe(() => !!o())()
                                          ? G($.Generic, {
                                              css: {
                                                height: "auto",
                                                "@media (max-width: 767px)": {
                                                  width: "12rem",
                                                },
                                              },
                                              as: yN,
                                            })
                                          : G($.Generic, {
                                              css: {
                                                marginLeft: "1.5rem",
                                                height: "auto",
                                                "@media (max-width: 767px)": {
                                                  marginLeft: "0px",
                                                  width: "11rem",
                                                },
                                              },
                                              as: _N,
                                            });
                                      },
                                    }),
                                  ];
                                },
                              });
                        },
                      }),
                  });
                },
              }),
            ];
          },
        });
      },
    });
  },
  J1e = xt("<div>"),
  Q1e = xt("<canvas>");
let Zn = {
  width: 1.4,
  height: 1.4,
  spacingX: 1.5,
  spacingY: 1.5,
  curveMultiplier: -0.01,
  minWidth: 1.2,
  minHeight: 1.2,
};
const q1e = (n, e, t, i, r) => {
    const s = window.innerWidth > 768 ? 0 : 0.55,
      o = (window.innerWidth > 768, 0),
      a = Math.floor(n / e),
      c = ((n % e) - (e - 1) / 2) * i + s,
      u = ((t - 1) / 2 - a) * r + o;
    return [c, u, 0];
  },
  e0e = (n, e) => {
    let t;
    return (...i) => {
      (clearTimeout(t), (t = setTimeout(() => n.apply(globalThis, i), e)));
    };
  },
  Sf = new Gt(),
  tl = { x: 0, y: 0 },
  Vi = { x: 0, y: 0 },
  l7 = 0.95,
  t0e = 1e-4,
  n0e = new bR(),
  pc = { current: !1 },
  nl = new Gt();
let [c7, u7] = [0, 0];
const i0e = 5;
let i0 = !1,
  h7,
  r0 = !1;
const d7 = 0.3;
let lo, Hs, mc, JA;
const mme = (n) => {
  const [e, t] = Jt(null),
    [i, r] = Jt(!1);
  let s, o;
  const a = () => {
      ((lo = new Hv()),
        (Hs = new Ri(65, window.innerWidth / window.innerHeight, 0.1, 5)),
        Hs.position.set(0, 0, -1),
        (mc = new Jv({ canvas: o })),
        mc.setPixelRatio(Math.min(window.devicePixelRatio, 2)),
        mc.setSize(window.innerWidth, window.innerHeight),
        (JA = new vR()));
      const M = new _R(16777215, 4.5),
        L = new yR(16777215, 1);
      (L.position.set(10, 10, 10), lo.add(M, L), h());
    },
    l = () => {
      const M = lo.getObjectByName("meshGroup");
      M &&
        (M.children.forEach((L) => {
          (L instanceof si &&
            (L.geometry && L.geometry.dispose(),
            L.material &&
              (Array.isArray(L.material)
                ? L.material.forEach((P) => {
                    (P.dispose(),
                      P.uniforms?.uTexture?.value instanceof Oi &&
                        P.uniforms.uTexture.value.dispose());
                  })
                : (L.material.dispose(),
                  L.material.uniforms?.uTexture?.value instanceof Oi &&
                    L.material.uniforms.uTexture.value.dispose()))),
            M.remove(L));
        }),
        lo.remove(M),
        mc.info.reset());
    },
    c = () => {
      const M = new AR();
      let L = lo.getObjectByName("meshGroup");
      L ? l() : ((L = new Is()), (L.name = "meshGroup"), lo.add(L));
      const { itemsPerRow: P, totalRows: U } = n,
        O = P * U,
        V = n.items;
      let W = [...V];
      for (; W.length < O; ) W.push(...V);
      W = W.slice(0, O);
      const re = Array(U)
          .fill(null)
          .map(() => Array(P).fill(null)),
        Z = (ge, be, J) => {
          const se = [
            [0, -1],
            [0, 1],
            [-1, 0],
            [1, 0],
            [-1, -1],
            [-1, 1],
            [1, -1],
            [1, 1],
          ];
          for (const [ce, ae] of se) {
            const Ce = ge + ce,
              $e = be + ae;
            if (Ce >= 0 && Ce < U && $e >= 0 && $e < P) {
              const Te = re[Ce][$e];
              if (Te && Te.id === J.id) return !1;
            }
          }
          return !0;
        };
      let te = 0;
      for (let ge = 0; ge < U; ge++)
        for (let be = 0; be < P; be++) {
          const J = W[te];
          let se = 0;
          for (; !Z(ge, be, J) && se < W.length; )
            ((te = (te + 1) % W.length), se++);
          ((re[ge][be] = W[te]), (te = (te + 1) % W.length));
        }
      re.flat().forEach((ge, be) => {
        const J = M.load(`${ge.thumbnail?.src}?fm=webp` ?? ""),
          se = new Vd(Zn.width, Zn.height, 1, 1),
          ce = new Kte({
            vertexShader: X1e,
            fragmentShader: K1e,
            uniforms: {
              uTexture: { value: J },
              uMultiplier: { value: Zn.curveMultiplier },
            },
          }),
          ae = new si(se, ce);
        ae.scaleTarget = 1;
        const Ce = q1e(be, P, U, Zn.spacingX, Zn.spacingY);
        (ae.position.set(Ce[0], Ce[1], Ce[2]),
          (ae.userData = { data: JSON.stringify(ge) }),
          L.add(ae));
      });
    };
  let u = null;
  const h = () => {
      const M = n0e.getDelta();
      ((u = requestAnimationFrame(h)),
        (Vi.x *= l7),
        (Vi.y *= l7),
        Math.abs(Vi.x) < 1e-4 && (Vi.x = 0),
        Math.abs(Vi.y) < 1e-4 && (Vi.y = 0),
        (tl.x += Vi.x),
        (tl.y += Vi.y + t0e));
      const L = lo.getObjectByName("meshGroup");
      (L &&
        (L.children.forEach((P) => {
          d(P);
          const U = Math.max(Zn.minWidth / Zn.width, 1 - Math.abs(Vi.y) * d7),
            O = Math.max(Zn.minHeight / Zn.height, 1 - Math.abs(Vi.x) * d7);
          P.scale.set(
            (U * Zn.width) / Zn.width,
            (O * Zn.height) / Zn.height,
            1,
          );
        }),
        L.position.set(tl.x, tl.y, 0)),
        n.lottieAnimationComplete && !r0 && (r0 = !0),
        r0 && g(M),
        mc.render(lo, Hs));
    },
    d = (M) => {
      const L = (n.itemsPerRow * Zn.spacingX) / 2 + Zn.width / 2,
        P = (n.totalRows * Zn.spacingY) / 2 + Zn.height / 2;
      (M.position.x + tl.x > L && (M.position.x -= n.itemsPerRow * Zn.spacingX),
        M.position.x + tl.x < -L &&
          (M.position.x += n.itemsPerRow * Zn.spacingX),
        M.position.y + tl.y > P && (M.position.y -= n.totalRows * Zn.spacingY),
        M.position.y + tl.y < -P &&
          (M.position.y += n.totalRows * Zn.spacingY));
    },
    f = () => {
      if (i()) return;
      const M = lo.getObjectByName("meshGroup");
      JA.setFromCamera(Sf, Hs);
      const L = JA.intersectObjects(M.children, !1);
      let P = !1;
      if (L.length > 0) {
        const U = L[0].object;
        (e() !== U && t(U), (P = !0));
      }
      !P && e() !== null && t(null);
    },
    g = (M) => {
      const U = 2.7 - Hs.position.z;
      U > 0
        ? ((Hs.position.z += M * (U * 2)), Hs.lookAt(0, 0, 0))
        : U <= 0 &&
          ((r0 = !1),
          (document.body.style.cursor = "pointer"),
          (Hs.position.z = 2.7),
          Hs.lookAt(0, 0, 0));
    },
    p = e0e(() => {
      const M = window.innerWidth;
      ((Zn = {
        width: M > 768 ? 1.4 : 1,
        height: M > 768 ? 1.4 : 1,
        spacingX: M > 768 ? 1.5 : 1.1,
        spacingY: M > 768 ? 1.5 : 1.1,
        curveMultiplier: M > 768 ? -0.01 : 0,
        minWidth: M > 768 ? 1.2 : 1,
        minHeight: M > 768 ? 1.2 : 1,
      }),
        (Hs.aspect = window.innerWidth / window.innerHeight),
        Hs.updateProjectionMatrix(),
        mc.setSize(window.innerWidth, window.innerHeight),
        c());
    }, 300),
    m = () => {
      (l(), p());
    },
    C = (M) => {
      if (
        !i0 &&
        (M.preventDefault(),
        (Sf.x = (M.clientX / window.innerWidth) * 2 - 1),
        (Sf.y = -(M.clientY / window.innerHeight) * 2 + 1),
        pc.current)
      ) {
        const L = zc.clamp((M.clientX - nl.x) * 5e-4, -1, 1),
          P = zc.clamp((M.clientY - nl.y) * -5e-4, -1, 1);
        ((Vi.x += L), (Vi.y += P), nl.set(M.clientX, M.clientY));
      }
    },
    A = (M) => {
      (M.preventDefault(), (pc.current = !0), nl.set(M.clientX, M.clientY));
    },
    I = () => {
      pc.current = !1;
    },
    y = (M) => {
      (M.preventDefault(),
        M.touches.length > 0 &&
          ((pc.current = !0),
          nl.set(M.touches[0].clientX, M.touches[0].clientY),
          (Sf.x = (M.touches[0].clientX / window.innerWidth) * 2 - 1),
          (Sf.y = -(M.touches[0].clientY / window.innerHeight) * 2 + 1)));
    },
    x = (M) => {
      if ((M.preventDefault(), pc.current && M.touches.length > 0)) {
        const L = (M.touches[0].clientX - nl.x) * 0.001,
          P = (M.touches[0].clientY - nl.y) * -0.001;
        ((Vi.x += L),
          (Vi.y += P),
          nl.set(M.touches[0].clientX, M.touches[0].clientY));
      }
    },
    T = () => {
      pc.current = !1;
    },
    S = () => {
      i0 || ((i0 = !0), t(null));
    },
    E = () => {
      i0 = !1;
    },
    _ = (M) => {
      (S(),
        M.preventDefault(),
        (Vi.x += zc.clamp(-M.deltaX * 25e-5, -1, 1)),
        (Vi.y += zc.clamp(M.deltaY * 25e-5, -1, 1)),
        clearTimeout(h7),
        (h7 = setTimeout(E, 150)));
    },
    b = () => {
      document.body.style.cursor = "pointer";
    },
    R = () => {
      ((document.body.style.cursor = "auto"), (pc.current = !1), t(null));
    };
  return (
    rr(() => {
      (a(),
        m(),
        s?.addEventListener("touchstart", y, { passive: !1 }),
        s?.addEventListener("touchmove", x, { passive: !1 }),
        s?.addEventListener("wheel", _, { passive: !1 }),
        window.addEventListener("resize", m),
        dn(() => {
          (u !== null && (cancelAnimationFrame(u), (u = null)),
            (document.body.style.cursor = "auto"),
            window.removeEventListener("resize", m),
            s?.removeEventListener("wheel", _, { passive: !1 }),
            mc.dispose(),
            lo.clear());
        }));
    }),
    [
      (() => {
        const M = ft(J1e);
        ((M.$$touchend = T),
          (M.$$mousemove = C),
          (M.$$mousedown = A),
          (M.$$mouseup = I),
          (M.$$pointerup = (P) => {
            const U = P.clientX,
              O = P.clientY;
            Math.sqrt((U - c7) ** 2 + (O - u7) ** 2) <= i0e &&
              (f(), e() && r(!0));
          }),
          (M.$$pointerdown = (P) => {
            (t(null), (c7 = P.clientX), (u7 = P.clientY));
          }),
          M.addEventListener("pointerleave", R),
          M.addEventListener("pointerenter", b));
        const L = s;
        return (
          typeof L == "function" ? ry(L, M) : (s = M),
          M.style.setProperty("width", "100%"),
          M.style.setProperty("height", "100%"),
          M.style.setProperty("position", "fixed"),
          M.style.setProperty("top", "0"),
          M.style.setProperty("left", "0"),
          Mn(
            M,
            G(iI, {
              get type() {
                return xi.Project;
              },
              children: (P) =>
                (() => {
                  const U = ft(Q1e),
                    O = o;
                  return (
                    typeof O == "function" ? ry(O, U) : (o = U),
                    U.style.setProperty("width", "100%"),
                    U.style.setProperty("height", "100%"),
                    fn(U, P, !1, !1),
                    An(),
                    U
                  );
                })(),
            }),
          ),
          An(),
          M
        );
      })(),
      pe(
        (() => {
          const M = pe(() => !!i());
          return () =>
            M() &&
            G($1e, {
              get item() {
                return e();
              },
              setModalOpen: r,
              setSelectedItem: t,
            });
        })(),
      ),
    ]
  );
};
Qg([
  "pointerdown",
  "pointerup",
  "mouseup",
  "mousedown",
  "mousemove",
  "touchend",
]);
const r0e = () =>
    is(() =>
      rs({
        "*[_type == 'lab3Page'][0]": {
          seo: Bs,
          '"lab3": *[_type == "lab3"]': {
            orderRank: !0,
            thumbnail: Ye(),
            title: !0,
            description: !0,
            tags: [{ label: !0, icon: Ye() }],
            blocks: [
              { images: [Ye()], copy: { copy: !0 }, isAlternativeLayout: !0 },
            ],
          },
        },
      }),
    ),
  s0e = ({ params: n }) =>
    is(() =>
      rs(
        {
          "*[_type == 'project' && slug.current == $slug][0]": {
            seo: Bs,
            thumbnail: Ye(),
            hero: Ye(),
            statsGrid: {
              sgOverview: { sgoHeader: !0, sgoCopy: !0 },
              sgDuration: {
                sgdHeader: !0,
                sgdTimeStats: [{ sgdTimeFrame: !0, sgdCopy: !0 }],
              },
              sgSuccess: {
                sgsHeader: !0,
                sgsStats: [{ sgsStat: !0, sgsCopy: !0 }],
              },
              sgClientQuote: {
                sgcqHeader: !0,
                sgcqAuthorName: !0,
                sgcqAuthorPosition: !0,
                sgcqQuote: !0,
              },
            },
            title: !0,
            tags: !0,
            excerpt: !0,
            description: !0,
            year: !0,
            logo: Ye(),
            blocks: [
              {
                _type: !0,
                '_type == "intro" =>': { tags: !0, results: !0, copy: !0 },
                '_type == "images" =>': {
                  images: [Ye()],
                  shouldBleed: !0,
                  isAlternativeLayout: !0,
                },
                '_type == "titledCopy" =>': {
                  title: !0,
                  subtitle: !0,
                  copy: !0,
                },
                '_type == "audioQuote" =>': {
                  audio: {
                    '"file": file.asset->url': !0,
                    subtitle: !0,
                    image: Ye(),
                    speaker: { name: !0, role: !0 },
                    title: !0,
                  },
                  testimonial: { subtitle: !0, quote: !0, author: !0 },
                },
                '_type == "reelEnd" =>': {
                  title: !0,
                  "'image': media": Ye(),
                  tags: [{ label: !0, icon: Ye() }],
                },
                '_type == "heading" =>': { subtitle: !0, title: !0 },
                '_type == "repeatedTitledCopy" =>': {
                  sections: [{ title: !0, copy: !0 }],
                },
                '_type == "contact" =>': { title: !0, copy: !0 },
                '_type == "recentWork" =>': {
                  "projects[]->": {
                    title: !0,
                    excerpt: !0,
                    tags: !0,
                    '"slug": slug.current': !0,
                    thumbnail: Ye(),
                  },
                },
                '_type == "carousel" =>': { title: !0, images: [Ye()] },
              },
            ],
          },
        },
        { slug: n.slug },
      ),
    ),
  o0e = xt(
    '<svg width="22" height="22" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M2 1H8C8.55229 1 9 1.44772 9 2V8C9 8.55229 8.55229 9 8 9H2C1.44772 9 1 8.55229 1 8V2C1 1.44772 1.44772 1 2 1ZM0 2C0 0.89543 0.895431 0 2 0H8C9.10457 0 10 0.895431 10 2V8C10 9.10457 9.10457 10 8 10H2C0.89543 10 0 9.10457 0 8V2ZM14 1H20C20.5523 1 21 1.44772 21 2V8C21 8.55229 20.5523 9 20 9H14C13.4477 9 13 8.55229 13 8V2C13 1.44772 13.4477 1 14 1ZM12 2C12 0.89543 12.8954 0 14 0H20C21.1046 0 22 0.895431 22 2V8C22 9.10457 21.1046 10 20 10H14C12.8954 10 12 9.10457 12 8V2ZM8 13H2C1.44772 13 1 13.4477 1 14V20C1 20.5523 1.44772 21 2 21H8C8.55229 21 9 20.5523 9 20V14C9 13.4477 8.55229 13 8 13ZM2 12C0.895431 12 0 12.8954 0 14V20C0 21.1046 0.89543 22 2 22H8C9.10457 22 10 21.1046 10 20V14C10 12.8954 9.10457 12 8 12H2ZM14 13H20C20.5523 13 21 13.4477 21 14V20C21 20.5523 20.5523 21 20 21H14C13.4477 21 13 20.5523 13 20V14C13 13.4477 13.4477 13 14 13ZM12 14C12 12.8954 12.8954 12 14 12H20C21.1046 12 22 12.8954 22 14V20C22 21.1046 21.1046 22 20 22H14C12.8954 22 12 21.1046 12 20V14Z">',
  ),
  a0e = (n = {}) =>
    (() => {
      const e = ft(o0e);
      return (fn(e, n, !0, !0), An(), e);
    })(),
  l0e = xt(
    '<svg width="22" height="22" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M2 1H20C20.5523 1 21 1.44771 21 2V8C21 8.55229 20.5523 9 20 9H2C1.44772 9 1 8.55229 1 8V2C1 1.44772 1.44772 1 2 1ZM0 2C0 0.89543 0.895431 0 2 0H20C21.1046 0 22 0.895431 22 2V8C22 9.10457 21.1046 10 20 10H2C0.89543 10 0 9.10457 0 8V2ZM2 13H20C20.5523 13 21 13.4477 21 14V20C21 20.5523 20.5523 21 20 21H2C1.44772 21 1 20.5523 1 20V14C1 13.4477 1.44772 13 2 13ZM0 14C0 12.8954 0.895431 12 2 12H20C21.1046 12 22 12.8954 22 14V20C22 21.1046 21.1046 22 20 22H2C0.89543 22 0 21.1046 0 20V14Z">',
  ),
  c0e = (n = {}) =>
    (() => {
      const e = ft(l0e);
      return (fn(e, n, !0, !0), An(), e);
    })(),
  u0e = (n) => {
    let e = null;
    const t = Dn(!1),
      i = nI();
    return (
      Ct(
        gr(i, (r) => {
          r &&
            setTimeout(() => {
              t(!0);
            }, n.delay);
        }),
      ),
      G(n.children, {
        ref(r) {
          const s = e;
          typeof s == "function" ? s(r) : (e = r);
        },
        get isTriggered() {
          return t();
        },
      })
    );
  },
  f7 = xt("<button>"),
  Cme = () => {
    const n = Ev(),
      e = nI(),
      t = n.projects,
      i = Di(!0),
      r = pe(() => i() || No()),
      [s, o] = nv(0);
    return (
      Ct(
        gr(
          r,
          () => {
            o(r() ? 1 : -1);
          },
          { defer: !0 },
        ),
      ),
      rr(() => {
        setTimeout(() => {
          o(1);
        }, 1e3);
      }),
      G($.Generic, {
        css: [
          {
            overflow: "hidden",
            paddingBottom: "176rem",
            paddingTop: "128rem",
            "@media (max-width: 767px)": {
              paddingBottom: "128rem",
              paddingTop: "64rem",
            },
          },
          va,
        ],
        as: "section",
        get children() {
          return [
            G($.Generic, {
              get css() {
                return [
                  {
                    marginBottom: "88rem",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "space-between",
                    "@media (max-width: 767px)": { marginBottom: "48rem" },
                  },
                  nt.breit.h4,
                  nt.m.breit.h3,
                ];
              },
              as: "div",
              get children() {
                return [
                  G(u0e, {
                    delay: 500,
                    children: (a) =>
                      G(yq, jn({ tag: "h2" }, a, { children: "Latest Work" })),
                  }),
                  G($.Generic, {
                    get css() {
                      return [
                        {
                          display: "flex",
                          alignItems: "center",
                          gap: "16rem",
                          "--tw-text-opacity": "0.2",
                          color: "rgb(255 255 255 / var(--tw-text-opacity))",
                          opacity: "0",
                          transitionProperty: "opacity",
                          transitionTimingFunction:
                            "cubic-bezier(0.4, 0, 0.2, 1)",
                          transitionDuration: "500ms",
                          transitionDelay: "1s",
                          "@media (max-width: 767px)": { display: "none" },
                        },
                        {
                          button: {
                            borderRadius: "9999px",
                            borderWidth: "1px",
                            "--tw-border-opacity": "1",
                            borderColor:
                              "rgb(255 255 255 / var(--tw-border-opacity))",
                            paddingLeft: "61rem",
                            paddingRight: "61rem",
                            paddingTop: "21rem",
                            paddingBottom: "21rem",
                            opacity: "0.5",
                            transitionProperty: "opacity, background-color",
                            transitionTimingFunction:
                              "cubic-bezier(0.4, 0, 0.2, 1)",
                            transitionDuration: "500ms",
                            "&:hover": { opacity: "1" },
                          },
                          "button.active": {
                            "--tw-bg-opacity": "1",
                            backgroundColor:
                              "rgb(255 255 255 / var(--tw-bg-opacity))",
                            opacity: "1",
                          },
                          "button.active svg": { fill: "#000" },
                          svg: {
                            height: "auto",
                            width: "22rem",
                            fill: "#FFF",
                            transitionProperty:
                              "color, background-color, border-color, text-decoration-color, fill, stroke",
                            transitionTimingFunction:
                              "cubic-bezier(0.4, 0, 0.2, 1)",
                            transitionDuration: "500ms",
                          },
                          ...(e() && { opacity: "1" }),
                        },
                      ];
                    },
                    as: "div",
                    get children() {
                      return [
                        (() => {
                          const a = ft(f7);
                          return (
                            (a.$$click = () => i(!0)),
                            Mn(a, G(a0e, {})),
                            vs(() => iy(a, i() ? "active" : "")),
                            An(),
                            a
                          );
                        })(),
                        (() => {
                          const a = ft(f7);
                          return (
                            (a.$$click = () => i(!1)),
                            Mn(a, G(c0e, {})),
                            vs(() => iy(a, i() ? "" : "active")),
                            An(),
                            a
                          );
                        })(),
                      ];
                    },
                  }),
                ];
              },
            }),
            G($.Generic, {
              css: { position: "relative" },
              as: "div",
              get children() {
                return G(Yn, {
                  get each() {
                    return Array.from({ length: 2 });
                  },
                  children: (a, l) => {
                    const c = pe(() => l() === (r() ? 0 : 1)),
                      u = pe(() => s() * (l() === 1 ? -1 : 1));
                    return G($.Generic, {
                      get css() {
                        return [
                          Im,
                          {
                            ...(l() === 1 && {
                              display: "flex",
                              flexDirection: "column",
                            }),
                            ...(!c() && {
                              pointerEvents: "none",
                              position: "absolute",
                              opacity: "0",
                            }),
                          },
                          {
                            top: "0px",
                            width: "100%",
                            rowGap: "88rem",
                            transitionProperty: "opacity",
                            transitionTimingFunction:
                              "cubic-bezier(0.4, 0, 0.2, 1)",
                            transitionDuration: "500ms",
                            "@media (max-width: 767px)": {
                              display: "flex",
                              flexDirection: "column",
                              rowGap: "56rem",
                            },
                          },
                        ];
                      },
                      as: "ul",
                      get children() {
                        return G(Yn, {
                          each: t,
                          children: (h, d) =>
                            G($.Generic, {
                              css: { gridColumn: "span 6 / span 6" },
                              as: "li",
                              get children() {
                                return G($.Generic, {
                                  get title() {
                                    return h.title;
                                  },
                                  get tags() {
                                    return h.tags;
                                  },
                                  get excerpt() {
                                    return l() === 0
                                      ? h.excerpt
                                      : h.description;
                                  },
                                  get isList() {
                                    return l() === 1;
                                  },
                                  get isComingSoon() {
                                    return h.isComingSoon;
                                  },
                                  get media() {
                                    return h.thumbnail;
                                  },
                                  fixedAspectRatio: !0,
                                  get slug() {
                                    return h.slug;
                                  },
                                  get opacity() {
                                    return u();
                                  },
                                  hideTags: !0,
                                  get style() {
                                    return {
                                      "transition-delay": `${1.25 + d() * 0.25}s`,
                                    };
                                  },
                                  get css() {
                                    return [
                                      {
                                        opacity: "0",
                                        transitionProperty: "opacity",
                                        transitionTimingFunction:
                                          "cubic-bezier(0.4, 0, 0.2, 1)",
                                        transitionDuration: "500ms",
                                      },
                                      { ...(e() && { opacity: "1" }) },
                                    ];
                                  },
                                  as: bN,
                                });
                              },
                            }),
                        });
                      },
                    });
                  },
                });
              },
            }),
          ];
        },
      })
    );
  };
Qg(["click"]);
const h0e = () =>
    is(() =>
      rs({
        "*[_type == 'work'][0]": {
          seo: Bs,
          '"reel": *[_type == "global"][0].reel.asset->url': !0,
          heroSection: { title: !0, copy: !0 },
          '"projects": *[_type == "project"] | order(orderRank)': {
            title: !0,
            isComingSoon: !0,
            description: !0,
            '"slug": slug.current': !0,
            excerpt: !0,
            tags: !0,
            thumbnail: Ye(),
          },
          aboutUsSection: {
            title: !0,
            copy: !0,
            button: Ji,
            carouselImages: [Ye()],
          },
        },
      }),
    ),
  d0e = [
    {
      data: E1e,
      component: _r(() =>
        lr(
          () => import("./about-0190fe16.js"),
          [
            "assets/about-0190fe16.js",
            "assets/AwardsSection-dcbfd084.js",
            "assets/OnScrollSplitWordsTransition-a840e488.js",
            "assets/OnScrollFadeIn-1c75ac00.js",
            "assets/Carousel-1f75bde8.js",
            "assets/ContactSection-7469ca23.js",
            "assets/F3Button-6d97d362.js",
            "assets/FeaturedBlogSection-9ebdb12d.js",
            "assets/ArticleThumbnail-a354cd42.js",
          ],
        ),
      ),
      path: "/about",
    },
    {
      data: D1e,
      component: _r(() =>
        lr(
          () => import("./index-6a0993da.js"),
          [
            "assets/index-6a0993da.js",
            "assets/OnScrollSplitWordsTransition-a840e488.js",
            "assets/OnScrollMoveLeft-31ba3d13.js",
            "assets/F3Button-6d97d362.js",
            "assets/ArticleThumbnail-a354cd42.js",
          ],
        ),
      ),
      path: "/ai/",
    },
    {
      data: G1e,
      component: _r(() =>
        lr(
          () => import("./contact-b0e768e0.js"),
          [
            "assets/contact-b0e768e0.js",
            "assets/F3Button-6d97d362.js",
            "assets/format-sticker-df2bd1d1.js",
            "assets/ConditionalCopy-f123a6eb.js",
            "assets/RichText-5ea94c19.js",
            "assets/index-6d4128cc.js",
            "assets/OnScrollSplitWordsTransition-a840e488.js",
          ],
        ),
      ),
      path: "/contact",
    },
    {
      data: F1e,
      component: _r(() =>
        lr(
          () => import("./_slug_-cf7190e3.js"),
          [
            "assets/_slug_-cf7190e3.js",
            "assets/OnScrollSplitWordsTransition-a840e488.js",
            "assets/OnScrollFadeIn-1c75ac00.js",
            "assets/index-6d4128cc.js",
            "assets/ContactSection-7469ca23.js",
            "assets/F3Button-6d97d362.js",
            "assets/ArticleThumbnail-a354cd42.js",
          ],
        ),
      ),
      path: "/curiosity/:slug",
    },
    {
      data: k1e,
      component: _r(() =>
        lr(
          () => import("./index-120fdd73.js"),
          [
            "assets/index-120fdd73.js",
            "assets/OnScrollSplitWordsTransition-a840e488.js",
            "assets/OnScrollFadeIn-1c75ac00.js",
            "assets/ContactSection-7469ca23.js",
            "assets/F3Button-6d97d362.js",
            "assets/ArticleThumbnail-a354cd42.js",
          ],
        ),
      ),
      path: "/curiosity/",
    },
    {
      data: W1e,
      component: _r(() =>
        lr(
          () => import("./index-4d7cd1cc.js"),
          [
            "assets/index-4d7cd1cc.js",
            "assets/F3Button-6d97d362.js",
            "assets/AwardsSection-dcbfd084.js",
            "assets/OnScrollSplitWordsTransition-a840e488.js",
            "assets/ClientsSection-b0329066.js",
            "assets/FeaturedBlogSection-9ebdb12d.js",
            "assets/ArticleThumbnail-a354cd42.js",
            "assets/ContactSection-7469ca23.js",
          ],
        ),
      ),
      path: "/",
    },
    {
      data: V1e,
      component: _r(() =>
        lr(
          () => import("./_slug_-69f0c582.js"),
          [
            "assets/_slug_-69f0c582.js",
            "assets/OnScrollSplitWordsTransition-a840e488.js",
            "assets/OnScrollFadeIn-1c75ac00.js",
            "assets/F3Button-6d97d362.js",
            "assets/ArticleThumbnail-a354cd42.js",
            "assets/ContactSection-7469ca23.js",
          ],
        ),
      ),
      path: "/industries/:slug",
    },
    {
      data: Z1e,
      component: _r(() =>
        lr(
          () => import("./_slug_-e64a883e.js"),
          [
            "assets/_slug_-e64a883e.js",
            "assets/RichText-5ea94c19.js",
            "assets/index-6d4128cc.js",
          ],
        ),
      ),
      path: "/legal/:slug",
    },
    {
      data: z1e,
      component: _r(() =>
        lr(
          () => import("./_slug_-438006d3.js"),
          [
            "assets/_slug_-438006d3.js",
            "assets/OnScrollSplitWordsTransition-a840e488.js",
            "assets/OnScrollFadeIn-1c75ac00.js",
          ],
        ),
      ),
      path: "/offerings/:slug",
    },
    {
      data: Y1e,
      component: _r(() =>
        lr(
          () => import("./services-018b8f4d.js"),
          [
            "assets/services-018b8f4d.js",
            "assets/ContactSection-7469ca23.js",
            "assets/OnScrollSplitWordsTransition-a840e488.js",
            "assets/F3Button-6d97d362.js",
            "assets/OnScrollFadeIn-1c75ac00.js",
            "assets/ClientsSection-b0329066.js",
            "assets/OnScrollMoveLeft-31ba3d13.js",
            "assets/FeaturedBlogSection-9ebdb12d.js",
            "assets/ArticleThumbnail-a354cd42.js",
          ],
        ),
      ),
      path: "/services",
    },
    {
      component: _r(() => lr(() => import("./sitemap-441cb453.js"), [])),
      path: "/sitemap",
    },
    {
      data: r0e,
      component: _r(() => lr(() => import("./index-ba7bc5db.js"), [])),
      path: "/vault/",
    },
    {
      data: s0e,
      component: _r(() =>
        lr(
          () => import("./_slug_-4848bf65.js"),
          [
            "assets/_slug_-4848bf65.js",
            "assets/OnScrollFadeIn-1c75ac00.js",
            "assets/OnScrollSplitWordsTransition-a840e488.js",
            "assets/index-6d4128cc.js",
            "assets/F3Button-6d97d362.js",
            "assets/format-sticker-df2bd1d1.js",
            "assets/ContactSection-7469ca23.js",
            "assets/Carousel-1f75bde8.js",
          ],
        ),
      ),
      path: "/work/:slug",
    },
    {
      data: h0e,
      component: _r(() =>
        lr(
          () => import("./index-e1e44f45.js"),
          [
            "assets/index-e1e44f45.js",
            "assets/ConditionalCopy-f123a6eb.js",
            "assets/F3Button-6d97d362.js",
            "assets/Carousel-1f75bde8.js",
            "assets/OnScrollSplitWordsTransition-a840e488.js",
            "assets/OnScrollFadeIn-1c75ac00.js",
            "assets/ContactSection-7469ca23.js",
          ],
        ),
      ),
      path: "/work/",
    },
  ],
  f0e = () => d0e,
  gl = Di(!1),
  g0e = (n) => {
    const e = pe(() => gl()),
      t = Eh,
      i = Qn;
    let r = 0,
      s = !1,
      o = 0,
      a = -1,
      l = null;
    function c() {
      l?.scrollTo(0, zt(i));
    }
    Ct((f) => (f !== -1 && t() === -1 && window.scrollTo(0, f), c(), t()), -1);
    let u = -1;
    function h(f) {
      const g = zt(i);
      let p = (f - u) / (1e3 / 60);
      const m = g + (r - g) * Math.min(1, 0.08 * p);
      if (((u = f), Math.round(m * 2) === Math.round(r * 2))) {
        ((s = !1), i(r), c());
        return;
      }
      (i(m),
        Math.abs(o - g) >= 1 / window.devicePixelRatio && (c(), (o = g)),
        (a = requestAnimationFrame(h)));
    }
    const d = Di(0);
    return (
      rr(() => {
        (requestAnimationFrame(() => {
          i(window.scrollY);
        }),
          c());
        let f,
          g = -1;
        const p = new ResizeObserver(([m]) => {
          Math.round(d()) !== Math.round(m.contentRect.height) &&
            (d(m.contentRect.height),
            g !== -1 &&
              g === m.contentRect.width &&
              (clearTimeout(f),
              (f = setTimeout(() => {
                xg(xg() + 1);
              }, 100))),
            (g = m.contentRect.width));
        });
        (p.observe(l.children[0]),
          dn(() => {
            (clearTimeout(f),
              c(),
              p.disconnect(),
              cancelAnimationFrame(a),
              (s = !1));
          }));
      }),
      Ct(() => {
        ((document.body.style.height = `${pV() ?? d()}px`),
          window.scrollTo(0, zt(i)));
      }),
      Ct(() => {
        e()
          ? (cancelAnimationFrame(a), (s = !1), window.scrollTo(0, zt(i)))
          : requestAnimationFrame(c);
      }),
      [
        G(Wd, {
          onWheel: [
            () => {
              zt(gl) && gl(!1);
            },
            { passive: !0 },
          ],
          onPointerMove: [
            (f) => {
              const g = f.pointerType === "touch";
              zt(gl) !== g && gl(g);
            },
            { passive: !0 },
          ],
          onScroll: () => {
            ((r = window.scrollY),
              zt(t) === -1 &&
                (zt(e)
                  ? requestAnimationFrame(() => {
                      i(r);
                    })
                  : s ||
                    ((s = !0),
                    (u = performance.now()),
                    (a = requestAnimationFrame(h)))));
          },
        }),
        G(
          $.Generic,
          jn(n, {
            ref(f) {
              const g = l;
              typeof g == "function" ? g(f) : (l = f);
            },
            css: {
              position: "fixed",
              top: "0px",
              zIndex: "10",
              height: "100%",
              width: "100%",
              overflow: "hidden",
              willChange: "scroll-position",
            },
            as: "div",
            get style() {
              return {
                ...(e() && _z({ position: "static", overflow: "visible" })),
              };
            },
          }),
        ),
      ]
    );
  },
  p0e = () => {
    const n = In;
    function e() {
      (No(window.innerWidth <= Si.MD),
        window.innerWidth !== n().width &&
          (gV(document.body.offsetWidth),
          n({ width: window.innerWidth, height: window.innerHeight })));
    }
    return (
      Ct(
        gr(gl, () => {
          if (gl()) {
            let i = function () {
                (ph(ph() + (Qn() - ph()) * 0.3),
                  (t = requestAnimationFrame(i)));
              },
              t;
            ((t = requestAnimationFrame(i)),
              dn(() => {
                cancelAnimationFrame(t);
              }));
          }
        }),
      ),
      Ct(() => {
        gl() || ph(Qn());
      }),
      Ct(() => {
        e();
      }),
      G(Wd, { onResize: e })
    );
  };
function m0e(n) {
  return (rv(), dn(() => {}), null);
}
const C0e = { src: "assets/gif/swingin.gif", width: 128, height: 128 },
  I0e = xt('<li><a rel="noreferrer">'),
  A0e = () => {
    const n = tI(),
      e = 2,
      t = Dn(-1);
    let i = null;
    Ct(
      gr(
        go,
        (m) => {
          m &&
            (Eh(Qn()),
            dn(() => {
              (Eh(Qn()),
                setTimeout(() => {
                  Eh(-1);
                }));
            }));
        },
        { defer: !0 },
      ),
    );
    let r = pe(() => Wc(163));
    const s = pe(() => !No()),
      o = pe(() =>
        s()
          ? Math.max(Math.ceil(In().height / r()) + 1, n.menu.links.length)
          : n.menu.links.length,
      ),
      [a, l, c] = nv(0, { multiplier: 0.1 }),
      u = pe(() => (s() ? Math.floor(a() / r()) : 0)),
      h = pe(() => {
        const m = [];
        for (let C = u(); C < o() + u(); C++) m.push(bz(n.menu.links, C));
        return m;
      }),
      d = pe(() => a() - u() * r());
    let f = 0;
    const g = Dn(!1);
    rr(() => {
      ((f = r() * e - Wc(120)), c(f));
    });
    const p = gp();
    return (
      Ct(
        gr(
          () => p.pathname,
          () => {
            (go(!1),
              setTimeout(() => {
                t(-1);
              }, 500));
          },
          { defer: !0 },
        ),
      ),
      [
        pe(
          (() => {
            const m = pe(() => !!go());
            return () =>
              m() &&
              G(Wd, {
                onKeydown: (C) => {
                  C.key === "Escape" && go(!1);
                },
                onWheel: [
                  (C) => {
                    (C.preventDefault(), (f += C.deltaY), l(f), g(!0));
                  },
                  { passive: !1 },
                ],
              });
          })(),
        ),
        G($.Generic, {
          get css() {
            return [
              {
                position: "fixed",
                inset: "0px",
                zIndex: "50",
                userSelect: "none",
                "--tw-bg-opacity": "1",
                backgroundColor: "rgb(0 0 0 / var(--tw-bg-opacity))",
                paddingLeft: "64rem",
                paddingRight: "64rem",
                transitionDuration: "1s",
                transitionTimingFunction: "cubic-bezier(0.5, 0, 0.1, 1)",
                clipPath: "inset(0 0 100% 0)",
                "@media (max-width: 767px)": {
                  display: "flex",
                  flexDirection: "column",
                  justifyContent: "space-between",
                  paddingLeft: "24rem",
                  paddingRight: "24rem",
                  paddingBottom: "32rem",
                },
              },
              { ...(go() && { clipPath: "inset(0 0 0 0)" }) },
            ];
          },
          as: "nav",
          get children() {
            return [
              G($.Generic, {
                isMenu: !0,
                css: {
                  position: "absolute !important",
                  width: "calc(100% - 128rem) !important",
                  paddingLeft: "0px !important",
                  paddingRight: "0px !important",
                  "@media (max-width: 767px)": {
                    width: "calc(100% - 48rem) !important",
                  },
                },
                as: SL,
              }),
              G($.Generic, {
                css: {
                  willChange: "transform",
                  "@media (max-width: 767px)": { paddingTop: "88rem" },
                },
                as: "ul",
                ref(m) {
                  const C = i;
                  typeof C == "function" ? C(m) : (i = m);
                },
                get style() {
                  return pe(() => !!s())()
                    ? { transform: `translateY(${-d()}px)` }
                    : {};
                },
                get children() {
                  return G(Yn, {
                    get each() {
                      return h();
                    },
                    children: (m, C) =>
                      G($.Generic, {
                        get css() {
                          return [
                            {
                              borderBottomWidth: "1px",
                              "--tw-border-opacity": "0.2",
                              borderColor:
                                "rgb(255 255 255 / var(--tw-border-opacity))",
                              paddingTop: "16rem",
                              paddingBottom: "16rem",
                              transitionProperty: "opacity, border-color",
                              transitionTimingFunction:
                                "cubic-bezier(0.4, 0, 0.2, 1)",
                              transitionDuration: "500ms",
                              "@media (max-width: 767px)": {
                                "&:last-child": { borderBottomWidth: "0px" },
                              },
                            },
                            {
                              ...(C() < 1 && !g() && s() && { opacity: "0" }),
                              ...(t() !== -1 &&
                                t() !== C() && { opacity: "0" }),
                              ...(t() !== -1 &&
                                t() === C() && {
                                  "--tw-border-opacity": "0",
                                  borderColor:
                                    "rgb(255 255 255 / var(--tw-border-opacity))",
                                }),
                            },
                          ];
                        },
                        as: "li",
                        get children() {
                          return G(
                            $.Generic,
                            jn(
                              {
                                get as() {
                                  return m.href === "#archive" ? "button" : zr;
                                },
                                get href() {
                                  return m.href;
                                },
                              },
                              () =>
                                m.href === "#archive"
                                  ? {
                                      onClick: () => {
                                        (go(!1),
                                          setTimeout(() => {
                                            SE(!0);
                                          }, 500));
                                      },
                                    }
                                  : {
                                      onClick: () => {
                                        m.href === p.pathname ? go(!1) : t(C());
                                      },
                                    },
                              {
                                css: {
                                  display: "flex",
                                  width: "100%",
                                  alignItems: "center",
                                  justifyContent: "space-between",
                                  "--tw-text-opacity": "0.2",
                                  color:
                                    "rgb(255 255 255 / var(--tw-text-opacity))",
                                  transitionProperty:
                                    "color, background-color, border-color, text-decoration-color, fill, stroke",
                                  transitionTimingFunction:
                                    "cubic-bezier(0.4, 0, 0.2, 1)",
                                  transitionDuration: "500ms",
                                  "&:hover": { "--tw-text-opacity": "1" },
                                },
                                get children() {
                                  return [
                                    G($.Generic, {
                                      get css() {
                                        return [
                                          nt.sohne.body3,
                                          nt.m.sohne.body4,
                                          {
                                            display: "flex",
                                            alignItems: "center",
                                            gap: "5rem",
                                          },
                                        ];
                                      },
                                      as: "div",
                                      get children() {
                                        return [
                                          pe(() => m.subtitle),
                                          G(Hl, {
                                            get when() {
                                              return (
                                                u() > 100 && m.href === "/"
                                              );
                                            },
                                            get children() {
                                              return G(
                                                $.Generic,
                                                jn(
                                                  {
                                                    css: {
                                                      height: "auto",
                                                      width: "24rem",
                                                    },
                                                    as: "img",
                                                  },
                                                  C0e,
                                                ),
                                              );
                                            },
                                          }),
                                        ];
                                      },
                                    }),
                                    G($.Generic, {
                                      get css() {
                                        return [
                                          nt.breit.h3,
                                          nt.m.breit.h2,
                                          {
                                            "@media (max-width: 767px)": {
                                              "--tw-text-opacity": "1",
                                              color:
                                                "rgb(255 255 255 / var(--tw-text-opacity))",
                                            },
                                          },
                                        ];
                                      },
                                      as: "div",
                                      get children() {
                                        return m.label;
                                      },
                                    }),
                                  ];
                                },
                              },
                            ),
                          );
                        },
                      }),
                  });
                },
              }),
              G($.Generic, {
                css: {
                  display: "none",
                  "@media (max-width: 767px)": { display: "block" },
                },
                as: "div",
                get children() {
                  return [
                    G($.Generic, {
                      get css() {
                        return [
                          nt.m.sohne.body4,
                          {
                            marginBottom: "16rem",
                            "--tw-text-opacity": "0.5",
                            color: "rgb(255 255 255 / var(--tw-text-opacity))",
                          },
                        ];
                      },
                      as: "div",
                      children: "Follow our journey",
                    }),
                    G($.Generic, {
                      get css() {
                        return [
                          { display: "flex", justifyContent: "space-between" },
                          nt.m.sohne.body3,
                        ];
                      },
                      as: "ul",
                      get children() {
                        return G(Yn, {
                          get each() {
                            return n.socials?.links;
                          },
                          children: (m) =>
                            (() => {
                              const C = ft(I0e),
                                A = C.firstChild;
                              return (
                                Mn(A, () => m.label),
                                vs(
                                  (I) => {
                                    const y = m.isExternal ? "_blank" : void 0,
                                      x = m.href;
                                    return (
                                      y !== I._v$ &&
                                        gg(A, "target", (I._v$ = y)),
                                      x !== I._v$2 &&
                                        gg(A, "href", (I._v$2 = x)),
                                      I
                                    );
                                  },
                                  { _v$: void 0, _v$2: void 0 },
                                ),
                                C
                              );
                            })(),
                        });
                      },
                    }),
                  ];
                },
              }),
            ];
          },
        }),
      ]
    );
  },
  y0e = (n) => {
    const e = Dn(!1);
    zW((i) => {
      (i.preventDefault(),
        e(!0),
        setTimeout(() => {
          i.retry(!0);
        }, 500));
    });
    const t = VW();
    return (
      Ct(
        gr(
          t,
          (i) => {
            i || e(!1);
          },
          { defer: !0 },
        ),
      ),
      G($.Generic, {
        get css() {
          return {
            ...(e() && {
              opacity: "0",
              transitionProperty: "opacity",
              transitionTimingFunction: "cubic-bezier(0.4, 0, 0.2, 1)",
              transitionDuration: "500ms",
            }),
          };
        },
        as: "div",
        get children() {
          return n.children;
        },
      })
    );
  };
const _0e = xt("<script async>/* GTM disabled */</script>"),
  b0e = xt(`<script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){console.log("gtag suppressed", arguments);}
              gtag('js', new Date());
              gtag('config', 'G-DKDWYY15G8');
            `),
  v0e = xt(`<script>/* GTM Injection disabled */`),
  x0e = xt(
    '<script>!function(key) {if (window.reb2b) return;window.reb2b = {loaded: true};var s = document.createElement("script");s.async = true;s.src = "https://ddwl4m2hdecbv.cloudfront.net/b/" + key + "/" + key + ".js.gz";document.getElementsByTagName("script")[0].parentNode.insertBefore(s, document.getElementsByTagName("script")[0]);}("LNKLDHE3WEOJ");',
  ),
  w0e = xt(`<script>
              var Countly = Countly || {};
              Countly.q = Countly.q || [];
              Countly.app_key = 'a9f397c5c801db79a97fe2422ba8116c32c58011';
              Countly.url = 'https://countly.lab.foxapps.tech';
              Countly.use_session_cookie = false;
              Countly.debug = false;
              Countly.q.push(['track_sessions']);
              Countly.q.push(['track_pageview']);
              Countly.q.push(['track_clicks']);
              Countly.q.push(['track_scrolls']);
              Countly.q.push(['track_errors']);
              Countly.q.push(['track_links']);
              (function() {
                var cly = document.createElement('script'); cly.type = 'text/javascript';
                cly.async = true;
                cly.src = 'https://cdn.jsdelivr.net/npm/countly-sdk-web@latest/lib/countly.min.js';
                cly.onload = function(){Countly.init()};
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(cly, s);
              })();
            `),
  S0e = xt("<div><!#><!/><!#><!/>"),
  T0e = xt('<script id="#root-data" type="application/json">'),
  E0e = () => {
    const n = tI(),
      e = gp();
    return (
      rr(() => {
        const t = document.createElement("noscript"),
          i = document.createElement("iframe");
        ((i.src = "https://www.googletagmanager.com/ns.html?id=GTM-NG8J8XJ6"),
          (i.height = "0"),
          (i.width = "0"),
          (i.style.display = "none"),
          (i.style.visibility = "hidden"),
          t.appendChild(i),
          document.body.appendChild(t));
      }),
      [
        G($.Global, {
          get css() {
            return [
              {
                "*, ::before, ::after": {
                  boxSizing: "border-box",
                  borderWidth: "0",
                  borderStyle: "solid",
                  borderColor: "currentColor",
                  "--tw-border-spacing-x": "0",
                  "--tw-border-spacing-y": "0",
                  "--tw-translate-x": "0",
                  "--tw-translate-y": "0",
                  "--tw-rotate": "0",
                  "--tw-skew-x": "0",
                  "--tw-skew-y": "0",
                  "--tw-scale-x": "1",
                  "--tw-scale-y": "1",
                  "--tw-pan-x": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-pan-y": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-pinch-zoom": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-scroll-snap-strictness": "proximity",
                  "--tw-gradient-from-position": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-gradient-via-position": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-gradient-to-position": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-ordinal": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-slashed-zero": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-numeric-figure": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-numeric-spacing": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-numeric-fraction": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-ring-offset-shadow": "0 0 #0000",
                  "--tw-ring-shadow": "0 0 #0000",
                  "--tw-shadow": "0 0 #0000",
                  "--tw-shadow-colored": "0 0 #0000",
                  "--tw-ring-inset": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-ring-offset-width": "0px",
                  "--tw-ring-offset-color": "#fff",
                  "--tw-ring-color": "rgb(59 130 246 / 0.5)",
                  "--tw-blur": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-brightness": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-contrast": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-grayscale": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-hue-rotate": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-invert": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-saturate": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-sepia": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-drop-shadow": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-backdrop-blur": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-backdrop-brightness": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-backdrop-contrast": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-backdrop-grayscale": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-backdrop-hue-rotate": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-backdrop-invert": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-backdrop-opacity": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-backdrop-saturate": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-backdrop-sepia": "var(--tw-empty,/*!*/ /*!*/)",
                },
                "::before, ::after": { "--tw-content": "''" },
                html: {
                  lineHeight: "1.5",
                  WebkitTextSizeAdjust: "100%",
                  MozTabSize: "4",
                  tabSize: "4",
                  fontFamily: " ui-sans-serif",
                  fontFeatureSettings: " normal",
                  fontVariationSettings: " normal",
                },
                body: { margin: "0", lineHeight: "inherit" },
                hr: { height: "0", color: "inherit", borderTopWidth: "1px" },
                "abbr:where([title])": { textDecoration: "underline dotted" },
                "h1, h2, h3, h4, h5, h6": {
                  fontSize: "inherit",
                  fontWeight: "inherit",
                },
                a: { color: "inherit", textDecoration: "inherit" },
                "b, strong": { fontWeight: "bolder" },
                "code, kbd, samp, pre": {
                  fontFamily: " ui-monospace",
                  fontSize: "1em",
                },
                small: { fontSize: "80%" },
                "sub, sup": {
                  fontSize: "75%",
                  lineHeight: "0",
                  position: "relative",
                  verticalAlign: "baseline",
                },
                sub: { bottom: "-0.25em" },
                sup: { top: "-0.5em" },
                table: {
                  textIndent: "0",
                  borderColor: "inherit",
                  borderCollapse: "collapse",
                },
                "button, input, optgroup, select, textarea": {
                  fontFamily: "inherit",
                  fontFeatureSettings: "inherit",
                  fontVariationSettings: "inherit",
                  fontSize: "100%",
                  fontWeight: "inherit",
                  lineHeight: "inherit",
                  color: "inherit",
                  margin: "0",
                  padding: "0",
                },
                "button, select": { textTransform: "none" },
                "button, [type='button'], [type='reset'], [type='submit']": {
                  WebkitAppearance: "button",
                  backgroundColor: "transparent",
                  backgroundImage: "none",
                },
                ":-moz-focusring": { outline: "auto" },
                ":-moz-ui-invalid": { boxShadow: "none" },
                progress: { verticalAlign: "baseline" },
                "::-webkit-inner-spin-button, ::-webkit-outer-spin-button": {
                  height: "auto",
                },
                "[type='search']": {
                  WebkitAppearance: "textfield",
                  outlineOffset: "-2px",
                },
                "::-webkit-search-decoration": { WebkitAppearance: "none" },
                "::-webkit-file-upload-button": {
                  WebkitAppearance: "button",
                  font: "inherit",
                },
                summary: { display: "list-item" },
                "blockquote, dl, dd, h1, h2, h3, h4, h5, h6, hr, figure, p, pre":
                  { margin: "0" },
                fieldset: { margin: "0", padding: "0" },
                legend: { padding: "0" },
                "ol, ul, menu": {
                  listStyle: "none",
                  margin: "0",
                  padding: "0",
                },
                dialog: { padding: "0" },
                textarea: { resize: "vertical" },
                "input::placeholder, textarea::placeholder": {
                  opacity: "1",
                  color: " #9ca3af",
                },
                'button, [role="button"]': { cursor: "pointer" },
                ":disabled": { cursor: "default" },
                "img, svg, video, canvas, audio, iframe, embed, object": {
                  display: "block",
                  verticalAlign: "middle",
                },
                "img, video": { maxWidth: "100%", height: "auto" },
                "[hidden]": { display: "none" },
                "::backdrop": {
                  "--tw-border-spacing-x": "0",
                  "--tw-border-spacing-y": "0",
                  "--tw-translate-x": "0",
                  "--tw-translate-y": "0",
                  "--tw-rotate": "0",
                  "--tw-skew-x": "0",
                  "--tw-skew-y": "0",
                  "--tw-scale-x": "1",
                  "--tw-scale-y": "1",
                  "--tw-pan-x": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-pan-y": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-pinch-zoom": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-scroll-snap-strictness": "proximity",
                  "--tw-gradient-from-position": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-gradient-via-position": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-gradient-to-position": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-ordinal": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-slashed-zero": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-numeric-figure": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-numeric-spacing": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-numeric-fraction": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-ring-offset-shadow": "0 0 #0000",
                  "--tw-ring-shadow": "0 0 #0000",
                  "--tw-shadow": "0 0 #0000",
                  "--tw-shadow-colored": "0 0 #0000",
                  "--tw-ring-inset": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-ring-offset-width": "0px",
                  "--tw-ring-offset-color": "#fff",
                  "--tw-ring-color": "rgb(59 130 246 / 0.5)",
                  "--tw-blur": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-brightness": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-contrast": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-grayscale": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-hue-rotate": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-invert": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-saturate": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-sepia": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-drop-shadow": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-backdrop-blur": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-backdrop-brightness": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-backdrop-contrast": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-backdrop-grayscale": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-backdrop-hue-rotate": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-backdrop-invert": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-backdrop-opacity": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-backdrop-saturate": "var(--tw-empty,/*!*/ /*!*/)",
                  "--tw-backdrop-sepia": "var(--tw-empty,/*!*/ /*!*/)",
                },
              },
              {
                "::selection": {
                  "--tw-bg-opacity": "1",
                  backgroundColor: "rgb(85 83 226 / var(--tw-bg-opacity))",
                  "--tw-text-opacity": "1",
                  color: "rgb(255 255 255 / var(--tw-text-opacity))",
                },
                img: { userSelect: "none" },
                "h1, h2, h3, h4, h5, h6": { userSelect: "none" },
                "*": { outline: "2px solid transparent", outlineOffset: "2px" },
                body: {
                  margin: "0px",
                  overflowY: "scroll",
                  "--tw-bg-opacity": "1",
                  backgroundColor: "rgb(0 0 0 / var(--tw-bg-opacity))",
                  "--tw-text-opacity": "1",
                  color: "rgb(255 255 255 / var(--tw-text-opacity))",
                  WebkitFontSmoothing: "antialiased",
                  MozOsxFontSmoothing: "grayscale",
                },
                html: {
                  fontSize: `calc(${100 / 1440} * 1vw)`,
                  "@media (max-width: 767px)": {
                    fontSize: `calc(${100 / 390} * 1vw)`,
                  },
                },
              },
              { body: [nt.sohne.body2, nt.m.sohne.body2] },
            ];
          },
        }),
        G(Wd, {
          onClick: (t) => {
            for (let i = t.target; i != null; i = i.parentElement)
              if (i instanceof HTMLAnchorElement) {
                const { href: r } = i;
                r && r === window.location.href && window.scrollTo(0, 0);
              }
          },
        }),
        G(Uz, {
          lang: "en",
          get children() {
            return [
              G(Hz, {
                get children() {
                  return [
                    ft(_0e),
                    ft(b0e),
                    ft(v0e),
                    ft(x0e),
                    ft(w0e),
                    G(bi, { charset: "utf-8" }),
                    G(bi, {
                      name: "viewport",
                      content: "width=device-width, initial-scale=1",
                    }),
                    G(bi, { name: "charset", content: "utf-8" }),
                  ];
                },
              }),
              G(Wz, {
                get children() {
                  return [
                    G(QN, {
                      get children() {
                        return G(Bz, {
                          get children() {
                            return [
                              G(g0e, {
                                get children() {
                                  const t = ft(S0e),
                                    i = t.firstChild,
                                    [r, s] = Xc(i.nextSibling),
                                    o = r.nextSibling,
                                    [a, l] = Xc(o.nextSibling);
                                  return (
                                    Mn(
                                      t,
                                      G(y0e, {
                                        get children() {
                                          return G(Hl, {
                                            get when() {
                                              return e.pathname;
                                            },
                                            keyed: !0,
                                            get children() {
                                              return G(xz, {
                                                get children() {
                                                  return G(f0e, {});
                                                },
                                              });
                                            },
                                          });
                                        },
                                      }),
                                      r,
                                      s,
                                    ),
                                    Mn(
                                      t,
                                      (() => {
                                        const c = pe(() => !!ky());
                                        return () => c() && G(A0e, {});
                                      })(),
                                      a,
                                      l,
                                    ),
                                    t
                                  );
                                },
                              }),
                              G(eee, {}),
                            ];
                          },
                        });
                      },
                    }),
                    G(Oz, {}),
                  ];
                },
              }),
              (() => {
                const t = ft(T0e);
                return (
                  Mn(t, () =>
                    JSON.stringify(n, (i, r) =>
                      typeof r == "function" ? r() : r,
                    ),
                  ),
                  t
                );
              })(),
              G(p0e, {}),
              G(m0e, {
                name: "Cache-Control",
                value: "s-maxage=60, public, stale-while-revalidate=604800",
              }),
            ];
          },
        }),
      ]
    );
  },
  g7 = Object.values(Object.assign({}))[0],
  M0e = g7 ? g7.default : void 0,
  L0e = ({ routerProps: n } = {}) => {
    let e = {
      get request() {},
      get clientAddress() {},
      get locals() {},
      get prevUrl() {},
      get responseHeaders() {},
      get tags() {},
      get env() {},
      get routerContext() {},
      setStatusCode(s) {},
      getStatusCode() {},
      $type: TE,
      fetch,
      $islands: new Set(),
      mutation: !1,
    };
    function t(s) {
      return G(qW, s);
    }
    const i = "/";
    let r = i;
    if (i.startsWith("http"))
      try {
        r = new URL(i).pathname;
      } catch {
        console.warn(
          "BASE_URL starts with http, but `new URL` failed to parse it. Please check your BASE_URL:",
          i,
        );
      }
    return G(EE.Provider, {
      value: e,
      get children() {
        return G(vW, {
          get children() {
            return G(
              t,
              jn({ base: r, data: M0e }, n, {
                get children() {
                  return G(E0e, {});
                },
              }),
            );
          },
        });
      },
    });
  };
uW({
  dsn: "https://134036d6b21d813693b76388075a83a6@o4510510420918272.ingest.de.sentry.io/4510510423801936",
  sendDefaultPii: !0,
});
window.history.scrollRestoration = "manual";
yW(() => {
  const n = JSON.parse(document.getElementById("#root-data").innerHTML);
  return G(wL.Provider, {
    value: n,
    get children() {
      return G(L0e, {});
    },
  });
}, document);
export {
  ZW as $,
  U0e as A,
  Jt as B,
  HC as C,
  sme as D,
  $f as E,
  Yn as F,
  Im as G,
  iI as H,
  xi as I,
  Si as J,
  nee as K,
  dV as L,
  nh as M,
  Wc as N,
  D0e as O,
  G0e as P,
  ume as Q,
  ime as R,
  $ as S,
  rme as T,
  Z0e as U,
  dme as V,
  zr as W,
  yN as X,
  _N as Y,
  No as Z,
  fme as _,
  Dr as a,
  Di as a0,
  gr as a1,
  ome as a2,
  Zc as a3,
  W0e as a4,
  gg as a5,
  bT as a6,
  Qq as a7,
  xT as a8,
  T5 as a9,
  V0e as aA,
  s_ as aB,
  tq as aC,
  SL as aD,
  JQ as aE,
  mme as aF,
  nme as aG,
  F0e as aH,
  N0e as aI,
  Qg as aJ,
  dD as aK,
  B0e as aL,
  R0e as aM,
  ro as aN,
  bD as aO,
  Fa as aP,
  iy as aQ,
  Cme as aR,
  gV as aS,
  bz as aT,
  Wd as aU,
  k0e as aV,
  O0e as aW,
  C0 as aX,
  pp as aY,
  Rs as aa,
  B5 as ab,
  Kq as ac,
  ry as ad,
  iv as ae,
  fR as af,
  ko as ag,
  Qi as ah,
  r7 as ai,
  s7 as aj,
  er as ak,
  o7 as al,
  a7 as am,
  Gt as an,
  I1e as ao,
  y1e as ap,
  xE as aq,
  nv as ar,
  ph as as,
  gme as at,
  bN as au,
  xg as av,
  pme as aw,
  hme as ax,
  R9 as ay,
  yq as az,
  Dn as b,
  Ct as c,
  G as d,
  nt as e,
  Xc as f,
  ft as g,
  va as h,
  Mn as i,
  Hl as j,
  H0e as k,
  Ev as l,
  jn as m,
  pe as n,
  dn as o,
  Ki as p,
  Cr as q,
  An as r,
  fn as s,
  xt as t,
  nI as u,
  In as v,
  Qn as w,
  vs as x,
  yz as y,
  rr as z,
};
